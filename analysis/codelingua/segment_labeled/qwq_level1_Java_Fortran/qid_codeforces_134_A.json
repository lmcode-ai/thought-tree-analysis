{
  "segments": [
    {
      "text": "Okay, I need to translate this Java code into Fortran.",
      "start_char": 0,
      "end_char": 54,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Let me start by understanding what the Java code does.",
      "start_char": 55,
      "end_char": 109,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "So, the Java program reads an integer n, then reads n integers into an array.",
      "start_char": 111,
      "end_char": 188,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "It calculates the sum of those numbers.",
      "start_char": 189,
      "end_char": 228,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Then, it loops through each element and checks two conditions: first, if (sum - arr[i]) is divisible by (n-1), and second, if the result of that division equals arr[i].",
      "start_char": 229,
      "end_char": 397,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "If both conditions are met, it increments a counter c and appends the index (plus 1) to a string.",
      "start_char": 398,
      "end_char": 495,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Finally, it prints the count and the list of indices.",
      "start_char": 496,
      "end_char": 549,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alright, translating this into Fortran. Let's see.",
      "start_char": 551,
      "end_char": 601,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "First, in Fortran, we don't have classes and methods like Java.",
      "start_char": 602,
      "end_char": 665,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "The main program will be a subroutine or just a main block.",
      "start_char": 666,
      "end_char": 725,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Since Fortran is more straightforward for procedural code, that should be manageable. Starting with the input. The Java code uses Scanner.",
      "start_char": 726,
      "end_char": 864,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "In Fortran, we'll use the read statement.",
      "start_char": 866,
      "end_char": 907,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Since Fortran is older, it might not have the same dynamic data structures as Java's ArrayLists, but since the array size is known from n, we can declare it with that size.",
      "start_char": 908,
      "end_char": 1080,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Wait, Fortran arrays are 1-based by default, but in the Java code, the array is 0-based.",
      "start_char": 1082,
      "end_char": 1170,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "So, that might be a consideration.",
      "start_char": 1171,
      "end_char": 1205,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "The indices here are from 0 to n-1 in Java.",
      "start_char": 1206,
      "end_char": 1249,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The output is (i + 1), so in Fortran, if I make the array 1-based, the conversion would be straightforward because each element's 1-based index would correspond directly. So maybe I can make the array start at 1 to avoid confusion.",
      "start_char": 1250,
      "end_char": 1481,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Alternatively, in Fortran, arrays can be declared with a lower bound of 0, but I think the default is 1 and sometimes people forget that. Hmm. Let me plan the steps:\n\n1. Read n from input. Declare an integer n.\n2.",
      "start_char": 1482,
      "end_char": 1695,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Read n integers into an array arr of size n. Declare an array arr(1:n). 3. Compute sum: sum = sum(arr).",
      "start_char": 1697,
      "end_char": 1800,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, loop through the array elements and accumulate. 4. Loop over each element from 1 to n:\n   a. Calculate temp = sum - arr(i)\n   b. Check temp mod (n-1) == 0\n   c. Check (temp/(n-1)) == arr(i)\n   If both, increment c and collect the indices (i, since Fortran is 1-based)\n5.",
      "start_char": 1801,
      "end_char": 2086,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Output the count c, then the list of indices separated by spaces.",
      "start_char": 2087,
      "end_char": 2152,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Wait, in the Java code, the output is the indices plus 1 because Java arrays start at 0.",
      "start_char": 2154,
      "end_char": 2242,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Since in Fortran arrays start at 1, the index i is exactly what we need. So maybe the translation's indices are exactly the same as i in Fortran's array. Wait the Java code does (i + 1), because in Java the array is 0-based, but here in Fortran, the indices start at 1. So the equivalent indices would be i, the loop variable, so when we print, just the current index i. That simplifies it.",
      "start_char": 2243,
      "end_char": 2633,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Now, variables: sum can be an integer.",
      "start_char": 2636,
      "end_char": 2674,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "The array can be an integer array. For the conditions: in the Java code, they check both (sum - arr[i]) mod (n-1) == 0, and that the division is equal to arr[i].",
      "start_char": 2675,
      "end_char": 2837,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Wait, in Java, if sum - arr[i] is divisible by (n -1), then the integer division (sum - arr[i])/(n-1) should equal arr[i], right?",
      "start_char": 2840,
      "end_char": 2969,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "In Fortran, the modulo operation is mod(), but I think in Fortran, mod(a,b) returns the remainder with the same sign as b. Hmm, but in modulus operations, sometimes there are sign issues. However in this case, since sum is the total of all elements and we are subtracting arr[i], so the sum could be anything, but the problem constraints probably ensure that the division is an integer and so the mod is zero for valid cases.",
      "start_char": 2971,
      "end_char": 3396,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Wait, in the code, the first condition is whether (sum - arr[i]) is divisible by (n-1). So in Fortran, it would be mod( sum - arr(i), n-1 ) == 0.\n\nSecond condition is that (sum - arr(i))/(n-1) == arr(i).",
      "start_char": 3398,
      "end_char": 3601,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Because when you subtract arr[i], then if the rest of the n-1 elements average to arr[i], but actually (sum - arr[i]) divided by (n-1) must be equal to arr[i]? Let me think.",
      "start_char": 3602,
      "end_char": 3775,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Wait, so the code checks if the average of the other (n-1) elements, when you exclude arr[i], is equal to arr[i].",
      "start_char": 3777,
      "end_char": 3890,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Because (sum - arr[i]) divided by (n-1) is the average of the remaining elements. So the condition is: when you remove arr[i], the average of the others must be equal to arr[i]. That's the condition here.",
      "start_char": 3891,
      "end_char": 4095,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "So, those conditions must hold.",
      "start_char": 4097,
      "end_char": 4128,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "So, in Fortran, I need to compute those two conditions.",
      "start_char": 4129,
      "end_char": 4184,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Now, for collecting the indices: The Java code uses a StringBuilder.",
      "start_char": 4186,
      "end_char": 4254,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "In Fortran, we can build a character string by concatenating.",
      "start_char": 4255,
      "end_char": 4316,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Alternatively, since the number of indices can be up to n (but probably small), we can build an array to hold the indices.",
      "start_char": 4318,
      "end_char": 4440,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Since we might not know its size upfront, but in Fortran, dynamic arrays can be handled with allocatable arrays.",
      "start_char": 4441,
      "end_char": 4553,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Alternatively, since the number of outputs per line is known (each index is printed as a space-separated list), perhaps we can first count the number (c) and then when building the list, just append each time. But in Fortran, strings are fixed-length. So maybe using a character variable of sufficient length.",
      "start_char": 4555,
      "end_char": 4864,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, perhaps use a write statement with a list directed so that it automatically appends.",
      "start_char": 4866,
      "end_char": 4965,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "However, the problem requires the indices in order. Let's see.",
      "start_char": 4966,
      "end_char": 5028,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Wait, in the first output line, it's the count c, then the second line is the list of indices.",
      "start_char": 5030,
      "end_char": 5124,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The second line is exactly the results stored.",
      "start_char": 5125,
      "end_char": 5171,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Let me think of building a character variable.",
      "start_char": 5172,
      "end_char": 5218,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, in Fortran:\n\nWe can do:\n\ninteger, dimension(:), allocatable :: indices\n\nAllocate( indices(0) )  !",
      "start_char": 5220,
      "end_char": 5332,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Initialize as empty\n\nThen, as each index is found, reallocate the array with size increased by 1 and append new element. But maybe for simplicity, since the maximum size is n, we can preallocate an array of size n, and track the current position.",
      "start_char": 5333,
      "end_char": 5579,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, perhaps in Fortran, we can just write the indices as they are found into an output list. But since we need to collect all indices before printing, it's better to store them.",
      "start_char": 5582,
      "end_char": 5770,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Let me plan variables:\n\nvariables needed:\n\ninteger :: n, c, sum, temp, i\n\ninteger, dimension(:), allocatable :: arr, indices\n\nThen, proceed: Read n, allocate arr(1:n). Read arr(1) to arr(n). Compute sum as sum(arr(1:n)). Initialize c=0 and indices as an array that will collect the positions (i). But let's see step by step code.",
      "start_char": 5772,
      "end_char": 6105,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "First, read n:\n\nRead(*,*) n\n\nallocate(arr(1:n))\n\nThen read n integers. In Fortran that can be:\n\nRead(*,*) (arr(i), i=1,n)\n\nBut wait, in Fortran, the values are read sequentially, so this should work. Sum: sum = sum( arr )\n\nNow loop over i from 1 to n:\n\ndo i=1,n\n\n   temp = sum - arr(i)\n\n   if (mod(temp, n -1) == 0 ) then\n\n      if ( temp/(n-1) == arr(i) ) then\n\n           c = c +1\n\n           indices(c) = i\n\n      end if\n\n   end if\n\nend do\n\nWait, but for that, I need to first allocate the indices array as well, since we don't know how many will be there. Hmm, that's a problem. Ah right.",
      "start_char": 6108,
      "end_char": 6701,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "In the code above, we can't know the size of indices until after the loops. So we can preallocate indices with size n and then after processing, we'll have c elements in it. So let's do that. So first, allocate indices(1:n).",
      "start_char": 6703,
      "end_char": 6927,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Then, during processing, store the indices in the first c entries, then at the end, after the loop, we can print those.",
      "start_char": 6929,
      "end_char": 7048,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, maybe just keep a character string and append to it. Let me see.",
      "start_char": 7050,
      "end_char": 7129,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternative approach for collecting the indices:\n\nInitialize a character string ' ' (empty)\n\nthen for each i that satisfies, append trim(adjustl( str(i) )) // ' ' etc.\n\nUsing Fortran 90 string handling features. Like:\n\ncharacter(len=256) :: sb = ''\n\nthen each time:\n\nwrite(temp_str, '(I0)') i\n\nsb = trim(sb) // temp_str // ' '\n\nThen, after, trim off any trailing space.",
      "start_char": 7131,
      "end_char": 7501,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Alternatively, use an array of indices and then write them in a loop. Either way might be okay. Let me think code steps in Fortran:\n\nWrite a program:\n\nprogram codeforces_134_a\n\nimplicit none\n\ninteger               :: n, i, sum_total, c = 0\n\ninteger, allocatable  :: arr(:), indices(:)\n\n! Read n\n\nread(*,*) n\n\n!",
      "start_char": 7503,
      "end_char": 7815,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Allocate arrays\n\nallocate( arr(1:n), indices(0:n) ) ! indices is allocated with max size n.\n\nc =0\n\n!",
      "start_char": 7816,
      "end_char": 7916,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Read array elements\n\nread(*,*) arr(1:n)\n\n! Compute sum of all elements\n\nsum_total = sum( arr )\n\n! Loop over each element:\n\ndo i=1, n\n\n    if ( (sum_total - arr(i)) ==0 ) then\n\n        !",
      "start_char": 7917,
      "end_char": 8102,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "If n-1 is zero, but n is input from user, but in code, n is the number of elements. So n must be at least 1.\n\n        ! But wait, when n is 1, n-1 is 0. So need to handle division by zero? But in the problem statement perhaps n is at least something else?",
      "start_char": 8103,
      "end_char": 8358,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Well, the problem may have constraints. Let me see. Looking at the original code: In the Java code, when n is 1, then the condition would require (sum - arr[0])%0 ==0, but mod with 0 is invalid. So perhaps the problem assumes n>=2? But the code probably expects that n is at least 2, otherwise, it would result in division by zero.",
      "start_char": 8360,
      "end_char": 8693,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Since in competition problems, sometimes such edge cases are considered.",
      "start_char": 8695,
      "end_char": 8767,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "Well, the fortran code must handle that as well. Hmm.",
      "start_char": 8769,
      "end_char": 8822,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "So, to avoid division by zero, perhaps in the code, when n is 1, but in that case, perhaps (sum - arr[0]) = 0",
      "start_char": 8824,
      "end_char": 8933,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "(since it's the only element), so mod(0, 0 ) which is undefined anyway. Therefore, the code needs to handle when n -1 is 0, i.e., n=1, but the code may not process those. In the code, for n=1:\n\nsum is arr[0], so (sum - arr[i]) is 0, so mod(0,0) is undefined.",
      "start_char": 8934,
      "end_char": 9194,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "The Java code would crash here.",
      "start_char": 9195,
      "end_char": 9226,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Therefore, the problem probably specifies that n is at least 2, so in fortran code, we can proceed under that assumption. But in our code, to avoid division by zero, perhaps adding:\n\nif (n == 1) then \n\n    ... \n\nend if \n\nBut let me see, perhaps better to check:\n\nn_minus_1 = n-1\n\nif (n_minus_1 <=0) then ... but for now, proceeding. In the loop over i:\n\n    temp = sum_total - arr(i)\n\n    if ( mod( temp, n_minus_1 ) ==0 ) then \n\n        ! divisible\n\n        if ( temp / n_minus_1 == arr(i) ) then \n\n            c = c +1 \n\n            indices(c) = i \n\n        end if \n\n    end if \n\nend do\n\nWait, but when n-1 is 0 (n=1), then mod is undefined, so the test is invalid. Hence, need to handle n=1 as a separate case. Alternatively, in the code, before proceeding, check n >=2, set c=0, and proceed, and for n=1, nothing is collected. But given that the code in Java would have faced this, perhaps it is okay that for n=1, we skip those checks, but the problem might not have test cases with n=1.",
      "start_char": 9228,
      "end_char": 10226,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "Well, proceeding under assumption that n is at least 2.",
      "start_char": 10228,
      "end_char": 10283,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Now, after the loop, allocate the indices array properly, or use a fixed size.",
      "start_char": 10285,
      "end_char": 10363,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Since we preallocated indices(0:n) maybe I made a mistake.",
      "start_char": 10364,
      "end_char": 10422,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "Let me change:\n\nallocate(arr(1:n))\n\nallocate( indices(1:n) )\n\nthen c starts at 0, so indices(1:c) will be filled as we go.",
      "start_char": 10423,
      "end_char": 10545,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Wait, yes, because in allocation indices(1:n) can be up to n elements. So for each eligible i, indices(c+1) = i, then c increments.",
      "start_char": 10547,
      "end_char": 10679,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "After the loop, the indices holds up to c elements.",
      "start_char": 10681,
      "end_char": 10732,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Now, to print the results:\n\nFirst output c, then the indices separated by space.",
      "start_char": 10734,
      "end_char": 10814,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "To do the second line, perhaps:\n\nwrite(*,'(I0)')",
      "start_char": 10816,
      "end_char": 10864,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "c \n\nThen, second line:\n\nwrite(*,'(1000I0)') (indices(1:c), each separated by a space?)",
      "start_char": 10865,
      "end_char": 10951,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Wait, in Fortran, if we can do something like:\n\nwrite(*,'(I0)')",
      "start_char": 10953,
      "end_char": 11016,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "indices(1:c)(:)\n\nHmm, perhaps better:\n\nwrite(*,'( (I0,1x),/ )' ) indices(1:c)",
      "start_char": 11017,
      "end_char": 11094,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Ah, here, the format: The parenthesis groups the elements, each written as I0 (free format integer), followed by a space, and the comma after I0,1x would add a new space? Wait maybe better to think.",
      "start_char": 11096,
      "end_char": 11294,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The format for writing the list:\n\nLet me think: To print all elements of indices(1:c) separated by spaces, followed by a newline.",
      "start_char": 11296,
      "end_char": 11425,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "The format '(\"There are \",I0,\" elements: \",1X,I0, \"(A /)')\" but perhaps:\n\nFirst, print c on its own line:\n\nwrite(*,*) c\n\nThen, write all the elements of indices(1:c) separated by spaces:\n\nwrite(*, '( (I0, 1X), : )' ) indices(1:c) But I need to check how to write a list with just spaces between.",
      "start_char": 11427,
      "end_char": 11722,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The format '( (I0, 1X), :, : )' you can do something.",
      "start_char": 11724,
      "end_char": 11777,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Alternatively, it's simpler to loop through the indices and print each with a space, but trailing space is acceptable for Fortran (since the problem may accept that). Alternatively, let's see:\n\nSuppose after collecting the indices, we do:\n\n if (c>0) then \n\n    do i=1,c\n\n        write(*,'(I0, 1X)', advance='no') indices(i)\n\n    end do\n\n    write(*,*)  !",
      "start_char": 11779,
      "end_char": 12134,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "newline\n\n else \n\n    write(*,*)  ! maybe print nothing? But the problem requires to show c as 0 then next line empty?",
      "start_char": 12135,
      "end_char": 12252,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Wait, the original Java code would print \"0\" then empty string, which would print \"0\" then the next line has 0 characters. Wait, see in Java, after creating the string, which would be empty if c =0. Then printing sb.toString() would output nothing (since appending nothing), but in Fortran, when you have an empty array, writing (indices(1:0))",
      "start_char": 12254,
      "end_char": 12598,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "etc. would either do nothing or error? Hmm.",
      "start_char": 12599,
      "end_char": 12642,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Alternatively, perhaps build a character string.",
      "start_char": 12645,
      "end_char": 12693,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Let me think of the approach with a string. Initialize a character variable:\n\ncharacter(len=256), parameter :: separator = \" \"\n\ncharacter(len=:), allocatable :: buffer\n\nAllocation might be needed, but Fortran strings are fixed length unless using allocatable.",
      "start_char": 12695,
      "end_char": 12955,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, use a fixed length buffer, but size? Maybe assume maximum n=1e5 elements, but the elements are up to say 1e9, but the output requires just their indices (up to 10 digits each). Then for n=1e5, 1e5 * (6 digits) ~ 5e5 characters, which may be too big.\n\nAlternatively, perhaps safer with a dynamic approach.",
      "start_char": 12957,
      "end_char": 13276,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, let's go back to first method with array. First line output is just c, the count. Second line is the list of indices, separated by spaces, so if c=0, it's empty line.",
      "start_char": 13278,
      "end_char": 13461,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "In Fortran:\n\nIf we have an indices array allocated properly, then:\n\nAfter computing the c, do:\n\nwrite(*,*) c\n\nif (c >0 ) then\n\n    write(*, '( (I0, 1X), : )' )",
      "start_char": 13463,
      "end_char": 13622,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "indices(1:c)\n\nend if\n\nAlternatively, the format could be '( (I0, 1X), / )' but maybe we need to ensure that the final space is omitted? Or does it not matter?",
      "start_char": 13623,
      "end_char": 13781,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Well, the problem probably allows the last element to have a trailing space.",
      "start_char": 13782,
      "end_char": 13858,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "Another way: write each index followed by a space, but then backspace the last space.",
      "start_char": 13860,
      "end_char": 13945,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, just write all with trailing space and see.",
      "start_char": 13947,
      "end_char": 14005,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "The problem's sample outputs probably include a trailing space.",
      "start_char": 14007,
      "end_char": 14070,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "Let's see:\n\nIn the sample below, perhaps.",
      "start_char": 14071,
      "end_char": 14112,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "Alternatively, use a do loop to print each, adding a space each time. So:\n\ndo i =1,c\n\nwrite(*,'(I0)', advance='no') indices(i) if (i < c ) then \n\n write(*,'(A)', advance='no') ' '\n\nelse \n\n write(*,*) ' '   ! or just newline? Wait, but new line is needed. Hmm.",
      "start_char": 14114,
      "end_char": 14375,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Alternatively:\n\nThe code would be: do i =1,c\n\n    write(*,'(I0, 1x)', advance='no') indices(i)\n\nend do\n\nwrite(*,*)    !",
      "start_char": 14378,
      "end_char": 14498,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "this adds a new line after the last space. Wait, for example, if c=3, then the write loop produces \"1 2 3 \", then a new line. But that's an extra space at the end. Maybe that's acceptable; the problem may accept it.",
      "start_char": 14499,
      "end_char": 14715,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Alternatively, perhaps safer to do:\n\nwrite(*,'( (I0,1x), : )' ) indices(1:c)\n\nThen a new line is automatically added because of the / at the end (if the end= is set?)",
      "start_char": 14717,
      "end_char": 14883,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Hmm I need toremebwe format descriptors.",
      "start_char": 14885,
      "end_char": 14925,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "Alternatively, format '(I0,1X)' has each item followed by space, and at the end of the output, maybe line moves, but perhaps the trailing space would be left on the line.",
      "start_char": 14927,
      "end_char": 15097,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Wait, Fortran uses the format to generate characters, so the format '( 10I0 )' etc. Let me perhaps test with an example.",
      "start_char": 15099,
      "end_char": 15219,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Alternatively, think about in Fortran, the standard code to write a list of numbers space-separated: Like: write(*, fmt='( (I0, 1X), : )' ) list.",
      "start_char": 15221,
      "end_char": 15367,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Wait, perhaps the format '( (I0, 1X) : )' ?",
      "start_char": 15369,
      "end_char": 15412,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "The format '( (I0,1X), : )' is a standard way to write in a loop, where each I0 is followed by a space, and after the specified list.",
      "start_char": 15414,
      "end_char": 15547,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Wait, perhaps a format like:\n\n'**(I0) **'?",
      "start_char": 15549,
      "end_char": 15591,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "No, maybe let me see the correct syntax.",
      "start_char": 15593,
      "end_char": 15633,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "The format for writing multiple items, each with a space after.",
      "start_char": 15635,
      "end_char": 15698,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "An example, if you have values x(1:n), then:\n\nwrite(*,'(1000(I0,1X))')",
      "start_char": 15700,
      "end_char": 15770,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "x(1:n)\n\nThis would write up to 1000 items, each with space, but because of the comma and the 1X, which might? Not exactly sure.",
      "start_char": 15771,
      "end_char": 15898,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Alternatively, the correct format to have all elements separated by spaces regardless of how many is:\n\n'(*(I0,1X))'\n\nSo with the * in the format, that allows variable length.",
      "start_char": 15900,
      "end_char": 16074,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Ah, right, the asterisk * in Fortran format allows variable repetitions. So the correct format is:\n\nwrite(*, '( *(I0, 1x) )') indices(1:c)",
      "start_char": 16076,
      "end_char": 16214,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "This would print each integer followed by a space.",
      "start_char": 16216,
      "end_char": 16266,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Then, the trailing space will be there. But the sample output might have it, but perhaps in the problem it's okay.",
      "start_char": 16268,
      "end_char": 16382,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Alternatively, the problem might allow any format as long as it's correct with numbers separated by spaces and nothing else.",
      "start_char": 16384,
      "end_char": 16508,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Since the code's original Java code also prints a trailing space, let's see:",
      "start_char": 16509,
      "end_char": 16585,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "In Java's case, the code uses a String initially empty, then for each index added \" (i+1) + \" \"<space>\", so the resulting string ends with a space. So printing that, the second line will have a trailing space, but that's allowed by the judge if the problem accepts it as correct, typically they do, unless specified otherwise.",
      "start_char": 16587,
      "end_char": 16913,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Therefore, the trailing space is acceptable here. So in Fortran, that's okay.",
      "start_char": 16915,
      "end_char": 16992,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Therefore, let's write:\n\nAfter the loop to collect indices, the code outputs:\n\nwrite(*,*) c\n\nwrite(*, '( *(I0, 1X) )' )",
      "start_char": 16995,
      "end_char": 17114,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "indices(1:c)\n\nWait, but Fortran's 1X is a single space, so each entry has a space after, so yes, that's correct.",
      "start_char": 17115,
      "end_char": 17227,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Alternatively, perhaps it's better to use:\n\nwrite(*, \"( (I0, 1X), / )\" ) indices(1:c)",
      "start_char": 17229,
      "end_char": 17314,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The '/' causes a new record, but the important part has each with 1X.\n\nWait, I think the format specification is crucial here.",
      "start_char": 17316,
      "end_char": 17442,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Let me think of an example:\n\nSuppose the indices are [1,3,5].",
      "start_char": 17443,
      "end_char": 17504,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "The list should be written as \"1 3 5 \" with a trailing space, followed by a newline. Alternatively, perhaps the following:\n\nThe code can first write all elements, each followed by a space:\n\nThus using:\n\nwrite(6,*) (indices(j),j=1,c)\n\nBecause when using list-directed I/O, spaces are between the terms.",
      "start_char": 17505,
      "end_char": 17807,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "For example, the list-directed output of write(*,*) 1,3,5 would produce \"1 3 5\" (without the trailing space).",
      "start_char": 17808,
      "end_char": 17917,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Wait, no, list directed output separates with spaces but doesn't add a trailing one. Let me think. Wait if I do write(*,*) indices(1:c), then list directed output will write each separated by a space, with no trailing space. So that's better. Wait, actually yes. If I do:\n\ninteger :: indices(3) =",
      "start_char": 17918,
      "end_char": 18216,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "[1,3,5]\n\nwrite(*,*) indices, then output would be \"1 3 5\", but for an array, it's written as per the elements. But for an array, when you write array, it's treated as elements.",
      "start_char": 18217,
      "end_char": 18393,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Ah, so:\n\nSuppose indices has c elements. Then:\n\nwrite(*,*) (indices(j), j = 1,c)\n\nThat would write each separated by spaces, with no trailing space, since list directed. Thus, that is better.",
      "start_char": 18396,
      "end_char": 18587,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Alternatively:\n\nwrite(*,*) , followed by the elements. Let's try. So, let's see. In the program:\n\nAfter collecting indices(1:c):\n\nwrite(*,*) c\n\nwrite(*,*) (indices(j), j=1,c)",
      "start_char": 18590,
      "end_char": 18766,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Wait, but then, in the second line, it'll be written with space-separated, and ending on a new line.",
      "start_char": 18768,
      "end_char": 18868,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "That's exactly what Java's code does. Yes, that seems good.",
      "start_char": 18869,
      "end_char": 18928,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Because when you do write(*,*) (values), the values are written with spaces between them, and the line ends with a new line. Wait, exactly. So:\n\nThe code would be:",
      "start_char": 18930,
      "end_char": 19093,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "First, print c.\n\nSecond, write all indices, space-separated on a new line.",
      "start_char": 19096,
      "end_char": 19170,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Hence this approach is better because it avoids trailing space. The Java code's:\n\nSystem.out.println(sb.toString());\n\nWhich is sb contains \"1 2 3 \", ending with a space.",
      "start_char": 19172,
      "end_char": 19342,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "That would have a trailing space, but in the Fortran code, with the above approach, there is no trailing space. Wait, which is right? Let me check. The Java code, for a case of c=3, the string is built with (i+1 \"+ \" \")\n\nWait the code appends a space after every index, including the last one, so the string ends with a space. So when printed, the output will have a trailing space. But the problem statement may not care about the trailing space, so both approaches may be acceptable, but in Fortran's case, printing via list-directed which doesn't add the space, it would be correct? Wait, let me recalculate.",
      "start_char": 19343,
      "end_char": 19955,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "original java:\n\nc is 3, then in the loop, appends (i+1) followed by \" \" each time. So for indices [1,2,3]:\n\nthe first i=0 (Java zero-based) would have been converted to 1, next 2, then 3. So when appended, the string would be \"1 2 3 \"\n\nso in Java, the string has a trailing space, so the System.out.println() appends that string, which has a space.",
      "start_char": 19958,
      "end_char": 20306,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Thus, the output's second line would have a trailing space.",
      "start_char": 20309,
      "end_char": 20368,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Thus, in Fortran, if I use the list-directed write, it will not, thus differing. But perhaps the judge is okay with it, as it is considered as space-separated, so even with an extra space.",
      "start_char": 20370,
      "end_char": 20558,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Hmm, so to be precise as the Java code, the trailing space should be present. So maybe in Fortran:\n\nThe code can do something like\n\ncharacter(len=10)n is the indices... Wait perhaps is better to collect the indices into a string.",
      "start_char": 20560,
      "end_char": 20790,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Therefore:\n\nMethod 2: Using a string. Initially:\n\ncharacter(len=200000) :: sb = ''\n\nThen, each iteration where the condition is met, append the index and a space.",
      "start_char": 20793,
      "end_char": 20956,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The problem is that in Fortran strings are fixed-length. So need to know the length.",
      "start_char": 20958,
      "end_char": 21042,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Let me estimate: if n is up to, say, 1e5 each integer is 6 digits. Each index is up to maybe 1e5 (but for indices up to n = 1e5, so 1e5 elements, each is up to 5 digits (since 1e5 is 5 digits). Then n elements would be 5*1e5 = 5e5 characters.",
      "start_char": 21044,
      "end_char": 21287,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Plus one more space between each, which adds another 1e5 characters, so total ~6e5 characters (600,000). So allocating a string of len=600000 should handle it.",
      "start_char": 21288,
      "end_char": 21447,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Alternatively, in modern computers this is manageable, but in code submission platforms, perhaps maximum string length allowed may have to be considered, but perhaps 1e6 is okay. In code:\n\ncharacter(len=1000000) :: sb = \"\"\n\nthen for each valid i:\n\nwrite (temp_str, '(I0)') i \n\nsb = trim(sb) //",
      "start_char": 21449,
      "end_char": 21743,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "temp_str // \" \"\n\nThus, with each addition, the string grows. Finally, the sb will have trailing space; to remove it, we can do trim(sb)||\" \" but not exactly. Wait trim removes leading and trailing blanks, so trim(sb) would remove the trailing space. But then we would lose that? Alternatively, when appending, do:\n\nsb = trim(adjustl(sb)) //",
      "start_char": 21744,
      "end_char": 22086,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "trim(adjustl( ... ) )\n\nNot sure. Wait maybe:\n\nEach time, append the current i and a space.",
      "start_char": 22087,
      "end_char": 22177,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "So, for the first i, it would be x and ' ', then next one appends ' ' + next x and ' '",
      "start_char": 22180,
      "end_char": 22266,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "etc, so the string becomes the numbers separated by spaces.",
      "start_char": 22267,
      "end_char": 22326,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "At the end, the string has a trailing space.",
      "start_char": 22328,
      "end_char": 22372,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Thus:\n\nif using trim(sb(1:len_trim(sb) -1) )\n\n/// \n\nAlternatively, just output the whole string, with trailing space.",
      "start_char": 22374,
      "end_char": 22491,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The problem's judge might accept it. Thus:\n\nAfter the loop, in Fortran:\n\nif (c /= 0) then \n\n   sb = trim(adjustl( sb )) // ' ' // trim(adjustl( ... ) ) ? Hmm getting complicated.",
      "start_char": 22492,
      "end_char": 22671,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Alternatively, let's see the earlier code using indices array and list directed output.",
      "start_char": 22674,
      "end_char": 22761,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The list directed output writes the indices separated by one or more whitespace, but no trailing. So in the case of 3 elements, the output would be \"1 3 5\" with no trailing space, whereas the Java code's output is \"1 2 3 \" as above. So there's a discrepancy here. Hmm, which is correct?",
      "start_char": 22763,
      "end_char": 23049,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Well, perhaps the problem requires the indices to be in space-separated format.",
      "start_char": 23052,
      "end_char": 23131,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "The trailing space may be acceptable, but if not, then we need to output exactly like the original Java.",
      "start_char": 23132,
      "end_char": 23236,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Alternative approach: use a string and build it properly. Let me try that in code:",
      "start_char": 23238,
      "end_char": 23320,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Allocate a character buffer, then for each valid index, write the value to the string with a trailing space.",
      "start_char": 23323,
      "end_char": 23431,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Then, at the end, the string has trailing space, but if c is zero, the string is empty.",
      "start_char": 23433,
      "end_char": 23520,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "Then, to print the string, use:\n\nif ( len_trim(sb) > 0 ) then \n\n    write(*,*) trim(sb(1:len(trim(sb)-1)) )\n\nelse \u2026 \n\nHmm.",
      "start_char": 23522,
      "end_char": 23644,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Alternatively, to write the buffer as it is, including the trailing space. The problem may accept.",
      "start_char": 23646,
      "end_char": 23744,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, perhaps the problem expects the trailing space, so let's try to have it. So in Fortran code: Using an intrinsic function to build the string:\n\ncharacter(len=2000000) :: sb = ''\n\ndo i=1,n\n\n    if conditions met:\n\n        write(temp_str,'(I0)') i\n\n        sb = trim(adjustl(sb)) // trim(adjustl(temp_str)) // ' '\n\nend do\n\nthen:\n\n write(*,*) c\n\n if ( c >0 ) then\n\n     write(*,'(A)')",
      "start_char": 23747,
      "end_char": 24144,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "trim(adjustl( sb )) // ' ' ???",
      "start_char": 24145,
      "end_char": 24175,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "No, perhaps not, but if I have sb:\n\nfor example, for three indices it would be \"1 \"+ \"2 \" + \"3 \" \u2192 \"12 3 \" ? Wait, wait, no.",
      "start_char": 24177,
      "end_char": 24301,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Wait, initial sb is empty string. - First i=1 (valid), append:\n\nsb is empty, so after first iteration: temp_str is \"1\" \u2192 temp_str adjusts to '1', ' ' \u2192 so sb is \"1 \" (assuming ' && with ). Next, for next i=2 (valid):\n\nnew temp_str is '2', then sb becomes previous \"1 \" // \"2 \" \u2192 \"1 2 \" etc.",
      "start_char": 24303,
      "end_char": 24595,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Yes, so after all valid entries, sb holds all indices, separated by spaces with a trailing space. Thus when printed, it matches the Java's output.",
      "start_char": 24598,
      "end_char": 24744,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Hence:\n\nAfter building sb like that, the second line is simply:\n\nwrite(*,'(A)') trim( adjustl( sb ) )",
      "start_char": 24747,
      "end_char": 24848,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "No, because the trailing space would still be there.",
      "start_char": 24850,
      "end_char": 24902,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "Wait, for example, if sb after loop for 3 indices is \"1 2 3 \", then trim(adjustl(sb)) gives \"1 2 3\", losing the trailing space?\n\nBecause TRIM removes any trailing whitespace, which the space is counted as whitespace. Thus trim(\"1 2 3 \") becomes \"1 2 3\".",
      "start_char": 24904,
      "end_char": 25157,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Which would make the output the same as list directed, with no trailing space, but that's exactly what list output do. Thus the correct way thus to keep the trailing space is tricky.",
      "start_char": 25159,
      "end_char": 25341,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Alternatively, perhaps build the sb like:\n\nfor each index: append index & space, thus the string has the trailing space, and then when you print it, the space is present.",
      "start_char": 25344,
      "end_char": 25514,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Hence:\n\nwriters:\n\nif c >0 then \n\n   write(*,'(A)') trim(adjustl( sb ) ) \n\nelse \n\n   write(*,*) ''\n\nend if \n\nBut then trimming removes the trailing space. So the sb is \"1 2 3 \" \u2192 trim is \"1 2 3\". Hence that won't work.",
      "start_char": 25515,
      "end_char": 25732,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Alternatively, perhaps do not use TRIM:\n\nwrite(*,'(A)') sb But the original sb has length with trailing space, and the 'A' format will write exactly the characters up to the last non-blank, including the trailing space. Wait in fortran, using the '(A)' will write the entire character string, so padding with spaces to the length of the array.",
      "start_char": 25736,
      "end_char": 26079,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Hmm, the trailing space is part of the array if we did append with the space.",
      "start_char": 26082,
      "end_char": 26159,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Yes, the variable sb holds the characters including the trailing space, so using write(*,*) sb would write the entire string, including the trailing space (as long as the string is exactly like that). Wait, in Fortran, when you write a character with \"(A)\", it writes all characters until the end of the string, but if the character variable is len=200000, but the actual content is shorter, it would write the content plus the following spaces? Wait no: len_trim( string ) gives the length up to first blank.",
      "start_char": 26161,
      "end_char": 26671,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "No.\n\nWait Fortran strings are stored as arrays of characters. If I have a character(len=10) variable, and I assign \"ABC \", then it's stored as ABC followed by 7 spaces.",
      "start_char": 26673,
      "end_char": 26841,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Thus, writing character(10) using (A) would output \"ABC        \" (with 7 spaces, which is not desired. Ah, so this is a problem.",
      "start_char": 26843,
      "end_char": 26971,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "This is similar to C strings in that Fortran's character arrays are not null-terminated, so writing them outputs the entire length.",
      "start_char": 26973,
      "end_char": 27104,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Thus, the code must manage the string's actual length.",
      "start_char": 27106,
      "end_char": 27160,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The best way is to write up to the length of the string.",
      "start_char": 27163,
      "end_char": 27219,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Thus:\n\nwrite(*,'(A)') sb(1: len_trim( sb ) )",
      "start_char": 27222,
      "end_char": 27266,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Which outputs only up to the last non-space character. Wait",
      "start_char": 27268,
      "end_char": 27327,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "but, what if the last character is a space?",
      "start_char": 27328,
      "end_char": 27371,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "Because when you build sb as \"1 2 3 \", the last character is a space.",
      "start_char": 27373,
      "end_char": 27442,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The len_trim of sb is length of the string up to the last non-space character. So len_trim of \"1 2 3 \" would be 4 characters (the first 4 include the last 3's digit and the space before the terminating space? Wait let me think: \"1 2 3 \" is 5 characters: '1', ' ', '2', ' ', '3', ' ',?",
      "start_char": 27444,
      "end_char": 27728,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Wait, no, let me count:\n\n\"1 2 3 \" is:\n\nIndices 1: '1'\n\n2: ' '\n\n3: '2'\n\n4: '3' ??",
      "start_char": 27731,
      "end_char": 27811,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "No, sorry, perhaps my example is not:\n\nWait if we had indices 1 and 2 and 3 (indices 1,2,3 in Fortran), then each appends the number and a space. First appends \"1 \" \u2192 sb= \"1 \" (len=2). Second appends \"2 \" \u2192 becomes \"1 \" (from first) + \"2 \" \u2192 \"1 2 \" (len=4). Third appends \"3 \" \u2192 now \"1 2 3 \" (len=6 characters, array entries 1 to 6 as '1',' ',',','2',' ',',','3', ' ' ? Wait no, each append adds (assuming the i=1 with 1 + space, then 2 + space, then 3 + space. So total of 3* (1 +1) characters (digit plus space)*3 \u2192 6 characters. So the string is \"1 2 3 \", with the last being space. Thus the len_trim(sb) would stop at the digit 3's character (the 5th?), so the 6th is space.",
      "start_char": 27812,
      "end_char": 28493,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "trim would give \"1 2 3\" as length_trim.",
      "start_char": 28495,
      "end_char": 28534,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Thus, the output would miss the last space. Therefore in this case, the approach of building a string and using it would end up missing that space, just as the list directed approach does.",
      "start_char": 28536,
      "end_char": 28724,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Hence, neither method would exactly reproduce the Java's trailing space. However, the problem's test cases probably allow any space-separated list; the trailing space doesn't matter, as it's still valid. Thus perhaps best to proceed with the indices array and list-directed output, which produces the exact format required (possibly without the trailing space).",
      "start_char": 28726,
      "end_char": 29088,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Now, returning to the overall code. Putting it all together.",
      "start_char": 29091,
      "end_char": 29151,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Also, in fortran, the loops are written with DO-ENDDO.",
      "start_char": 29154,
      "end_char": 29208,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Now, variables:\n\nProgram structure:\n\n1. Read n.\n\n2. Read n numbers into an array. 3. Compute their sum.",
      "start_char": 29210,
      "end_char": 29313,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "4. Iterate through each element, compute temp, check the conditions. 5. Collect indices in an array. Then output count and indices.",
      "start_char": 29316,
      "end_char": 29447,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Also, the code must allocate arrays, etc. Here's the code in Fortran 90:\n\nprogram codeforces_134_A\n\n    implicit none\n\n    integer :: n, i, sum_total, c\n    integer, dimension(:), allocatable :: arr, indices\n\n    read(*,*) n\n\n    if (n ==0) then\n        write(*,*) 0\n        write(*,*) \"\"\n        stop\n    end if\n\n    allocate( arr(1:n), indices(1:n) ) c =0\n\n    read(*,*) (arr(i), i=1,n)\n\n    sum_total = sum( arr )\n\n    do i=1,n\n        if ( (n-1) ==0 ) cycle  ! skip when n=1, since n-1=0, which would cause division by zero",
      "start_char": 29451,
      "end_char": 29983,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "if (mod( sum_total - arr(i), n-1 ) == 0 ) then\n            if ( ( (sum_total - arr(i)) / (n-1) ) == arr(i) ) then\n                c = c +1\n                indices(c) = i\n            end if\n        end if\n    end do\n\n    write(*,*) c\n    if (c >0 ) then\n        write(*,*) (indices(j), j=1,c)\n    else\n        write(*,*)  ! empty line\n    end if\n\n    deallocate(arr, indices)\nend program codeforces_134_A\n\nWait, but what about n=1 case?\n\nWhen n=1: Then n-1 =0 \u2192 the code would skip the rest of loop iterations (since in the do loop over 1 to 1, the 'cycle' skips the rest (the entire iteration).",
      "start_char": 29992,
      "end_char": 30587,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "Thus, at the end, c remains 0. Hence, output 0 and an empty line, which matches what the Java code would do if n=1. In the Java code, for n=1, the loop runs once:\n\ntemp = sum - arr[0] = 0.\n\nmod(0, 0) is invalid, which in Java would throw an exception, but since compiler allows it?",
      "start_char": 30589,
      "end_char": 30872,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Well, in practice, division by zero in mod is an error. Thus the Java code would crash for n=1, but our Fortran code properly skips it.",
      "start_char": 30873,
      "end_char": 31009,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Hence, the fortan code properlyer handles it.",
      "start_char": 31011,
      "end_char": 31056,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Now, code:\n\nLet me debug let me see:\n\nCheck variable declarations:\n\narr is allocated from 1 to n. Good.",
      "start_char": 31058,
      "end_char": 31161,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The read loop uses read(*,*) (arr(i), ...) \u2192 yes. The loop over i, mod and conditions.\n\nWait in the code:\n\nInside do i =1 to n:\n\n    if (n-1) ==0 \u2192 which is n=1, then cycle. So for n=1's case, code skips. Other cases:\n\nFor n >= 2. Yes.",
      "start_char": 31163,
      "end_char": 31401,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Now, the sum_total is the total sum. Conditions are checked.",
      "start_char": 31404,
      "end_char": 31464,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "If (sum - arr(i)) mod (n-1) is zero, and the integer division is arr(i).",
      "start_char": 31467,
      "end_char": 31539,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "In Fortran, integer division (using / operator is integer division). Thus, correct.",
      "start_char": 31541,
      "end_char": 31624,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Variable c counts the number of valid indices.",
      "start_char": 31627,
      "end_char": 31673,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Indices array saves their indices (1-based). Yes.",
      "start_char": 31674,
      "end_char": 31723,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Then, output c.\n\nSecond line, if c>0, output the indices, space-separated. The code for the second line uses list-directed output: (indices(j),j=1,c), which produces space-separated values, no trailing space. Which is different from Java. But perhaps acceptable. Now, what about when n is 2?",
      "start_char": 31726,
      "end_char": 32018,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Let's test hypothetical input.",
      "start_char": 32021,
      "end_char": 32051,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Sample Input:\n\n3\n\n3 3 0\n\nWait let's say the array is [3,3,0]. Wait n=3. Sum_total is 6. Testing each element:\n\ni=1 \u2192 arr[1]=3\n\ntemp = 6-3 = 3 \u2192 divided by n-1 = 2: 3 mod 2 =1 \u2192 fails.\n\ni=2: temp=3 \u21923/2 = 1.5, but integer division would be 1. Thus, 1 != 3 \u2192 no.\n\ni=3:\n\ntemp = 6-0 =6 \u2192 divided by 2:3 \u2192 3 equals arr(i) (0).",
      "start_char": 32053,
      "end_char": 32379,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "No, 3 is not equal to 0 \u2192 thus no.",
      "start_char": 32380,
      "end_char": 32414,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Hence no valid indices, so output would be 0, and empty line.",
      "start_char": 32416,
      "end_char": 32477,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Alternatively another test case.",
      "start_char": 32479,
      "end_char": 32511,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "Another sample:\n\nSample Input: \n\n2\n\n1 3\n\nsum is4. Each check:\n\nFor i=1, minus 1 is 3 \u2192 (3) divided by n-1=1 \u21923/1=3 \u2192 compare with arr(1)=1 \u21923 \u22601 \u2192 no. For i=2: temp 4-3=1 \u2192 1 divided by1=1 \u2192 compare with 3 \u2192 no. So c remains zero. Thus output 0 and empty line.",
      "start_char": 32513,
      "end_char": 32775,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Another test case where it is valid. Sample Input:\n\n3\n\n2 2 2.\n\nSum =6. For each i:\n\nsubtract arr[i] (2) \u2192 sum -2 =4.\n\nn-1",
      "start_char": 32779,
      "end_char": 32902,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "is 2 \u21924 divided by2 is 2 \u2192 equal to arr[i]. Thus condition holds. Thus all three indices qualify. Thus output c=3 and indices 1 2 3.",
      "start_char": 32903,
      "end_char": 33037,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "In Fortran code, the second line would print 1 2 3 with no trailing space, while Java's would have trailing space. But the problem may be okay with either. Another example:\n\nn=4: elements [2,2,2,2]\n\nsum is 8. For any index i:\n\nsum - arr[i] = 6 \u2192 divided by n-1 =3 \u21926/3=2, which is equal to arr[i]. So each element qualifies. Thus output is c=4 and 1 2 3 4 \u2192 printed correctly. The code seems correct.",
      "start_char": 33039,
      "end_char": 33441,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Now, putting it all into the code.",
      "start_char": 33444,
      "end_char": 33478,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Note that in Fortran, mod(a,b) returns a remainder with the same sign as b, but in this problem, a is sum - arr[i].",
      "start_char": 33479,
      "end_char": 33594,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Since sum is the total of all elements including arr[i], and sum - arr[i] is sum of all else. So assuming all elements are integers, mod is okay unless negative numbers are present. But the problem's condition can still be met even with neative numbers.",
      "start_char": 33595,
      "end_char": 33848,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The code should work in all cases, including negatives. Thus the code appears correct.",
      "start_char": 33851,
      "end_char": 33937,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    }
  ],
  "original_reasoning": "Okay, I need to translate this Java code into Fortran. Let me start by understanding what the Java code does.\n\nSo, the Java program reads an integer n, then reads n integers into an array. It calculates the sum of those numbers. Then, it loops through each element and checks two conditions: first, if (sum - arr[i]) is divisible by (n-1), and second, if the result of that division equals arr[i]. If both conditions are met, it increments a counter c and appends the index (plus 1) to a string. Finally, it prints the count and the list of indices.\n\nAlright, translating this into Fortran. Let's see. First, in Fortran, we don't have classes and methods like Java. The main program will be a subroutine or just a main block. Since Fortran is more straightforward for procedural code, that should be manageable.\n\nStarting with the input. The Java code uses Scanner. In Fortran, we'll use the read statement. Since Fortran is older, it might not have the same dynamic data structures as Java's ArrayLists, but since the array size is known from n, we can declare it with that size.\n\nWait, Fortran arrays are 1-based by default, but in the Java code, the array is 0-based. So, that might be a consideration. The indices here are from 0 to n-1 in Java. The output is (i + 1), so in Fortran, if I make the array 1-based, the conversion would be straightforward because each element's 1-based index would correspond directly. So maybe I can make the array start at 1 to avoid confusion. Alternatively, in Fortran, arrays can be declared with a lower bound of 0, but I think the default is 1 and sometimes people forget that.\n\nHmm. Let me plan the steps:\n\n1. Read n from input. Declare an integer n.\n2. Read n integers into an array arr of size n. Declare an array arr(1:n).\n3. Compute sum: sum = sum(arr). Alternatively, loop through the array elements and accumulate.\n4. Loop over each element from 1 to n:\n   a. Calculate temp = sum - arr(i)\n   b. Check temp mod (n-1) == 0\n   c. Check (temp/(n-1)) == arr(i)\n   If both, increment c and collect the indices (i, since Fortran is 1-based)\n5. Output the count c, then the list of indices separated by spaces.\n\nWait, in the Java code, the output is the indices plus 1 because Java arrays start at 0. Since in Fortran arrays start at 1, the index i is exactly what we need. So maybe the translation's indices are exactly the same as i in Fortran's array.\n\nWait the Java code does (i + 1), because in Java the array is 0-based, but here in Fortran, the indices start at 1. So the equivalent indices would be i, the loop variable, so when we print, just the current index i. That simplifies it.\n\nNow, variables: sum can be an integer. The array can be an integer array.\n\nFor the conditions: in the Java code, they check both (sum - arr[i]) mod (n-1) == 0, and that the division is equal to arr[i]. \n\nWait, in Java, if sum - arr[i] is divisible by (n -1), then the integer division (sum - arr[i])/(n-1) should equal arr[i], right?\n\nIn Fortran, the modulo operation is mod(), but I think in Fortran, mod(a,b) returns the remainder with the same sign as b. Hmm, but in modulus operations, sometimes there are sign issues. However in this case, since sum is the total of all elements and we are subtracting arr[i], so the sum could be anything, but the problem constraints probably ensure that the division is an integer and so the mod is zero for valid cases.\n\nWait, in the code, the first condition is whether (sum - arr[i]) is divisible by (n-1). So in Fortran, it would be mod( sum - arr(i), n-1 ) == 0.\n\nSecond condition is that (sum - arr(i))/(n-1) == arr(i). Because when you subtract arr[i], then if the rest of the n-1 elements average to arr[i], but actually (sum - arr[i]) divided by (n-1) must be equal to arr[i]? Let me think.\n\nWait, so the code checks if the average of the other (n-1) elements, when you exclude arr[i], is equal to arr[i]. Because (sum - arr[i]) divided by (n-1) is the average of the remaining elements. So the condition is: when you remove arr[i], the average of the others must be equal to arr[i]. That's the condition here.\n\nSo, those conditions must hold. So, in Fortran, I need to compute those two conditions.\n\nNow, for collecting the indices: The Java code uses a StringBuilder. In Fortran, we can build a character string by concatenating.\n\nAlternatively, since the number of indices can be up to n (but probably small), we can build an array to hold the indices. Since we might not know its size upfront, but in Fortran, dynamic arrays can be handled with allocatable arrays.\n\nAlternatively, since the number of outputs per line is known (each index is printed as a space-separated list), perhaps we can first count the number (c) and then when building the list, just append each time. But in Fortran, strings are fixed-length. So maybe using a character variable of sufficient length.\n\nAlternatively, perhaps use a write statement with a list directed so that it automatically appends. However, the problem requires the indices in order. Let's see.\n\nWait, in the first output line, it's the count c, then the second line is the list of indices. The second line is exactly the results stored. Let me think of building a character variable.\n\nAlternatively, in Fortran:\n\nWe can do:\n\ninteger, dimension(:), allocatable :: indices\n\nAllocate( indices(0) )  ! Initialize as empty\n\nThen, as each index is found, reallocate the array with size increased by 1 and append new element.\n\nBut maybe for simplicity, since the maximum size is n, we can preallocate an array of size n, and track the current position.\n\nAlternatively, perhaps in Fortran, we can just write the indices as they are found into an output list. But since we need to collect all indices before printing, it's better to store them.\n\nLet me plan variables:\n\nvariables needed:\n\ninteger :: n, c, sum, temp, i\n\ninteger, dimension(:), allocatable :: arr, indices\n\nThen, proceed:\n\nRead n, allocate arr(1:n).\n\nRead arr(1) to arr(n).\n\nCompute sum as sum(arr(1:n)).\n\nInitialize c=0 and indices as an array that will collect the positions (i).\n\nBut let's see step by step code.\n\nFirst, read n:\n\nRead(*,*) n\n\nallocate(arr(1:n))\n\nThen read n integers. In Fortran that can be:\n\nRead(*,*) (arr(i), i=1,n)\n\nBut wait, in Fortran, the values are read sequentially, so this should work.\n\nSum: sum = sum( arr )\n\nNow loop over i from 1 to n:\n\ndo i=1,n\n\n   temp = sum - arr(i)\n\n   if (mod(temp, n -1) == 0 ) then\n\n      if ( temp/(n-1) == arr(i) ) then\n\n           c = c +1\n\n           indices(c) = i\n\n      end if\n\n   end if\n\nend do\n\nWait, but for that, I need to first allocate the indices array as well, since we don't know how many will be there. Hmm, that's a problem.\n\nAh right. In the code above, we can't know the size of indices until after the loops. So we can preallocate indices with size n and then after processing, we'll have c elements in it. So let's do that.\n\nSo first, allocate indices(1:n). Then, during processing, store the indices in the first c entries, then at the end, after the loop, we can print those.\n\nAlternatively, maybe just keep a character string and append to it. Let me see.\n\nAlternative approach for collecting the indices:\n\nInitialize a character string ' ' (empty)\n\nthen for each i that satisfies, append trim(adjustl( str(i) )) // ' ' etc.\n\nUsing Fortran 90 string handling features.\n\nLike:\n\ncharacter(len=256) :: sb = ''\n\nthen each time:\n\nwrite(temp_str, '(I0)') i\n\nsb = trim(sb) // temp_str // ' '\n\nThen, after, trim off any trailing space.\n\nAlternatively, use an array of indices and then write them in a loop.\n\nEither way might be okay.\n\nLet me think code steps in Fortran:\n\nWrite a program:\n\nprogram codeforces_134_a\n\nimplicit none\n\ninteger               :: n, i, sum_total, c = 0\n\ninteger, allocatable  :: arr(:), indices(:)\n\n! Read n\n\nread(*,*) n\n\n! Allocate arrays\n\nallocate( arr(1:n), indices(0:n) ) ! indices is allocated with max size n.\n\nc =0\n\n! Read array elements\n\nread(*,*) arr(1:n)\n\n! Compute sum of all elements\n\nsum_total = sum( arr )\n\n! Loop over each element:\n\ndo i=1, n\n\n    if ( (sum_total - arr(i)) ==0 ) then\n\n        ! If n-1 is zero, but n is input from user, but in code, n is the number of elements. So n must be at least 1.\n\n        ! But wait, when n is 1, n-1 is 0. So need to handle division by zero? But in the problem statement perhaps n is at least something else?\n\nWell, the problem may have constraints. Let me see.\n\nLooking at the original code:\n\nIn the Java code, when n is 1, then the condition would require (sum - arr[0])%0 ==0, but mod with 0 is invalid. So perhaps the problem assumes n>=2?\n\nBut the code probably expects that n is at least 2, otherwise, it would result in division by zero. Since in competition problems, sometimes such edge cases are considered.\n\nWell, the fortran code must handle that as well.\n\nHmm. So, to avoid division by zero, perhaps in the code, when n is 1, but in that case, perhaps (sum - arr[0]) = 0 (since it's the only element), so mod(0, 0 ) which is undefined anyway.\n\nTherefore, the code needs to handle when n -1 is 0, i.e., n=1, but the code may not process those.\n\nIn the code, for n=1:\n\nsum is arr[0], so (sum - arr[i]) is 0, so mod(0,0) is undefined. The Java code would crash here.\n\nTherefore, the problem probably specifies that n is at least 2, so in fortran code, we can proceed under that assumption.\n\nBut in our code, to avoid division by zero, perhaps adding:\n\nif (n == 1) then \n\n    ... \n\nend if \n\nBut let me see, perhaps better to check:\n\nn_minus_1 = n-1\n\nif (n_minus_1 <=0) then ... but for now, proceeding.\n\nIn the loop over i:\n\n    temp = sum_total - arr(i)\n\n    if ( mod( temp, n_minus_1 ) ==0 ) then \n\n        ! divisible\n\n        if ( temp / n_minus_1 == arr(i) ) then \n\n            c = c +1 \n\n            indices(c) = i \n\n        end if \n\n    end if \n\nend do\n\nWait, but when n-1 is 0 (n=1), then mod is undefined, so the test is invalid.\n\nHence, need to handle n=1 as a separate case.\n\nAlternatively, in the code, before proceeding, check n >=2, set c=0, and proceed, and for n=1, nothing is collected. \n\nBut given that the code in Java would have faced this, perhaps it is okay that for n=1, we skip those checks, but the problem might not have test cases with n=1.\n\nWell, proceeding under assumption that n is at least 2.\n\nNow, after the loop, allocate the indices array properly, or use a fixed size. Since we preallocated indices(0:n) maybe I made a mistake. Let me change:\n\nallocate(arr(1:n))\n\nallocate( indices(1:n) )\n\nthen c starts at 0, so indices(1:c) will be filled as we go.\n\nWait, yes, because in allocation indices(1:n) can be up to n elements.\n\nSo for each eligible i, indices(c+1) = i, then c increments.\n\nAfter the loop, the indices holds up to c elements.\n\nNow, to print the results:\n\nFirst output c, then the indices separated by space.\n\nTo do the second line, perhaps:\n\nwrite(*,'(I0)') c \n\nThen, second line:\n\nwrite(*,'(1000I0)') (indices(1:c), each separated by a space?)\n\nWait, in Fortran, if we can do something like:\n\nwrite(*,'(I0)') indices(1:c)(:)\n\nHmm, perhaps better:\n\nwrite(*,'( (I0,1x),/ )' ) indices(1:c)\n\nAh, here, the format: The parenthesis groups the elements, each written as I0 (free format integer), followed by a space, and the comma after I0,1x would add a new space? Wait maybe better to think.\n\nThe format for writing the list:\n\nLet me think: To print all elements of indices(1:c) separated by spaces, followed by a newline.\n\nThe format '(\"There are \",I0,\" elements: \",1X,I0, \"(A /)')\" but perhaps:\n\nFirst, print c on its own line:\n\nwrite(*,*) c\n\nThen, write all the elements of indices(1:c) separated by spaces:\n\nwrite(*, '( (I0, 1X), : )' ) indices(1:c)\n\nBut I need to check how to write a list with just spaces between. The format '( (I0, 1X), :, : )' you can do something.\n\nAlternatively, it's simpler to loop through the indices and print each with a space, but trailing space is acceptable for Fortran (since the problem may accept that).\n\nAlternatively, let's see:\n\nSuppose after collecting the indices, we do:\n\n if (c>0) then \n\n    do i=1,c\n\n        write(*,'(I0, 1X)', advance='no') indices(i)\n\n    end do\n\n    write(*,*)  ! newline\n\n else \n\n    write(*,*)  ! maybe print nothing? But the problem requires to show c as 0 then next line empty?\n\nWait, the original Java code would print \"0\" then empty string, which would print \"0\" then the next line has 0 characters.\n\nWait, see in Java, after creating the string, which would be empty if c =0. Then printing sb.toString() would output nothing (since appending nothing), but in Fortran, when you have an empty array, writing (indices(1:0)) etc. would either do nothing or error?\n\nHmm.\n\nAlternatively, perhaps build a character string.\n\nLet me think of the approach with a string.\n\nInitialize a character variable:\n\ncharacter(len=256), parameter :: separator = \" \"\n\ncharacter(len=:), allocatable :: buffer\n\nAllocation might be needed, but Fortran strings are fixed length unless using allocatable.\n\nAlternatively, use a fixed length buffer, but size? Maybe assume maximum n=1e5 elements, but the elements are up to say 1e9, but the output requires just their indices (up to 10 digits each). Then for n=1e5, 1e5 * (6 digits) ~ 5e5 characters, which may be too big.\n\nAlternatively, perhaps safer with a dynamic approach.\n\nAlternatively, let's go back to first method with array.\n\nFirst line output is just c, the count.\n\nSecond line is the list of indices, separated by spaces, so if c=0, it's empty line.\n\nIn Fortran:\n\nIf we have an indices array allocated properly, then:\n\nAfter computing the c, do:\n\nwrite(*,*) c\n\nif (c >0 ) then\n\n    write(*, '( (I0, 1X), : )' ) indices(1:c)\n\nend if\n\nAlternatively, the format could be '( (I0, 1X), / )' but maybe we need to ensure that the final space is omitted? Or does it not matter? Well, the problem probably allows the last element to have a trailing space.\n\nAnother way: write each index followed by a space, but then backspace the last space.\n\nAlternatively, just write all with trailing space and see.\n\nThe problem's sample outputs probably include a trailing space. Let's see:\n\nIn the sample below, perhaps.\n\nAlternatively, use a do loop to print each, adding a space each time.\n\nSo:\n\ndo i =1,c\n\nwrite(*,'(I0)', advance='no') indices(i)\n\nif (i < c ) then \n\n write(*,'(A)', advance='no') ' '\n\nelse \n\n write(*,*) ' '   ! or just newline?\n\nWait, but new line is needed. Hmm.\n\nAlternatively:\n\nThe code would be:\n\ndo i =1,c\n\n    write(*,'(I0, 1x)', advance='no') indices(i)\n\nend do\n\nwrite(*,*)    ! this adds a new line after the last space.\n\nWait, for example, if c=3, then the write loop produces \"1 2 3 \", then a new line. But that's an extra space at the end. Maybe that's acceptable; the problem may accept it.\n\nAlternatively, perhaps safer to do:\n\nwrite(*,'( (I0,1x), : )' ) indices(1:c)\n\nThen a new line is automatically added because of the / at the end (if the end= is set?)\n\nHmm I need toremebwe format descriptors.\n\nAlternatively, format '(I0,1X)' has each item followed by space, and at the end of the output, maybe line moves, but perhaps the trailing space would be left on the line.\n\nWait, Fortran uses the format to generate characters, so the format '( 10I0 )' etc. Let me perhaps test with an example.\n\nAlternatively, think about in Fortran, the standard code to write a list of numbers space-separated:\n\nLike: write(*, fmt='( (I0, 1X), : )' ) list.\n\nWait, perhaps the format '( (I0, 1X) : )' ?\n\nThe format '( (I0,1X), : )' is a standard way to write in a loop, where each I0 is followed by a space, and after the specified list.\n\nWait, perhaps a format like:\n\n'**(I0) **'?\n\nNo, maybe let me see the correct syntax.\n\nThe format for writing multiple items, each with a space after.\n\nAn example, if you have values x(1:n), then:\n\nwrite(*,'(1000(I0,1X))') x(1:n)\n\nThis would write up to 1000 items, each with space, but because of the comma and the 1X, which might? Not exactly sure.\n\nAlternatively, the correct format to have all elements separated by spaces regardless of how many is:\n\n'(*(I0,1X))'\n\nSo with the * in the format, that allows variable length.\n\nAh, right, the asterisk * in Fortran format allows variable repetitions. So the correct format is:\n\nwrite(*, '( *(I0, 1x) )') indices(1:c)\n\nThis would print each integer followed by a space.\n\nThen, the trailing space will be there. But the sample output might have it, but perhaps in the problem it's okay.\n\nAlternatively, the problem might allow any format as long as it's correct with numbers separated by spaces and nothing else. Since the code's original Java code also prints a trailing space, let's see:\n\nIn Java's case, the code uses a String initially empty, then for each index added \" (i+1) + \" \"<space>\", so the resulting string ends with a space. So printing that, the second line will have a trailing space, but that's allowed by the judge if the problem accepts it as correct, typically they do, unless specified otherwise.\n\nTherefore, the trailing space is acceptable here.\n\nSo in Fortran, that's okay.\n\nTherefore, let's write:\n\nAfter the loop to collect indices, the code outputs:\n\nwrite(*,*) c\n\nwrite(*, '( *(I0, 1X) )' ) indices(1:c)\n\nWait, but Fortran's 1X is a single space, so each entry has a space after, so yes, that's correct.\n\nAlternatively, perhaps it's better to use:\n\nwrite(*, \"( (I0, 1X), / )\" ) indices(1:c)\n\nThe '/' causes a new record, but the important part has each with 1X.\n\nWait, I think the format specification is crucial here. Let me think of an example:\n\nSuppose the indices are [1,3,5]. The list should be written as \"1 3 5 \" with a trailing space, followed by a newline.\n\nAlternatively, perhaps the following:\n\nThe code can first write all elements, each followed by a space:\n\nThus using:\n\nwrite(6,*) (indices(j),j=1,c)\n\nBecause when using list-directed I/O, spaces are between the terms. For example, the list-directed output of write(*,*) 1,3,5 would produce \"1 3 5\" (without the trailing space). Wait, no, list directed output separates with spaces but doesn't add a trailing one. Let me think.\n\nWait if I do write(*,*) indices(1:c), then list directed output will write each separated by a space, with no trailing space. So that's better.\n\nWait, actually yes. If I do:\n\ninteger :: indices(3) = [1,3,5]\n\nwrite(*,*) indices, then output would be \"1 3 5\", but for an array, it's written as per the elements.\n\nBut for an array, when you write array, it's treated as elements.\n\nAh, so:\n\nSuppose indices has c elements. Then:\n\nwrite(*,*) (indices(j), j = 1,c)\n\nThat would write each separated by spaces, with no trailing space, since list directed.\n\nThus, that is better.\n\nAlternatively:\n\nwrite(*,*) , followed by the elements. Let's try.\n\nSo, let's see.\n\nIn the program:\n\nAfter collecting indices(1:c):\n\nwrite(*,*) c\n\nwrite(*,*) (indices(j), j=1,c)\n\nWait, but then, in the second line, it'll be written with space-separated, and ending on a new line. That's exactly what Java's code does.\n\nYes, that seems good. Because when you do write(*,*) (values), the values are written with spaces between them, and the line ends with a new line.\n\nWait, exactly. So:\n\nThe code would be:\n\nFirst, print c.\n\nSecond, write all indices, space-separated on a new line.\n\nHence this approach is better because it avoids trailing space.\n\nThe Java code's:\n\nSystem.out.println(sb.toString());\n\nWhich is sb contains \"1 2 3 \", ending with a space. That would have a trailing space, but in the Fortran code, with the above approach, there is no trailing space. Wait, which is right? Let me check.\n\nThe Java code, for a case of c=3, the string is built with (i+1 \"+ \" \")\n\nWait the code appends a space after every index, including the last one, so the string ends with a space. So when printed, the output will have a trailing space. But the problem statement may not care about the trailing space, so both approaches may be acceptable, but in Fortran's case, printing via list-directed which doesn't add the space, it would be correct?\n\nWait, let me recalculate.\n\noriginal java:\n\nc is 3, then in the loop, appends (i+1) followed by \" \" each time. So for indices [1,2,3]:\n\nthe first i=0 (Java zero-based) would have been converted to 1, next 2, then 3.\n\nSo when appended, the string would be \"1 2 3 \"\n\nso in Java, the string has a trailing space, so the System.out.println() appends that string, which has a space.\n\nThus, the output's second line would have a trailing space.\n\nThus, in Fortran, if I use the list-directed write, it will not, thus differing. But perhaps the judge is okay with it, as it is considered as space-separated, so even with an extra space.\n\nHmm, so to be precise as the Java code, the trailing space should be present.\n\nSo maybe in Fortran:\n\nThe code can do something like\n\ncharacter(len=10)n is the indices...\n\nWait perhaps is better to collect the indices into a string.\n\nTherefore:\n\nMethod 2: Using a string.\n\nInitially:\n\ncharacter(len=200000) :: sb = ''\n\nThen, each iteration where the condition is met, append the index and a space.\n\nThe problem is that in Fortran strings are fixed-length. So need to know the length.\n\nLet me estimate: if n is up to, say, 1e5 each integer is 6 digits.\n\nEach index is up to maybe 1e5 (but for indices up to n = 1e5, so 1e5 elements, each is up to 5 digits (since 1e5 is 5 digits). Then n elements would be 5*1e5 = 5e5 characters. Plus one more space between each, which adds another 1e5 characters, so total ~6e5 characters (600,000). So allocating a string of len=600000 should handle it.\n\nAlternatively, in modern computers this is manageable, but in code submission platforms, perhaps maximum string length allowed may have to be considered, but perhaps 1e6 is okay.\n\nIn code:\n\ncharacter(len=1000000) :: sb = \"\"\n\nthen for each valid i:\n\nwrite (temp_str, '(I0)') i \n\nsb = trim(sb) // temp_str // \" \"\n\nThus, with each addition, the string grows. Finally, the sb will have trailing space; to remove it, we can do trim(sb)||\" \" but not exactly.\n\nWait trim removes leading and trailing blanks, so trim(sb) would remove the trailing space. But then we would lose that?\n\nAlternatively, when appending, do:\n\nsb = trim(adjustl(sb)) // trim(adjustl( ... ) )\n\nNot sure.\n\nWait maybe:\n\nEach time, append the current i and a space.\n\nSo, for the first i, it would be x and ' ', then next one appends ' ' + next x and ' ' etc, so the string becomes the numbers separated by spaces.\n\nAt the end, the string has a trailing space.\n\nThus:\n\nif using trim(sb(1:len_trim(sb) -1) )\n\n/// \n\nAlternatively, just output the whole string, with trailing space. The problem's judge might accept it.\n\nThus:\n\nAfter the loop, in Fortran:\n\nif (c /= 0) then \n\n   sb = trim(adjustl( sb )) // ' ' // trim(adjustl( ... ) ) ?\n\nHmm getting complicated.\n\nAlternatively, let's see the earlier code using indices array and list directed output.\n\nThe list directed output writes the indices separated by one or more whitespace, but no trailing. So in the case of 3 elements, the output would be \"1 3 5\" with no trailing space, whereas the Java code's output is \"1 2 3 \" as above.\n\nSo there's a discrepancy here.\n\nHmm, which is correct? Well, perhaps the problem requires the indices to be in space-separated format. The trailing space may be acceptable, but if not, then we need to output exactly like the original Java.\n\nAlternative approach: use a string and build it properly.\n\nLet me try that in code:\n\nAllocate a character buffer, then for each valid index, write the value to the string with a trailing space.\n\nThen, at the end, the string has trailing space, but if c is zero, the string is empty.\n\nThen, to print the string, use:\n\nif ( len_trim(sb) > 0 ) then \n\n    write(*,*) trim(sb(1:len(trim(sb)-1)) )\n\nelse \u2026 \n\nHmm.\n\nAlternatively, to write the buffer as it is, including the trailing space.\n\nThe problem may accept.\n\nAlternatively, perhaps the problem expects the trailing space, so let's try to have it.\n\nSo in Fortran code:\n\nUsing an intrinsic function to build the string:\n\ncharacter(len=2000000) :: sb = ''\n\ndo i=1,n\n\n    if conditions met:\n\n        write(temp_str,'(I0)') i\n\n        sb = trim(adjustl(sb)) // trim(adjustl(temp_str)) // ' '\n\nend do\n\nthen:\n\n write(*,*) c\n\n if ( c >0 ) then\n\n     write(*,'(A)') trim(adjustl( sb )) // ' ' ???\n\nNo, perhaps not, but if I have sb:\n\nfor example, for three indices it would be \"1 \"+ \"2 \" + \"3 \" \u2192 \"12 3 \" ?\n\nWait, wait, no. Wait, initial sb is empty string.\n\n- First i=1 (valid), append:\n\nsb is empty, so after first iteration: temp_str is \"1\" \u2192 temp_str adjusts to '1', ' ' \u2192 so sb is \"1 \" (assuming ' && with ).\n\nNext, for next i=2 (valid):\n\nnew temp_str is '2', then sb becomes previous \"1 \" // \"2 \" \u2192 \"1 2 \" etc. \n\nYes, so after all valid entries, sb holds all indices, separated by spaces with a trailing space.\n\nThus when printed, it matches the Java's output.\n\nHence:\n\nAfter building sb like that, the second line is simply:\n\nwrite(*,'(A)') trim( adjustl( sb ) )\n\nNo, because the trailing space would still be there.\n\nWait, for example, if sb after loop for 3 indices is \"1 2 3 \", then trim(adjustl(sb)) gives \"1 2 3\", losing the trailing space?\n\nBecause TRIM removes any trailing whitespace, which the space is counted as whitespace. Thus trim(\"1 2 3 \") becomes \"1 2 3\".\n\nWhich would make the output the same as list directed, with no trailing space, but that's exactly what list output do.\n\nThus the correct way thus to keep the trailing space is tricky.\n\nAlternatively, perhaps build the sb like:\n\nfor each index: append index & space, thus the string has the trailing space, and then when you print it, the space is present. Hence:\n\nwriters:\n\nif c >0 then \n\n   write(*,'(A)') trim(adjustl( sb ) ) \n\nelse \n\n   write(*,*) ''\n\nend if \n\nBut then trimming removes the trailing space. So the sb is \"1 2 3 \" \u2192 trim is \"1 2 3\". \n\nHence that won't work.\n\nAlternatively, perhaps do not use TRIM:\n\nwrite(*,'(A)') sb\n\nBut the original sb has length with trailing space, and the 'A' format will write exactly the characters up to the last non-blank, including the trailing space.\n\nWait in fortran, using the '(A)' will write the entire character string, so padding with spaces to the length of the array. Hmm, the trailing space is part of the array if we did append with the space.\n\nYes, the variable sb holds the characters including the trailing space, so using write(*,*) sb would write the entire string, including the trailing space (as long as the string is exactly like that).\n\nWait, in Fortran, when you write a character with \"(A)\", it writes all characters until the end of the string, but if the character variable is len=200000, but the actual content is shorter, it would write the content plus the following spaces?\n\nWait no: len_trim( string ) gives the length up to first blank. No.\n\nWait Fortran strings are stored as arrays of characters. If I have a character(len=10) variable, and I assign \"ABC \", then it's stored as ABC followed by 7 spaces.\n\nThus, writing character(10) using (A) would output \"ABC        \" (with 7 spaces, which is not desired.\n\nAh, so this is a problem. This is similar to C strings in that Fortran's character arrays are not null-terminated, so writing them outputs the entire length.\n\nThus, the code must manage the string's actual length. \n\nThe best way is to write up to the length of the string. \n\nThus:\n\nwrite(*,'(A)') sb(1: len_trim( sb ) )\n\nWhich outputs only up to the last non-space character. Wait but, what if the last character is a space?\n\nBecause when you build sb as \"1 2 3 \", the last character is a space.\n\nThe len_trim of sb is length of the string up to the last non-space character.\n\nSo len_trim of \"1 2 3 \" would be 4 characters (the first 4 include the last 3's digit and the space before the terminating space? Wait let me think: \"1 2 3 \" is 5 characters: '1', ' ', '2', ' ', '3', ' ',?\n\nWait, no, let me count:\n\n\"1 2 3 \" is:\n\nIndices 1: '1'\n\n2: ' '\n\n3: '2'\n\n4: '3' ?? No, sorry, perhaps my example is not:\n\nWait if we had indices 1 and 2 and 3 (indices 1,2,3 in Fortran), then each appends the number and a space.\n\nFirst appends \"1 \" \u2192 sb= \"1 \" (len=2).\n\nSecond appends \"2 \" \u2192 becomes \"1 \" (from first) + \"2 \" \u2192 \"1 2 \" (len=4).\n\nThird appends \"3 \" \u2192 now \"1 2 3 \" (len=6 characters, array entries 1 to 6 as '1',' ',',','2',' ',',','3', ' ' ? Wait no, each append adds (assuming the i=1 with 1 + space, then 2 + space, then 3 + space. So total of 3* (1 +1) characters (digit plus space)*3 \u2192 6 characters. So the string is \"1 2 3 \", with the last being space.\n\nThus the len_trim(sb) would stop at the digit 3's character (the 5th?), so the 6th is space. trim would give \"1 2 3\" as length_trim.\n\nThus, the output would miss the last space.\n\nTherefore in this case, the approach of building a string and using it would end up missing that space, just as the list directed approach does. Hence, neither method would exactly reproduce the Java's trailing space.\n\nHowever, the problem's test cases probably allow any space-separated list; the trailing space doesn't matter, as it's still valid.\n\nThus perhaps best to proceed with the indices array and list-directed output, which produces the exact format required (possibly without the trailing space).\n\nNow, returning to the overall code.\n\nPutting it all together.\n\nAlso, in fortran, the loops are written with DO-ENDDO.\n\nNow, variables:\n\nProgram structure:\n\n1. Read n.\n\n2. Read n numbers into an array.\n\n3. Compute their sum.\n\n4. Iterate through each element, compute temp, check the conditions.\n\n5. Collect indices in an array.\n\nThen output count and indices.\n\nAlso, the code must allocate arrays, etc.\n\nHere's the code in Fortran 90:\n\nprogram codeforces_134_A\n\n    implicit none\n\n    integer :: n, i, sum_total, c\n    integer, dimension(:), allocatable :: arr, indices\n\n    read(*,*) n\n\n    if (n ==0) then\n        write(*,*) 0\n        write(*,*) \"\"\n        stop\n    end if\n\n    allocate( arr(1:n), indices(1:n) )\n    c =0\n\n    read(*,*) (arr(i), i=1,n)\n\n    sum_total = sum( arr )\n\n    do i=1,n\n        if ( (n-1) ==0 ) cycle  ! skip when n=1, since n-1=0, which would cause division by zero\n        if (mod( sum_total - arr(i), n-1 ) == 0 ) then\n            if ( ( (sum_total - arr(i)) / (n-1) ) == arr(i) ) then\n                c = c +1\n                indices(c) = i\n            end if\n        end if\n    end do\n\n    write(*,*) c\n    if (c >0 ) then\n        write(*,*) (indices(j), j=1,c)\n    else\n        write(*,*)  ! empty line\n    end if\n\n    deallocate(arr, indices)\nend program codeforces_134_A\n\nWait, but what about n=1 case?\n\nWhen n=1:\n\nThen n-1 =0 \u2192 the code would skip the rest of loop iterations (since in the do loop over 1 to 1, the 'cycle' skips the rest (the entire iteration).\n\nThus, at the end, c remains 0.\n\nHence, output 0 and an empty line, which matches what the Java code would do if n=1.\n\nIn the Java code, for n=1, the loop runs once:\n\ntemp = sum - arr[0] = 0.\n\nmod(0, 0) is invalid, which in Java would throw an exception, but since compiler allows it? Well, in practice, division by zero in mod is an error.\n\nThus the Java code would crash for n=1, but our Fortran code properly skips it.\n\nHence, the fortan code properlyer handles it.\n\nNow, code:\n\nLet me debug let me see:\n\nCheck variable declarations:\n\narr is allocated from 1 to n. Good.\n\nThe read loop uses read(*,*) (arr(i), ...) \u2192 yes.\n\nThe loop over i, mod and conditions.\n\nWait in the code:\n\nInside do i =1 to n:\n\n    if (n-1) ==0 \u2192 which is n=1, then cycle.\n\nSo for n=1's case, code skips.\n\nOther cases:\n\nFor n >= 2.\n\nYes.\n\nNow, the sum_total is the total sum.\n\nConditions are checked.\n\nIf (sum - arr(i)) mod (n-1) is zero, and the integer division is arr(i).\n\nIn Fortran, integer division (using / operator is integer division).\n\nThus, correct.\n\nVariable c counts the number of valid indices. Indices array saves their indices (1-based).\n\nYes.\n\nThen, output c.\n\nSecond line, if c>0, output the indices, space-separated.\n\nThe code for the second line uses list-directed output: (indices(j),j=1,c), which produces space-separated values, no trailing space. Which is different from Java.\n\nBut perhaps acceptable.\n\nNow, what about when n is 2? Let's test hypothetical input.\n\nSample Input:\n\n3\n\n3 3 0\n\nWait let's say the array is [3,3,0].\n\nWait n=3.\n\nSum_total is 6.\n\nTesting each element:\n\ni=1 \u2192 arr[1]=3\n\ntemp = 6-3 = 3 \u2192 divided by n-1 = 2: 3 mod 2 =1 \u2192 fails.\n\ni=2: temp=3 \u21923/2 = 1.5, but integer division would be 1. \n\nThus, 1 != 3 \u2192 no.\n\ni=3:\n\ntemp = 6-0 =6 \u2192 divided by 2:3 \u2192 3 equals arr(i) (0). No, 3 is not equal to 0 \u2192 thus no.\n\nHence no valid indices, so output would be 0, and empty line.\n\nAlternatively another test case.\n\nAnother sample:\n\nSample Input: \n\n2\n\n1 3\n\nsum is4.\n\nEach check:\n\nFor i=1, minus 1 is 3 \u2192 (3) divided by n-1=1 \u21923/1=3 \u2192 compare with arr(1)=1 \u21923 \u22601 \u2192 no.\n\nFor i=2: temp 4-3=1 \u2192 1 divided by1=1 \u2192 compare with 3 \u2192 no.\n\nSo c remains zero.\n\nThus output 0 and empty line.\n\nAnother test case where it is valid.\n\nSample Input:\n\n3\n\n2 2 2.\n\nSum =6.\n\nFor each i:\n\nsubtract arr[i] (2) \u2192 sum -2 =4.\n\nn-1 is 2 \u21924 divided by2 is 2 \u2192 equal to arr[i]. Thus condition holds.\n\nThus all three indices qualify.\n\nThus output c=3 and indices 1 2 3.\n\nIn Fortran code, the second line would print 1 2 3 with no trailing space, while Java's would have trailing space. But the problem may be okay with either.\n\nAnother example:\n\nn=4: elements [2,2,2,2]\n\nsum is 8.\n\nFor any index i:\n\nsum - arr[i] = 6 \u2192 divided by n-1 =3 \u21926/3=2, which is equal to arr[i]. So each element qualifies. Thus output is c=4 and 1 2 3 4 \u2192 printed correctly.\n\nThe code seems correct.\n\nNow, putting it all into the code. Note that in Fortran, mod(a,b) returns a remainder with the same sign as b, but in this problem, a is sum - arr[i]. Since sum is the total of all elements including arr[i], and sum - arr[i] is sum of all else.\n\nSo assuming all elements are integers, mod is okay unless negative numbers are present. But the problem's condition can still be met even with neative numbers.\n\nThe code should work in all cases, including negatives.\n\nThus the code appears correct."
}