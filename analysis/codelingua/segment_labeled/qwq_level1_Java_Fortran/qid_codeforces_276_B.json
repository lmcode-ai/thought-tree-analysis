{
  "segments": [
    {
      "text": "Okay, I need to translate this Java code into Fortran.",
      "start_char": 0,
      "end_char": 54,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Let me start by understanding what the Java code does.",
      "start_char": 55,
      "end_char": 109,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The program reads a string from standard input.",
      "start_char": 111,
      "end_char": 158,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Then, it counts the frequency of each character using a HashMap.",
      "start_char": 159,
      "end_char": 223,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "It then checks the number of characters with an odd count. If the number of such odd counts is 0 or 1, the first player wins (\"First\"); otherwise, if there are even number of odd counts beyond that, it's \"Second\".",
      "start_char": 224,
      "end_char": 437,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "First, the Fortran equivalent of Java's HashMap.",
      "start_char": 440,
      "end_char": 488,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Since Fortran doesn't have an inbuilt hash map, maybe we can use an array to count frequencies since characters are limited (assuming ASCII).",
      "start_char": 489,
      "end_char": 630,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Let's see: characters can be from 'a' to 'z' and 'A' to 'Z'? Or maybe any possible?",
      "start_char": 631,
      "end_char": 714,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "Well, in Java, it uses a generic map, but in Fortran, perhaps arrays are better.",
      "start_char": 715,
      "end_char": 795,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Let's assume the input is in lowercase for simplicity.",
      "start_char": 796,
      "end_char": 850,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Wait, the problem might not specify that.",
      "start_char": 851,
      "end_char": 892,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "Hmm, but maybe I can map each character's ASCII code to an index. So ASCII characters have codes from 0 to 255, so an array of size 256 should handle all possible characters.",
      "start_char": 893,
      "end_char": 1067,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Wait, in Fortran, characters can be converted to their ASCII code using ICHAR. So I can create an integer array of size 256, initializing all entries to 0. Then for each character in the string, increment the corresponding index by 1.",
      "start_char": 1069,
      "end_char": 1303,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Then, after building the frequency array, we need to count how many entries are odd. Let me outline the steps:\n\n1. Read the input string.",
      "start_char": 1305,
      "end_char": 1442,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "2. Initialize an integer array (let's say of size 256) to store frequencies.",
      "start_char": 1443,
      "end_char": 1519,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "3. Loop through each character in the string, get its ASCII code, increment the corresponding array element. 4. Then loop through the frequency array to count how many elements are odd (mod 2 is 1).\n5. Decide the output based on the condition: if oddCount is <=1 or oddCount is odd, then first else second. So now, the Fortran code steps. First, reading the input.",
      "start_char": 1520,
      "end_char": 1884,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "In Fortran, reading a string of unknown length can be a bit tricky.",
      "start_char": 1887,
      "end_char": 1954,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "We can read a line using a character variable with sufficient length, say something big.",
      "start_char": 1955,
      "end_char": 2043,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Or better, allocate, but in older Fortran versions, perhaps we need to use a fixed length.",
      "start_char": 2044,
      "end_char": 2134,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "Alternatively, use the \"unformatted\" read or some inquiry functions.",
      "start_char": 2135,
      "end_char": 2203,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Alternatively, perhaps read until end of line.",
      "start_char": 2204,
      "end_char": 2250,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, maybe just use a large enough buffer.",
      "start_char": 2252,
      "end_char": 2304,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Since in the problem, the code is similar to codeforces problem, perhaps the input is one line, which in Fortran can be read with a buffer.",
      "start_char": 2305,
      "end_char": 2444,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Wait, in the original code, the Java code uses bufferedReader.readLine() which reads the entire line. So in Fortran, perhaps using a GET_COMMAND or something else, but I think a better way would be to read from stdin until the end of the line. Alternatively, in Fortran, perhaps:\n\n    character(len=1000) :: str\n    read(*,'(A)')",
      "start_char": 2446,
      "end_char": 2776,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "str\n\nBut leading/trailing spaces may be read? Hmm.",
      "start_char": 2777,
      "end_char": 2827,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Alternatively, using a variable length string. In Fortran 2003, there's a len=\" variable, but for simplicity, perhaps just use a large enough size.",
      "start_char": 2828,
      "end_char": 2975,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Assuming the input line is not more than 1000 characters.",
      "start_char": 2977,
      "end_char": 3034,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Then, each character in the string can be looped: Do i = 1, len_trim(str)",
      "start_char": 3036,
      "end_char": 3110,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Then, for each character, get its ASCII code via ICHAR(str(i:i)), since in Fortran strings are characters, so extracting position i is str(i:i).",
      "start_char": 3112,
      "end_char": 3256,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Now, the frequency array: declare an integer array, say freq, size 256, initialized to 0. Then loop through each character. Then, after building freq array., then loop over all elements of freq, count how many have an odd count (value mod 2 ==1). Once the oddCount is determined, then the logic is similar to Java's: If oddCount \u22641 or oddCount %2 ==1. So, if ((oddCount <=1) .OR. (MOD(oddCount,2) ==1)), then print \"First\", else \"Second\".",
      "start_char": 3258,
      "end_char": 3698,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Now, the conditions:\n\nWait the original Java code says: if (oddCount <= 1 || oddCount % 2 !=0) {\n\nWait wait.",
      "start_char": 3700,
      "end_char": 3809,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Java's condition is:\n\nif (oddCount is less than or equal to 1, OR the oddCount is odd). Because the condition was:\n\nif (oddCount<=1 or (oddCount is odd (because the mod !=0))).",
      "start_char": 3810,
      "end_char": 3986,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Wait, actually, oddCount is the number of characters with odd counts. The condition in Java is:\n\nif (oddCount <=1 || (oddCount %2 !=0)). Wait no, the original Java code: if (oddCount <= 1 || oddCount % 2 != 0) So the first condition is \"less than or equal to 1\", OR \"the count is odd (oddCount mod 2 !=0).",
      "start_char": 3988,
      "end_char": 4297,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Wait, but oddCount can be 2,4 etc.",
      "start_char": 4298,
      "end_char": 4332,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Let me see:\n\nWait the condition would trigger \"First\" in cases where there is 0 or 1 odd counts, or any other odd number of odd counts (like 3,5 etc). Wait but that makes sense?",
      "start_char": 4333,
      "end_char": 4510,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Let me think about the problem.",
      "start_char": 4512,
      "end_char": 4543,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "Ah, perhaps this relates to whether the remaining odd counts can be taken by the players alternately, so the first player has some advantage.",
      "start_char": 4545,
      "end_char": 4686,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Let me see, perhaps the problem is similar to some matchstick game where each player takes pairs, and if there's an odd number remaining, the first can take the last. Wait perhaps the original Java code is solving a specific problem where the player can take any pair, but pairs of the same character?",
      "start_char": 4687,
      "end_char": 4988,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The logic here is such that the first player wins if the number of characters with odd counts is 0 or 1, because then it can be split equally or have one left for the first player. Wait perhaps the actual logic is that the first player wins if the number of odd counts is 0 or 1, but if there's an even number of odd counts greater than 1, then second player wins. Wait but the code's condition is a bit different. Let me check. Original code's condition:\n\nif (oddCount <=1 || (oddCount %2 !=0)) then print first, else second. Wait, oddCount must be a number where either it\u2019s <=1, or it\u2019s odd (but that would include like 3,5...). Hmm.",
      "start_char": 4990,
      "end_char": 5628,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Well, regardless, I just need to translate the code's logic accurately. Now, translating that condition into Fortran:\n\nThe condition is: if ( (oddCount <=1) .or. mod(oddCount,2) /=0 ) then print \"First\". Wait the original Java code: oddCount % 2 !=0 \u2192 mod(oddCount,2) .ne. 0.",
      "start_char": 5630,
      "end_char": 5908,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Wait, but in the condition, combining those two.",
      "start_char": 5910,
      "end_char": 5958,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Let me see: for oddCount being:\n\nCase 0 \u2192 first.\n\n1 \u2192 first. But also, 3 \u2192 mod(3,2)=1 \u2192 first.\n\n2 \u2192 even, mod is 0 \u2192 so check the first condition (if 2 <=1? No) \u2192 so not first, so else second.",
      "start_char": 5959,
      "end_char": 6152,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Similarly, 4 \u2192 mod 0 \u2192 condition is false, so second. So the program's logic is that as long as the number of odd-counted characters is zero, one, or an odd number (like 3,5, etc. but greater than 1?), then first wins. Wait but 3 is greater than 1 and is odd, so yes. So the first player can win in those cases. Wait the code is designed for a problem where \"first\" wins if the count is zero or one, or an odd number? Hmm, but why?",
      "start_char": 6154,
      "end_char": 6585,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Well the code is likely solving a programming contest problem (given the initial code's class name codeforces_276_B). So knowing that, but I don't need to know why, just translate.",
      "start_char": 6590,
      "end_char": 6770,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Now, moving to writing the Fortran code.",
      "start_char": 6772,
      "end_char": 6812,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "First, the outline:\n\nProgram codeforces_276_B\n\n     implicit none\n\n     ( declare variables )\n\n     Read string.",
      "start_char": 6814,
      "end_char": 6926,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Process frequencies.\n\n     compute odd count.",
      "start_char": 6933,
      "end_char": 6978,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "evaluate condition.\n\n     output. End program\n\nNow, variables: We need to read the string.",
      "start_char": 6985,
      "end_char": 7075,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Let's choose a character array with a length of say 1000, or better, use a variable length string, but maybe in older Fortran versions? Assuming it's Fortran 90. Declare a string. Let's say:\n\ncharacter(len=200) :: s\n\nthen we can read until the end of line. But in Fortran, reading with a variable length.",
      "start_char": 7078,
      "end_char": 7383,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Alternatively, read with trailing spaces, but using len_trim:\n\nRead the entire line into s, using a length\u81ea\u4fe1, which may include spaces?",
      "start_char": 7385,
      "end_char": 7520,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Let's see: the Java code reads bufferedReader.readLine(), so including whitespace except newline.",
      "start_char": 7521,
      "end_char": 7618,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "In Fortran, perhaps:\n\n read(*, '(A)') s \u2192 this reads the current line, including all characters except the newline.",
      "start_char": 7620,
      "end_char": 7735,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "The array to hold frequencies can be declared as:\n\ninteger, dimension(0:255) :: freq\n\nInitialize all to zero.",
      "start_char": 7737,
      "end_char": 7846,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "The ASCII for a character c is given by ichar(c). So for each character in s (up to the length of the read string), we'll get its ASCII code. Note that in Fortran, s is a character string with len=200, but the actual length can be found via len_trim(s). So the loop is from i=1 to len_trim(s). Loop:\n\ndo i=1, len_trim(s)\n\n    ch = s(i:i)\n\n    code = ichar(ch)\n\n    freq( code ) = freq( code ) +1\n\nend do\n\nThen, after filling the freq array, compute odd_count:\n\nodd_count =0\n\ndo i=0,255\n\n   if (mod(freq(i),2)/=0) then\n\n       odd_count = odd_count +1\n\n   end if\n\nend do\n\nThen check the condition:\n\nif ( (odd_count <=1) .or. (mod(odd_count,2)/=0) ) then\n\n   write(*,*) 'First'\n\nelse\n\n   write(*,*) 'Second'\n\nend if\n\nWait wait, the condition is odd_count <=1 OR odd_count is odd.",
      "start_char": 7848,
      "end_char": 8626,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Wait, but when odd_count is less than or equal to 1, it's possible to have 0 or 1. 0 is even, 1 is odd. So combining these OR, it covers:\n\n- If there are even counts (zero odd counts \u2192 condition met), so first.\n\n- If there's one odd count \u2192 condition is met, first.\n\n- Or if there are multiple but odd number of odd counts (like 3,5 etc.), then also first.",
      "start_char": 8627,
      "end_char": 8983,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The second case (Second) is when the number of odd counts is even and greater than 1 (like 2,4, etc.).",
      "start_char": 8985,
      "end_char": 9087,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Now, that's correct as per the original code. Now putting all together in Fortran:\n\nCheck variable declarations.",
      "start_char": 9090,
      "end_char": 9202,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Also, in Fortran, array indexes start at 1 by default, but we declared freq as 0:255, which is okay. So the full code:\n\nprogram codeforces_276_B\n\n    implicit none\n\n    character(len=200) :: s\n    integer, dimension(0:255) :: freq\n    integer :: i, code, odd_count\n\n    ! Initialize frequency array to 0\n    freq = 0\n\n    !",
      "start_char": 9204,
      "end_char": 9528,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Read the input\n    read(*, '(A)') s\n\n    ! Compute frequencies\n    do i =1, len_trim(s)\n        ! Get current character\n        code = ichar( s(i:i) )\n        freq(code) = freq(code) +1\n    end do\n\n    odd_count =0\n    do i =0,255\n        if (mod(freq(i),2)/=0) then\n            odd_count = odd_count +1\n        end if\n    end do\n\n    ! Check condition and output\n    if ( (odd_count <=1) .or. (mod(odd_count, 2)/=0) ) then\n        write(*,*) 'First'\n    else\n        write(*,*) 'Second'\n    end if\n\nend program codeforces_276_B\n\nWait, but in the initial part, the freq array must have to be initialized to zero. In the code above, we have \"freq =0\" which should set all elements to zero.",
      "start_char": 9529,
      "end_char": 10217,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "In Fortran 90, this is allowed, yes. Wait, variable declarations. Since in the declarations, we have 'integer, dimension(0:255) :: freq' and 'freq=0' in the code.",
      "start_char": 10218,
      "end_char": 10381,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Wait, but in fortran, initialization at declaration requires an explicit initialization part. The line 'freq =0' is an assignment statement which should work for static arrays. So that's okay. Now testing possible issues:\n\nWhat about characters with codes above 255?",
      "start_char": 10383,
      "end_char": 10649,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Probably the codeforces problem uses ASCII characters, so assuming up to 255 is okay.",
      "start_char": 10651,
      "end_char": 10736,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Since the Java code uses char (16 bits), but in Fortran, ichar on characters returns 16-bit signed (up to 32767?), but probably for the problem, the characters are printable, so within 0-255. But if the code is required to handle Unicode?",
      "start_char": 10737,
      "end_char": 10975,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Well, given the original code uses Java (which uses 16-bit chars), but perhaps the problem's input is in ASCII. So we can proceed.",
      "start_char": 10977,
      "end_char": 11107,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Another possible issue: in Fortran strings, uppercase vs lowercase letters are distinct. But the problem's logic likely treats them as different, since the Java code does so. So that's correct. Now, what about empty string?",
      "start_char": 11109,
      "end_char": 11332,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Well, if the input is empty, then odd_count would be 0, so first player wins.",
      "start_char": 11334,
      "end_char": 11411,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "That aligns with the original code.",
      "start_char": 11412,
      "end_char": 11447,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Another test case: \"aab\" \u2192 counts are a:2 (even, so 0. Wait no: \"aab\" \u2192 'a' appears 2 times, 'b' 1 \u2192 counts of odd are 1. So odd_count is 1 \u21d2 print first. Yes, which would be correct. Another case: \"abc\" \u2192 a:1, b:1, c:1 \u2192 odd_counts =3 \u2192 3>1 and odd? Yes, so first. Second case like \"aabb\" \u2192 odd_count is 0 \u2192 first. A case where odd_count=2 \u2192 for example \"ab\" \u2192 a:1, b:1 \u2192 odd_count=2 (even and more than one), so second. So the code seems to handle.",
      "start_char": 11449,
      "end_char": 11903,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "I think that should be correct. So the translated Fortran code is as above.",
      "start_char": 11906,
      "end_char": 11981,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    }
  ],
  "original_reasoning": "Okay, I need to translate this Java code into Fortran. Let me start by understanding what the Java code does.\n\nThe program reads a string from standard input. Then, it counts the frequency of each character using a HashMap. It then checks the number of characters with an odd count. If the number of such odd counts is 0 or 1, the first player wins (\"First\"); otherwise, if there are even number of odd counts beyond that, it's \"Second\". \n\nFirst, the Fortran equivalent of Java's HashMap. Since Fortran doesn't have an inbuilt hash map, maybe we can use an array to count frequencies since characters are limited (assuming ASCII). Let's see: characters can be from 'a' to 'z' and 'A' to 'Z'? Or maybe any possible? Well, in Java, it uses a generic map, but in Fortran, perhaps arrays are better. Let's assume the input is in lowercase for simplicity. Wait, the problem might not specify that. Hmm, but maybe I can map each character's ASCII code to an index. So ASCII characters have codes from 0 to 255, so an array of size 256 should handle all possible characters.\n\nWait, in Fortran, characters can be converted to their ASCII code using ICHAR. So I can create an integer array of size 256, initializing all entries to 0. Then for each character in the string, increment the corresponding index by 1.\n\nThen, after building the frequency array, we need to count how many entries are odd. Let me outline the steps:\n\n1. Read the input string.\n2. Initialize an integer array (let's say of size 256) to store frequencies.\n3. Loop through each character in the string, get its ASCII code, increment the corresponding array element.\n4. Then loop through the frequency array to count how many elements are odd (mod 2 is 1).\n5. Decide the output based on the condition: if oddCount is <=1 or oddCount is odd, then first else second.\n\nSo now, the Fortran code steps.\n\nFirst, reading the input. In Fortran, reading a string of unknown length can be a bit tricky. We can read a line using a character variable with sufficient length, say something big. Or better, allocate, but in older Fortran versions, perhaps we need to use a fixed length. Alternatively, use the \"unformatted\" read or some inquiry functions. Alternatively, perhaps read until end of line.\n\nAlternatively, maybe just use a large enough buffer. Since in the problem, the code is similar to codeforces problem, perhaps the input is one line, which in Fortran can be read with a buffer.\n\nWait, in the original code, the Java code uses bufferedReader.readLine() which reads the entire line. So in Fortran, perhaps using a GET_COMMAND or something else, but I think a better way would be to read from stdin until the end of the line.\n\nAlternatively, in Fortran, perhaps:\n\n    character(len=1000) :: str\n    read(*,'(A)') str\n\nBut leading/trailing spaces may be read? Hmm. Alternatively, using a variable length string. In Fortran 2003, there's a len=\" variable, but for simplicity, perhaps just use a large enough size.\n\nAssuming the input line is not more than 1000 characters.\n\nThen, each character in the string can be looped:\n\nDo i = 1, len_trim(str)\n\nThen, for each character, get its ASCII code via ICHAR(str(i:i)), since in Fortran strings are characters, so extracting position i is str(i:i).\n\nNow, the frequency array: declare an integer array, say freq, size 256, initialized to 0. Then loop through each character.\n\nThen, after building freq array., then loop over all elements of freq, count how many have an odd count (value mod 2 ==1).\n\nOnce the oddCount is determined, then the logic is similar to Java's: If oddCount \u22641 or oddCount %2 ==1. So, if ((oddCount <=1) .OR. (MOD(oddCount,2) ==1)), then print \"First\", else \"Second\".\n\nNow, the conditions:\n\nWait the original Java code says:\n\nif (oddCount <= 1 || oddCount % 2 !=0) {\n\nWait wait. Java's condition is:\n\nif (oddCount is less than or equal to 1, OR the oddCount is odd). Because the condition was:\n\nif (oddCount<=1 or (oddCount is odd (because the mod !=0))).\n\nWait, actually, oddCount is the number of characters with odd counts. The condition in Java is:\n\nif (oddCount <=1 || (oddCount %2 !=0)).\n\nWait no, the original Java code:\n\nif (oddCount <= 1 || oddCount % 2 != 0) \n\nSo the first condition is \"less than or equal to 1\", OR \"the count is odd (oddCount mod 2 !=0). Wait, but oddCount can be 2,4 etc. Let me see:\n\nWait the condition would trigger \"First\" in cases where there is 0 or 1 odd counts, or any other odd number of odd counts (like 3,5 etc).\n\nWait but that makes sense? Let me think about the problem.\n\nAh, perhaps this relates to whether the remaining odd counts can be taken by the players alternately, so the first player has some advantage. Let me see, perhaps the problem is similar to some matchstick game where each player takes pairs, and if there's an odd number remaining, the first can take the last.\n\nWait perhaps the original Java code is solving a specific problem where the player can take any pair, but pairs of the same character? The logic here is such that the first player wins if the number of characters with odd counts is 0 or 1, because then it can be split equally or have one left for the first player. Wait perhaps the actual logic is that the first player wins if the number of odd counts is 0 or 1, but if there's an even number of odd counts greater than 1, then second player wins. Wait but the code's condition is a bit different. Let me check.\n\nOriginal code's condition:\n\nif (oddCount <=1 || (oddCount %2 !=0)) then print first, else second.\n\nWait, oddCount must be a number where either it\u2019s <=1, or it\u2019s odd (but that would include like 3,5...). Hmm.\n\nWell, regardless, I just need to translate the code's logic accurately.\n\nNow, translating that condition into Fortran:\n\nThe condition is: if ( (oddCount <=1) .or. mod(oddCount,2) /=0 ) then print \"First\".\n\nWait the original Java code:\n\noddCount % 2 !=0 \u2192 mod(oddCount,2) .ne. 0.\n\nWait, but in the condition, combining those two. Let me see: for oddCount being:\n\nCase 0 \u2192 first.\n\n1 \u2192 first.\n\nBut also, 3 \u2192 mod(3,2)=1 \u2192 first.\n\n2 \u2192 even, mod is 0 \u2192 so check the first condition (if 2 <=1? No) \u2192 so not first, so else second.\n\nSimilarly, 4 \u2192 mod 0 \u2192 condition is false, so second.\n\nSo the program's logic is that as long as the number of odd-counted characters is zero, one, or an odd number (like 3,5, etc. but greater than 1?), then first wins. Wait but 3 is greater than 1 and is odd, so yes. So the first player can win in those cases.\n\nWait the code is designed for a problem where \"first\" wins if the count is zero or one, or an odd number?\n\nHmm, but why?\n\nWell the code is likely solving a programming contest problem (given the initial code's class name codeforces_276_B). So knowing that, but I don't need to know why, just translate.\n\nNow, moving to writing the Fortran code.\n\nFirst, the outline:\n\nProgram codeforces_276_B\n\n     implicit none\n\n     ( declare variables )\n\n     Read string.\n\n     Process frequencies.\n\n     compute odd count.\n\n     evaluate condition.\n\n     output.\n\nEnd program\n\nNow, variables:\n\nWe need to read the string. Let's choose a character array with a length of say 1000, or better, use a variable length string, but maybe in older Fortran versions? Assuming it's Fortran 90.\n\nDeclare a string. Let's say:\n\ncharacter(len=200) :: s\n\nthen we can read until the end of line. But in Fortran, reading with a variable length.\n\nAlternatively, read with trailing spaces, but using len_trim:\n\nRead the entire line into s, using a length\u81ea\u4fe1, which may include spaces? Let's see: the Java code reads bufferedReader.readLine(), so including whitespace except newline.\n\nIn Fortran, perhaps:\n\n read(*, '(A)') s \u2192 this reads the current line, including all characters except the newline.\n\nThe array to hold frequencies can be declared as:\n\ninteger, dimension(0:255) :: freq\n\nInitialize all to zero.\n\nThe ASCII for a character c is given by ichar(c). So for each character in s (up to the length of the read string), we'll get its ASCII code. Note that in Fortran, s is a character string with len=200, but the actual length can be found via len_trim(s). So the loop is from i=1 to len_trim(s).\n\nLoop:\n\ndo i=1, len_trim(s)\n\n    ch = s(i:i)\n\n    code = ichar(ch)\n\n    freq( code ) = freq( code ) +1\n\nend do\n\nThen, after filling the freq array, compute odd_count:\n\nodd_count =0\n\ndo i=0,255\n\n   if (mod(freq(i),2)/=0) then\n\n       odd_count = odd_count +1\n\n   end if\n\nend do\n\nThen check the condition:\n\nif ( (odd_count <=1) .or. (mod(odd_count,2)/=0) ) then\n\n   write(*,*) 'First'\n\nelse\n\n   write(*,*) 'Second'\n\nend if\n\nWait wait, the condition is odd_count <=1 OR odd_count is odd. Wait, but when odd_count is less than or equal to 1, it's possible to have 0 or 1. 0 is even, 1 is odd. So combining these OR, it covers:\n\n- If there are even counts (zero odd counts \u2192 condition met), so first.\n\n- If there's one odd count \u2192 condition is met, first.\n\n- Or if there are multiple but odd number of odd counts (like 3,5 etc.), then also first.\n\nThe second case (Second) is when the number of odd counts is even and greater than 1 (like 2,4, etc.). \n\nNow, that's correct as per the original code.\n\nNow putting all together in Fortran:\n\nCheck variable declarations. Also, in Fortran, array indexes start at 1 by default, but we declared freq as 0:255, which is okay.\n\nSo the full code:\n\nprogram codeforces_276_B\n\n    implicit none\n\n    character(len=200) :: s\n    integer, dimension(0:255) :: freq\n    integer :: i, code, odd_count\n\n    ! Initialize frequency array to 0\n    freq = 0\n\n    ! Read the input\n    read(*, '(A)') s\n\n    ! Compute frequencies\n    do i =1, len_trim(s)\n        ! Get current character\n        code = ichar( s(i:i) )\n        freq(code) = freq(code) +1\n    end do\n\n    odd_count =0\n    do i =0,255\n        if (mod(freq(i),2)/=0) then\n            odd_count = odd_count +1\n        end if\n    end do\n\n    ! Check condition and output\n    if ( (odd_count <=1) .or. (mod(odd_count, 2)/=0) ) then\n        write(*,*) 'First'\n    else\n        write(*,*) 'Second'\n    end if\n\nend program codeforces_276_B\n\nWait, but in the initial part, the freq array must have to be initialized to zero. In the code above, we have \"freq =0\" which should set all elements to zero. In Fortran 90, this is allowed, yes.\n\nWait, variable declarations. Since in the declarations, we have 'integer, dimension(0:255) :: freq' and 'freq=0' in the code.\n\nWait, but in fortran, initialization at declaration requires an explicit initialization part. The line 'freq =0' is an assignment statement which should work for static arrays. So that's okay.\n\nNow testing possible issues:\n\nWhat about characters with codes above 255? Probably the codeforces problem uses ASCII characters, so assuming up to 255 is okay. Since the Java code uses char (16 bits), but in Fortran, ichar on characters returns 16-bit signed (up to 32767?), but probably for the problem, the characters are printable, so within 0-255.\n\nBut if the code is required to handle Unicode? Well, given the original code uses Java (which uses 16-bit chars), but perhaps the problem's input is in ASCII. So we can proceed.\n\nAnother possible issue: in Fortran strings, uppercase vs lowercase letters are distinct. But the problem's logic likely treats them as different, since the Java code does so. So that's correct.\n\nNow, what about empty string? Well, if the input is empty, then odd_count would be 0, so first player wins. That aligns with the original code.\n\nAnother test case: \"aab\" \u2192 counts are a:2 (even, so 0. Wait no: \"aab\" \u2192 'a' appears 2 times, 'b' 1 \u2192 counts of odd are 1. So odd_count is 1 \u21d2 print first.\n\nYes, which would be correct.\n\nAnother case: \"abc\" \u2192 a:1, b:1, c:1 \u2192 odd_counts =3 \u2192 3>1 and odd? Yes, so first.\n\nSecond case like \"aabb\" \u2192 odd_count is 0 \u2192 first.\n\nA case where odd_count=2 \u2192 for example \"ab\" \u2192 a:1, b:1 \u2192 odd_count=2 (even and more than one), so second.\n\nSo the code seems to handle.\n\nI think that should be correct. So the translated Fortran code is as above."
}