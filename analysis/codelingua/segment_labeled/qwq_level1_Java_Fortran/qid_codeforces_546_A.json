{
  "segments": [
    {
      "text": "Okay, I need to translate the given Java code into Fortran.",
      "start_char": 0,
      "end_char": 59,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Let me first understand what the Java code does.",
      "start_char": 60,
      "end_char": 108,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The Java program reads three long integers: pandu, vundu, and urdu. Then it calculates the sum of i*pandu for i from 1 to urdu. This sum is stored in 'c'. If this sum is less than vundu, it prints 0; otherwise, it prints c minus vundu.",
      "start_char": 111,
      "end_char": 346,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Hmm, translating this into Fortran. Let's think about the steps. First, the input part. In Java, they use a Scanner.",
      "start_char": 348,
      "end_char": 464,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "In Fortran, we can read from stdin using read(*,*) statements. Variables: The Java code uses long for pandu, vundu, urdu, and c. Fortran doesn't have a 'long' keyword; but on most systems, integers can be 4 or 8 bytes.",
      "start_char": 466,
      "end_char": 686,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "To handle large numbers, maybe use integer*8 or the kind parameter.",
      "start_char": 687,
      "end_char": 754,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, using the selected_int_kind function would be better for portability. Wait, but maybe for simplicity, I'll just use integer(8) or integer(kind=8) since the problem might require handling large values. Since in Java, Long.",
      "start_char": 755,
      "end_char": 991,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "MAX_VALUE is 2^63-1, so 8-byte integers are needed here.",
      "start_char": 991,
      "end_char": 1047,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Because Fortran doesn't have 64-bit ints as default, unless specified. So in Fortran, variables should probably be declared as integer*8 or with kind=8.",
      "start_char": 1048,
      "end_char": 1200,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The loop in Java is a for loop from 1 to urdu (inclusive).",
      "start_char": 1202,
      "end_char": 1260,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "In Fortran, loops are done with do loops. So something like do i = 1, urdu.",
      "start_char": 1261,
      "end_char": 1336,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Then, the calculation of c. In Fortran, variables must be declared. So first, we need to initialize c to 0.",
      "start_char": 1338,
      "end_char": 1445,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Then, in each iteration, add i*pandu to c.",
      "start_char": 1446,
      "end_char": 1488,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "The conditional is straightforward: if c < vundu then print 0, else c - vundu.",
      "start_char": 1490,
      "end_char": 1568,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Wait, but in Fortran, all variables must be declared before use. So the variables should be declared at the beginning of the program.",
      "start_char": 1570,
      "end_char": 1703,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Let's think about the structure.",
      "start_char": 1704,
      "end_char": 1736,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "The Fortran program will be a main program, not a class. So something like:\n\nprogram codeforces_546_A\n  implicit none\n  !",
      "start_char": 1738,
      "end_char": 1859,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "declarations here\n  ...\nend program codeforces_546_A\n\nNow, variables.",
      "start_char": 1860,
      "end_char": 1929,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "In Java, the variables are pandu, vundu, urdu, c. All are long. Translating to Fortran:\n\npandu, vundu, urdu, c: integer(kind=8). So:\n\ninteger(kind=8) :: pandu, vundu, urdu, c,",
      "start_char": 1932,
      "end_char": 2109,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "i\n\nWait, but in the loop, i is an integer.",
      "start_char": 2110,
      "end_char": 2152,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Since urdu could be up to 1e18?",
      "start_char": 2153,
      "end_char": 2184,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "Wait, in Java, urdu is a long.",
      "start_char": 2185,
      "end_char": 2215,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Wait, but in the for loop in Java, the loop variable (i) is an int, right?",
      "start_char": 2216,
      "end_char": 2290,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Wait, the original code has urdu as long, but the loop uses i as an int.",
      "start_char": 2291,
      "end_char": 2363,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "Wait, that could be a problem.",
      "start_char": 2364,
      "end_char": 2394,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "Because if urdu is larger than 2^31-1, then the loop will not go up to urdu.",
      "start_char": 2395,
      "end_char": 2471,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Because in Java, the loop's i is an int, so if urdu bigger than 2^31-1, which is possible since urdu is a long, then the loop variable would overflow. But perhaps that's a bug in the Java code.",
      "start_char": 2472,
      "end_char": 2665,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Wait, but the original code may have a problem in Java if urdu exceeds 2^31-1.",
      "start_char": 2667,
      "end_char": 2745,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "However, since the user wants us to translate the code as given, we have to replicate it as such. So in the Java code, since the loop variable is an int, then the loop will work only if urdu is within the int range.",
      "start_char": 2746,
      "end_char": 2961,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "However, since the Java variables are long, but urdu could be up to something large, but the code's behavior would be incorrect beyond the max integer value. But since the Fortran translation isn't taking into account those limitations, perhaps the problem expects us to just translate the code as written, not fix any \"issues\". So in Fortran, the loop variable can be integer because urdu can be up to its maximum (so 8 bytes).",
      "start_char": 2962,
      "end_char": 3390,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Wait, in the for loop in the Java code, the loop variable is 'int",
      "start_char": 3392,
      "end_char": 3457,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "i', so the loop would not handle urdu beyond 2^31.",
      "start_char": 3458,
      "end_char": 3508,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "However, the Fortran code will use an integer with sufficient length. Hmm.",
      "start_char": 3509,
      "end_char": 3583,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Wait, perhaps in the Java code, this could be a problem but the problem constraints may ensure that urdu is within the int range.",
      "start_char": 3586,
      "end_char": 3715,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Well, the problem's translation should mirror the original code exactly, so in Fortran, the loop variable should be same as the loop in Java. So to replicate the same possible (but incorrect) behavior, perhaps in Fortran, i should also be an integer (4 bytes?), so that if urdu is larger than the maximum int, the loop won't go up. But since Fortran is different, maybe the translation will just proceed as 8-byte integers.",
      "start_char": 3716,
      "end_char": 4139,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Hmm, perhaps I should proceed to use integers for all variables at the least size needed. But in this problem's loop, regardless of what urdu is, in the Fortran code, the loop will be from i=1 to urdu (as urdu is integer(8)), so even for large values, but in Java, if urdu is a long beyond int, the loop won't function properly.",
      "start_char": 4140,
      "end_char": 4468,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Well, since the problem says to translate the code as written, I'll proceed to handle it in Fortran with the variables appropriately sized. So for the variables, use 8-byte integers to prevent overflow for large values. So variables declaration:\n\ninteger(kind=8) :: pandu, vundu, urdu, c, i\n\nWait, but the loop variable i in Fortran: if urdu is up to 1e18, that's a problem because looping over 1e18 times isn't feasible.",
      "start_char": 4471,
      "end_char": 4893,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "The code in Java would take time proportional to urdu, which would be impossible for large urdu, but perhaps it's a bug.",
      "start_char": 4894,
      "end_char": 5014,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "However, perhaps the problem expects this code, so I have to translate it as is. So assuming that the problem constraints have urdu as a manageable number.",
      "start_char": 5015,
      "end_char": 5170,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Well, we have to just translate the code. Now, the loop:\n\nThe Java code runs from i=1 to urdu (inclusive). So in Fortran, the loop would be: do i = 1, urdu\n  c = c",
      "start_char": 5171,
      "end_char": 5336,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "+ i * pandu\nend do\n\nWait yes, that's right. So c is starting at 0.",
      "start_char": 5337,
      "end_char": 5403,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Then, each iteration adds i*pandu to it, from 1 to urdu.",
      "start_char": 5404,
      "end_char": 5460,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Then, the condition: if (c < vundu) then print 0 else write the difference.",
      "start_char": 5462,
      "end_char": 5537,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "In Fortran, to read the inputs, I need to read them from stdin.",
      "start_char": 5539,
      "end_char": 5602,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "So:\n\nread(*,*) pandu, vundu, urdu\n\nWait, but the order is correct? Let me check the Java code:\n\npandu = sc.nextLong();\nvundu = sc.nextLong();\nurdu = sc.nextLong(); Yes, so the inputs are pandu, vundu, urdu.",
      "start_char": 5603,
      "end_char": 5809,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "In Fortran's read statement, the variables are listed in order, so the read(*,*) needs to read in that order. Now, variables must be declared before use, so the code structure is:\n\nprogram codeforces_546_A\n  implicit none\n  integer(kind=8) :: pandu, vundu, urdu, c, i\n  read(*,*) pandu, vundu, urdu\n  c = 0\n  do i = 1, urdu\n    c = c + i * pandu\n  end do\n  if (c < vundu) then\n    print *, 0\n  else\n    print *, c - vundu\n  end if\nend program codeforces_546_A\n\nWait, but in the print statements, does Fortran require a specific format? Let me think.",
      "start_char": 5812,
      "end_char": 6362,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Because in Java, they use System.out.print, which just writes the number with no newline. But Fortran uses print *, which outputs numbers with a space, probably.",
      "start_char": 6363,
      "end_char": 6524,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Alternatively, maybe it should use write statements with appropriate formats.",
      "start_char": 6525,
      "end_char": 6602,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Wait, the problem's Java code uses System.out.print, which doesn't add a newline, but the Fortran code may need to replicate that.",
      "start_char": 6604,
      "end_char": 6734,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "However, in Fortran, using print *, will add a newline.",
      "start_char": 6735,
      "end_char": 6790,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Alternatively, maybe the problem expects no trailing newline? Let me see.",
      "start_char": 6791,
      "end_char": 6864,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "The Java code's output: for example, outputs \"0\" (with no newline), then ends. The non-newline is important. So in Fortran, writing print *,0 would output 0 followed by a newline.",
      "start_char": 6867,
      "end_char": 7046,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "To output without a newline, perhaps the code should use write statement with an appropriate format.",
      "start_char": 7047,
      "end_char": 7147,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Wait, in Fortran, the 'print *' statement is the same as write(*,*) which by default adds a new line.",
      "start_char": 7149,
      "end_char": 7250,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "To output without a new line, you can use a format that doesn't have a new line, but in practice, for simple printing, perhaps it's okay to proceed with print *.",
      "start_char": 7251,
      "end_char": 7412,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Since the problem's sample output is likely in the same way.",
      "start_char": 7413,
      "end_char": 7473,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, if we need the exact behavior as Java's System.out.print, then perhaps:\n\nIn Fortran: write(*,'(I0)') 0 would write the integer 0 without any trailing space and with no new line.",
      "start_char": 7475,
      "end_char": 7667,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Or, perhaps, in some versions the new line is added.",
      "start_char": 7668,
      "end_char": 7720,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Wait, I think that the default is that the `*` in the output includes a new line.",
      "start_char": 7721,
      "end_char": 7802,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "To avoid that, you can use an explicit format with 'A' and no new line. Hmm.",
      "start_char": 7803,
      "end_char": 7879,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "Alternatively, maybe it's acceptable.",
      "start_char": 7881,
      "end_char": 7918,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "Since problems usually don't care about a trailing newline, just the exact number.output.",
      "start_char": 7919,
      "end_char": 8008,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "I think proceeding with the print * command is okay. So the code line can be written as:\n\nif (c < vundu) then\n  print *, 0\nelse \n  print *, c - vundu\nend if\n\nAlternatively, perhaps to use the write statement:\n\nwrite(*,*) 0 \n\netc.",
      "start_char": 8009,
      "end_char": 8238,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Since in coding contests, this is usually acceptable.",
      "start_char": 8239,
      "end_char": 8292,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "Another point: In Fortran, integers must be declared before use.",
      "start_char": 8295,
      "end_char": 8359,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Also, the loop variable i is declared.",
      "start_char": 8360,
      "end_char": 8398,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Wait, in the declaration line, the variables are pandu, vundu, urdu, c, i. So yes, including i. \n\nWait, in Fortran loops, the loop variable is a variable that's declared before the do loop.",
      "start_char": 8401,
      "end_char": 8590,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Because in the do loop code, i is used as an integer. So since we included i in the declarations, that's okay.",
      "start_char": 8591,
      "end_char": 8701,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "I think that's the correct approach.",
      "start_char": 8704,
      "end_char": 8740,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "Let me check example:\n\nSample input: Let's see, suppose input is 1 3 3. Then c is 1*1 + 2*1 +3*1 = 6. If vundu is 3, then since 6>3, output is 6-3=3. If inputs are such as 1 10 3, then c =6 <10, so output zero. The code seems to do that. Wait, in the Fortran code, the loop will correctly sum i*pandu from i=1 to urdu. So yes.",
      "start_char": 8741,
      "end_char": 9072,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Potential issues:\n\n1) The loop.",
      "start_char": 9074,
      "end_char": 9105,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "If urdu is very large, like 1e9, then this code would be way too slow. But the Java code would also be slow. So this is a possible flaw but part of the problem's code.",
      "start_char": 9106,
      "end_char": 9273,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Assuming that's the case and the problem expects a straightforward translation, this is acceptable.",
      "start_char": 9275,
      "end_char": 9374,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Another possible issue is the data type sizes.",
      "start_char": 9376,
      "end_char": 9422,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "Java's long is 64-bit, so in Fortran using integer(8) which on many systems is 8 bytes (64-bit) would match. So that's okay. So that should be the code.",
      "start_char": 9423,
      "end_char": 9575,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    }
  ],
  "original_reasoning": "Okay, I need to translate the given Java code into Fortran. Let me first understand what the Java code does. \n\nThe Java program reads three long integers: pandu, vundu, and urdu. Then it calculates the sum of i*pandu for i from 1 to urdu. This sum is stored in 'c'. If this sum is less than vundu, it prints 0; otherwise, it prints c minus vundu.\n\nHmm, translating this into Fortran. Let's think about the steps.\n\nFirst, the input part. In Java, they use a Scanner. In Fortran, we can read from stdin using read(*,*) statements. \n\nVariables: The Java code uses long for pandu, vundu, urdu, and c. Fortran doesn't have a 'long' keyword; but on most systems, integers can be 4 or 8 bytes. To handle large numbers, maybe use integer*8 or the kind parameter. Alternatively, using the selected_int_kind function would be better for portability. Wait, but maybe for simplicity, I'll just use integer(8) or integer(kind=8) since the problem might require handling large values. Since in Java, Long.MAX_VALUE is 2^63-1, so 8-byte integers are needed here. Because Fortran doesn't have 64-bit ints as default, unless specified. So in Fortran, variables should probably be declared as integer*8 or with kind=8.\n\nThe loop in Java is a for loop from 1 to urdu (inclusive). In Fortran, loops are done with do loops. So something like do i = 1, urdu.\n\nThen, the calculation of c. In Fortran, variables must be declared. So first, we need to initialize c to 0. Then, in each iteration, add i*pandu to c.\n\nThe conditional is straightforward: if c < vundu then print 0, else c - vundu.\n\nWait, but in Fortran, all variables must be declared before use. So the variables should be declared at the beginning of the program. Let's think about the structure.\n\nThe Fortran program will be a main program, not a class. So something like:\n\nprogram codeforces_546_A\n  implicit none\n  ! declarations here\n  ...\nend program codeforces_546_A\n\nNow, variables. \n\nIn Java, the variables are pandu, vundu, urdu, c. All are long. Translating to Fortran:\n\npandu, vundu, urdu, c: integer(kind=8). \n\nSo:\n\ninteger(kind=8) :: pandu, vundu, urdu, c, i\n\nWait, but in the loop, i is an integer. Since urdu could be up to 1e18? Wait, in Java, urdu is a long. Wait, but in the for loop in Java, the loop variable (i) is an int, right? Wait, the original code has urdu as long, but the loop uses i as an int. Wait, that could be a problem. Because if urdu is larger than 2^31-1, then the loop will not go up to urdu. Because in Java, the loop's i is an int, so if urdu bigger than 2^31-1, which is possible since urdu is a long, then the loop variable would overflow. But perhaps that's a bug in the Java code.\n\nWait, but the original code may have a problem in Java if urdu exceeds 2^31-1. However, since the user wants us to translate the code as given, we have to replicate it as such. So in the Java code, since the loop variable is an int, then the loop will work only if urdu is within the int range. However, since the Java variables are long, but urdu could be up to something large, but the code's behavior would be incorrect beyond the max integer value. But since the Fortran translation isn't taking into account those limitations, perhaps the problem expects us to just translate the code as written, not fix any \"issues\".\n\nSo in Fortran, the loop variable can be integer because urdu can be up to its maximum (so 8 bytes). Wait, in the for loop in the Java code, the loop variable is 'int i', so the loop would not handle urdu beyond 2^31. However, the Fortran code will use an integer with sufficient length. Hmm. \n\nWait, perhaps in the Java code, this could be a problem but the problem constraints may ensure that urdu is within the int range. Well, the problem's translation should mirror the original code exactly, so in Fortran, the loop variable should be same as the loop in Java. So to replicate the same possible (but incorrect) behavior, perhaps in Fortran, i should also be an integer (4 bytes?), so that if urdu is larger than the maximum int, the loop won't go up. But since Fortran is different, maybe the translation will just proceed as 8-byte integers. Hmm, perhaps I should proceed to use integers for all variables at the least size needed. But in this problem's loop, regardless of what urdu is, in the Fortran code, the loop will be from i=1 to urdu (as urdu is integer(8)), so even for large values, but in Java, if urdu is a long beyond int, the loop won't function properly. \n\nWell, since the problem says to translate the code as written, I'll proceed to handle it in Fortran with the variables appropriately sized. So for the variables, use 8-byte integers to prevent overflow for large values.\n\nSo variables declaration:\n\ninteger(kind=8) :: pandu, vundu, urdu, c, i\n\nWait, but the loop variable i in Fortran: if urdu is up to 1e18, that's a problem because looping over 1e18 times isn't feasible. The code in Java would take time proportional to urdu, which would be impossible for large urdu, but perhaps it's a bug. However, perhaps the problem expects this code, so I have to translate it as is. So assuming that the problem constraints have urdu as a manageable number. Well, we have to just translate the code.\n\nNow, the loop:\n\nThe Java code runs from i=1 to urdu (inclusive). So in Fortran, the loop would be:\n\ndo i = 1, urdu\n  c = c + i * pandu\nend do\n\nWait yes, that's right. So c is starting at 0. Then, each iteration adds i*pandu to it, from 1 to urdu.\n\nThen, the condition: if (c < vundu) then print 0 else write the difference.\n\nIn Fortran, to read the inputs, I need to read them from stdin. So:\n\nread(*,*) pandu, vundu, urdu\n\nWait, but the order is correct? Let me check the Java code:\n\npandu = sc.nextLong();\nvundu = sc.nextLong();\nurdu = sc.nextLong();\n\nYes, so the inputs are pandu, vundu, urdu.\n\nIn Fortran's read statement, the variables are listed in order, so the read(*,*) needs to read in that order.\n\nNow, variables must be declared before use, so the code structure is:\n\nprogram codeforces_546_A\n  implicit none\n  integer(kind=8) :: pandu, vundu, urdu, c, i\n  read(*,*) pandu, vundu, urdu\n  c = 0\n  do i = 1, urdu\n    c = c + i * pandu\n  end do\n  if (c < vundu) then\n    print *, 0\n  else\n    print *, c - vundu\n  end if\nend program codeforces_546_A\n\nWait, but in the print statements, does Fortran require a specific format? Let me think. Because in Java, they use System.out.print, which just writes the number with no newline. But Fortran uses print *, which outputs numbers with a space, probably. Alternatively, maybe it should use write statements with appropriate formats.\n\nWait, the problem's Java code uses System.out.print, which doesn't add a newline, but the Fortran code may need to replicate that. However, in Fortran, using print *, will add a newline. Alternatively, maybe the problem expects no trailing newline? Let me see. \n\nThe Java code's output: for example, outputs \"0\" (with no newline), then ends. The non-newline is important. So in Fortran, writing print *,0 would output 0 followed by a newline. To output without a newline, perhaps the code should use write statement with an appropriate format.\n\nWait, in Fortran, the 'print *' statement is the same as write(*,*) which by default adds a new line. To output without a new line, you can use a format that doesn't have a new line, but in practice, for simple printing, perhaps it's okay to proceed with print *. Since the problem's sample output is likely in the same way.\n\nAlternatively, if we need the exact behavior as Java's System.out.print, then perhaps:\n\nIn Fortran: write(*,'(I0)') 0 would write the integer 0 without any trailing space and with no new line. Or, perhaps, in some versions the new line is added. Wait, I think that the default is that the `*` in the output includes a new line. To avoid that, you can use an explicit format with 'A' and no new line.\n\nHmm. Alternatively, maybe it's acceptable. Since problems usually don't care about a trailing newline, just the exact number.output. I think proceeding with the print * command is okay. So the code line can be written as:\n\nif (c < vundu) then\n  print *, 0\nelse \n  print *, c - vundu\nend if\n\nAlternatively, perhaps to use the write statement:\n\nwrite(*,*) 0 \n\netc. Since in coding contests, this is usually acceptable. \n\nAnother point: In Fortran, integers must be declared before use. Also, the loop variable i is declared. \n\nWait, in the declaration line, the variables are pandu, vundu, urdu, c, i. So yes, including i. \n\nWait, in Fortran loops, the loop variable is a variable that's declared before the do loop. Because in the do loop code, i is used as an integer. So since we included i in the declarations, that's okay. \n\nI think that's the correct approach. Let me check example:\n\nSample input: Let's see, suppose input is 1 3 3. \n\nThen c is 1*1 + 2*1 +3*1 = 6. If vundu is 3, then since 6>3, output is 6-3=3.\n\nIf inputs are such as 1 10 3, then c =6 <10, so output zero.\n\nThe code seems to do that.\n\nWait, in the Fortran code, the loop will correctly sum i*pandu from i=1 to urdu. So yes.\n\nPotential issues:\n\n1) The loop. If urdu is very large, like 1e9, then this code would be way too slow. But the Java code would also be slow. So this is a possible flaw but part of the problem's code.\n\nAssuming that's the case and the problem expects a straightforward translation, this is acceptable.\n\nAnother possible issue is the data type sizes. Java's long is 64-bit, so in Fortran using integer(8) which on many systems is 8 bytes (64-bit) would match. So that's okay.\n\nSo that should be the code."
}