{
  "segments": [
    {
      "text": "Okay, so I need to translate this Java code into Fortran.",
      "start_char": 0,
      "end_char": 57,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Let me look at the Java code first and understand what it does.",
      "start_char": 58,
      "end_char": 121,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The program reads a list of integers, removes duplicates, sorts them, and checks if there are three consecutive numbers in the sorted list.",
      "start_char": 122,
      "end_char": 261,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "If there are, it outputs \"YES\", else \"NO\".",
      "start_char": 262,
      "end_char": 304,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Hmm, in Fortran, I need to handle input, process the list, and output the result. Let's think step by step.",
      "start_char": 306,
      "end_char": 413,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "First, the Java code uses a Scanner to read from System.in.",
      "start_char": 415,
      "end_char": 474,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "In Fortran, I can read from the standard input using read(*,*) statements.",
      "start_char": 475,
      "end_char": 549,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Next, the input is an integer n, followed by n integers. So I'll need to read n first, then allocate an array of size n. Wait, but in Fortran arrays are statically sized, so I can either read into a dynamic array (using an allocatable array) or a fixed size large enough.",
      "start_char": 552,
      "end_char": 823,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Since n is given as input, allocatable is better.",
      "start_char": 824,
      "end_char": 873,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Now, after reading the numbers, the next step is to remove duplicates.",
      "start_char": 875,
      "end_char": 945,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Java uses a stream's distinct() method here. In Fortran, how do I do that?",
      "start_char": 946,
      "end_char": 1020,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Well, perhaps I can create a logical array to track which numbers are duplicates, then collect the unique ones.",
      "start_char": 1021,
      "end_char": 1132,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, since after sorting duplicates are adjacent, maybe it's easier to sort first and then remove duplicates.",
      "start_char": 1134,
      "end_char": 1253,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Let me think: maybe sort the array first, then loop through and copy only elements that are different from the previous one.",
      "start_char": 1254,
      "end_char": 1378,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Wait, the code first sorts the list, but before that it uses distinct(). So in Fortran, maybe better to first sort, then remove duplicates. Wait no, actually the Java code does a stream().distinct().sorted(). So they first remove duplicates and then sort them. So the correct order is important here. So first deduplicate, then sort? Or does the order matter?",
      "start_char": 1381,
      "end_char": 1740,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Let me check the Java code order again:",
      "start_char": 1742,
      "end_char": 1781,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Yes, the chain is .distinct().sorted() so the list is first processed to have unique elements, then sorted. Wait no, the order matters because .distinct() comes before .sorted() in the chain.",
      "start_char": 1784,
      "end_char": 1975,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "That is, the elements are deduplicated first in their original order (but since they don't preserve order for distinct streams?), but actually, the result after distinct is a stream, and then sorted.",
      "start_char": 1976,
      "end_char": 2175,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Hmm, perhaps in Java, the distinct() ensures unique elements, but sorted() applies the sorting after. So overall, the list is the unique elements sorted in order. So the equivalent in Fortran would be to process the array, first make all elements unique, then sort them. Now how?\n\nLet me lay out the steps in Fortran:\n\n1.",
      "start_char": 2178,
      "end_char": 2499,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Read n and the array a of size n.\n\n2.",
      "start_char": 2504,
      "end_char": 2541,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Remove duplicates from a. So create a new array containing unique elements. 3.",
      "start_char": 2542,
      "end_char": 2620,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Sort the new array in ascending order (since Java's sorted() is in natural order, which is ascending).",
      "start_char": 2623,
      "end_char": 2725,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "4. Loop through the sorted array to check for three consecutive numbers. 5. Output",
      "start_char": 2727,
      "end_char": 2809,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "YES or NO based on whether such triplet exists.",
      "start_char": 2811,
      "end_char": 2858,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Hmm, step 2 and 3 are crucial here. Let's think of step 2 first.",
      "start_char": 2860,
      "end_char": 2924,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Possible approach for deduplication: create an array with unique elements.",
      "start_char": 2927,
      "end_char": 3001,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Since Fortran has to arrays: the input array and the unique array.",
      "start_char": 3002,
      "end_char": 3068,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "One common way is to loop through each element and check if it's already in the unique list.",
      "start_char": 3071,
      "end_char": 3163,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, if you first sort the array, then you can check adjacent elements for duplicates.",
      "start_char": 3166,
      "end_char": 3262,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Wait: let's say we first sort the array, then loop through, adding elements to a temporary array only if they are not equal to the previous. Then that would give the unique elements in sorted order, which is exactly what was done in Java (since they first made distinct and then sorted, but if after making distinct, the sorted sorts them again). Wait no, if you first get distinct, sorted applies a sort, so the overall order is sorted and distinct.",
      "start_char": 3265,
      "end_char": 3715,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Hmm, in the Java code, the list after distinct().sorted() is first getting all unique elements, then sorted. So the end result is the distinct elements sorted. So the process in Fortran can be done by first sorting the array, then removing adjacent duplicates?",
      "start_char": 3716,
      "end_char": 3976,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Wait, if I first sort and then remove duplicates (since duplicates would be adjacent after sorting), then the order is sorted and then deduplicated. But in Java, the order is first deduplicated then sorted, but perhaps the final result is the same as dedup then sort.",
      "start_char": 3979,
      "end_char": 4246,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Because sorted is after the distinct, so the final list is sorted. So the key is the unique elements, sorted. So the two approaches (sort then dedup vs dedup then sort) might lead to the same end result, but we need to be sure which is correct.",
      "start_char": 4247,
      "end_char": 4491,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Wait, for example, if the original array has numbers in any order, deduplicating first would leave elements in their first occurrence order, but then sorting.",
      "start_char": 4493,
      "end_char": 4651,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Whereas sorting first then dedup'ing would give unique elements in sorted order. Wait, in Java, list.distinct() doesn't remove elements in a sorted way; it just returns a stream with unique elements in the order of their first occurrence. Then sorted() sorts that. But in any case, the final list is sorted, with duplicates removed. Alternatively, since in the problem, we need three consecutive elements regardless of their original order; so maybe dedup then sort, the three elements after dedup must be in sorted order. So the correct way in fortran is to first deduplicate (preserving the order?), then sort?",
      "start_char": 4652,
      "end_char": 5266,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Hmm, but since in the problem, after dedup and then sorting, the elements are arranged in order, so the sorted list contains unique elements in order, and we just check if three in a row have value difference of 1. But the order in which duplicates are removed doesn't matter as long as after processing, we have a sorted list of unique elements. So perhaps in Fortran, it's easier to first create the unique list and then sort it.",
      "start_char": 5267,
      "end_char": 5698,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Let me think of steps again:\n\n1.",
      "start_char": 5703,
      "end_char": 5735,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Read the list and store in an array, say 'input_array'.",
      "start_char": 5736,
      "end_char": 5791,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "2. Create another array 'unique' which contains only unique elements from input_array. 3. Sort unique array. Then check for 3 in a row.",
      "start_char": 5793,
      "end_char": 5928,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, first sort the input array, find duplicates, then process. The approach could be:",
      "start_char": 5933,
      "end_char": 6029,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Sort the input array, then create a unique array by stepping through and ignoring duplicates.",
      "start_char": 6032,
      "end_char": 6125,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "That would be more efficient perhaps.",
      "start_char": 6127,
      "end_char": 6164,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "For step 2 (after step 1):\n\nSort the input array. Then loop through and collect only when the current element is different from the last unique element.",
      "start_char": 6166,
      "end_char": 6318,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Wait, but that's possible, but the input array's elements may not be all stored properly first. Let me think of code steps.",
      "start_char": 6320,
      "end_char": 6443,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Let me think about the variables. Let's say in Fortran:\n\ninteger, allocatable :: input(:), unique(:)\n\nRead n:\n\nRead(*,*) n\n\nallocate(input(n))\n\ndo i = 1, n\n\n   read(*,*) input(i)\n\nenddo\n\nThen, duplicate removal and sorting:\n\nBut to deduplicate, perhaps:\n\nFirst sort the array, then extract the uniques.",
      "start_char": 6445,
      "end_char": 6747,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Sort the array using a sort routine (Fortran has a sort function, but we need to sort integers. So call:\n\ncall sort(input)\n\nThen create the unique array.",
      "start_char": 6750,
      "end_char": 6903,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Allocate a temporary array with same size (since duplicates could be all, but worst case none). count = 1\n\nunique(count) = input(1) do i =2, n\n\n   if (input(i) /= input(i-1)) then \n\n       count = count +1\n\n       unique(count) = input(i)\n\nenddo But that requires that unique array be preallocated with enough size.",
      "start_char": 6906,
      "end_char": 7223,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Since initially, n could be up to say 1e5, but in the code, perhaps the problem constraints are such that n is small, but in Fortran, managing allocations properly is needed.",
      "start_char": 7225,
      "end_char": 7399,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Alternatively, to first create an array of size n, then after dedup'ing count the number of elements and then compact. So:\n\nallocate(unique(n))\n\nunique(1) = input(1)\n\ncount =1\n\ndo i =2, n\n\n   if(input(i) /= unique(count)) then\n\n       count = count +1\n\n       unique(count) = input(i)\n\n   endif\n\nenddo\n\nThen, allocate a smaller array. unique = unique(1:count) So that's the unique array, sorted if the input was sorted. But in the problem's case, the dedup requires sorting first, then the unique array would be sorted.",
      "start_char": 7402,
      "end_char": 7923,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "That matches the Java's 'distinct().sorted()' ?",
      "start_char": 7926,
      "end_char": 7973,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Wait, in Java: distinct() gives unique elements, but not sorted. Then sorted() comes afterwards. So Java does sort the unique elements. But in the Fortran approach above, if we first sort the original input array, then do dedup (which gives unique elements in sorted order). Then we have that the same as Java. So the overall process would be the same here.",
      "start_char": 7975,
      "end_char": 8332,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Thus, in the code, the first approach would work. So the steps in Fortran are:\n\nRead n and the array. Sort the input array. Then remove duplicates by going through and selecting unique elements.",
      "start_char": 8338,
      "end_char": 8532,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Then, the unique elements are in sorted order, so now you can check for three consecutive increasing by 1.",
      "start_char": 8537,
      "end_char": 8643,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Now, the code steps would be:\n\n1. Read n and the array. 2. Sort the array.",
      "start_char": 8645,
      "end_char": 8719,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "3. Create unique array by iterating through, storing only non-duplicates. 4. Then check the unique array for three in a row. Now, how to do this in code. Let me proceed step by step. First, declare variables.",
      "start_char": 8722,
      "end_char": 8930,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Implicit none is good practice.",
      "start_char": 8936,
      "end_char": 8967,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "program codeforces_653\n\nimplicit none\n\ninteger :: n, i, count, m\n\ninteger, dimension(:), allocatable :: input, unique\n\nRead n.\n\nread(*,*)n\n\nallocate(input(n)) Read input array. do i=1, n\n\n   read*, input(i)\n\nenddo\n\nSort the input array:\n\ncall sort(input)\n\nNow create unique array.\n\nallocate(unique(n)) count = 1\n\nunique(1) = input(1)\n\ndo i=2, n\n\n   if (input(i)/= unique(count)) then\n\n       count = count+1\n\n       unique(count) = input(i)\n\n   end if\n\nend do\n\nNow we need to adjust the unique array so that it only has size count.",
      "start_char": 8969,
      "end_char": 9503,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "allocate a new array or just deallocate and reallocate. But since we need to check the unique array (truncated), perhaps it's better to create a new array.\n\nallocate(tmp(count)) tmp(1:count) = unique(1:count)\n\ndeallocate(unique)\n\nallocate(unique(count))\n\nunique = tmp\n\ndeallocate(tmp)",
      "start_char": 9505,
      "end_char": 9791,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Alternatively, in Fortran 2003, can use move_alloc, but perhaps better to use pointers?",
      "start_char": 9793,
      "end_char": 9880,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Wait, perhaps in code like this:\n\nBut to make it simpler, perhaps the initial allocation of unique(n) can be followed by re-allocating unique to count, thus:\n\nBut to avoid confusion, let's write it:\n\nallocate(unique(count)) unique(1:count) = [unique elements]\n\nWait, perhaps better way:\n\nAfter the loop where count is found:\n\nallocate(unique(count))\n\nunique(1) = input(1)\n\ndo i=2, n\n\n   if (input(i)/=input(i-1)) then\n\n      unique(count) = input(i)\n\n       count=count+1   \u2014 Wait, no,  in code above the count is being tracked, so perhaps:\n\nWait let me retrace the earlier loop:",
      "start_char": 9881,
      "end_char": 10461,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Initially, in that code:\n\nunique is allocated as size n (very important point here, because if I just have an array like unique, but I can't write beyond count's value...)\n\nWait the original approach's code may have a problem here.",
      "start_char": 10463,
      "end_char": 10694,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Let me see:\n\nSuppose input is sorted.",
      "start_char": 10695,
      "end_char": 10732,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "The first element is stored as unique(1).",
      "start_char": 10733,
      "end_char": 10774,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Then, for each i from 2 to n:\n\nif input(i) is different from previous one (unique(count)), then add. So:\n\nthe code:\n\nallocate(unique(n))\n\nunique(1) = input(1)\n\ncount =1\n\nthen loop over i from 2 to n.\n\nBut that way, unique array may have gaps. Wait, the code inside is:\n\nif (input(i) /=",
      "start_char": 10775,
      "end_char": 11060,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "unique(count)), then unique(count+1) = input(i), and increment count.",
      "start_char": 11061,
      "end_char": 11130,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "So:\n\nYes, the code:\n\n allocate(unique(n)) then in the loop:\n\nWhen the if is true:\n\nunique(count+1)=input(i) count = count +1.",
      "start_char": 11132,
      "end_char": 11260,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "This is okay as long as input is up to n elements.",
      "start_char": 11262,
      "end_char": 11312,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "After processing, the count is the actual unique count.",
      "start_char": 11313,
      "end_char": 11368,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "then, after the loop, you have that unique(1) to unique(count) are the unique elements in order. Thus, now to trim the array to size count, you can reallocate:\n\ncall move_alloc( from=unique(1:count), to=tmp)\n\nno, perhaps better, reallocate:\n\nThe code can be adjusted: Allocate unique(n) first (because initially we need the space to store the data), then after processing, reallocate unique to count:\n\nallocate( temp(count) ) temp = unique(1:count)\n\n deallocate( unique )\n\n allocate( unique, source = temp ) deallocate( temp )",
      "start_char": 11370,
      "end_char": 11900,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "This may be a bit messy, but perhaps in Fortran 90 and above, you can use the reservation of allocatable arrays which allows us to resize.",
      "start_char": 11904,
      "end_char": 12042,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Wait, another approach: the initial allocation for unique can be of size n, but after determining the count, we can simply allocate unique as the correct size, but only copy the first count elements.",
      "start_char": 12044,
      "end_char": 12243,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, it may be more straightforward to use a new array for the unique elements.",
      "start_char": 12245,
      "end_char": 12334,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, in Fortran, you can have arrays of adjustable size (with explicit-shape, but not sure).",
      "start_char": 12336,
      "end_char": 12438,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Hmm, maybe using a dynamic approach with an allocatable array that first is allocated with the original array size and then trimmed down to count.",
      "start_char": 12439,
      "end_char": 12585,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, you can use a list which is built by appending, but that requires dynamic allocation steps.",
      "start_char": 12587,
      "end_char": 12693,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, perhaps it's more efficient to use the approach of first reading the array, sorting it, and then building the unique array without using an initial array of allocated n.\n\nAlternatively, let's proceed step by step.",
      "start_char": 12695,
      "end_char": 12923,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Let me outline code with comments. So the code so far:\n\nprogram codeforces_653A\n\n    implicit none\n\n    integer :: n, i, count\n\n    integer, allocatable :: input(:), unique(:)\n\n    read(*,*) n\n\n    allocate(input(n))\n\n    do i=1,n\n\n        read(*,*) input(i)\n\n    end do\n\n    !",
      "start_char": 12924,
      "end_char": 13202,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Sort the input array:\n\n    call sort(input)  !",
      "start_char": 13203,
      "end_char": 13249,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Need to make sure that this is done correctly.\n\n    ! Now create unique array.\n\n    allocate(unique(n)) \n\n    unique(1) = input(1)\n\n    count=1\n\n    do i=2, n\n\n        if (input(i)/= unique(count)) then\n\n            count=count +1\n\n            unique(count)=input(i)\n\n        end if\n\n    end do \n\n    ! Now we have count elements in unique array, but memory is up to n. \n\n    ! So reallocate to actual count:\n\n    !",
      "start_char": 13250,
      "end_char": 13665,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "We need to make sure the array size is count:\n\n    !",
      "start_char": 13666,
      "end_char": 13718,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Either using temporary array or better using reallocate.",
      "start_char": 13719,
      "end_char": 13775,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "if (allocated(unique)) deallocate(unique)\n\n    allocate(unique(count))\n\n    ! now copy first count elements from the temporary array? Wait, no, no. Wait, wait a second.",
      "start_char": 13781,
      "end_char": 13949,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "My allocation for unique was to n, but the first n elements were not allocated yet. Wait no",
      "start_char": 13951,
      "end_char": 14042,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": ": unique is allocated size n, but we only filled up to count. So after this step, the first count elements of unique (allocated with size n) are stored.",
      "start_char": 14042,
      "end_char": 14194,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "To resize:\n\nAnother approach:\n\nThe new unique array needs to be of size count.",
      "start_char": 14196,
      "end_char": 14274,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "So, create a new array of that size and copy, then replace.",
      "start_char": 14275,
      "end_char": 14334,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively:\n\nallocate ( unique(count) )\n\nthen loop again? Wait, perhaps yes.",
      "start_char": 14336,
      "end_char": 14415,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Because the data is stored in the first count elements of the first unique array (which was allocated as n first). So in this case:\n\ntemp array approach:\n\nallocate( unique_new(count) )\n\ndo i=1, count\n\n    unique_new(i) = unique_old(i)\n\nend do\n\n deallocate unique_old, set unique_new to unique, but this requires code steps.",
      "start_char": 14417,
      "end_char": 14740,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Alternatively, in Fortran 2003, one can use the move_alloc function: So here's a possible way:\n\nAfter the count is determined (with the first unique array of size n):\n\nallocate(unique_new(count) )\n\nunique_new = unique(1:count)",
      "start_char": 14742,
      "end_char": 14969,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Since the first array was allocated as size n, then unique(1:count) is valid. Then deallocate the old unique array and transfer to new.",
      "start_char": 14972,
      "end_char": 15107,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Wait, perhaps:\n\nWe can first have: The initial code (so far, up to count=count+1 part):\n\n    allocate(unique(n)) \n\n    unique(1) = input(1)\n\n    count =1\n\n    do i=2, n\n\n       ... as before\n\n    end do\n\nAt this point, the first count elements of unique (allocated n) are filled with unique elements in order. Then we can proceed to:\n\n   allocate(unique_trim (count))\n\n   unique_trim = unique(1:count)\n\n   deallocate(unique)\n\n   unique => unique_trim\n\nBut in Fortran, pointers and pointer assignments are an option, but perhaps better to use:\n\nOriginal code:",
      "start_char": 15109,
      "end_char": 15668,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "After computing count:\n\nSince we don't need the rest of the unique array beyond the count, perhaps just proceed with unique(1:count) and treat it as if it's size count.",
      "start_char": 15670,
      "end_char": 15838,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "However, to avoid reallocations, we can perhaps proceed without trimming the array and just use count as the length.",
      "start_char": 15839,
      "end_char": 15955,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "However, in the code after, when checking for the triplet, we can loop only up to count. So perhaps it is sufficient. So the next steps after the count is known.",
      "start_char": 15956,
      "end_char": 16117,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Check for the presence of three consecutive numbers. In Fortran, the unique elements are in sorted order, so check for i from 1 to count-2:\n\nif unique(i)+1 == unique(i+1) and unique(i+1)+1 == unique(i+2). So:\n\nInitialize a logical flag found = .false. then loop:\n\ndo i=1, count-2\n\n   if ( unique(i+1) == unique(i)+1 .and. unique(i+2) == unique(i+1)+1 ) then \n\n       found = .true.",
      "start_char": 16120,
      "end_char": 16504,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "exit\n\n   end if\n\nend do \n\nThen output 'YES' or 'NO'.",
      "start_char": 16513,
      "end_char": 16565,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Alternatively, the loop can continue until there's a hit. So perhaps in code:\n\nlogical :: found = .false. do i=1, count-2\n\n   if( (unique(i+1) == unique(i)+1 ) .and. (unique(i+2) == unique(i+1)+1 ) ) then\n\n        found = .true.",
      "start_char": 16567,
      "end_char": 16797,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "exit\n\n   end if\n\nend do \n\nThen, after the loop, check found. Now putting all together:\n\nNow, putting this into code.",
      "start_char": 16807,
      "end_char": 16923,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Wait, but before I forget: in the step where you sort input array.",
      "start_char": 16928,
      "end_char": 16994,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "The 'call sort(input)' \u2014 Fortran provides a built-in sort function? Sort of.",
      "start_char": 16997,
      "end_char": 17073,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "In standard Fortran, the function requires using a subroutine.",
      "start_char": 17074,
      "end_char": 17136,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "For example, one can use the intrinsic procedure MOLD (Fortran 2003?), but in many cases, people write their own sorting subroutines.",
      "start_char": 17137,
      "end_char": 17270,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Alternatively, the sort_inplace function is available via some libraries.",
      "start_char": 17272,
      "end_char": 17345,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Hmm, perhaps it is better to implement a sort here, because in Java, integers are sorted in natural order (ascending).",
      "start_char": 17346,
      "end_char": 17464,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Since we need to sort the array in ascending order.",
      "start_char": 17465,
      "end_char": 17516,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Thus, perhaps safest to write a simple bubble sort or a quicksort. But for the purpose of code submission, bubble sort would be okay for small N, but given that the problem's constraints (if any) may not be given.",
      "start_char": 17518,
      "end_char": 17731,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Hmm, but in the problem (since it's from Codeforces problem 653A), perhaps n is up to 5000?",
      "start_char": 17732,
      "end_char": 17823,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "Not sure, but for code submission in Fortran, using a built-in sort function would be better if possible.",
      "start_char": 17824,
      "end_char": 17929,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, perhaps using the merge sort or other code.",
      "start_char": 17931,
      "end_char": 17989,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, in Fortran, there is a built-in sort routine via the ISO_FORTRAN_ENV module? Not sure.",
      "start_char": 17991,
      "end_char": 18092,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Wait, actually, Fortran 90 and later have array functions.",
      "start_char": 18093,
      "end_char": 18151,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "To sort an array, you can use the sort function with a work array. Wait, the correct approach for sorting in Fortran without relying on non-standard library is to use the \"sort\" routine from the instrinsics, but I think the standard way is to use the following method:\n\nKIND=1.0 hypothetical? Wait, no. Wait, here's how to do it:",
      "start_char": 18152,
      "end_char": 18483,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "The syntax would be:\n\ncall merge_sort(input) But that's not a standard.",
      "start_char": 18485,
      "end_char": 18556,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "Alternatively, perhaps the following code would suffice.",
      "start_char": 18558,
      "end_char": 18614,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, use the 'essort' function or use the sort from already existing functions.",
      "start_char": 18616,
      "end_char": 18705,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, the following is an example of a selection sort routine for an integer array.",
      "start_char": 18708,
      "end_char": 18800,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Since even if n is 1e5, it would be too slow, but for Codeforces problem, maybe the test cases are small.",
      "start_char": 18801,
      "end_char": 18906,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "Alternatively, assuming that the test case is manageable and for a codeforces-like Problem, the solution would be under time constraints.",
      "start_char": 18909,
      "end_char": 19046,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, in the code, perhaps the best way to handle the sorting is to use a bubble sort or a selection sort.",
      "start_char": 19048,
      "end_char": 19163,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Let me note that the problem is codeforces 653A, perhaps the n is small.",
      "start_char": 19165,
      "end_char": 19237,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Let me try to code a quick selection sort for the input array. So code to perform selection sort on the input array:\n\nsubroutine selection_sort(a)",
      "start_char": 19240,
      "end_char": 19386,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "integer, intent(inout) :: a(:)\n\ninteger :: i, j,imin, temp\n\ninteger :: n = size(a)\n\ndo i=1, n-1\n\n   imin =i\n\n   do j=i+1, n\n\n       if (a(j) < a(imin)) then\n\n           imin =j\n\n       end if\n\n   end do\n\n   temp = a(i)\n\n   a(i) = a(imin)\n\n   a(imin) = temp\n\nend do\n\nend subroutine\n\nWe can include this subroutine in the code.",
      "start_char": 19389,
      "end_char": 19714,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Alternatively, since this is in the main program, perhaps we can write it in the same file.",
      "start_char": 19715,
      "end_char": 19806,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, better to code the sorting in the main routine, but perhaps wrapping into a subroutine is cleaner.",
      "start_char": 19808,
      "end_char": 19921,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, since I need to implement the selection sort here, perhaps better to code that.",
      "start_char": 19923,
      "end_char": 20017,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Thus, adding a sort subroutine.",
      "start_char": 20019,
      "end_char": 20050,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, in the main code after reading the array, perform selection sort.",
      "start_char": 20052,
      "end_char": 20132,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, better to add a sort subroutine.",
      "start_char": 20134,
      "end_char": 20181,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Thus, putting this together, here the steps:\n\nThe code outline would be:\n\nprogram codeforces_653A\n\nimplicit none\n\ninteger, allocatable :: input(:), unique(:)\n\ninteger :: n, count, i\n\nlogical :: found\n\ncall read_input\n\ncall sort_input\n\ncall create_unique\n\ncall find_sequence\n\ncall output_result\n\nend program\n\nBut here's how the code can be structured with subroutines.",
      "start_char": 20183,
      "end_char": 20550,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, better to write inline to avoid getting lost. Now moving back to the code steps.",
      "start_char": 20552,
      "end_char": 20647,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Putting all together, here's a possible Fortran code: First the code with all steps, including the sort. program codeforces_653A\n\n    implicit none\n\n    integer :: n, i, count\n\n    integer, allocatable :: input(:), unique(:)\n\n    logical :: found = .false.\n\n    !",
      "start_char": 20650,
      "end_char": 20915,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Read n and input array\n\n    read(*,*) n\n\n    allocate(input(n)) do i =1,n\n\n        read(*,*) input(i)\n\n    end do\n\n    !",
      "start_char": 20916,
      "end_char": 21041,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Sort the input array:\n\n    call selection_sort(input)  ! need to define this\n\n    ! Now create unique array.\n\n    allocate(unique(n))\n\n    unique(1) = input(1)\n\n    count = 1 do i = 2, n\n\n        if (input(i) /= unique(count)) then\n\n            count = count +1\n\n            unique(count) = input(i)\n\n        end if\n\n    end do \n\n    ! Resize the unique array:\n\n    allocate(unique, source=unique(1:count))  ! Fortran 2003 feature? Maybe not safe.\n\n    !",
      "start_char": 21042,
      "end_char": 21501,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Alternatively, use another allocation:\n\n    !",
      "start_char": 21502,
      "end_char": 21547,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "So, first deallocate existing unique. deallocate(unique)\n\n    allocate(unique(count))\n\n    do i=1, count\n\n        unique(i) = input_original?\n\n    wait no, the previous array was allocated(n) with the count elements stored in unique(1) to unique(count).",
      "start_char": 21548,
      "end_char": 21806,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Hmm, so perhaps we need to first store the previous array, reallocate, and then copy. So perhaps:\n\n!",
      "start_char": 21812,
      "end_char": 21912,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "after building count:\n\ninteger, allocatable :: tmp(:)\n\nallocate(tmp(count)) tmp = unique(1:count)\n\ndeallocate(unique)\n\nallocate(unique(count))\n\nunique = tmp\n\ndeallocate(tmp)\n\n!",
      "start_char": 21914,
      "end_char": 22091,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "After this, unique now has size count and contains the unique elements.\n\n    !",
      "start_char": 22092,
      "end_char": 22170,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Now, check for the three consecutive numbers. if (count >=3) then\n\n        do i =1, count -2\n\n            if ( unique(i+1) == unique(i)+1 .and. unique(i+2) == unique(i+1)+1 ) then\n\n                found =.true.\n\n                exit\n\n            end if\n\n        end do\n\n    end if\n\n    !",
      "start_char": 22171,
      "end_char": 22463,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Output the result\n\n    if (found) then\n\n        print*,\"YES\"\n\n    else\n\n        print*,\"NO\"\n\n    end if\n\ncontains\n\n    ! Include the selection sort subroutine\n\n    subroutine selection_sort(a)\n\n        integer, intent(inout) :: a(:)\n\n        integer :: n, i, j, imin, temp\n\n        n = size(a)\n\n        do i=1, n-1\n\n            imin =i\n\n            do j=i+1, n\n\n                if (a(j) < a(imin)) then\n\n                    imin =j\n\n                end if\n\n            end do\n\n            temp = a(i)\n\n            a(i) = a(imin)\n\n            a(imin) = temp\n\n        end do\n\n    end subroutine\n\nend program codeforces_653A\n\nWait, but in the unique allocation part, in the code above:",
      "start_char": 22464,
      "end_char": 23146,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Wait, after the initial allocation of unique(n) and building up to count: But since Fortran doesn't have slice assignment for array size unless using new features, the way to do it is to first allocate a temp array of size count, copy the values, then deallocate and reallocate unique as temp, then deallocate temp. So that's the approach.",
      "start_char": 23148,
      "end_char": 23487,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Wait, the above code had:\n\n allocate(tmp(count)) tmp = unique(1:count)\n\nBut unique was allocated as size n, so unique(1:count) is a section of that array. So yes, that code should work. Then after that, the array unique is properly allocated with the correct size.",
      "start_char": 23490,
      "end_char": 23755,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Wait, but when they deallocate unique (which is n size) and then allocate to count.",
      "start_char": 23759,
      "end_char": 23842,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "So, the above steps in the code I wrote are:",
      "start_char": 23843,
      "end_char": 23887,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "After building count, and the unique array is allocated size n and contains data in first count elements.",
      "start_char": 23889,
      "end_char": 23994,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "We then:\n\n- allocate tmp(count) from unique's first count elements.\n\n- deallocate original unique (size n).",
      "start_char": 23996,
      "end_char": 24103,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "- allocate unique to count size, set from tmp array. - then deallocate tmp. This seems okay. Alternatively, the steps:\n\nAfter:\n\nallocate(tmp(count))\n\ntmp(1:count) = unique(1:count)\n\nBut perhaps better to write:\n\ndo i=1, count\n\n   tmp(i) = unique(i)\n\nend do But that's also okay.",
      "start_char": 24105,
      "end_char": 24386,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The code with the initial approach might be concise. Thus, proceeding. Now, this code should work.",
      "start_char": 24388,
      "end_char": 24486,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Let me test with sample input.",
      "start_char": 24490,
      "end_char": 24520,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Sample Input 1:\n\n5\n\n1 2 3 4 5\n\nAfter sorting, the input is already sorted.",
      "start_char": 24522,
      "end_char": 24596,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Create unique array: same as input (since all unique). count is 5.",
      "start_char": 24598,
      "end_char": 24664,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Then, look for 1,2,3 consecutive, so YES. Sample output: YES.",
      "start_char": 24666,
      "end_char": 24727,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Another sample:\n\n3\n\n5 6 8 \u2192 input sorted is [5,6,8]. unique array size 3. Check 5+1=6, 6+1=7 not equal to 8. So no triplet. Output NO.",
      "start_char": 24730,
      "end_char": 24865,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Another test case: 3 numbers as 3,4,5 \u2192 output YES.",
      "start_char": 24867,
      "end_char": 24918,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "Another edge case: if count <3 \u2192 output NO. Another case: duplicates.",
      "start_char": 24920,
      "end_char": 24989,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "Say input:4 6,5,5,6 \u2192 after sorting [5,5,6,6]. Then unique array is [5,6]. count is 2 \u2192 so output NO.",
      "start_char": 24993,
      "end_char": 25094,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Another input with duplicates but with three unique numbers in a row.",
      "start_char": 25096,
      "end_char": 25165,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "E.g. input 5 1,2,2,3,4 \u2192 sorted input is [1,2,2,3,4], unique is [1,2,3,4].",
      "start_char": 25166,
      "end_char": 25240,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Check for consecutive: 1-2-3 \u2192 yes, so output YES. Thus, this should work.",
      "start_char": 25241,
      "end_char": 25315,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Possible error points: the selection sort.",
      "start_char": 25318,
      "end_char": 25360,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "Wait, in the sort, the selection_sort is done on 'input' array.",
      "start_char": 25362,
      "end_char": 25425,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Yes, so the input array is sorted in place, so after that, the sorted array is indeed in order.",
      "start_char": 25427,
      "end_char": 25522,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The selection_sort function is correct.",
      "start_char": 25523,
      "end_char": 25562,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "Thus, the code should correctly work.",
      "start_char": 25564,
      "end_char": 25601,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "Another point: in checking the indices.",
      "start_char": 25603,
      "end_char": 25642,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "For the loop over i from 1 to count -2. So if count is 3, it loops once. That's correct.",
      "start_char": 25644,
      "end_char": 25732,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Another edge case: the three-consecutive elements may be in positions 2,3,4. The code would detect that when i=2. So code should be okay.",
      "start_char": 25734,
      "end_char": 25871,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Now, when the code is compiled, the sorting subroutine is contained within contains block. Yes. Thus, that should work.",
      "start_char": 25874,
      "end_char": 25993,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Wait, in the code where after computing the count, we have the tmp array as the new array of size count.",
      "start_char": 25997,
      "end_char": 26101,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Then, after copying to unique via allocate, yes.",
      "start_char": 26102,
      "end_char": 26150,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "Alternatively, perhaps there is a more compact way to resize. But in Fortran 90, you can directly allocate:\n\n unique = [ (unique(i), i = 1, count) ] But for allocatables with deferred size, you can write:\n\ndeallocate( unique )\n\n allocate( unique, source = unique(1:count) )",
      "start_char": 26152,
      "end_char": 26426,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Wait, is the following allowed? allocate( unique(count) ) unique = unique(1:count) But the old unique is allocated to n. So after deallocation, and then allocating new size.",
      "start_char": 26428,
      "end_char": 26604,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Wait:\n\n Step 1:\n\nAfter:\n\nOriginal unique is allocated to n, then we allocate tmp as count.",
      "start_char": 26607,
      "end_char": 26697,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "unique was already allocated with n, so when we do:\n\ndeallocation of unique (the original unique array) frees the memory, then alloc  to new. Alternatively, in the code:\n\nallocate(tmp(count))\n\ntmp = unique(1:count)\n\ndeallocate( unique )\n\n allocate( unique, source = tmp )\n\ndeallocate( tmp )\n\nAlternatively.",
      "start_char": 26700,
      "end_char": 27007,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Thus, in the code above, the code should work. Now I think this code should be correct.",
      "start_char": 27009,
      "end_char": 27096,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "Thus, the final Fortran code is as above.",
      "start_char": 27099,
      "end_char": 27140,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    }
  ],
  "original_reasoning": "Okay, so I need to translate this Java code into Fortran. Let me look at the Java code first and understand what it does. The program reads a list of integers, removes duplicates, sorts them, and checks if there are three consecutive numbers in the sorted list. If there are, it outputs \"YES\", else \"NO\".\n\nHmm, in Fortran, I need to handle input, process the list, and output the result. Let's think step by step.\n\nFirst, the Java code uses a Scanner to read from System.in. In Fortran, I can read from the standard input using read(*,*) statements. \n\nNext, the input is an integer n, followed by n integers. So I'll need to read n first, then allocate an array of size n. Wait, but in Fortran arrays are statically sized, so I can either read into a dynamic array (using an allocatable array) or a fixed size large enough. Since n is given as input, allocatable is better.\n\nNow, after reading the numbers, the next step is to remove duplicates. Java uses a stream's distinct() method here. In Fortran, how do I do that? Well, perhaps I can create a logical array to track which numbers are duplicates, then collect the unique ones.\n\nAlternatively, since after sorting duplicates are adjacent, maybe it's easier to sort first and then remove duplicates. Let me think: maybe sort the array first, then loop through and copy only elements that are different from the previous one. \n\nWait, the code first sorts the list, but before that it uses distinct(). So in Fortran, maybe better to first sort, then remove duplicates.\n\nWait no, actually the Java code does a stream().distinct().sorted(). So they first remove duplicates and then sort them. So the correct order is important here. So first deduplicate, then sort? Or does the order matter? Let me check the Java code order again: \n\nYes, the chain is .distinct().sorted() so the list is first processed to have unique elements, then sorted. Wait no, the order matters because .distinct() comes before .sorted() in the chain. That is, the elements are deduplicated first in their original order (but since they don't preserve order for distinct streams?), but actually, the result after distinct is a stream, and then sorted. \n\nHmm, perhaps in Java, the distinct() ensures unique elements, but sorted() applies the sorting after. So overall, the list is the unique elements sorted in order. \n\nSo the equivalent in Fortran would be to process the array, first make all elements unique, then sort them. \n\nNow how?\n\nLet me lay out the steps in Fortran:\n\n1. Read n and the array a of size n.\n\n2. Remove duplicates from a. So create a new array containing unique elements. \n\n3. Sort the new array in ascending order (since Java's sorted() is in natural order, which is ascending).\n\n4. Loop through the sorted array to check for three consecutive numbers.\n\n5. Output YES or NO based on whether such triplet exists.\n\nHmm, step 2 and 3 are crucial here. Let's think of step 2 first. \n\nPossible approach for deduplication: create an array with unique elements. Since Fortran has to arrays: the input array and the unique array. \n\nOne common way is to loop through each element and check if it's already in the unique list. \n\nAlternatively, if you first sort the array, then you can check adjacent elements for duplicates. \n\nWait: let's say we first sort the array, then loop through, adding elements to a temporary array only if they are not equal to the previous. Then that would give the unique elements in sorted order, which is exactly what was done in Java (since they first made distinct and then sorted, but if after making distinct, the sorted sorts them again). Wait no, if you first get distinct, sorted applies a sort, so the overall order is sorted and distinct. Hmm, in the Java code, the list after distinct().sorted() is first getting all unique elements, then sorted. So the end result is the distinct elements sorted. So the process in Fortran can be done by first sorting the array, then removing adjacent duplicates? \n\nWait, if I first sort and then remove duplicates (since duplicates would be adjacent after sorting), then the order is sorted and then deduplicated. But in Java, the order is first deduplicated then sorted, but perhaps the final result is the same as dedup then sort. Because sorted is after the distinct, so the final list is sorted. So the key is the unique elements, sorted. So the two approaches (sort then dedup vs dedup then sort) might lead to the same end result, but we need to be sure which is correct.\n\nWait, for example, if the original array has numbers in any order, deduplicating first would leave elements in their first occurrence order, but then sorting. Whereas sorting first then dedup'ing would give unique elements in sorted order. Wait, in Java, list.distinct() doesn't remove elements in a sorted way; it just returns a stream with unique elements in the order of their first occurrence. Then sorted() sorts that. But in any case, the final list is sorted, with duplicates removed. \n\nAlternatively, since in the problem, we need three consecutive elements regardless of their original order; so maybe dedup then sort, the three elements after dedup must be in sorted order. So the correct way in fortran is to first deduplicate (preserving the order?), then sort? Hmm, but since in the problem, after dedup and then sorting, the elements are arranged in order, so the sorted list contains unique elements in order, and we just check if three in a row have value difference of 1. \n\nBut the order in which duplicates are removed doesn't matter as long as after processing, we have a sorted list of unique elements. \n\nSo perhaps in Fortran, it's easier to first create the unique list and then sort it. Let me think of steps again:\n\n1. Read the list and store in an array, say 'input_array'.\n\n2. Create another array 'unique' which contains only unique elements from input_array. \n\n3. Sort unique array.\n\nThen check for 3 in a row.\n\nAlternatively, first sort the input array, find duplicates, then process.\n\nThe approach could be:\n\nSort the input array, then create a unique array by stepping through and ignoring duplicates.\n\nThat would be more efficient perhaps.\n\nFor step 2 (after step 1):\n\nSort the input array. Then loop through and collect only when the current element is different from the last unique element.\n\nWait, but that's possible, but the input array's elements may not be all stored properly first. Let me think of code steps.\n\nLet me think about the variables. Let's say in Fortran:\n\ninteger, allocatable :: input(:), unique(:)\n\nRead n:\n\nRead(*,*) n\n\nallocate(input(n))\n\ndo i = 1, n\n\n   read(*,*) input(i)\n\nenddo\n\nThen, duplicate removal and sorting:\n\nBut to deduplicate, perhaps:\n\nFirst sort the array, then extract the uniques. \n\nSort the array using a sort routine (Fortran has a sort function, but we need to sort integers. So call:\n\ncall sort(input)\n\nThen create the unique array. \n\nAllocate a temporary array with same size (since duplicates could be all, but worst case none).\n\ncount = 1\n\nunique(count) = input(1)\n\ndo i =2, n\n\n   if (input(i) /= input(i-1)) then \n\n       count = count +1\n\n       unique(count) = input(i)\n\nenddo\n\nBut that requires that unique array be preallocated with enough size. Since initially, n could be up to say 1e5, but in the code, perhaps the problem constraints are such that n is small, but in Fortran, managing allocations properly is needed. \n\nAlternatively, to first create an array of size n, then after dedup'ing count the number of elements and then compact.\n\nSo:\n\nallocate(unique(n))\n\nunique(1) = input(1)\n\ncount =1\n\ndo i =2, n\n\n   if(input(i) /= unique(count)) then\n\n       count = count +1\n\n       unique(count) = input(i)\n\n   endif\n\nenddo\n\nThen, allocate a smaller array.\n\nunique = unique(1:count)\n\nSo that's the unique array, sorted if the input was sorted.\n\nBut in the problem's case, the dedup requires sorting first, then the unique array would be sorted. That matches the Java's 'distinct().sorted()' ?\n\nWait, in Java: distinct() gives unique elements, but not sorted. Then sorted() comes afterwards. So Java does sort the unique elements. \n\nBut in the Fortran approach above, if we first sort the original input array, then do dedup (which gives unique elements in sorted order). Then we have that the same as Java. \n\nSo the overall process would be the same here.\n\nThus, in the code, the first approach would work.\n\nSo the steps in Fortran are:\n\nRead n and the array.\n\nSort the input array.\n\nThen remove duplicates by going through and selecting unique elements.\n\nThen, the unique elements are in sorted order, so now you can check for three consecutive increasing by 1.\n\nNow, the code steps would be:\n\n1. Read n and the array.\n\n2. Sort the array.\n\n3. Create unique array by iterating through, storing only non-duplicates.\n\n4. Then check the unique array for three in a row.\n\nNow, how to do this in code.\n\nLet me proceed step by step.\n\nFirst, declare variables.\n\nImplicit none is good practice.\n\nprogram codeforces_653\n\nimplicit none\n\ninteger :: n, i, count, m\n\ninteger, dimension(:), allocatable :: input, unique\n\nRead n.\n\nread(*,*)n\n\nallocate(input(n))\n\nRead input array.\n\ndo i=1, n\n\n   read*, input(i)\n\nenddo\n\nSort the input array:\n\ncall sort(input)\n\nNow create unique array.\n\nallocate(unique(n))\n\ncount = 1\n\nunique(1) = input(1)\n\ndo i=2, n\n\n   if (input(i)/= unique(count)) then\n\n       count = count+1\n\n       unique(count) = input(i)\n\n   end if\n\nend do\n\nNow we need to adjust the unique array so that it only has size count.\n\nallocate a new array or just deallocate and reallocate.\n\nBut since we need to check the unique array (truncated), perhaps it's better to create a new array.\n\nallocate(tmp(count))\n\ntmp(1:count) = unique(1:count)\n\ndeallocate(unique)\n\nallocate(unique(count))\n\nunique = tmp\n\ndeallocate(tmp)\n\nAlternatively, in Fortran 2003, can use move_alloc, but perhaps better to use pointers? Wait, perhaps in code like this:\n\nBut to make it simpler, perhaps the initial allocation of unique(n) can be followed by re-allocating unique to count, thus:\n\nBut to avoid confusion, let's write it:\n\nallocate(unique(count))\n\nunique(1:count) = [unique elements]\n\nWait, perhaps better way:\n\nAfter the loop where count is found:\n\nallocate(unique(count))\n\nunique(1) = input(1)\n\ndo i=2, n\n\n   if (input(i)/=input(i-1)) then\n\n      unique(count) = input(i)\n\n       count=count+1   \u2014 Wait, no,  in code above the count is being tracked, so perhaps:\n\nWait let me retrace the earlier loop:\n\nInitially, in that code:\n\nunique is allocated as size n (very important point here, because if I just have an array like unique, but I can't write beyond count's value...)\n\nWait the original approach's code may have a problem here. Let me see:\n\nSuppose input is sorted. The first element is stored as unique(1). Then, for each i from 2 to n:\n\nif input(i) is different from previous one (unique(count)), then add. So:\n\nthe code:\n\nallocate(unique(n))\n\nunique(1) = input(1)\n\ncount =1\n\nthen loop over i from 2 to n.\n\nBut that way, unique array may have gaps. Wait, the code inside is:\n\nif (input(i) /= unique(count)), then unique(count+1) = input(i), and increment count.\n\nSo:\n\nYes, the code:\n\n allocate(unique(n)) \n\nthen in the loop:\n\nWhen the if is true:\n\nunique(count+1)=input(i)\n\ncount = count +1.\n\nThis is okay as long as input is up to n elements. After processing, the count is the actual unique count.\n\nthen, after the loop, you have that unique(1) to unique(count) are the unique elements in order.\n\nThus, now to trim the array to size count, you can reallocate:\n\ncall move_alloc( from=unique(1:count), to=tmp)\n\nno, perhaps better, reallocate:\n\nThe code can be adjusted:\n\nAllocate unique(n) first (because initially we need the space to store the data), then after processing, reallocate unique to count:\n\nallocate( temp(count) )\n\n temp = unique(1:count)\n\n deallocate( unique )\n\n allocate( unique, source = temp )\n\n deallocate( temp )\n\nThis may be a bit messy, but perhaps in Fortran 90 and above, you can use the reservation of allocatable arrays which allows us to resize.\n\nWait, another approach: the initial allocation for unique can be of size n, but after determining the count, we can simply allocate unique as the correct size, but only copy the first count elements.\n\nAlternatively, it may be more straightforward to use a new array for the unique elements.\n\nAlternatively, in Fortran, you can have arrays of adjustable size (with explicit-shape, but not sure). Hmm, maybe using a dynamic approach with an allocatable array that first is allocated with the original array size and then trimmed down to count.\n\nAlternatively, you can use a list which is built by appending, but that requires dynamic allocation steps.\n\nAlternatively, perhaps it's more efficient to use the approach of first reading the array, sorting it, and then building the unique array without using an initial array of allocated n.\n\nAlternatively, let's proceed step by step. Let me outline code with comments.\n\nSo the code so far:\n\nprogram codeforces_653A\n\n    implicit none\n\n    integer :: n, i, count\n\n    integer, allocatable :: input(:), unique(:)\n\n    read(*,*) n\n\n    allocate(input(n))\n\n    do i=1,n\n\n        read(*,*) input(i)\n\n    end do\n\n    ! Sort the input array:\n\n    call sort(input)  ! Need to make sure that this is done correctly.\n\n    ! Now create unique array.\n\n    allocate(unique(n)) \n\n    unique(1) = input(1)\n\n    count=1\n\n    do i=2, n\n\n        if (input(i)/= unique(count)) then\n\n            count=count +1\n\n            unique(count)=input(i)\n\n        end if\n\n    end do \n\n    ! Now we have count elements in unique array, but memory is up to n. \n\n    ! So reallocate to actual count:\n\n    ! We need to make sure the array size is count:\n\n    ! Either using temporary array or better using reallocate.\n\n    if (allocated(unique)) deallocate(unique)\n\n    allocate(unique(count))\n\n    ! now copy first count elements from the temporary array? Wait, no, no.\n\nWait, wait a second. My allocation for unique was to n, but the first n elements were not allocated yet. Wait no: unique is allocated size n, but we only filled up to count. So after this step, the first count elements of unique (allocated with size n) are stored.\n\nTo resize:\n\nAnother approach:\n\nThe new unique array needs to be of size count. So, create a new array of that size and copy, then replace.\n\nAlternatively:\n\nallocate ( unique(count) )\n\nthen loop again?\n\nWait, perhaps yes. Because the data is stored in the first count elements of the first unique array (which was allocated as n first). So in this case:\n\ntemp array approach:\n\nallocate( unique_new(count) )\n\ndo i=1, count\n\n    unique_new(i) = unique_old(i)\n\nend do\n\n deallocate unique_old, set unique_new to unique, but this requires code steps.\n\nAlternatively, in Fortran 2003, one can use the move_alloc function:\n\nSo here's a possible way:\n\nAfter the count is determined (with the first unique array of size n):\n\nallocate(unique_new(count) )\n\nunique_new = unique(1:count) \n\nSince the first array was allocated as size n, then unique(1:count) is valid. Then deallocate the old unique array and transfer to new.\n\nWait, perhaps:\n\nWe can first have:\n\nThe initial code (so far, up to count=count+1 part):\n\n    allocate(unique(n)) \n\n    unique(1) = input(1)\n\n    count =1\n\n    do i=2, n\n\n       ... as before\n\n    end do\n\nAt this point, the first count elements of unique (allocated n) are filled with unique elements in order. Then we can proceed to:\n\n   allocate(unique_trim (count))\n\n   unique_trim = unique(1:count)\n\n   deallocate(unique)\n\n   unique => unique_trim\n\nBut in Fortran, pointers and pointer assignments are an option, but perhaps better to use:\n\nOriginal code:\n\nAfter computing count:\n\nSince we don't need the rest of the unique array beyond the count, perhaps just proceed with unique(1:count) and treat it as if it's size count. However, to avoid reallocations, we can perhaps proceed without trimming the array and just use count as the length. However, in the code after, when checking for the triplet, we can loop only up to count. So perhaps it is sufficient.\n\nSo the next steps after the count is known.\n\nCheck for the presence of three consecutive numbers.\n\nIn Fortran, the unique elements are in sorted order, so check for i from 1 to count-2:\n\nif unique(i)+1 == unique(i+1) and unique(i+1)+1 == unique(i+2).\n\nSo:\n\nInitialize a logical flag found = .false.\n\nthen loop:\n\ndo i=1, count-2\n\n   if ( unique(i+1) == unique(i)+1 .and. unique(i+2) == unique(i+1)+1 ) then \n\n       found = .true.\n\n       exit\n\n   end if\n\nend do \n\nThen output 'YES' or 'NO'.\n\nAlternatively, the loop can continue until there's a hit.\n\nSo perhaps in code:\n\nlogical :: found = .false.\n\ndo i=1, count-2\n\n   if( (unique(i+1) == unique(i)+1 ) .and. (unique(i+2) == unique(i+1)+1 ) ) then\n\n        found = .true.\n\n        exit\n\n   end if\n\nend do \n\nThen, after the loop, check found. \n\nNow putting all together:\n\nNow, putting this into code. \n\nWait, but before I forget: in the step where you sort input array. \n\nThe 'call sort(input)' \u2014 Fortran provides a built-in sort function? Sort of. In standard Fortran, the function requires using a subroutine. For example, one can use the intrinsic procedure MOLD (Fortran 2003?), but in many cases, people write their own sorting subroutines.\n\nAlternatively, the sort_inplace function is available via some libraries. Hmm, perhaps it is better to implement a sort here, because in Java, integers are sorted in natural order (ascending). Since we need to sort the array in ascending order.\n\nThus, perhaps safest to write a simple bubble sort or a quicksort. But for the purpose of code submission, bubble sort would be okay for small N, but given that the problem's constraints (if any) may not be given. Hmm, but in the problem (since it's from Codeforces problem 653A), perhaps n is up to 5000? Not sure, but for code submission in Fortran, using a built-in sort function would be better if possible.\n\nAlternatively, perhaps using the merge sort or other code.\n\nAlternatively, in Fortran, there is a built-in sort routine via the ISO_FORTRAN_ENV module? Not sure. Wait, actually, Fortran 90 and later have array functions. To sort an array, you can use the sort function with a work array. \n\nWait, the correct approach for sorting in Fortran without relying on non-standard library is to use the \"sort\" routine from the instrinsics, but I think the standard way is to use the following method:\n\nKIND=1.0 hypothetical? Wait, no. Wait, here's how to do it:\n\nThe syntax would be:\n\ncall merge_sort(input)\n\nBut that's not a standard. Alternatively, perhaps the following code would suffice.\n\nAlternatively, use the 'essort' function or use the sort from already existing functions. \n\nAlternatively, the following is an example of a selection sort routine for an integer array. Since even if n is 1e5, it would be too slow, but for Codeforces problem, maybe the test cases are small. \n\nAlternatively, assuming that the test case is manageable and for a codeforces-like Problem, the solution would be under time constraints.\n\nAlternatively, in the code, perhaps the best way to handle the sorting is to use a bubble sort or a selection sort.\n\nLet me note that the problem is codeforces 653A, perhaps the n is small. \n\nLet me try to code a quick selection sort for the input array.\n\nSo code to perform selection sort on the input array:\n\nsubroutine selection_sort(a)\n\ninteger, intent(inout) :: a(:)\n\ninteger :: i, j,imin, temp\n\ninteger :: n = size(a)\n\ndo i=1, n-1\n\n   imin =i\n\n   do j=i+1, n\n\n       if (a(j) < a(imin)) then\n\n           imin =j\n\n       end if\n\n   end do\n\n   temp = a(i)\n\n   a(i) = a(imin)\n\n   a(imin) = temp\n\nend do\n\nend subroutine\n\nWe can include this subroutine in the code. Alternatively, since this is in the main program, perhaps we can write it in the same file.\n\nAlternatively, better to code the sorting in the main routine, but perhaps wrapping into a subroutine is cleaner.\n\nAlternatively, since I need to implement the selection sort here, perhaps better to code that.\n\nThus, adding a sort subroutine.\n\nAlternatively, in the main code after reading the array, perform selection sort.\n\nAlternatively, better to add a sort subroutine.\n\nThus, putting this together, here the steps:\n\nThe code outline would be:\n\nprogram codeforces_653A\n\nimplicit none\n\ninteger, allocatable :: input(:), unique(:)\n\ninteger :: n, count, i\n\nlogical :: found\n\ncall read_input\n\ncall sort_input\n\ncall create_unique\n\ncall find_sequence\n\ncall output_result\n\nend program\n\nBut here's how the code can be structured with subroutines.\n\nAlternatively, better to write inline to avoid getting lost.\n\nNow moving back to the code steps.\n\nPutting all together, here's a possible Fortran code:\n\nFirst the code with all steps, including the sort.\n\nprogram codeforces_653A\n\n    implicit none\n\n    integer :: n, i, count\n\n    integer, allocatable :: input(:), unique(:)\n\n    logical :: found = .false.\n\n    ! Read n and input array\n\n    read(*,*) n\n\n    allocate(input(n))\n\n    do i =1,n\n\n        read(*,*) input(i)\n\n    end do\n\n    ! Sort the input array:\n\n    call selection_sort(input)  ! need to define this\n\n    ! Now create unique array.\n\n    allocate(unique(n))\n\n    unique(1) = input(1)\n\n    count = 1\n\n    do i = 2, n\n\n        if (input(i) /= unique(count)) then\n\n            count = count +1\n\n            unique(count) = input(i)\n\n        end if\n\n    end do \n\n    ! Resize the unique array:\n\n    allocate(unique, source=unique(1:count))  ! Fortran 2003 feature? Maybe not safe.\n\n    ! Alternatively, use another allocation:\n\n    ! So, first deallocate existing unique.\n\n    deallocate(unique)\n\n    allocate(unique(count))\n\n    do i=1, count\n\n        unique(i) = input_original?\n\n    wait no, the previous array was allocated(n) with the count elements stored in unique(1) to unique(count).\n\n    Hmm, so perhaps we need to first store the previous array, reallocate, and then copy.\n\nSo perhaps:\n\n! after building count:\n\ninteger, allocatable :: tmp(:)\n\nallocate(tmp(count))\n\ntmp = unique(1:count)\n\ndeallocate(unique)\n\nallocate(unique(count))\n\nunique = tmp\n\ndeallocate(tmp)\n\n! After this, unique now has size count and contains the unique elements.\n\n    ! Now, check for the three consecutive numbers.\n\n    if (count >=3) then\n\n        do i =1, count -2\n\n            if ( unique(i+1) == unique(i)+1 .and. unique(i+2) == unique(i+1)+1 ) then\n\n                found =.true.\n\n                exit\n\n            end if\n\n        end do\n\n    end if\n\n    ! Output the result\n\n    if (found) then\n\n        print*,\"YES\"\n\n    else\n\n        print*,\"NO\"\n\n    end if\n\ncontains\n\n    ! Include the selection sort subroutine\n\n    subroutine selection_sort(a)\n\n        integer, intent(inout) :: a(:)\n\n        integer :: n, i, j, imin, temp\n\n        n = size(a)\n\n        do i=1, n-1\n\n            imin =i\n\n            do j=i+1, n\n\n                if (a(j) < a(imin)) then\n\n                    imin =j\n\n                end if\n\n            end do\n\n            temp = a(i)\n\n            a(i) = a(imin)\n\n            a(imin) = temp\n\n        end do\n\n    end subroutine\n\nend program codeforces_653A\n\nWait, but in the unique allocation part, in the code above:\n\nWait, after the initial allocation of unique(n) and building up to count:\n\nBut since Fortran doesn't have slice assignment for array size unless using new features, the way to do it is to first allocate a temp array of size count, copy the values, then deallocate and reallocate unique as temp, then deallocate temp. So that's the approach.\n\nWait, the above code had:\n\n allocate(tmp(count))\n\ntmp = unique(1:count)\n\nBut unique was allocated as size n, so unique(1:count) is a section of that array. So yes, that code should work. \n\nThen after that, the array unique is properly allocated with the correct size.\n\nWait, but when they deallocate unique (which is n size) and then allocate to count. So, the above steps in the code I wrote are:\n\nAfter building count, and the unique array is allocated size n and contains data in first count elements.\n\nWe then:\n\n- allocate tmp(count) from unique's first count elements.\n\n- deallocate original unique (size n).\n\n- allocate unique to count size, set from tmp array.\n\n- then deallocate tmp.\n\nThis seems okay.\n\nAlternatively, the steps:\n\nAfter:\n\nallocate(tmp(count))\n\ntmp(1:count) = unique(1:count)\n\nBut perhaps better to write:\n\ndo i=1, count\n\n   tmp(i) = unique(i)\n\nend do\n\nBut that's also okay. The code with the initial approach might be concise.\n\nThus, proceeding.\n\nNow, this code should work.\n\nLet me test with sample input.\n\nSample Input 1:\n\n5\n\n1 2 3 4 5\n\nAfter sorting, the input is already sorted.\n\nCreate unique array: same as input (since all unique). count is 5.\n\nThen, look for 1,2,3 consecutive, so YES.\n\nSample output: YES.\n\nAnother sample:\n\n3\n\n5 6 8 \u2192 input sorted is [5,6,8]. unique array size 3.\n\nCheck 5+1=6, 6+1=7 not equal to 8. So no triplet. Output NO.\n\nAnother test case: 3 numbers as 3,4,5 \u2192 output YES.\n\nAnother edge case: if count <3 \u2192 output NO. \n\nAnother case: duplicates.\n\nSay input:4 6,5,5,6 \u2192 after sorting [5,5,6,6]. Then unique array is [5,6]. count is 2 \u2192 so output NO.\n\nAnother input with duplicates but with three unique numbers in a row. E.g. input 5 1,2,2,3,4 \u2192 sorted input is [1,2,2,3,4], unique is [1,2,3,4]. Check for consecutive: 1-2-3 \u2192 yes, so output YES.\n\nThus, this should work.\n\nPossible error points: the selection sort.\n\nWait, in the sort, the selection_sort is done on 'input' array.\n\nYes, so the input array is sorted in place, so after that, the sorted array is indeed in order. The selection_sort function is correct.\n\nThus, the code should correctly work.\n\nAnother point: in checking the indices.\n\nFor the loop over i from 1 to count -2. So if count is 3, it loops once. That's correct.\n\nAnother edge case: the three-consecutive elements may be in positions 2,3,4. The code would detect that when i=2.\n\nSo code should be okay.\n\nNow, when the code is compiled, the sorting subroutine is contained within contains block.\n\nYes.\n\nThus, that should work.\n\nWait, in the code where after computing the count, we have the tmp array as the new array of size count. Then, after copying to unique via allocate, yes.\n\nAlternatively, perhaps there is a more compact way to resize. But in Fortran 90, you can directly allocate:\n\n unique = [ (unique(i), i = 1, count) ]\n\nBut for allocatables with deferred size, you can write:\n\ndeallocate( unique )\n\n allocate( unique, source = unique(1:count) )\n\nWait, is the following allowed?\n\nallocate( unique(count) )\n\n unique = unique(1:count)\n\nBut the old unique is allocated to n. So after deallocation, and then allocating new size.\n\nWait:\n\n Step 1:\n\nAfter:\n\nOriginal unique is allocated to n, then we allocate tmp as count. \n\nunique was already allocated with n, so when we do:\n\ndeallocation of unique (the original unique array) frees the memory, then alloc  to new.\n\nAlternatively, in the code:\n\nallocate(tmp(count))\n\ntmp = unique(1:count)\n\ndeallocate( unique )\n\n allocate( unique, source = tmp )\n\ndeallocate( tmp )\n\nAlternatively.\n\nThus, in the code above, the code should work.\n\nNow I think this code should be correct.\n\nThus, the final Fortran code is as above."
}