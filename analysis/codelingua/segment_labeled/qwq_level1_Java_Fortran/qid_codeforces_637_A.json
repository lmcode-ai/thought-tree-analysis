{
  "segments": [
    {
      "text": "Okay, I need to translate this Java code into Fortran.",
      "start_char": 0,
      "end_char": 54,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Let me look through the code step by step.",
      "start_char": 55,
      "end_char": 97,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "First, the Java code reads integers from the input, counts the frequency of each number, finds the maximum frequency, and then outputs the first number that reaches that maximum frequency as it's encountered in the array.",
      "start_char": 100,
      "end_char": 321,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Hmm, in Fortran, I'll need to handle input and output a bit differently. Let's see the structure.",
      "start_char": 324,
      "end_char": 421,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "The Java program uses a Scanner and PrintWriter.",
      "start_char": 424,
      "end_char": 472,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "In Fortran, I can read from standard input using read(*,*) and write to standard output with write(*,*) statements. The main steps are:\n\n1.",
      "start_char": 473,
      "end_char": 612,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Read n, then the array elements.",
      "start_char": 614,
      "end_char": 646,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "2. Count the frequency of each element, storing in a map (in Java, it's a HashMap).",
      "start_char": 647,
      "end_char": 730,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "3. Find the maximum frequency. 4. Then iterate through the array again, keeping a second count until an element reaches the max frequency, then print that element and exit.",
      "start_char": 731,
      "end_char": 903,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Now, translating each part step by step. First, handling the input.",
      "start_char": 905,
      "end_char": 972,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "The array in Java is declared as int ara [] = new int[n]; In Fortran, arrays are fixed at compile time unless we use allocatable arrays. So I can declare an array with size n. But Fortran requires knowing the size at allocation. So perhaps first I need to read n, then allocate the array. So something like:\n\nRead(*,*) n\nAllocate(arr(n))",
      "start_char": 974,
      "end_char": 1310,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Next, the first map: a way to track frequencies of each number.",
      "start_char": 1312,
      "end_char": 1375,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Since Java's HashMap uses key-value pairs, in Fortran, I might need an associative array. But Fortran doesn't have built-in hash maps. Oh right, this is a problem.",
      "start_char": 1376,
      "end_char": 1539,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Because Fortran's arrays are indexed by integers, but here the keys can be any integer values (the elements in the array), not just indices. Hmm, how to handle this?",
      "start_char": 1540,
      "end_char": 1705,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Hmm, maybe since the array elements are integers, perhaps track their counts using another array, but then need to map unique elements to indexes?",
      "start_char": 1709,
      "end_char": 1855,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, maybe collect the unique elements first, then track counts in an array.",
      "start_char": 1856,
      "end_char": 1942,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Wait, perhaps the elements are within a certain range. But the problem description doesn't say, so we have to assume they can be any integers, positive or negative?",
      "start_char": 1945,
      "end_char": 2109,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "In any case, using a list to store unique numbers and an array for counts.",
      "start_char": 2111,
      "end_char": 2185,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Let's think: first, read the array, then collect all unique elements, store them in a list, and have a count array parallel to that list of unique elements.",
      "start_char": 2186,
      "end_char": 2342,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, use a data structure like a hash map. But in Fortran, standard (Fortran 90/95) doesn't support hash maps. So need a workaround.",
      "start_char": 2344,
      "end_char": 2486,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "An alternative is to use a dynamic array to keep track of the unique elements and their counts.",
      "start_char": 2488,
      "end_char": 2583,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "For each element in the input array, check if it's already in the unique list.",
      "start_char": 2584,
      "end_char": 2662,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "If yes, increment the count at that position.",
      "start_char": 2663,
      "end_char": 2708,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "If not, add it to the list with a count of 1. That's probably manageable. Let's try that.",
      "start_char": 2709,
      "end_char": 2798,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "So:\n\nFirst, read the input array into an allocatable array arr of size n.\n\nThen initialize a list (array) for the unique numbers and a corresponding count array. They can be dynamic.",
      "start_char": 2801,
      "end_char": 2983,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Since arrays in Fortran can be allocated, re-sized.",
      "start_char": 2984,
      "end_char": 3035,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "In Fortran, we can use a list of unique elements (like an array u) and a count array (counts).",
      "start_char": 3037,
      "end_char": 3131,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Initially, u and counts have size 0. For each element in arr:\n\nLoop through the array elements:\n\nelement = arr(i) Check if element is in u.",
      "start_char": 3133,
      "end_char": 3272,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "If present, increment counts at its position.",
      "start_char": 3274,
      "end_char": 3319,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "If not, append to u and set count to 1.\n\nOnce done, we need to find the maximum count from the counts array. That's straightforward.",
      "start_char": 3320,
      "end_char": 3452,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Then, the second pass through the array arr.",
      "start_char": 3454,
      "end_char": 3498,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "We need to track, for each element, how many times it's been seen so far, and when any element's count reaches the max count, output it and exit.",
      "start_char": 3499,
      "end_char": 3644,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "For this second step, since we need to count per element incrementally, we can again track a \"current count\" for each element. Let me see.",
      "start_char": 3646,
      "end_char": 3784,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, perhaps the same approach as before: another array to track current counts.",
      "start_char": 3786,
      "end_char": 3876,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, perhaps track the counts as we go through the array again. Wait, let me think again.",
      "start_char": 3878,
      "end_char": 3977,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "The problem requires that after the first pass, we have the max frequency, then in the second pass through the array, we are to output the element that was the first to reach the max frequency.",
      "start_char": 3980,
      "end_char": 4173,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "The first occurrence of an element to have its count equal to the max is printed and the loop terminates.",
      "start_char": 4174,
      "end_char": 4279,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "So, during the first pass, we can have for each element in the array, the total number of occurrences (the frequency map), then in the second pass, keep a separate counter for each element. So when that counter reaches the max frequency, print it.",
      "start_char": 4281,
      "end_char": 4528,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "So, similar to Java's logic here. But in Fortran, implementing this requires a way to track both the total frequency (from first pass) and the current count (during the second pass). Hmm.",
      "start_char": 4530,
      "end_char": 4717,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Let me think in steps:\n\nFirst Part:\n\nRead n.\n\nRead the array elements into arr of size n.\n\nInitialize:\n\n- An array of unique elements (u) and their counts (counts). Start with empty.",
      "start_char": 4720,
      "end_char": 4902,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Proceed through each element in the array.",
      "start_char": 4904,
      "end_char": 4946,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "For each element a in arr:\n\nloop over u's elements to see if a is there.",
      "start_char": 4947,
      "end_char": 5019,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Wait, but if the array is large (like if n is up to 1e5?), this could be O(n^2), which is bad. So this might not be efficient for large N? But perhaps in the problem constraints n is manageable?",
      "start_char": 5021,
      "end_char": 5215,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The original problem's Java code can handle up to O(n) time using a hash map, but if the Fortran solution uses O(n^2) due to the check for uniqueness, it might not be efficient.",
      "start_char": 5217,
      "end_char": 5394,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Wait, but the problem might have constraints that make this manageable.",
      "start_char": 5395,
      "end_char": 5466,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Anyway, assuming that we have to proceed with this approach for now, since Fortran doesn't have built-in hash tables.",
      "start_char": 5467,
      "end_char": 5584,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Wait, perhaps using a hash table via a module, but I think that might not be straightforward for a beginner.",
      "start_char": 5586,
      "end_char": 5694,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, use an associating array via a derived type or something else.",
      "start_char": 5695,
      "end_char": 5772,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Maybe in Fortran 2003 or higher, but perhaps the user expects a standard approach.",
      "start_char": 5773,
      "end_char": 5855,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Alternatively, perhaps the elements can be in a limited range. But perhaps the elements are within reasonable limits.",
      "start_char": 5857,
      "end_char": 5974,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, use a sparse array.",
      "start_char": 5975,
      "end_char": 6009,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Alternatively, take all elements, and create an array of integers (the elements), and another array (count for each).",
      "start_char": 6011,
      "end_char": 6128,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Since in Fortran, arrays have fixed size, but we can make an array with a large size (like 1e6), but that might be overkill.",
      "start_char": 6129,
      "end_char": 6253,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Or we can find all unique elements first and store them, then track their counts.",
      "start_char": 6254,
      "end_char": 6335,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, since in Fortran's allocatable arrays can be resized, perhaps use a list of unique elements and corresponding counts, and every time we find a new element, append to the unique array.",
      "start_char": 6337,
      "end_char": 6535,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Let me try to proceed with that approach. Step by step:\n\n1. Read n.\n\n2. Read the array.",
      "start_char": 6537,
      "end_char": 6624,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "3. Initialize unique array and counts.",
      "start_char": 6627,
      "end_char": 6665,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "These will start as empty or with initial size zero, and we can reallocate as needed. Wait, but how in Fortran?",
      "start_char": 6666,
      "end_char": 6777,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "We can start with unique counts as allocatable arrays.",
      "start_char": 6780,
      "end_char": 6834,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Something like:\n\ninteger, allocatable :: u(:), counts(:)\n\nThen initialize:\n\nallocate(u(0)) !",
      "start_char": 6836,
      "end_char": 6928,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "zero size initially\nallocate(counts(0)) Then for each element in arr:\n\nelement = arr(i)\n\nsearch through u(1:) to see if element is in there.",
      "start_char": 6929,
      "end_char": 7070,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "If found, say at position pos: increment counts(pos) by 1.",
      "start_char": 7072,
      "end_char": 7130,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "If not found: check size of u and counts. Need to reallocate. Hmm.",
      "start_char": 7132,
      "end_char": 7198,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, make it a loop over elements, expanding u and counts as necessary.",
      "start_char": 7201,
      "end_char": 7282,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "This might be manageable but a bit tedious. Let's think.",
      "start_char": 7284,
      "end_char": 7340,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "Alternative idea:\n\nPerhaps track two arrays: a list (u) of keys (unique values) and their counts.",
      "start_char": 7342,
      "end_char": 7439,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Each time processing a new value from the input array:\n\n- Search u for the value.",
      "start_char": 7440,
      "end_char": 7521,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "If found, increment its count.",
      "start_char": 7522,
      "end_char": 7552,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "- If not found, append to u and set its count to 1.",
      "start_char": 7554,
      "end_char": 7605,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "However, searching through u each time would be O(n) per element, leading to O(n^2), which is bad. So this is a problem if the array is large. But perhaps in the original problem, the constraints are small enough?",
      "start_char": 7607,
      "end_char": 7820,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The original Java code uses a hashmap, O(n) time.",
      "start_char": 7822,
      "end_char": 7871,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Hmm, but since I have to code it in Fortran, I have to use some method acceptable here.",
      "start_char": 7873,
      "end_char": 7960,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Alternatively, maybe use some sorting approach.",
      "start_char": 7962,
      "end_char": 8009,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "If I first sort all the elements, I can count frequencies more easily. Let me think. Sort the array.",
      "start_char": 8012,
      "end_char": 8112,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Then, walk through the sorted array: each group of identical elements can be counted. This can also track the max. But this would require sorting first O(n log n). Then to find frequencies: but then in the second pass, we need to find the element first encountered to reach that frequency. But the second pass would need to track their counts as encountered in the original array's order, not the sorted order.",
      "start_char": 8117,
      "end_char": 8527,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Therefore, the first approach (even with O(n^2) time) may be the only way.",
      "start_char": 8533,
      "end_char": 8607,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Well, maybe the problem's constraints make n small enough, so that this is acceptable. Let's see.",
      "start_char": 8608,
      "end_char": 8705,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Alternatively, use a module that has a hash map.",
      "start_char": 8707,
      "end_char": 8755,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "For example, in Fortran, there are some third-party libraries that support associative arrays, but I don't think the problem expects that.",
      "start_char": 8756,
      "end_char": 8894,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Alternatively, use a derived type and a linked list structure. But that's probably overkill.",
      "start_char": 8896,
      "end_char": 8988,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Hmm, maybe in the problem's context, the elements are within a small range.",
      "start_char": 8990,
      "end_char": 9065,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "For example if the numbers are between 1 and a million, then an array can be used.",
      "start_char": 9066,
      "end_char": 9148,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "However, the user might have numbers that are large negative or positive integers.",
      "start_char": 9149,
      "end_char": 9231,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "Wait, if elements can be any integer, including negatives or very large? Then a direct array can't be used.",
      "start_char": 9234,
      "end_char": 9341,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "So, in absence of a hash map structure, perhaps the best approach is to use the O(n^2) method. We can proceed with that.",
      "start_char": 9344,
      "end_char": 9464,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, use a hash table approach in Fortran 90/95.",
      "start_char": 9466,
      "end_char": 9524,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "For example, using an array of elements with sufficient indexes. But without knowing the elements' keys, that's hard.",
      "start_char": 9525,
      "end_char": 9642,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, use a different tactic.",
      "start_char": 9644,
      "end_char": 9682,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Since in the second part, once you have the maximum frequency, you can iterate through the array elements, keep track of their counts so far, and as soon as any of them reaches the max count, output that element and break. So maybe the second part can be done with another hash map. Oh, but again, same problem.",
      "start_char": 9683,
      "end_char": 9994,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, for the second part, use an array to track the counts again. But since the first part's maximum can be known, perhaps during the first step, we can also have stored the list of elements that have max counts. Then in the array, the first occurrence that one of them reaches the max is our answer.",
      "start_char": 9997,
      "end_char": 10307,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Wait, the problem wants the first element in the array that reaches the max frequency when counting until that point. So for example, suppose an array has elements [1,2,3,2,2].",
      "start_char": 10309,
      "end_char": 10485,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "The max frequency is 3 for element 2.",
      "start_char": 10487,
      "end_char": 10524,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "The first time the count of 2 reaches 3 is when we reach the fifth element, so when we have three 2s, that's the moment.",
      "start_char": 10525,
      "end_char": 10645,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Alternatively, maybe the max frequency is 3, and the first element that has count equal to that is found when you hit three occurrences.",
      "start_char": 10647,
      "end_char": 10783,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Now, perhaps for the second pass: the counts can again be tracked using an array. So perhaps, even if it takes O(n^2) time for the frequency counts, perhaps it is manageable.",
      "start_char": 10786,
      "end_char": 10960,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, perhaps in Fortran 90/95, perhaps the best way is to do:\n\nRead in all elements. First pass: compute each element's total count (even with O(n^2)), and track the maximum. Second pass: for each element in the array, track its current count (incrementing each time it is encountered), once any element reaches the maximum count, output it and stop. But for the second pass, the counts needed are their cumulative up to that step. So for this, perhaps a separate array can track the count so far for each element. But how to do this without a hash map? Let's see. Wait for the second pass:",
      "start_char": 10962,
      "end_char": 11562,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Initialize another array counts_so_far.",
      "start_char": 11570,
      "end_char": 11609,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Wait, but the keys are potential elements which can be of any integer.",
      "start_char": 11610,
      "end_char": 11680,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Since we can't have a dynamic array here again, perhaps during the second pass, we can use a hash map approach again.",
      "start_char": 11681,
      "end_char": 11798,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, for the second pass, we can again iterate through each element, and track it's current count up to that index.",
      "start_char": 11801,
      "end_char": 11926,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Like: for each element in the array, as you iterate:\n\nIf the element is not in a list of tracked elements, add to it, and track the count.",
      "start_char": 11929,
      "end_char": 12067,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Wait, this is similar to the first step but tracking only until that point. But again, it would required O(n^2) time. Hmm.",
      "start_char": 12070,
      "end_char": 12192,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Perhaps proceed with this approach.",
      "start_char": 12195,
      "end_char": 12230,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Overall, the problem can be accepted with O(n^2) methods for small constraints.",
      "start_char": 12232,
      "end_char": 12311,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Let's try to proceed with that. So here's the plan.",
      "start_char": 12312,
      "end_char": 12363,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Implement in Fortran as follows:\n\nMain Algorithm:",
      "start_char": 12366,
      "end_char": 12415,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Read n.\n\nRead the array into arr(n). Then compute counts for each element in arr:",
      "start_char": 12417,
      "end_char": 12498,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Initialize an array to hold unique elements (u) and their counts.",
      "start_char": 12501,
      "end_char": 12566,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Start with empty u and counts arrays. Loop through each element in arr:\n\n   current_element = arr(i)",
      "start_char": 12568,
      "end_char": 12669,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Search through u to see if current_element exists. found = search(u, current_element, k) If found, counts(k) = counts(k)",
      "start_char": 12674,
      "end_char": 12804,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "+1\n\n   else:\n\n      append current_element to u, and set counts(k) to 1.",
      "start_char": 12805,
      "end_char": 12877,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "After processing all elements, find the maximum count. max_count = maxval(counts)",
      "start_char": 12879,
      "end_char": 12961,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Then, second pass: iterate through the array arr again, and track the counts_so_far for each element:\n\nfor each element in arr:\n\n   search in the list u for the element (since u contains all unique elements, maybe)\n\n   Get the position k in u where element is found. But in the same array u.\n\n   Then, if counts_so_far for that element reaches max_count, then output the element and stop. Wait.",
      "start_char": 12963,
      "end_char": 13357,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, maybe use a separate array to track current counts.",
      "start_char": 13359,
      "end_char": 13425,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, during the second pass, keep another array for counts_so_far.",
      "start_char": 13427,
      "end_char": 13503,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Since the elements can be up to the existing unique list, perhaps iterate through unique elements first, and then track their count as you step through the array. But maybe it's complicated.",
      "start_char": 13504,
      "end_char": 13694,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Perhaps better to track counts_so_far for each element as you go.",
      "start_char": 13698,
      "end_char": 13763,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, for each element in arr during second pass, check how many times it has been encountered so far.",
      "start_char": 13765,
      "end_char": 13876,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "We can have an array counts_so_far which is same size as u (the unique elements), initialized to zero. Then:\n\ninitialize counts_so_far = 0 array of size size(u) Then, loop over each element in arr:\n\n   current_e = arr(j)\n\n   find index k in u where u(k) = current_e \n\n   counts_so_far(k) = counts_so_far(k)+1 if (counts_so_far(k) == max_count) then\n\n       print *, current_e\n\n       stop\n\n   end if\n\nThis way, the second pass can be done this way. So this uses the unique elements' list.",
      "start_char": 13879,
      "end_char": 14373,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Since counts_so_far is only tracked per unique element, this is manageable. So steps:\n\nFirst pass:\n\nRead all elements, build u and counts arrays. Second pass: track counts_so_far and check.",
      "start_char": 14375,
      "end_char": 14564,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Thus, the Fortran code can proceed with this plan. Now code.",
      "start_char": 14568,
      "end_char": 14628,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Now, implementing this step by step.",
      "start_char": 14631,
      "end_char": 14667,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "First, in Fortran:\n\nProgram codeforces_637_A\n\nImplicit None\n\nInteger :: n, i\n\ninteger, allocatable :: arr(:)\n\ninteger, allocatable :: u(:), counts(:), counts_so_far(:)\n\ntype(pair) :: ... Wait, no idea.",
      "start_char": 14669,
      "end_char": 14870,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Alternatively proceed step by step.",
      "start_char": 14871,
      "end_char": 14906,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "First, step 1:\n\nRead n.\n\nThen read the n elements into array arr. Allocate arr(n)\n\nRead(*,*) n \n\nallocate( arr(n) )\n\ndo i=1, n\n\n read(*,*) arr(i)\n\nend do\n\nWait, but since the inputs are given in one line?",
      "start_char": 14908,
      "end_char": 15113,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "In the Java code, the elements are read via in.nextInt() which reads all tokens. So in Fortran, probably the user inputs all numbers, but how to read them.",
      "start_char": 15114,
      "end_char": 15269,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Assuming they are given as space-separated, the code \"read(*,*) n\" will read the first integer. Then arr can be read via read(*,*) arr. Thus, perhaps:\n\nRead(*,*) n\n\nallocate( arr(n) )\n\nread(*,*) (arr(i), i=1,n)\n\nThat's better. Then first pass.",
      "start_char": 15271,
      "end_char": 15515,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Initialize the unique list u and counts array:",
      "start_char": 15518,
      "end_char": 15564,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "First, let's start with u and counts being empty.",
      "start_char": 15566,
      "end_char": 15615,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "initialize:\n\nallocate(u(0), counts(0)) then for each element in arr,\n\ncurrent_val = arr(i)\n\nthen search through the u array for current_val. if found, increment counts(k)\n\nelse append current_val to u at position (size(u)+1) and set counts(k) =1.",
      "start_char": 15617,
      "end_char": 15865,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "To perform this, the searching step requires a loop through current length of u and checking equality.",
      "start_char": 15867,
      "end_char": 15969,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Wait, in Fortran, let's code that. So for each i from 1 to n:\n\ncurrent_val = arr(i)\n\nflag = .false. Do j=1, size(u) If (u(j) == current_val) then\n\n  counts(j) = counts(j) +1\n\n  flag = .true.\n\n  exit\n\n End if\n\nEnd do\n\nif (.not. flag) then\n\n   allocate new arrays: perhaps first, need to extend u array:\n\n   old_size = size(u,1)\n\n   new_size = old_size +1\n\n   temp_u = u\n\n   deallocate(u) \n\n   allocate(u(old_size+1)) u(1:old_size) = temp_u\n\n   u(old_size+1) = current_val\n\n   similarly for counts array:\n\n   temp_counts = counts \n\n   deallocate(counts) \n\n   allocate(counts(old_size+1))\n\n   counts(1:old_size) = temp_counts\n\n   counts(old_size+1) =1\n\n End if\n\nHmm, this reallocation is a bit messy but necessary unless one uses a different approach.",
      "start_char": 15971,
      "end_char": 16727,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Alternatively, pre-allocate the arrays to a maximum possible size. But the question is, what's n.\n\nWait the problem constraints?",
      "start_char": 16729,
      "end_char": 16857,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Well, in the original problem (codeforces 637A?), the constraints for n may be small enough that the above code doesn't hit performance issues, but the code must work within the problem's constraints.",
      "start_char": 16858,
      "end_char": 17058,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Alternatively maybe use a different approach with dynamic arrays, reallocating as they grow.",
      "start_char": 17060,
      "end_char": 17152,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Wait, in Fortran, when you deallocate and reallocate, it can be done but may be inefficient, but again we can proceed.",
      "start_char": 17154,
      "end_char": 17272,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Perhaps better to loop step by step. But even so, the code can be written this way.",
      "start_char": 17274,
      "end_char": 17357,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, use a different method, such as collect all elements, sort them, and then count frequencies by comparing adjacent elements. This might be more efficient.",
      "start_char": 17360,
      "end_char": 17528,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Let me think:\n\nThe first approach (hashmap-like) is O(n^2), which for N ~1e4 is about 1e8 operations, which would take a few seconds on a modern computer, but for some problems might be acceptable. But perhaps the maximum N here is small e.g. 1e4? Not sure, but let's proceed.",
      "start_char": 17531,
      "end_char": 17807,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternative method with sorting:",
      "start_char": 17809,
      "end_char": 17841,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "After reading the array, sort it.",
      "start_char": 17843,
      "end_char": 17876,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Then, go through the sorted array and count the frequency of each element in sequence.",
      "start_char": 17878,
      "end_char": 17964,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "This will count the frequencies in O(n log n) time for sorting, which is better. But then, need to also track the maximum frequency.",
      "start_char": 17966,
      "end_char": 18098,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Since after sorting, the data is ordered, so when you look for the max frequency, it's easy. Then for the second pass, need to track the counts as we go through the original array.",
      "start_char": 18100,
      "end_char": 18280,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Wait, but the original array's order is important for the second step.",
      "start_char": 18284,
      "end_char": 18354,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Because we have to check when the elements in their original order first reach the max count. This seems conflicting. Wait for the second step:\n\nWe need to loop through the original array and increment a current count, and see when the count equals max_count.",
      "start_char": 18355,
      "end_char": 18614,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "The original array is the correct order.",
      "start_char": 18619,
      "end_char": 18659,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "Thus, if we first sort the array for counting frequencies, but then lose track of the elements' original order for the second pass. Wait no, the second pass uses the original array, but how?",
      "start_char": 18662,
      "end_char": 18852,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "So, the sorting step can be done without affecting the original array.",
      "start_char": 18855,
      "end_char": 18925,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Yes: \n\nStep1: Read the original array into arr(orig).",
      "start_char": 18928,
      "end_char": 18981,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Step2: Make a copy and sort it. array_sort = arr.\n\ncall sort(array_sort)\n\nSTEP2 compute frequencies and max count via this sorted array. But even better:\n\nAfter sorting, loop through array_sort, to compute frequencies for unique elements. That can be done.",
      "start_char": 18983,
      "end_char": 19240,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Then, we can get the max count and the elements with max count.",
      "start_char": 19245,
      "end_char": 19308,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Once max_count is known, for the second step, process original array in order to see which element's cumulative count first reaches the max count.",
      "start_char": 19310,
      "end_char": 19456,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "The problem now is, how to track in the original array: for each element as you see them, track how many times it has been seen so far, and when it reaches max_count.",
      "start_char": 19458,
      "end_char": 19624,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "This doesn't need a hashmap, since per element, but again, unless they are unique.",
      "start_char": 19626,
      "end_char": 19708,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Wait, but for the second step's tracking:\n\nWe need to track for each element in original array their count up to current position. Thus, for each element x in the original array as it's processed in order:\n\n   count_in_original(x) += 1\n\n   if count_in_original(x) == max_count then\n\n       print x and stop.",
      "start_char": 19710,
      "end_char": 20019,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Thus, need a way to track counts for elements in the array.",
      "start_char": 20021,
      "end_char": 20080,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Again, without a hashmap, but can track an array counts_orig(X) for all possible X in the array.",
      "start_char": 20083,
      "end_char": 20179,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Alternatively, track a unique array and their current counts.",
      "start_char": 20181,
      "end_char": 20242,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, during first processing, after getting all unique elements from the first step, store them in a list of u. Then, during the second pass:\n\ncounts_orig array can be an integer array with same size as u, initialized to 0. Then for each element in original array:\n\nget the index k of that element in the u array.\n\ncounts_orig(k) +=1.\n\nif counts_orig(k) == max_count:\n\n    print the element (u(k) )\n\n    exit.",
      "start_char": 20244,
      "end_char": 20665,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Thus, this approach uses two passes:\n\nFirst, processing the array to get unique elements and frequencies, which requires sorting or the hashmap-like approach.",
      "start_char": 20667,
      "end_char": 20825,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Second, processing the array again, using the unique elements list to track counts towards max_count.",
      "start_char": 20827,
      "end_char": 20928,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Thus, this approach may be manageable.",
      "start_char": 20930,
      "end_char": 20968,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "The benefits of sorting first would be O(n log n), which is better than O(n^2) for the hashmap-like search each time. Thus I think I'll try this approach.",
      "start_char": 20971,
      "end_char": 21125,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Let me proceed with the code:\n\n---\n\nSteps:\n\n1. Read original array. Read n.\n\nRead arr. 2. Make a copy and sort it. array_temp = arr(:)\n\ncall sort(array_temp)\n\n3.",
      "start_char": 21128,
      "end_char": 21292,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Process the sorted array to calculate frequencies. Initialize u as empty. current count.",
      "start_char": 21293,
      "end_char": 21381,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Initialize count array (counts_freq) and max_count.",
      "start_char": 21385,
      "end_char": 21436,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "So, in code:\n\nAfter the first element, it starts comparison. Set u(1)= array_temp(1), count 1. Then loop through array_temp(2) to array_temp(n):\n\n  if current element is same as last element in u, add to count.",
      "start_char": 21438,
      "end_char": 21649,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "else append to u and set count 1.",
      "start_char": 21654,
      "end_char": 21687,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Thus:\n\nFirst, initialize variables. integer :: i, m. Here m is the size of unique array u.\n\nThus:\n\nFirst, Initialize u and counts_freq arrays.\n\nallocate(u(0)), counts_freq(0)\n\nthen:\n\nu array starts, when first element:\n\nelement = array_temp(1)\n\nsince u is empty, so append first element to u, resize arrays.",
      "start_char": 21689,
      "end_char": 21997,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "so:\n\noriginal way:\n\nallocate(new array for u and counts_freq to 1, and set first value.",
      "start_char": 21999,
      "end_char": 22086,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "So:\n\nafter initializing u and counts_freq as 0 size. first element:\n\nif (size(u) ==0) then\n\nallocate(u(1))\n\nu(1) = array_temp(1)\n\nallocate(counts_freq(1))\n\ncounts_freq(1) =1\n\nmax_count =1\n\nelse\n\nthen, for next elements. So perhaps better to code as follows:\n\nlet array_sorted = array_temp after being sorted. initialize u(1) = array_sorted(1)\n\ncounts_freq(1) = 1\n\nthen loop over i from 2 to n:\n\ncurrent_value = array_sorted(i)\n\nlast_u = u(m) where m is current size of u. \n\nWait, no, need to track the current length of u. \n\nHmm, but this way, compared the current element with the last in the unique list. Thus:\n\ncurrent length of u is m = size(u)\n\nif (current_value == u(m) ) then \n\n   counts_freq(m) = counts_freq(m)+1 \n\n   if (counts_freq(m) > max_count) then \n\n      max_count = counts_freq(m)\n\n   end if \n\nelse\n\n   append u and counts_freq with current_value, count 1. m = m + 1 \\\n\n   u(m) = current_value\n\n   allocate a new element to counts_freq\n\n   counts_freq(m) =1\n\n   if (1 > max_count) then \n\n      max_count =1 \n\n   end if \n\nend\n\nThus, using this approach.",
      "start_char": 22088,
      "end_char": 23168,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "This would process the sorted array in O(n) time, giving the counts of each unique element (as grouped in the sorted array). Wait but the problem is that in Fortran, to append to an array means reallocate. Thus code structure:\n\nProcessing of the sorted array: First, \n\nallocate(u(1))\n\nu(1) = array_sorted(1)\n\nallocate(counts_freq(1))\n\ncounts_freq(1) = 1\n\nmax_count=1\n\nDo i=2, n \n\n   current_value = array_sorted(i)\n\n   m = size(u) if (current_value == u(m)) then \n\n       counts_freq(m) = counts_freq(m) +1 \n\n       if(counts_freq(m) > max_count) max_count = counts_freq(m)\n\n   else \n\n       m = m +1 \n\n       ! We need to resize arrays to m. \n\n       temp1 = u(1:m-1) \n\n       deallocate(u)\n\n       allocate(u(m))\n\n       u(1:m-1) = temp1\n\n       u(m) = current_value \n\n       temp2 = counts_freq(1:m-1)\n\n       deallocate(counts_freq)\n\n       allocate(counts_freq(m))\n\n       counts_freq(1:m-1) = temp2 \n\n       counts_freq(m) =1 \n\n       if (counts_freq(m) > max_count ) max_count = counts_freq(m) \n\n   end if \n\nEnd do \n\nWait, this reallocation each time an element is added.",
      "start_char": 23170,
      "end_char": 24255,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "This may be time-consuming if u grows large.",
      "start_char": 24256,
      "end_char": 24300,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Alternatively, preallocate memory with a larger initial size.",
      "start_char": 24303,
      "end_char": 24364,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Perhaps better to preallocate with maximum possible possible size (like n). But that could wasting memory.",
      "start_char": 24367,
      "end_char": 24473,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively proceed step by step.",
      "start_char": 24476,
      "end_char": 24511,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "This approach is getting complicated, but perhaps manageable. Alternatively, allow the sorted array to be processed sequentially, and the unique arrays can be built:\n\nLet me try:\n\nallocate(u(n), counts_freq(n) )\n\nm =0 \n\ndo i=1, n \n\n   current_val = array_sorted(i) if (m ==0 or current_val /= u(m) ) then \n\n      m = m +1\n\n      u(m) = current_val \n\n      counts_freq(m)=1 \n\n  else \n\n      counts_freq(m) = counts_freq(m) +1 \n\n  end if \n\n  if ( counts_freq(m) > max_count ) max_count = counts_freq(m)\n\nend do \n\nThen after this loop, the actual size of u is m.",
      "start_char": 24513,
      "end_char": 25077,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Thus, this approach is better because preallocating the arrays u(n) and counts_freq(n) and then the loop runs in O(n).",
      "start_char": 25079,
      "end_char": 25197,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "This requires applying the F90's features. Wait, okay:\n\nLet me see: At the start:\n\nallocate(u(n) )\n\nallocate(counts_freq(n) )\n\nm =0 \n\nmax_count =0 \n\nso:\n\ndo i =1 to n:\n\n   current_val = array_sorted(i)\n\n   if (m ==0) then \u2192 it's first element \n\n       m =1 \n\n       u(m) =current_val \n\n       counts_freq(m)=1 \n\n       max_count =1 \n\n   else:\n\n       IF current_val == u(m) \u2192 add \n\n       counts_freq(m) +=1 \n\n       else \u2192 new element \n\n       m= m+1 \n\n       u(m) = current_val \n\n       counts_freq(m) =1 \n\n   end \n\n   then check if counts_freq(m) > max_count \u2192 update max_count \n\nThus, after the loop ends, m holds the number of unique elements, and the arrays are up to m elements. So this approach is O(n) time. Yes, this is better. Thus this allows the first part to be done in linear time.",
      "start_char": 25199,
      "end_char": 25997,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "The sorted array was O(n log n).",
      "start_char": 26001,
      "end_char": 26033,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Now, after this, we have:\n\nmax_count is known.",
      "start_char": 26035,
      "end_char": 26081,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "The unique elements and their counts are stored in the first m elements of u and counts_freq. Now the second step. Second pass: process original array elements in order to find the first element whose count reaches max_count.",
      "start_char": 26082,
      "end_char": 26307,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Thus, need to track counts_so_far for each element in the u array.",
      "start_char": 26311,
      "end_char": 26377,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Thus, for that:\n\nInitialize counts_so_far array (size m) to zero. allocate(counts_so_far(m)) counts_so_far =0\n\nthen loop over the elements in arr (original array order):\n\nfor each val in arr\n\n   locate the index k in u where u(k)=val. \n\n   counts_so_far(k) +=1 \n\n   if counts_so_far(k) == max_count \n\n      then write val and exit.",
      "start_char": 26379,
      "end_char": 26712,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Thus, problem now becomes to find, for each element in arr, the index k in u where val equals u(k)\n\nWhich requires a linear search for each element of arr.",
      "start_char": 26714,
      "end_char": 26869,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "This can take O(n * m), but m is the number of unique elements, which at worst n, so O(n^2)\n\nHmm, which could be bad for large n and m approaching n.\n\nBut perhaps in this case, the total time is O(n log n) for sorting + O(n) for precounts + O(n*m) for this linear search.",
      "start_char": 26872,
      "end_char": 27143,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "If n is large, this might be a problem, but again maybe the problem constraints are small.",
      "start_char": 27145,
      "end_char": 27235,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Since the problem is from codeforces (problem codeforces 637A), perhaps the constraints are reasonable.",
      "start_char": 27237,
      "end_char": 27340,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Like n up to 1e4, but let's proceed.",
      "start_char": 27341,
      "end_char": 27377,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "Alternatively, can we optimize this search?",
      "start_char": 27379,
      "end_char": 27422,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Use a hash table method for the elements of the unique array?",
      "start_char": 27424,
      "end_char": 27485,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, since the array u is sorted (since we used sorted array), then u is in order. So can we perform a binary search to find the element.",
      "start_char": 27488,
      "end_char": 27635,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Wait, the first m elements of the u array (since array_sorted was sorted) are themselves in strictly increasing order. Thus the u elements are in sorted order.",
      "start_char": 27637,
      "end_char": 27796,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Thus, each time we want to find whether an element val is present, we can use binary search. So instead of a linear search over the first m elements of u (the unique elements), use binary search to find val in u(1:m).",
      "start_char": 27799,
      "end_char": 28016,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "If found at position found_idx then use that, else, that can't happen (since val is present in original array and u has all unique elements in order). Thus this reduces the lookup from O(m) to O(log m), leading to O(n log m) for the second loop. Which is better.",
      "start_char": 28019,
      "end_char": 28281,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Implementing binary search in Fortran:\n\nFunction to perform binary search in u's first m elements. function binsearch(arr, n, val) result (idx)\n\nimplicit none\n\ninteger, intent(in) :: arr(1:n)\n\ninteger, intent(in) :: n, val\n\ninteger :: low, high, mid, idx\n\nlow =1 \n\nhigh= n \n\nidx =-1\n\ndo while (low <= high)\n\n   mid = (low+high)/2 \n\n   if (arr(mid) == val) then \n\n      idx = mid \n\n      exit \n\n   else if (arr(mid) < val) then \n\n      low = mid +1 \n\n   else \n\n      high = mid -1 \n\n   end if \n\nend do \n\nend function binsearch \n\nWait, but in the code, we need to code it inline. Wait, inside the loop over the original array's elements:\n\nval = arr(j)\n\ncall binsearch to find val in u's first m elements. If found:\n\nthen idx is found index.\n\ncounts_so_far(idx) +=1 \n\nthen check etc. Thus binary search can be used here.",
      "start_char": 28285,
      "end_char": 29105,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Thus, this reduces the second loop's time from O(nm) to O(n log m).",
      "start_char": 29108,
      "end_char": 29175,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Thus, the steps with the sorted approach:\n\nFirst:\n\nSort array_sorted, preallocating arrays for u and counts, then process them in O(n) time.",
      "start_char": 29177,
      "end_char": 29317,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Second, process original array with binary search and track counts_so_far.",
      "start_char": 29319,
      "end_char": 29393,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Thus, the code can be:\n\nPutting together the steps:\n\nProgram codeforces_637_A\n\nImplicit None\n\nInteger :: n, i, m, max_count, val, found_idx \n\nInteger, allocatable :: arr(:), array_sorted(:), u(:), counts_freq(:), counts_so_far(:)\n\nRead *, n\n\nallocate( arr(n) ) Read *, (arr(i), i=1, n)\n\n! make a copy and sort:\n\nallocate(array_sorted(n))\n\narray_sorted = arr\n\ncall qs(array_sorted) ! Need to code the sort.",
      "start_char": 29395,
      "end_char": 29801,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "call sort_routine\n\nWait, but need to code a sort function.",
      "start_char": 29803,
      "end_char": 29861,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, in Fortran use Mergesort, but for the code submission, perhaps use built-in sorting.",
      "start_char": 29864,
      "end_char": 29963,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Fortran has the 'sort' intrinsic. Wait in F90 and later,\n\ncall sort(arr) But does the array need to be allocatable?",
      "start_char": 29965,
      "end_char": 30080,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Ah, yes: in F90, one can use built-in sort:\n\nTo sort array_sorted:\n\ncall merge_sort(array_sorted)",
      "start_char": 30084,
      "end_char": 30181,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Wait, Fortran 90 doesn't have a built-in sort function, wait.",
      "start_char": 30183,
      "end_char": 30244,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Oops, need to implement my own or use the sort function provided by the compiler.",
      "start_char": 30247,
      "end_char": 30328,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Wait, in Fortran, the syntax for intrinsic sort may depend on the compiler.",
      "start_char": 30331,
      "end_char": 30406,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Alternatively, let's use:\n\ncall sort( array_sorted ) But I'm not sure if that is available in standard F90.",
      "start_char": 30408,
      "end_char": 30515,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Alternatively, assume the user has a sort routine available. Wait perhaps the user can assume that there is sort capability using:\n\ncall sort(array_sorted)\n\nBut maybe need to code a quicksort function. Hmm, this is a hurdle.",
      "start_char": 30517,
      "end_char": 30741,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, use bubble sort, but that would be O(n^2), which is not ideal for large N.\n\nAlternatively, proceed to code a quicksort.",
      "start_char": 30745,
      "end_char": 30879,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Thus, perhaps better to code a quicksort function for an integer array.",
      "start_char": 30881,
      "end_char": 30952,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Thus, let's include a recursive subroutine for quicksort.",
      "start_char": 30954,
      "end_char": 31011,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Interlude: implementing quicksort in F90. Add this at the bottom:\n\nSubroutine Qsort(arr, low, high)\n\n   Implicit None\n\n   Integer, Intent(inout) :: arr(*)\n\n   Integer,Intent(in) :: low, high\n\n   Integer :: i, j, pivot, temp\n\n   if (low >= high) return \n\n   pivot = arr((low + high)/2 )\n\n   i = low \n\n   j = high \n\n   do \n\n      do while (arr(i) < pivot ) i = i+1 \n\n      end do \n\n      do while (arr(j) > pivot )\n\n         j =j -1 \n\n      end do \n\n      if (i <=j ) then \n\n         temp = arr(i)\n\n         arr(i) = arr(j)\n\n         arr(j) = temp\n\n         i=i+1 \n\n         j=j-1 \n\n     end if \n\n     if (i >j ) exit \n\n  end do \n\n  call Qsort(arr, low, j )\n\n  call Qsort(arr, i, high )",
      "start_char": 31013,
      "end_char": 31708,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "End Subroutine Qsort\n\nThus, to call the sort: call qsort(array_sorted, 1, n) Thus, in the main:\n\n    allocate(array_sorted(n))\n\n    array_sorted = arr \n\n    call qsort(array_sorted, 1, n )\n\nThen proceed with the processing. Thus the code:\n\nNow back to main steps:\n\nAfter sorting:\n\nProcess the array_sorted.",
      "start_char": 31710,
      "end_char": 32017,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Initialize:\n\nallocate(u(n), counts_freq(n)) m=0\n\nmax_count =0 do i =1 to n\n\ncurrent value = array_sorted(i)\n\nif m ==0 then:\n\n   m= 1 \n\n   u(1) = current value \n\n   counts_freq(1)=1 \n\n   max_count =1 \n\nelse \n\n   if ( current_value == u(m) ) then \n\n      counts_freq(m) +=1 \n\n      if (counts_freq(m) > max_count ) max_count = counts_freq(m) \n\n   else \n\n      m = m+1 \n\n      u(m) = current_value \n\n      counts_freq(m) =1 \n\n      if ( counts_freq(m) > max_count ) \n\n         max_count = counts_freq(m) \n\n   end if \n\nend if \n\nend do \n\nThus the loops ends. Now counts_so_far is to be initialized to zero for m elements:\n\nallocating counts_so_far(m) ? Wait. allocate( counts_so_far(m) ) counts_so_far =0 \n\nthen: loop over the elements in arr in their original order. do j =1, n \n\n   val = arr(j)\n\n   !",
      "start_char": 32020,
      "end_char": 32826,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "find val in u (1:m)\n\n   found_index is the position in u(1:m) where val is found. found_idx = binary_search(u, m, val) \n\n   if (found_idx == -1) then \n\n      ! should not happen \n\n      print *, ' error'\n\n      stop \n\n   else \n\n      counts_so_far(found_idx) = counts_so_far(found_idx) +1 \n\n      if (counts_so_far(found_idx) == max_count ) then \n\n         write(*,*) val \n\n         deallocate all variables \n\n         stop \n\n      end if \n\n  end if \n\nend do \n\nThus, needs function for binary search.",
      "start_char": 32827,
      "end_char": 33331,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Implementing the binary search function as an internal function.",
      "start_char": 33333,
      "end_char": 33397,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Write a function:\n\nFunction find_index( arr, n, target ) result ( idx ) Implicit None\n\nInteger, Intent(in) :: arr(1:n), n, target \n\nInteger :: idx, low, high, mid \n\nidx = -1 \n\nlow =1 \n\nhigh = n \n\ndo while ( low <= high )\n\n   mid = (low + high)/2 if ( arr(mid) == target ) then \n\n      idx = mid \n\n      exit \n\n   else if ( arr(mid) < target ) then \n\n      low = mid +1 \n\n   else \n\n      high = mid -1 \n\n   end if \n\nend do \n\nif ( low > high ) then \n\n   if ( low <=n .and. arr(low) == target ) idx = low\n\n   ! Wrong.",
      "start_char": 33399,
      "end_char": 33919,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "Probably better to let the function return -1 \n\n   idk, maybe clean \n\nelse\n\n  idx is already set if found \n\nend \n\nResult is idx.",
      "start_char": 33920,
      "end_char": 34048,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "Thus, this function returns index if found else -1 Wait but in our case, since val is in arr, and array_sorted includes all elements, and thus u includes all unique elements of original array (since we sorted and processed from there).",
      "start_char": 34051,
      "end_char": 34286,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Hence u must contain val, thus function should find it.",
      "start_char": 34291,
      "end_char": 34346,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Hence the function's result can be taken as:\n\nThe found_idx is nonzero.",
      "start_char": 34349,
      "end_char": 34420,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Thercode for the function can be written inside the program. Thus in code:\n\nInside the program, declare this function as an internal function:\n\nFUNCTION find_index( arr, len, target ) result(idx)\n\n   IMPLICIT NONE\n\n   INTEGER, INTENT(IN) :: arr(:), len, target\n\n   INTEGER :: idx, low, high, mid\n\n   idx = -1\n\n   low = 1\n\n   high = len\n\n   DO\n\n      IF (low > high) EXIT\n\n      mid = (low + high)/2\n\n      IF (arr(mid) == target) THEN\n\n         idx = mid\n\n         RETURN\n\n      ELSE IF (arr(mid) < target) THEN\n\n         low = mid + 1\n\n      ELSE \n\n         high = mid -1\n\n      END",
      "start_char": 34422,
      "end_char": 35006,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "IF\n\n   END DO\n\n   RETURN\n\nEND FUNCTION find_index\n\nWait, but to use this function inside the main program, we need to declare it. So in the main:\n\ncontains \n\n  function find_index( arr, n, target ) result ( idx )\n\n    !",
      "start_char": 35007,
      "end_char": 35226,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "definition as above\n\n  end function \n\nAlternatively, placing it after the declarations. Hmm.",
      "start_char": 35228,
      "end_char": 35320,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Well, in the program's code, all functions must be declared within the program block or external.",
      "start_char": 35322,
      "end_char": 35419,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Since this is an internal function, it can be placed as a contained subroutine. Thus, the code would look:\n\nInside main program:\n\n... (declarations)\n\ncontains \n\n  function find_index(arr, n, target) result (idx) \n\n    IMPLICIT NONE \n\n    integer, intent(in) :: arr(1:n), n, target \n\n    integer :: idx, low =1, high =n, mid \n\n    idx =-1 \n\n    do \n\n      if (low > high ) exit \n\n      mid = (low + high)/2 if ( arr(mid) == target ) then \n\n        idx = mid \n\n        exit \n\n      else if ( arr(mid) < target ) then \n\n        low = mid +1 \n\n      else \n\n        high = mid-1 \n\n      end if \n\n    end do \n\n  end function find_index \n\n... Then, in the loop over arr(j's):\n\n...\n\nval = arr(j)\n\nfound_idx = find_index( u(1:m), m, val ) \n\nif (found_idx ==-1 ) then \n\n   print *, 'element not found' \n\n   stop \n\nelse \n\n   counts_so_far(found_idx) = counts_so_far(found_idx)",
      "start_char": 35420,
      "end_char": 36295,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "+1 \n\n   if (counts_so_far(found_idx) == max_count ) then \n\n      print *, val \n\n      < free all memory and exit>\n\n   end if \n\nend if \n\nThus, this works.",
      "start_char": 36296,
      "end_char": 36449,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "Now, after passing through all elements without finding, but this shouldn't happen.",
      "start_char": 36451,
      "end_char": 36534,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "Putting all together, and making sure all variables are properly allocated and deallocated.",
      "start_char": 36537,
      "end_char": 36628,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Now, the code steps:\n\nAllocate all arrays and deallocate them at proper times. But in Fortran, deallocation can be placed at the end of the program. But since we have multiple allocations, perhaps deallocations are better. But as a first pass, perhaps proceed step to write the code accurately.",
      "start_char": 36630,
      "end_char": 36924,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Now, listing all allocations and deallocations. Steps:\n\nRead n and array. Allocate arr(n). Allocate array_sorted(n). Sorting. Then allocate u(n), counts_freq(n), m is updated. Allocate counts_so_far(m).",
      "start_char": 36927,
      "end_char": 37129,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "After the second loop, deallocate arr, array_sorted, u, counts_freq, counts_so_far. But in code:\n\nWait, the 'u' is stored in an array size n, but the actual size is m.",
      "start_char": 37140,
      "end_char": 37307,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "However, the code can allocate counts_so_far(m).",
      "start_char": 37311,
      "end_char": 37359,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Thus, the full code would be something like this:\n\nProgram codeforces_637_A\n\n  Implicit None\n\n  Integer :: n, i, j, m, max_count\n  Integer, Allocatable :: arr(:), u(:), array_sorted(:), counts_freq(:), counts_so_far(:)\n\n  Read *,n\n\n  Allocate( arr(n) ) Read *, (arr(i),i=1,n)\n\n  Allocate(array_sorted(n))\n  array_sorted = arr\n  Call Qsort(array_sorted, 1, n) ! Sort using quicksort\n\n  Allocate(u(n))\n  Allocate(counts_freq(n))\n\n  m =0\n  max_count =0 Do i = 1, n\n    Integer :: current_value = array_sorted(i) If (m == 0) Then\n      m =1\n      u(1) = current_value\n      counts_freq(1) =1\n      max_count=1\n    Else\n      If (Current_value == u(m) ) Then\n        counts_freq(m)=counts_freq(m)+1\n        If (counts_freq(m) > max_count) max_count = counts_freq(m)\n      Else\n        m = m +1\n        u(m) = current_value\n        counts_freq(m) =1\n        If (1 > max_count) max_count=1   !",
      "start_char": 37362,
      "end_char": 38257,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Probably not necessary, but needed for first entry. If (counts_freq(m) > max_count) max_count = counts_freq(m)\n      Endif\n    Endif\n  End Do\n\n  Allocate(counts_so_far(m))\n  counts_so_far = 0\n\n  Do j =1, n\n    Integer :: val = arr(j), found_idx\n    found_idx = find_index(u(1:m), m, val)\n    counts_so_far(found_idx)= counts_so_far(found_idx)+1 If( counts_so_far(found_idx) == max_count ) Then\n      print *, val\n      Deallocate(arr, array_sorted, u, counts_freq, counts_so_far)\n      Stop\n    Endif\n  End Do !",
      "start_char": 38258,
      "end_char": 38781,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "should not reach here in valid input ?\n\n  !",
      "start_char": 38782,
      "end_char": 38825,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "Deallocation all others:\n  Deallocate(arr, array_sorted, u, counts_freq, counts_so_far)\n\nContains\n\n  !",
      "start_char": 38826,
      "end_char": 38928,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "QuickSort subroutine\n  Recursive Subroutine Qsort( arr, low, high )",
      "start_char": 38929,
      "end_char": 38996,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Integer, Intent(INOUT) :: arr(:)\n    Integer, intent(IN) :: low, high\n    Integer :: i,j,pivot,temp\n    i = low\n    j = high\n    if( i >= j ) return\n    pivot = arr( (low + high)/2 )\n    do\n      do while( arr(i) < pivot ) i = i+1\n      end do\n      do while( arr(j) > pivot )\n        j = j-1\n      end do\n      if( i <= j ) then\n        temp = arr(i)\n        arr(i) = arr(j)\n        arr(j) = temp i = i+1\n        j = j-1\n      end if\n      if( i > j ) exit\n    end do\n    Call Qsort( arr, low, j )\n    Call Qsort( arr, i, high ) End Subroutine Qsort\n\n  !",
      "start_char": 39001,
      "end_char": 39572,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Find index function\n  Function find_index( arr, n, target ) Result ( idx )\n    Integer, Intent(IN) :: arr(1:n), n, target\n    Integer :: idx, low, high, mid\n    idx = -1\n    low =1\n    high =n\n    do\n      if( low > high ) exit\n      mid = (low + high)/2\n      if( arr(mid) == target ) then\n        idx = mid\n        exit\n      else if( arr(mid) < target ) then\n        low = mid+1\n      else\n        high = mid-1\n      end if\n    end do\n  End Function find_index\n\nEnd Program codeforces_637_A\n\nWait, the first assignment when counts_freq(m) is first set to1:\n\nSince in the else clause when adding new element:\n\nWhen it sets counts_freq(m) =1 and if (counts_freq(m) > max_count) then update.",
      "start_char": 39575,
      "end_char": 40266,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Since initially max_counts could be zero (if m was zero?), no. But in the case m starts at0 (if n=0?), which is probably not possible given the problem. But when first element is processed, m starts at1 and counts_freq(1) is 1, max_count=1. Thus perhaps in the else case:\n\nThe code for else can be better written as:\n\nElse\n\n    m = m+1 \n\n    u(m) = current_value \n\n    counts_freq(m) =1 \n\n    if (counts_freq(m) > max_count) then \n\n         max_count = counts_freq(m) \n\n    end if \n\nEnd if \n\nThis is better. Thus in the code inside the Do i=1, n loop:\n\nAfter the code: Else \n\n  m = m +1 \n\n  u(m) = current_value \n\n  counts_freq(m) =1 \n\n  if (counts_freq(m) > max_count) then \n\n    max_count = counts_freq(m) \n\n  end if \n\nend i.",
      "start_char": 40268,
      "end_char": 40999,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "Yes, because when a new element is added, its count is 1. Now, testing the code.",
      "start_char": 41002,
      "end_char": 41082,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "Test case: \n\nInput:\n\n5\n\n1 2 3 2 2 \n\nThe elements: 1,2,3,2,2 \u2192 \n\nSorted array:1, 2,2,2,3. Processing sorted elements:\n\ni=1: m=0 \u2192 m becomes1, u(1)=1, counts_freq(1)=1 \u2192max becomes1 \n\ni=2: 2 !=u(m)=1 \u2192 new element. m becomes2, u(2)=2. count =1. max",
      "start_char": 41086,
      "end_char": 41333,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "still 1 (since count is 1 not exceeding previous max). i=3: val=2 is equal to u(2)=2 \u2192 increment to 2 \u2192 new max. \n\ni=4 \u2192 val2 again \u2192 counts_freq(2)=3 \u2192 max becomes 3 now. i=5:3\u2192 new element: m=3\u2192u(3)=3, count1. Thus max_count is 3.",
      "start_char": 41334,
      "end_char": 41569,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "In the second pass, the original array elements:\n\n1,2,3,2,2 \n\nProcess the first elements:\n\ncounts_so_far initialized to (0,0,0). First element 1:\n\nits found at index 1 of u \u2192 so increment counts_so_far(1) to1 \u2192 compare to max_count3.",
      "start_char": 41573,
      "end_char": 41806,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "No.\n\nsecond element 2:\n\nfound at index2.",
      "start_char": 41808,
      "end_char": 41848,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "counts becomes1 \u2192 <3.\n\nthird 3 \u2192 index3 \u2192 count1 \u2192 no \n\n4th element 2 \u2192 index2. count =2. \n\n5th element 2 \u2192 index2's count now3 \u2192 equals max_count \u2192 thus print 2. Program exits. So the output should be 2. Which matches.",
      "start_char": 41849,
      "end_char": 42068,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Another test case:\n\nInput 3\n\n3 2 3 \u2192 sorted: 2,3,3 \u2192 \n\nUnique elements 2(count1),3(count2). max_count =2.",
      "start_char": 42071,
      "end_char": 42178,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "Original array:3(first time count reaches 2 is at third element. So steps:\n\nthird element is first time 3 reaches count2 \u2192 so third element is 3 \u2192 output3. Thus the code works.",
      "start_char": 42180,
      "end_char": 42356,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Now, check if the code does that. In code:\n\nOriginal array 3 is first element:\n\n_val =3 is in u \u2192 which now after sorting, the sorted array is [2,3,3]. so the unique arrays are:\n\nu(1)=2, u(2)=3 \u2192 m=2. counts_freq are [1,2] \u2192 max_count=2.",
      "start_char": 42361,
      "end_char": 42603,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Then, processing original array's first element 3:\n\nfound index2 \u2192 counts_so_far(2) becomes1 \u2192 less than max.\n\nsecond element is2 \u2192 j=2:\n\nelement2 \u2192 found at index1 \u2192 counts_so_far(1) becomes1. Third element:3 \u2192 \n\nAt j=3:\n\n_val=3 \u2192 index2.\n\ncounts_so_far(2) increments to 2 \u2192 equal to max_count (2). Thus, program prints3. Which is correct.",
      "start_char": 42605,
      "end_char": 42946,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Another test case:\n\nInput 1\n\n1 \u2192 the output should be1. Yes.",
      "start_char": 42950,
      "end_char": 43010,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "Now, the code should handle these cases.",
      "start_char": 43013,
      "end_char": 43053,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Edge case where max_count is 1. E.g input n=4 elements all distinct.",
      "start_char": 43056,
      "end_char": 43126,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "output should be first element since they all have count 1 and first to reach that. Thus the first occurrence is first element.",
      "start_char": 43129,
      "end_char": 43256,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Hence the code *should * work.",
      "start_char": 43260,
      "end_char": 43290,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "Now, in the code, need to ensure that when a new element is added to u (m increases), the maximum count can be considered, even if it's 1. The code handles this.",
      "start_char": 43292,
      "end_char": 43453,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Thus, the code above is correct.",
      "start_char": 43457,
      "end_char": 43489,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "Now, I must write this into the Fortran code.",
      "start_char": 43491,
      "end_char": 43536,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    }
  ],
  "original_reasoning": "Okay, I need to translate this Java code into Fortran. Let me look through the code step by step. \n\nFirst, the Java code reads integers from the input, counts the frequency of each number, finds the maximum frequency, and then outputs the first number that reaches that maximum frequency as it's encountered in the array. \n\nHmm, in Fortran, I'll need to handle input and output a bit differently. Let's see the structure. \n\nThe Java program uses a Scanner and PrintWriter. In Fortran, I can read from standard input using read(*,*) and write to standard output with write(*,*) statements.\n\nThe main steps are:\n\n1. Read n, then the array elements.\n2. Count the frequency of each element, storing in a map (in Java, it's a HashMap).\n3. Find the maximum frequency.\n4. Then iterate through the array again, keeping a second count until an element reaches the max frequency, then print that element and exit.\n\nNow, translating each part step by step.\n\nFirst, handling the input. The array in Java is declared as int ara[] = new int[n]; In Fortran, arrays are fixed at compile time unless we use allocatable arrays. So I can declare an array with size n. But Fortran requires knowing the size at allocation. So perhaps first I need to read n, then allocate the array. So something like:\n\nRead(*,*) n\nAllocate(arr(n))\n\nNext, the first map: a way to track frequencies of each number. Since Java's HashMap uses key-value pairs, in Fortran, I might need an associative array. But Fortran doesn't have built-in hash maps. Oh right, this is a problem. Because Fortran's arrays are indexed by integers, but here the keys can be any integer values (the elements in the array), not just indices. \n\nHmm, how to handle this?\n\nHmm, maybe since the array elements are integers, perhaps track their counts using another array, but then need to map unique elements to indexes? Alternatively, maybe collect the unique elements first, then track counts in an array. \n\nWait, perhaps the elements are within a certain range. But the problem description doesn't say, so we have to assume they can be any integers, positive or negative?\n\nIn any case, using a list to store unique numbers and an array for counts. Let's think: first, read the array, then collect all unique elements, store them in a list, and have a count array parallel to that list of unique elements.\n\nAlternatively, use a data structure like a hash map. But in Fortran, standard (Fortran 90/95) doesn't support hash maps. So need a workaround.\n\nAn alternative is to use a dynamic array to keep track of the unique elements and their counts. For each element in the input array, check if it's already in the unique list. If yes, increment the count at that position. If not, add it to the list with a count of 1.\n\nThat's probably manageable. Let's try that.\n\nSo:\n\nFirst, read the input array into an allocatable array arr of size n.\n\nThen initialize a list (array) for the unique numbers and a corresponding count array. They can be dynamic. Since arrays in Fortran can be allocated, re-sized.\n\nIn Fortran, we can use a list of unique elements (like an array u) and a count array (counts).\n\nInitially, u and counts have size 0. For each element in arr:\n\nLoop through the array elements:\n\nelement = arr(i)\n\nCheck if element is in u. If present, increment counts at its position. If not, append to u and set count to 1.\n\nOnce done, we need to find the maximum count from the counts array. That's straightforward.\n\nThen, the second pass through the array arr. We need to track, for each element, how many times it's been seen so far, and when any element's count reaches the max count, output it and exit.\n\nFor this second step, since we need to count per element incrementally, we can again track a \"current count\" for each element. Let me see.\n\nAlternatively, perhaps the same approach as before: another array to track current counts.\n\nAlternatively, perhaps track the counts as we go through the array again.\n\nWait, let me think again.\n\nThe problem requires that after the first pass, we have the max frequency, then in the second pass through the array, we are to output the element that was the first to reach the max frequency. The first occurrence of an element to have its count equal to the max is printed and the loop terminates.\n\nSo, during the first pass, we can have for each element in the array, the total number of occurrences (the frequency map), then in the second pass, keep a separate counter for each element. So when that counter reaches the max frequency, print it.\n\nSo, similar to Java's logic here.\n\nBut in Fortran, implementing this requires a way to track both the total frequency (from first pass) and the current count (during the second pass).\n\nHmm. Let me think in steps:\n\nFirst Part:\n\nRead n.\n\nRead the array elements into arr of size n.\n\nInitialize:\n\n- An array of unique elements (u) and their counts (counts). Start with empty.\n\nProceed through each element in the array. For each element a in arr:\n\nloop over u's elements to see if a is there.\n\nWait, but if the array is large (like if n is up to 1e5?), this could be O(n^2), which is bad. So this might not be efficient for large N? But perhaps in the problem constraints n is manageable?\n\nThe original problem's Java code can handle up to O(n) time using a hash map, but if the Fortran solution uses O(n^2) due to the check for uniqueness, it might not be efficient. Wait, but the problem might have constraints that make this manageable. Anyway, assuming that we have to proceed with this approach for now, since Fortran doesn't have built-in hash tables.\n\nWait, perhaps using a hash table via a module, but I think that might not be straightforward for a beginner. Alternatively, use an associating array via a derived type or something else. Maybe in Fortran 2003 or higher, but perhaps the user expects a standard approach.\n\nAlternatively, perhaps the elements can be in a limited range. But perhaps the elements are within reasonable limits. Alternatively, use a sparse array.\n\nAlternatively, take all elements, and create an array of integers (the elements), and another array (count for each). Since in Fortran, arrays have fixed size, but we can make an array with a large size (like 1e6), but that might be overkill. Or we can find all unique elements first and store them, then track their counts.\n\nAlternatively, since in Fortran's allocatable arrays can be resized, perhaps use a list of unique elements and corresponding counts, and every time we find a new element, append to the unique array.\n\nLet me try to proceed with that approach.\n\nStep by step:\n\n1. Read n.\n\n2. Read the array.\n\n3. Initialize unique array and counts. These will start as empty or with initial size zero, and we can reallocate as needed.\n\nWait, but how in Fortran?\n\nWe can start with unique counts as allocatable arrays.\n\nSomething like:\n\ninteger, allocatable :: u(:), counts(:)\n\nThen initialize:\n\nallocate(u(0)) ! zero size initially\nallocate(counts(0))\n\nThen for each element in arr:\n\nelement = arr(i)\n\nsearch through u(1:) to see if element is in there.\n\nIf found, say at position pos: increment counts(pos) by 1.\n\nIf not found: check size of u and counts. Need to reallocate.\n\nHmm.\n\nAlternatively, make it a loop over elements, expanding u and counts as necessary.\n\nThis might be manageable but a bit tedious. Let's think.\n\nAlternative idea:\n\nPerhaps track two arrays: a list (u) of keys (unique values) and their counts. Each time processing a new value from the input array:\n\n- Search u for the value. If found, increment its count.\n\n- If not found, append to u and set its count to 1.\n\nHowever, searching through u each time would be O(n) per element, leading to O(n^2), which is bad.\n\nSo this is a problem if the array is large. But perhaps in the original problem, the constraints are small enough? The original Java code uses a hashmap, O(n) time.\n\nHmm, but since I have to code it in Fortran, I have to use some method acceptable here.\n\nAlternatively, maybe use some sorting approach. \n\nIf I first sort all the elements, I can count frequencies more easily.\n\nLet me think. \n\nSort the array.\n\nThen, walk through the sorted array: each group of identical elements can be counted.\n\nThis can also track the max. But this would require sorting first O(n log n). \n\nThen to find frequencies: but then in the second pass, we need to find the element first encountered to reach that frequency.\n\nBut the second pass would need to track their counts as encountered in the original array's order, not the sorted order.\n\nTherefore, the first approach (even with O(n^2) time) may be the only way. Well, maybe the problem's constraints make n small enough, so that this is acceptable. Let's see.\n\nAlternatively, use a module that has a hash map. For example, in Fortran, there are some third-party libraries that support associative arrays, but I don't think the problem expects that.\n\nAlternatively, use a derived type and a linked list structure. But that's probably overkill.\n\nHmm, maybe in the problem's context, the elements are within a small range. For example if the numbers are between 1 and a million, then an array can be used. However, the user might have numbers that are large negative or positive integers. \n\nWait, if elements can be any integer, including negatives or very large? Then a direct array can't be used. \n\nSo, in absence of a hash map structure, perhaps the best approach is to use the O(n^2) method. We can proceed with that.\n\nAlternatively, use a hash table approach in Fortran 90/95. For example, using an array of elements with sufficient indexes. But without knowing the elements' keys, that's hard.\n\nAlternatively, use a different tactic. Since in the second part, once you have the maximum frequency, you can iterate through the array elements, keep track of their counts so far, and as soon as any of them reaches the max count, output that element and break.\n\nSo maybe the second part can be done with another hash map. Oh, but again, same problem.\n\nAlternatively, for the second part, use an array to track the counts again. But since the first part's maximum can be known, perhaps during the first step, we can also have stored the list of elements that have max counts. Then in the array, the first occurrence that one of them reaches the max is our answer.\n\nWait, the problem wants the first element in the array that reaches the max frequency when counting until that point.\n\nSo for example, suppose an array has elements [1,2,3,2,2]. The max frequency is 3 for element 2. The first time the count of 2 reaches 3 is when we reach the fifth element, so when we have three 2s, that's the moment.\n\nAlternatively, maybe the max frequency is 3, and the first element that has count equal to that is found when you hit three occurrences. \n\nNow, perhaps for the second pass: the counts can again be tracked using an array. So perhaps, even if it takes O(n^2) time for the frequency counts, perhaps it is manageable.\n\nAlternatively, perhaps in Fortran 90/95, perhaps the best way is to do:\n\nRead in all elements.\n\nFirst pass: compute each element's total count (even with O(n^2)), and track the maximum.\n\nSecond pass: for each element in the array, track its current count (incrementing each time it is encountered), once any element reaches the maximum count, output it and stop.\n\nBut for the second pass, the counts needed are their cumulative up to that step. So for this, perhaps a separate array can track the count so far for each element. \n\nBut how to do this without a hash map? Let's see.\n\nWait for the second pass:\n\nInitialize another array counts_so_far. Wait, but the keys are potential elements which can be of any integer. Since we can't have a dynamic array here again, perhaps during the second pass, we can use a hash map approach again. \n\nAlternatively, for the second pass, we can again iterate through each element, and track it's current count up to that index. \n\nLike: for each element in the array, as you iterate:\n\nIf the element is not in a list of tracked elements, add to it, and track the count. \n\nWait, this is similar to the first step but tracking only until that point.\n\nBut again, it would required O(n^2) time.\n\nHmm. Perhaps proceed with this approach.\n\nOverall, the problem can be accepted with O(n^2) methods for small constraints. Let's try to proceed with that.\n\nSo here's the plan.\n\nImplement in Fortran as follows:\n\nMain Algorithm:\n\nRead n.\n\nRead the array into arr(n).\n\nThen compute counts for each element in arr:\n\nInitialize an array to hold unique elements (u) and their counts.\n\nStart with empty u and counts arrays.\n\nLoop through each element in arr:\n\n   current_element = arr(i)\n\n   Search through u to see if current_element exists.\n\n   found = search(u, current_element, k)  \n\n   If found, counts(k) = counts(k) +1\n\n   else:\n\n      append current_element to u, and set counts(k) to 1.\n\nAfter processing all elements, find the maximum count.\n\nmax_count = maxval(counts)\n\nThen, second pass: iterate through the array arr again, and track the counts_so_far for each element:\n\nfor each element in arr:\n\n   search in the list u for the element (since u contains all unique elements, maybe)\n\n   Get the position k in u where element is found. But in the same array u.\n\n   Then, if counts_so_far for that element reaches max_count, then output the element and stop.\n\nWait. Alternatively, maybe use a separate array to track current counts.\n\nAlternatively, during the second pass, keep another array for counts_so_far. Since the elements can be up to the existing unique list, perhaps iterate through unique elements first, and then track their count as you step through the array.\n\nBut maybe it's complicated. \n\nPerhaps better to track counts_so_far for each element as you go.\n\nAlternatively, for each element in arr during second pass, check how many times it has been encountered so far. \n\nWe can have an array counts_so_far which is same size as u (the unique elements), initialized to zero.\n\nThen:\n\ninitialize counts_so_far = 0 array of size size(u)\n\nThen, loop over each element in arr:\n\n   current_e = arr(j)\n\n   find index k in u where u(k) = current_e \n\n   counts_so_far(k) = counts_so_far(k)+1\n\n   if (counts_so_far(k) == max_count) then\n\n       print *, current_e\n\n       stop\n\n   end if\n\nThis way, the second pass can be done this way.\n\nSo this uses the unique elements' list. Since counts_so_far is only tracked per unique element, this is manageable.\n\nSo steps:\n\nFirst pass:\n\nRead all elements, build u and counts arrays.\n\nSecond pass: track counts_so_far and check.\n\nThus, the Fortran code can proceed with this plan.\n\nNow code.\n\nNow, implementing this step by step.\n\nFirst, in Fortran:\n\nProgram codeforces_637_A\n\nImplicit None\n\nInteger :: n, i\n\ninteger, allocatable :: arr(:)\n\ninteger, allocatable :: u(:), counts(:), counts_so_far(:)\n\ntype(pair) :: ... Wait, no idea. Alternatively proceed step by step.\n\nFirst, step 1:\n\nRead n.\n\nThen read the n elements into array arr.\n\nAllocate arr(n)\n\nRead(*,*) n \n\nallocate( arr(n) )\n\ndo i=1, n\n\n read(*,*) arr(i)\n\nend do\n\nWait, but since the inputs are given in one line? In the Java code, the elements are read via in.nextInt() which reads all tokens. So in Fortran, probably the user inputs all numbers, but how to read them.\n\nAssuming they are given as space-separated, the code \"read(*,*) n\" will read the first integer. Then arr can be read via read(*,*) arr.\n\nThus, perhaps:\n\nRead(*,*) n\n\nallocate( arr(n) )\n\nread(*,*) (arr(i), i=1,n)\n\nThat's better.\n\nThen first pass.\n\nInitialize the unique list u and counts array:\n\nFirst, let's start with u and counts being empty.\n\ninitialize:\n\nallocate(u(0), counts(0))\n\nthen for each element in arr,\n\ncurrent_val = arr(i)\n\nthen search through the u array for current_val.\n\nif found, increment counts(k)\n\nelse append current_val to u at position (size(u)+1) and set counts(k) =1.\n\nTo perform this, the searching step requires a loop through current length of u and checking equality.\n\nWait, in Fortran, let's code that.\n\nSo for each i from 1 to n:\n\ncurrent_val = arr(i)\n\nflag = .false.\n\nDo j=1, size(u)\n\n If (u(j) == current_val) then\n\n  counts(j) = counts(j) +1\n\n  flag = .true.\n\n  exit\n\n End if\n\nEnd do\n\nif (.not. flag) then\n\n   allocate new arrays: perhaps first, need to extend u array:\n\n   old_size = size(u,1)\n\n   new_size = old_size +1\n\n   temp_u = u\n\n   deallocate(u) \n\n   allocate(u(old_size+1))\n\n   u(1:old_size) = temp_u\n\n   u(old_size+1) = current_val\n\n   similarly for counts array:\n\n   temp_counts = counts \n\n   deallocate(counts) \n\n   allocate(counts(old_size+1))\n\n   counts(1:old_size) = temp_counts\n\n   counts(old_size+1) =1\n\n End if\n\nHmm, this reallocation is a bit messy but necessary unless one uses a different approach.\n\nAlternatively, pre-allocate the arrays to a maximum possible size. But the question is, what's n.\n\nWait the problem constraints? Well, in the original problem (codeforces 637A?), the constraints for n may be small enough that the above code doesn't hit performance issues, but the code must work within the problem's constraints.\n\nAlternatively maybe use a different approach with dynamic arrays, reallocating as they grow.\n\nWait, in Fortran, when you deallocate and reallocate, it can be done but may be inefficient, but again we can proceed.\n\nPerhaps better to loop step by step.\n\nBut even so, the code can be written this way.\n\nAlternatively, use a different method, such as collect all elements, sort them, and then count frequencies by comparing adjacent elements.\n\nThis might be more efficient.\n\nLet me think:\n\nThe first approach (hashmap-like) is O(n^2), which for N ~1e4 is about 1e8 operations, which would take a few seconds on a modern computer, but for some problems might be acceptable. But perhaps the maximum N here is small e.g. 1e4? Not sure, but let's proceed.\n\nAlternative method with sorting:\n\nAfter reading the array, sort it.\n\nThen, go through the sorted array and count the frequency of each element in sequence.\n\nThis will count the frequencies in O(n log n) time for sorting, which is better. But then, need to also track the maximum frequency.\n\nSince after sorting, the data is ordered, so when you look for the max frequency, it's easy.\n\nThen for the second pass, need to track the counts as we go through the original array. \n\nWait, but the original array's order is important for the second step. Because we have to check when the elements in their original order first reach the max count.\n\nThis seems conflicting.\n\nWait for the second step:\n\nWe need to loop through the original array and increment a current count, and see when the count equals max_count. \n\nThe original array is the correct order. \n\nThus, if we first sort the array for counting frequencies, but then lose track of the elements' original order for the second pass. Wait no, the second pass uses the original array, but how? \n\nSo, the sorting step can be done without affecting the original array. \n\nYes: \n\nStep1: Read the original array into arr(orig).\n\nStep2: Make a copy and sort it.\n\narray_sort = arr.\n\ncall sort(array_sort)\n\nSTEP2 compute frequencies and max count via this sorted array.\n\nBut even better:\n\nAfter sorting, loop through array_sort, to compute frequencies for unique elements. \n\nThat can be done.\n\nThen, we can get the max count and the elements with max count.\n\nOnce max_count is known, for the second step, process original array in order to see which element's cumulative count first reaches the max count.\n\nThe problem now is, how to track in the original array: for each element as you see them, track how many times it has been seen so far, and when it reaches max_count.\n\nThis doesn't need a hashmap, since per element, but again, unless they are unique.\n\nWait, but for the second step's tracking:\n\nWe need to track for each element in original array their count up to current position. \n\nThus, for each element x in the original array as it's processed in order:\n\n   count_in_original(x) += 1\n\n   if count_in_original(x) == max_count then\n\n       print x and stop.\n\nThus, need a way to track counts for elements in the array. \n\nAgain, without a hashmap, but can track an array counts_orig(X) for all possible X in the array.\n\nAlternatively, track a unique array and their current counts. \nAlternatively, during first processing, after getting all unique elements from the first step, store them in a list of u. Then, during the second pass:\n\ncounts_orig array can be an integer array with same size as u, initialized to 0. \n\nThen for each element in original array:\n\nget the index k of that element in the u array.\n\ncounts_orig(k) +=1.\n\nif counts_orig(k) == max_count:\n\n    print the element (u(k) )\n\n    exit.\n\nThus, this approach uses two passes:\n\nFirst, processing the array to get unique elements and frequencies, which requires sorting or the hashmap-like approach.\n\nSecond, processing the array again, using the unique elements list to track counts towards max_count.\n\nThus, this approach may be manageable. \n\nThe benefits of sorting first would be O(n log n), which is better than O(n^2) for the hashmap-like search each time.\n\nThus I think I'll try this approach.\n\nLet me proceed with the code:\n\n---\n\nSteps:\n\n1. Read original array.\n\nRead n.\n\nRead arr.\n\n2. Make a copy and sort it.\n\narray_temp = arr(:)\n\ncall sort(array_temp)\n\n3. Process the sorted array to calculate frequencies.\n\nInitialize u as empty.\n\ncurrent count.\n\nInitialize count array (counts_freq) and max_count.\n\nSo, in code:\n\nAfter the first element, it starts comparison.\n\nSet u(1)= array_temp(1), count 1.\n\nThen loop through array_temp(2) to array_temp(n):\n\n  if current element is same as last element in u, add to count.\n\n  else append to u and set count 1.\n\nThus:\n\nFirst, initialize variables.\n\ninteger :: i, m. Here m is the size of unique array u.\n\nThus:\n\nFirst, Initialize u and counts_freq arrays.\n\nallocate(u(0)), counts_freq(0)\n\nthen:\n\nu array starts, when first element:\n\nelement = array_temp(1)\n\nsince u is empty, so append first element to u, resize arrays.\n\nso:\n\noriginal way:\n\nallocate(new array for u and counts_freq to 1, and set first value.\n\nSo:\n\nafter initializing u and counts_freq as 0 size.\n\nfirst element:\n\nif (size(u) ==0) then\n\nallocate(u(1))\n\nu(1) = array_temp(1)\n\nallocate(counts_freq(1))\n\ncounts_freq(1) =1\n\nmax_count =1\n\nelse\n\nthen, for next elements.\n\nSo perhaps better to code as follows:\n\nlet array_sorted = array_temp after being sorted. \n\ninitialize u(1) = array_sorted(1)\n\ncounts_freq(1) = 1\n\nthen loop over i from 2 to n:\n\ncurrent_value = array_sorted(i)\n\nlast_u = u(m) where m is current size of u. \n\nWait, no, need to track the current length of u. \n\nHmm, but this way, compared the current element with the last in the unique list.\n\nThus:\n\ncurrent length of u is m = size(u)\n\nif (current_value == u(m) ) then \n\n   counts_freq(m) = counts_freq(m)+1 \n\n   if (counts_freq(m) > max_count) then \n\n      max_count = counts_freq(m)\n\n   end if \n\nelse\n\n   append u and counts_freq with current_value, count 1. \n\n   m = m + 1 \\\n\n   u(m) = current_value\n\n   allocate a new element to counts_freq\n\n   counts_freq(m) =1\n\n   if (1 > max_count) then \n\n      max_count =1 \n\n   end if \n\nend\n\nThus, using this approach.\n\nThis would process the sorted array in O(n) time, giving the counts of each unique element (as grouped in the sorted array).\n\nWait but the problem is that in Fortran, to append to an array means reallocate.\n\nThus code structure:\n\nProcessing of the sorted array:\n\nFirst, \n\nallocate(u(1))\n\nu(1) = array_sorted(1)\n\nallocate(counts_freq(1))\n\ncounts_freq(1) = 1\n\nmax_count=1\n\nDo i=2, n \n\n   current_value = array_sorted(i)\n\n   m = size(u)\n\n   if (current_value == u(m)) then \n\n       counts_freq(m) = counts_freq(m) +1 \n\n       if(counts_freq(m) > max_count) max_count = counts_freq(m)\n\n   else \n\n       m = m +1 \n\n       ! We need to resize arrays to m. \n\n       temp1 = u(1:m-1) \n\n       deallocate(u)\n\n       allocate(u(m))\n\n       u(1:m-1) = temp1\n\n       u(m) = current_value \n\n       temp2 = counts_freq(1:m-1)\n\n       deallocate(counts_freq)\n\n       allocate(counts_freq(m))\n\n       counts_freq(1:m-1) = temp2 \n\n       counts_freq(m) =1 \n\n       if (counts_freq(m) > max_count ) max_count = counts_freq(m) \n\n   end if \n\nEnd do \n\nWait, this reallocation each time an element is added. This may be time-consuming if u grows large. \n\nAlternatively, preallocate memory with a larger initial size. \n\nPerhaps better to preallocate with maximum possible possible size (like n).\n\nBut that could wasting memory.\n\nAlternatively proceed step by step.\n\nThis approach is getting complicated, but perhaps manageable.\n\nAlternatively, allow the sorted array to be processed sequentially, and the unique arrays can be built:\n\nLet me try:\n\nallocate(u(n), counts_freq(n) )\n\nm =0 \n\ndo i=1, n \n\n   current_val = array_sorted(i)\n\n   if (m ==0 or current_val /= u(m) ) then \n\n      m = m +1\n\n      u(m) = current_val \n\n      counts_freq(m)=1 \n\n  else \n\n      counts_freq(m) = counts_freq(m) +1 \n\n  end if \n\n  if ( counts_freq(m) > max_count ) max_count = counts_freq(m)\n\nend do \n\nThen after this loop, the actual size of u is m.\n\nThus, this approach is better because preallocating the arrays u(n) and counts_freq(n) and then the loop runs in O(n).\n\nThis requires applying the F90's features.\n\nWait, okay:\n\nLet me see:\n\nAt the start:\n\nallocate(u(n) )\n\nallocate(counts_freq(n) )\n\nm =0 \n\nmax_count =0 \n\nso:\n\ndo i =1 to n:\n\n   current_val = array_sorted(i)\n\n   if (m ==0) then \u2192 it's first element \n\n       m =1 \n\n       u(m) =current_val \n\n       counts_freq(m)=1 \n\n       max_count =1 \n\n   else:\n\n       IF current_val == u(m) \u2192 add \n\n       counts_freq(m) +=1 \n\n       else \u2192 new element \n\n       m= m+1 \n\n       u(m) = current_val \n\n       counts_freq(m) =1 \n\n   end \n\n   then check if counts_freq(m) > max_count \u2192 update max_count \n\nThus, after the loop ends, m holds the number of unique elements, and the arrays are up to m elements.\n\nSo this approach is O(n) time.\n\nYes, this is better.\n\nThus this allows the first part to be done in linear time. The sorted array was O(n log n).\n\nNow, after this, we have:\n\nmax_count is known. The unique elements and their counts are stored in the first m elements of u and counts_freq.\n\nNow the second step.\n\nSecond pass: process original array elements in order to find the first element whose count reaches max_count.\n\nThus, need to track counts_so_far for each element in the u array.\n\nThus, for that:\n\nInitialize counts_so_far array (size m) to zero.\n\nallocate(counts_so_far(m))\n\ncounts_so_far =0\n\nthen loop over the elements in arr (original array order):\n\nfor each val in arr\n\n   locate the index k in u where u(k)=val. \n\n   counts_so_far(k) +=1 \n\n   if counts_so_far(k) == max_count \n\n      then write val and exit.\n\nThus, problem now becomes to find, for each element in arr, the index k in u where val equals u(k)\n\nWhich requires a linear search for each element of arr. \n\nThis can take O(n * m), but m is the number of unique elements, which at worst n, so O(n^2)\n\nHmm, which could be bad for large n and m approaching n.\n\nBut perhaps in this case, the total time is O(n log n) for sorting + O(n) for precounts + O(n*m) for this linear search.\n\nIf n is large, this might be a problem, but again maybe the problem constraints are small.\n\nSince the problem is from codeforces (problem codeforces 637A), perhaps the constraints are reasonable. Like n up to 1e4, but let's proceed.\n\nAlternatively, can we optimize this search?\n\nUse a hash table method for the elements of the unique array? \n\nAlternatively, since the array u is sorted (since we used sorted array), then u is in order. So can we perform a binary search to find the element.\n\nWait, the first m elements of the u array (since array_sorted was sorted) are themselves in strictly increasing order.\n\nThus the u elements are in sorted order.\n\nThus, each time we want to find whether an element val is present, we can use binary search.\n\nSo instead of a linear search over the first m elements of u (the unique elements), use binary search to find val in u(1:m).\n\nIf found at position found_idx then use that, else, that can't happen (since val is present in original array and u has all unique elements in order).\n\nThus this reduces the lookup from O(m) to O(log m), leading to O(n log m) for the second loop.\n\nWhich is better.\n\nImplementing binary search in Fortran:\n\nFunction to perform binary search in u's first m elements.\n\nfunction binsearch(arr, n, val) result (idx)\n\nimplicit none\n\ninteger, intent(in) :: arr(1:n)\n\ninteger, intent(in) :: n, val\n\ninteger :: low, high, mid, idx\n\nlow =1 \n\nhigh= n \n\nidx =-1\n\ndo while (low <= high)\n\n   mid = (low+high)/2 \n\n   if (arr(mid) == val) then \n\n      idx = mid \n\n      exit \n\n   else if (arr(mid) < val) then \n\n      low = mid +1 \n\n   else \n\n      high = mid -1 \n\n   end if \n\nend do \n\nend function binsearch \n\nWait, but in the code, we need to code it inline.\n\nWait, inside the loop over the original array's elements:\n\nval = arr(j)\n\ncall binsearch to find val in u's first m elements.\n\nIf found:\n\nthen idx is found index.\n\ncounts_so_far(idx) +=1 \n\nthen check etc.\n\nThus binary search can be used here.\n\nThus, this reduces the second loop's time from O(nm) to O(n log m).\n\nThus, the steps with the sorted approach:\n\nFirst:\n\nSort array_sorted, preallocating arrays for u and counts, then process them in O(n) time.\n\nSecond, process original array with binary search and track counts_so_far.\n\nThus, the code can be:\n\nPutting together the steps:\n\nProgram codeforces_637_A\n\nImplicit None\n\nInteger :: n, i, m, max_count, val, found_idx \n\nInteger, allocatable :: arr(:), array_sorted(:), u(:), counts_freq(:), counts_so_far(:)\n\nRead *, n\n\nallocate( arr(n) )\n\nRead *, (arr(i), i=1, n)\n\n! make a copy and sort:\n\nallocate(array_sorted(n))\n\narray_sorted = arr\n\ncall qs(array_sorted) ! Need to code the sort.\n\ncall sort_routine\n\nWait, but need to code a sort function. \n\nAlternatively, in Fortran use Mergesort, but for the code submission, perhaps use built-in sorting.\n\nFortran has the 'sort' intrinsic.\n\nWait in F90 and later,\n\ncall sort(arr)\n\nBut does the array need to be allocatable?\n\nAh, yes: in F90, one can use built-in sort:\n\nTo sort array_sorted:\n\ncall merge_sort(array_sorted)\n\nWait, Fortran 90 doesn't have a built-in sort function, wait. \n\nOops, need to implement my own or use the sort function provided by the compiler. \n\nWait, in Fortran, the syntax for intrinsic sort may depend on the compiler.\n\nAlternatively, let's use:\n\ncall sort( array_sorted )\n\nBut I'm not sure if that is available in standard F90. Alternatively, assume the user has a sort routine available.\n\nWait perhaps the user can assume that there is sort capability using:\n\ncall sort(array_sorted)\n\nBut maybe need to code a quicksort function.\n\nHmm, this is a hurdle.\n\nAlternatively, use bubble sort, but that would be O(n^2), which is not ideal for large N.\n\nAlternatively, proceed to code a quicksort.\n\nThus, perhaps better to code a quicksort function for an integer array.\n\nThus, let's include a recursive subroutine for quicksort.\n\nInterlude: implementing quicksort in F90.\n\nAdd this at the bottom:\n\nSubroutine Qsort(arr, low, high)\n\n   Implicit None\n\n   Integer, Intent(inout) :: arr(*)\n\n   Integer,Intent(in) :: low, high\n\n   Integer :: i, j, pivot, temp\n\n   if (low >= high) return \n\n   pivot = arr((low + high)/2 )\n\n   i = low \n\n   j = high \n\n   do \n\n      do while (arr(i) < pivot )\n\n         i = i+1 \n\n      end do \n\n      do while (arr(j) > pivot )\n\n         j =j -1 \n\n      end do \n\n      if (i <=j ) then \n\n         temp = arr(i)\n\n         arr(i) = arr(j)\n\n         arr(j) = temp\n\n         i=i+1 \n\n         j=j-1 \n\n     end if \n\n     if (i >j ) exit \n\n  end do \n\n  call Qsort(arr, low, j )\n\n  call Qsort(arr, i, high )\n\nEnd Subroutine Qsort\n\nThus, to call the sort: call qsort(array_sorted, 1, n)\n\nThus, in the main:\n\n    allocate(array_sorted(n))\n\n    array_sorted = arr \n\n    call qsort(array_sorted, 1, n )\n\nThen proceed with the processing.\n\nThus the code:\n\nNow back to main steps:\n\nAfter sorting:\n\nProcess the array_sorted.\n\nInitialize:\n\nallocate(u(n), counts_freq(n)) \n\nm=0\n\nmax_count =0 \n\ndo i =1 to n\n\ncurrent value = array_sorted(i)\n\nif m ==0 then:\n\n   m= 1 \n\n   u(1) = current value \n\n   counts_freq(1)=1 \n\n   max_count =1 \n\nelse \n\n   if ( current_value == u(m) ) then \n\n      counts_freq(m) +=1 \n\n      if (counts_freq(m) > max_count ) max_count = counts_freq(m) \n\n   else \n\n      m = m+1 \n\n      u(m) = current_value \n\n      counts_freq(m) =1 \n\n      if ( counts_freq(m) > max_count ) \n\n         max_count = counts_freq(m) \n\n   end if \n\nend if \n\nend do \n\nThus the loops ends.\n\nNow counts_so_far is to be initialized to zero for m elements:\n\nallocating counts_so_far(m) ?\n\nWait.\n\nallocate( counts_so_far(m) )\n\ncounts_so_far =0 \n\nthen: loop over the elements in arr in their original order.\n\ndo j =1, n \n\n   val = arr(j)\n\n   ! find val in u (1:m)\n\n   found_index is the position in u(1:m) where val is found.\n\n   found_idx = binary_search(u, m, val) \n\n   if (found_idx == -1) then \n\n      ! should not happen \n\n      print *, ' error'\n\n      stop \n\n   else \n\n      counts_so_far(found_idx) = counts_so_far(found_idx) +1 \n\n      if (counts_so_far(found_idx) == max_count ) then \n\n         write(*,*) val \n\n         deallocate all variables \n\n         stop \n\n      end if \n\n  end if \n\nend do \n\nThus, needs function for binary search.\n\nImplementing the binary search function as an internal function.\n\nWrite a function:\n\nFunction find_index( arr, n, target ) result ( idx )\n\nImplicit None\n\nInteger, Intent(in) :: arr(1:n), n, target \n\nInteger :: idx, low, high, mid \n\nidx = -1 \n\nlow =1 \n\nhigh = n \n\ndo while ( low <= high )\n\n   mid = (low + high)/2 \n\n   if ( arr(mid) == target ) then \n\n      idx = mid \n\n      exit \n\n   else if ( arr(mid) < target ) then \n\n      low = mid +1 \n\n   else \n\n      high = mid -1 \n\n   end if \n\nend do \n\nif ( low > high ) then \n\n   if ( low <=n .and. arr(low) == target ) idx = low\n\n   ! Wrong. Probably better to let the function return -1 \n\n   idk, maybe clean \n\nelse\n\n  idx is already set if found \n\nend \n\nResult is idx. \n\nThus, this function returns index if found else -1 \n\nWait but in our case, since val is in arr, and array_sorted includes all elements, and thus u includes all unique elements of original array (since we sorted and processed from there). \n\nHence u must contain val, thus function should find it. \n\nHence the function's result can be taken as:\n\nThe found_idx is nonzero.\n\nThercode for the function can be written inside the program.\n\nThus in code:\n\nInside the program, declare this function as an internal function:\n\nFUNCTION find_index( arr, len, target ) result(idx)\n\n   IMPLICIT NONE\n\n   INTEGER, INTENT(IN) :: arr(:), len, target\n\n   INTEGER :: idx, low, high, mid\n\n   idx = -1\n\n   low = 1\n\n   high = len\n\n   DO\n\n      IF (low > high) EXIT\n\n      mid = (low + high)/2\n\n      IF (arr(mid) == target) THEN\n\n         idx = mid\n\n         RETURN\n\n      ELSE IF (arr(mid) < target) THEN\n\n         low = mid + 1\n\n      ELSE \n\n         high = mid -1\n\n      END IF\n\n   END DO\n\n   RETURN\n\nEND FUNCTION find_index\n\nWait, but to use this function inside the main program, we need to declare it.\n\nSo in the main:\n\ncontains \n\n  function find_index( arr, n, target ) result ( idx )\n\n    ! definition as above\n\n  end function \n\nAlternatively, placing it after the declarations.\n\nHmm. Well, in the program's code, all functions must be declared within the program block or external. Since this is an internal function, it can be placed as a contained subroutine.\n\nThus, the code would look:\n\nInside main program:\n\n... (declarations)\n\ncontains \n\n  function find_index(arr, n, target) result (idx) \n\n    IMPLICIT NONE \n\n    integer, intent(in) :: arr(1:n), n, target \n\n    integer :: idx, low =1, high =n, mid \n\n    idx =-1 \n\n    do \n\n      if (low > high ) exit \n\n      mid = (low + high)/2 \n\n      if ( arr(mid) == target ) then \n\n        idx = mid \n\n        exit \n\n      else if ( arr(mid) < target ) then \n\n        low = mid +1 \n\n      else \n\n        high = mid-1 \n\n      end if \n\n    end do \n\n  end function find_index \n\n...\n\nThen, in the loop over arr(j's):\n\n...\n\nval = arr(j)\n\nfound_idx = find_index( u(1:m), m, val ) \n\nif (found_idx ==-1 ) then \n\n   print *, 'element not found' \n\n   stop \n\nelse \n\n   counts_so_far(found_idx) = counts_so_far(found_idx) +1 \n\n   if (counts_so_far(found_idx) == max_count ) then \n\n      print *, val \n\n      < free all memory and exit>\n\n   end if \n\nend if \n\nThus, this works.\n\nNow, after passing through all elements without finding, but this shouldn't happen. \n\nPutting all together, and making sure all variables are properly allocated and deallocated.\n\nNow, the code steps:\n\nAllocate all arrays and deallocate them at proper times. But in Fortran, deallocation can be placed at the end of the program. But since we have multiple allocations, perhaps deallocations are better.\n\nBut as a first pass, perhaps proceed step to write the code accurately.\n\nNow, listing all allocations and deallocations.\n\nSteps:\n\nRead n and array. Allocate arr(n). \n\nAllocate array_sorted(n). \n\nSorting. \n\nThen allocate u(n), counts_freq(n), m is updated. \n\nAllocate counts_so_far(m).\n\nAfter the second loop, deallocate arr, array_sorted, u, counts_freq, counts_so_far.\n\nBut in code:\n\nWait, the 'u' is stored in an array size n, but the actual size is m. \n\nHowever, the code can allocate counts_so_far(m). \n\nThus, the full code would be something like this:\n\nProgram codeforces_637_A\n\n  Implicit None\n\n  Integer :: n, i, j, m, max_count\n  Integer, Allocatable :: arr(:), u(:), array_sorted(:), counts_freq(:), counts_so_far(:)\n\n  Read *,n\n\n  Allocate( arr(n) )\n  Read *, (arr(i),i=1,n)\n\n  Allocate(array_sorted(n))\n  array_sorted = arr\n  Call Qsort(array_sorted, 1, n) ! Sort using quicksort\n\n  Allocate(u(n))\n  Allocate(counts_freq(n))\n\n  m =0\n  max_count =0\n\n  Do i = 1, n\n    Integer :: current_value = array_sorted(i)\n    If (m == 0) Then\n      m =1\n      u(1) = current_value\n      counts_freq(1) =1\n      max_count=1\n    Else\n      If (Current_value == u(m) ) Then\n        counts_freq(m)=counts_freq(m)+1\n        If (counts_freq(m) > max_count) max_count = counts_freq(m)\n      Else\n        m = m +1\n        u(m) = current_value\n        counts_freq(m) =1\n        If (1 > max_count) max_count=1   ! Probably not necessary, but needed for first entry.\n        If (counts_freq(m) > max_count) max_count = counts_freq(m)\n      Endif\n    Endif\n  End Do\n\n  Allocate(counts_so_far(m))\n  counts_so_far = 0\n\n  Do j =1, n\n    Integer :: val = arr(j), found_idx\n    found_idx = find_index(u(1:m), m, val)\n    counts_so_far(found_idx)= counts_so_far(found_idx)+1\n    If( counts_so_far(found_idx) == max_count ) Then\n      print *, val\n      Deallocate(arr, array_sorted, u, counts_freq, counts_so_far)\n      Stop\n    Endif\n  End Do ! should not reach here in valid input ?\n\n  ! Deallocation all others:\n  Deallocate(arr, array_sorted, u, counts_freq, counts_so_far)\n\nContains\n\n  ! QuickSort subroutine\n  Recursive Subroutine Qsort( arr, low, high )\n    Integer, Intent(INOUT) :: arr(:)\n    Integer, intent(IN) :: low, high\n    Integer :: i,j,pivot,temp\n    i = low\n    j = high\n    if( i >= j ) return\n    pivot = arr( (low + high)/2 )\n    do\n      do while( arr(i) < pivot )\n        i = i+1\n      end do\n      do while( arr(j) > pivot )\n        j = j-1\n      end do\n      if( i <= j ) then\n        temp = arr(i)\n        arr(i) = arr(j)\n        arr(j) = temp\n        i = i+1\n        j = j-1\n      end if\n      if( i > j ) exit\n    end do\n    Call Qsort( arr, low, j )\n    Call Qsort( arr, i, high )\n  End Subroutine Qsort\n\n  ! Find index function\n  Function find_index( arr, n, target ) Result ( idx )\n    Integer, Intent(IN) :: arr(1:n), n, target\n    Integer :: idx, low, high, mid\n    idx = -1\n    low =1\n    high =n\n    do\n      if( low > high ) exit\n      mid = (low + high)/2\n      if( arr(mid) == target ) then\n        idx = mid\n        exit\n      else if( arr(mid) < target ) then\n        low = mid+1\n      else\n        high = mid-1\n      end if\n    end do\n  End Function find_index\n\nEnd Program codeforces_637_A\n\nWait, the first assignment when counts_freq(m) is first set to1:\n\nSince in the else clause when adding new element:\n\nWhen it sets counts_freq(m) =1 and if (counts_freq(m) > max_count) then update.\n\nSince initially max_counts could be zero (if m was zero?), no. But in the case m starts at0 (if n=0?), which is probably not possible given the problem.\n\nBut when first element is processed, m starts at1 and counts_freq(1) is 1, max_count=1.\n\nThus perhaps in the else case:\n\nThe code for else can be better written as:\n\nElse\n\n    m = m+1 \n\n    u(m) = current_value \n\n    counts_freq(m) =1 \n\n    if (counts_freq(m) > max_count) then \n\n         max_count = counts_freq(m) \n\n    end if \n\nEnd if \n\nThis is better.\n\nThus in the code inside the Do i=1, n loop:\n\nAfter the code:\n\nElse \n\n  m = m +1 \n\n  u(m) = current_value \n\n  counts_freq(m) =1 \n\n  if (counts_freq(m) > max_count) then \n\n    max_count = counts_freq(m) \n\n  end if \n\nend i. \n\nYes, because when a new element is added, its count is 1. \n\nNow, testing the code.\n\nTest case: \n\nInput:\n\n5\n\n1 2 3 2 2 \n\nThe elements: 1,2,3,2,2 \u2192 \n\nSorted array:1, 2,2,2,3.\n\nProcessing sorted elements:\n\ni=1: m=0 \u2192 m becomes1, u(1)=1, counts_freq(1)=1 \u2192max becomes1 \n\ni=2: 2 !=u(m)=1 \u2192 new element. m becomes2, u(2)=2. count =1. max still 1 (since count is 1 not exceeding previous max).\n\ni=3: val=2 is equal to u(2)=2 \u2192 increment to 2 \u2192 new max. \n\ni=4 \u2192 val2 again \u2192 counts_freq(2)=3 \u2192 max becomes 3 now. \n\ni=5:3\u2192 new element: m=3\u2192u(3)=3, count1. \n\nThus max_count is 3.\n\nIn the second pass, the original array elements:\n\n1,2,3,2,2 \n\nProcess the first elements:\n\ncounts_so_far initialized to (0,0,0).\n\nFirst element 1:\n\nits found at index 1 of u \u2192 so increment counts_so_far(1) to1 \u2192 compare to max_count3. No.\n\nsecond element 2:\n\nfound at index2. counts becomes1 \u2192 <3.\n\nthird 3 \u2192 index3 \u2192 count1 \u2192 no \n\n4th element 2 \u2192 index2. count =2. \n\n5th element 2 \u2192 index2's count now3 \u2192 equals max_count \u2192 thus print 2. Program exits.\n\nSo the output should be 2. Which matches.\n\nAnother test case:\n\nInput 3\n\n3 2 3 \u2192 sorted: 2,3,3 \u2192 \n\nUnique elements 2(count1),3(count2). \n\nmax_count =2.\n\nOriginal array:3(first time count reaches 2 is at third element.\n\nSo steps:\n\nthird element is first time 3 reaches count2 \u2192 so third element is 3 \u2192 output3. \n\nThus the code works.\n\nNow, check if the code does that.\n\nIn code:\n\nOriginal array 3 is first element:\n\n_val =3 is in u \u2192 which now after sorting, the sorted array is [2,3,3]. \n\nso the unique arrays are:\n\nu(1)=2, u(2)=3 \u2192 m=2.\n\n counts_freq are [1,2] \u2192 max_count=2.\n\nThen, processing original array's first element 3:\n\nfound index2 \u2192 counts_so_far(2) becomes1 \u2192 less than max.\n\nsecond element is2 \u2192 j=2:\n\nelement2 \u2192 found at index1 \u2192 counts_so_far(1) becomes1.\n\nThird element:3 \u2192 \n\nAt j=3:\n\n_val=3 \u2192 index2.\n\ncounts_so_far(2) increments to 2 \u2192 equal to max_count (2).\n\nThus, program prints3.\n\nWhich is correct.\n\nAnother test case:\n\nInput 1\n\n1 \u2192 the output should be1.\n\nYes.\n\nNow, the code should handle these cases. \n\nEdge case where max_count is 1. \n\nE.g input n=4 elements all distinct. \n\noutput should be first element since they all have count 1 and first to reach that.\n\nThus the first occurrence is first element. \n\nHence the code *should * work.\n\nNow, in the code, need to ensure that when a new element is added to u (m increases), the maximum count can be considered, even if it's 1. \n\nThe code handles this.\n\nThus, the code above is correct.\n\nNow, I must write this into the Fortran code."
}