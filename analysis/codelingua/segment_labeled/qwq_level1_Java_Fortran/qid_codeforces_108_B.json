{
  "segments": [
    {
      "text": "Okay, I need to translate this Java code into Fortran.",
      "start_char": 0,
      "end_char": 54,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Let me start by understanding what the Java code does.",
      "start_char": 55,
      "end_char": 109,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The problem seems to check if there are two consecutive elements in a sorted array where the next element is less than twice the previous one and they are not equal.",
      "start_char": 110,
      "end_char": 275,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "If such a pair exists, it prints \"YES\", else \"NO\".",
      "start_char": 276,
      "end_char": 326,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "First, I need to see how the Java code works step by step.",
      "start_char": 328,
      "end_char": 386,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The Java code reads an integer n, then reads n integers into an array a. It sorts the array, then loops through each element except the last, checking if the next element is less than twice the current and they are not equal. If found, returns YES. So in Fortran, I need to replicate this.",
      "start_char": 387,
      "end_char": 676,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Let me think of the components: 1.",
      "start_char": 678,
      "end_char": 712,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Reading input: In Fortran, we can use read(*,*) for input. The first input is n.",
      "start_char": 714,
      "end_char": 794,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Then, an array of size n needs to be read. But how to dynamically allocate that array?",
      "start_char": 795,
      "end_char": 881,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Since Fortran 90 and above supports dynamic arrays. 2.",
      "start_char": 882,
      "end_char": 936,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Sorting the array: Fortran has the sort function. But I need to make sure to sort the array in ascending order. 3. Looping through the array: Once sorted, loop from i=1 to n-1 (since Fortran arrays are usually 1-based, but in the Java code, it's 0-based; or wait, no, the array index starts at 1 here?",
      "start_char": 939,
      "end_char": 1242,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Wait, in Fortran, the default is 1-based, unless specified otherwise. So I might need to adjust the indices.)",
      "start_char": 1243,
      "end_char": 1352,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Wait, in Java, the array is 0-based.",
      "start_char": 1354,
      "end_char": 1390,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "When the Java code loops for i from 0 to n-2, and checks a[i+1] < a[i] *2. So in Fortran, since arrays might start at 1, the loop should go from i=1 to n-1, and check a(i+1) < a(i)*2 and a(i) /=a(i+1). Wait, let's make sure. Let's see:\n\nOriginal Java code's loop:\n\nfor (int i = 0; i < a.length -1; i++)\n   check a[i+1] < a[i] * 2 etc.",
      "start_char": 1391,
      "end_char": 1727,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "In Java's array, a has indices 0 to n-1. So a.length is n, so a.length -1 is n-1, so i runs from 0 to n-2, which means a[i+1] runs up to a[n-1]. That's correct.",
      "start_char": 1729,
      "end_char": 1889,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "In Fortran, arrays can be 1-based.",
      "start_char": 1892,
      "end_char": 1926,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Let's define the array to be of size n starting at 1. So the elements are 1 to n. So the loop would be for i=1 to n-1. So steps in Fortran:\n\n- Read n from stdin.\n- Read the array of n integers.",
      "start_char": 1927,
      "end_char": 2120,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "- Sort the array in ascending order. - Loop over each element from i=1 to n-1:\n   - if a(i+1) < a(i)*2 and a(i) /= a(i+1) , then output YES and exit.",
      "start_char": 2123,
      "end_char": 2272,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "- If none found after loop, output NO. Okay. Now let's structure the Fortran code. First, declare variables.",
      "start_char": 2272,
      "end_char": 2380,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "n as integer, array a as integer array of size n. But in Fortran, arrays need to be declared with known dimensions.",
      "start_char": 2383,
      "end_char": 2498,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Since n is read first, this requires a dynamic allocation. Pro tip: Use a dynamic array. So code outline:\n\nprogram codeforces108b\n  implicit none\n  integer :: n, i\n  integer, dimension(:), allocatable :: a\n\n  ! Read n\n  read(*,*) n\n\n  !",
      "start_char": 2499,
      "end_char": 2735,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Allocate array\n  allocate(a(n))\n\n  ! Read array elements\n  read(*,*) (a(i), i=1, n)\n\n  !",
      "start_char": 2738,
      "end_char": 2826,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Sort the array in ascending order\n  call sort(a)\n\n  ! Loop through elements do i = 1, n-1\n     if (a(i+1) < 2*a(i) .and. a(i) /= a(i+1)) then\n        print*, 'YES'\n        stop\n     end if\n  end do\n\n  !",
      "start_char": 2827,
      "end_char": 3031,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "If loop completes without stopping, output NO\n  print*, 'NO'\n\n  !",
      "start_char": 3032,
      "end_char": 3097,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Deallocate array (not strictly needed as it's allocated in program scope and exit after)\n  deallocate(a)\n\nend program\n\nWait, but in Fortran, the sort routine. How do I sort?",
      "start_char": 3098,
      "end_char": 3271,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "The intrinsic function isated with the merge sort?\n\nWait, Fortran's intrinsic function is the 'sort' routine, but I need to make sure.",
      "start_char": 3272,
      "end_char": 3406,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Or perhaps better to use the intrinsic function sort from the standard library.",
      "start_char": 3407,
      "end_char": 3486,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "In Fortran 90 and above, there is the function 'sort' which can be used as a function, or there's a subroutine? Let me recall.",
      "start_char": 3488,
      "end_char": 3614,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Actually, the correct approach is to use the 'sort' intrinsic function.",
      "start_char": 3616,
      "end_char": 3687,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Wait, here's an example: \n\ncall merge_sort(a) isn't right because there's no merge_sort in standard. Ah right. The Fortran 95 language standard includes a fortran intrinsic like a=sort(a), but I think the correct syntax is using the intrinsic function sort.",
      "start_char": 3690,
      "end_char": 3948,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "Wait, perhaps:\n\nStarting in Fortran 95, you can use the 'sort' function in the 'ieee' module, but perhaps the easiest way is to use the standard sort by using the function from the intrinsic.",
      "start_char": 3949,
      "end_char": 4140,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, perhaps using the syntax:\n\ncall sort(a)\n\nBut that might not exist in the standard.",
      "start_char": 4141,
      "end_char": 4238,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Wait, maybe I'm confused between different versions or extensions. Wait, another approach.",
      "start_char": 4239,
      "end_char": 4329,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, I remember that in some compilers, the sort may be available via iso_fortran_env modules? Not that I recall.",
      "start_char": 4330,
      "end_char": 4453,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Alternatively, perhaps I should use the provided Qsort in some way, but in Fortran, Qsort is not standard. Wait, actually, the correct approach for Fortran is to use the intrinsic function \"SORT\", but the syntax is:\n\na = sort(a)\n\nWhich works. So yes. For kind=4 integers, the sort function can be used. Let me check.",
      "start_char": 4455,
      "end_char": 4772,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Suppose a is a rank-1 array, then sort(a) returns a sorted array in ascending order. So the code:\n\na = sort(a)\n\nwould sort the array.",
      "start_char": 4774,
      "end_char": 4907,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Yes, that's probably the standard way. Thus, the code will sort using a = sort(a). Then proceed with the loop. So let's rewrite code accordingly.",
      "start_char": 4909,
      "end_char": 5055,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Wait, code steps again:\n\nRead n.\n\nRead the array elements. Sort the array.",
      "start_char": 5058,
      "end_char": 5132,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Check for each consecutive pair.",
      "start_char": 5135,
      "end_char": 5167,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Wait, in code:\n\nAfter reading the array, we need to sort it. So:\n\n   a = sort(a) But in Fortran, the 'sort' function requires that we either have the same array type. Let me confirm the syntax.",
      "start_char": 5169,
      "end_char": 5362,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Wait, perhaps in some compiler, the sort is available, but in standard Fortran (F90/95) there is no such intrinsic. Wait!",
      "start_char": 5365,
      "end_char": 5486,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Wait, actually I think I might be mistaken here. Let me check standards.",
      "start_char": 5487,
      "end_char": 5559,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "Wait, looking up Fortran sort intrinsics. Hmm.",
      "start_char": 5561,
      "end_char": 5607,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Oh no, wait, maybe I was thinking of 'merge_sort' or similar.",
      "start_char": 5609,
      "end_char": 5670,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, perhaps the sort is part of the ISO module, but not standard?",
      "start_char": 5671,
      "end_char": 5747,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Ah yes, actually, the ISO Fortran does not have a sort intrinsic in the early versions.",
      "start_char": 5749,
      "end_char": 5836,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Wait, for Fortran 90, there is no built-in sort function. Oh, that complicates things. Then I have to implement sorting here? Oh that's a problem.",
      "start_char": 5838,
      "end_char": 5984,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Wait, the code I saw in the example might have to use other methods.",
      "start_char": 5986,
      "end_char": 6054,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Wait, perhaps the user expects that the code will utilize Fortran's sort method via some intrinsic, but if the standard doesn't have one, then we need to implement a sort. Hmm, this is a problem.",
      "start_char": 6056,
      "end_char": 6251,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Because the original Java code uses Arrays.sort, which is straightforward, but in Fortran without an intrinsic, we need to write a sort function. Hmm.",
      "start_char": 6253,
      "end_char": 6403,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "For simplicity's sake, maybe using a bubble sort would be manageable, since the problem probably has constraints on n?",
      "start_char": 6405,
      "end_char": 6523,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Or perhaps better use selection sort?",
      "start_char": 6524,
      "end_char": 6561,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, since the problem likely allows any sorting method as long as it's correct.",
      "start_char": 6563,
      "end_char": 6653,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, in some versions, perhaps the sort is available via the standard library function. Wait, let me think again.",
      "start_char": 6655,
      "end_char": 6778,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Wait, according to Fortran 2003 and 2008 standards, there's still no built-in sort. Hmm. So perhaps I need to write the sort subroutine.",
      "start_char": 6780,
      "end_char": 6916,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, perhaps some intrinsics with the help of pointers? Hmm, probably not.",
      "start_char": 6920,
      "end_char": 7004,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, use the 'SORT' function as an extension of the compiler.",
      "start_char": 7006,
      "end_char": 7077,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Like in gfortran, there is an intrinsic function called 'SORT', but is that standard? Let me check documentation.",
      "start_char": 7079,
      "end_char": 7192,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Looking up gfortran documentation.",
      "start_char": 7194,
      "end_char": 7228,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Ah, according to some references, the library includes 'sort' as an intrinsic function.",
      "start_char": 7231,
      "end_char": 7318,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "For GFortran, the sort function is available via the ISO_C_BINDING module?",
      "start_char": 7319,
      "end_char": 7393,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Or maybe it is part of the intrinsic functions. Wait here's some info: \n\nIn some docs, it is said that the Fortran 2008 added an intrinsic function 'sort', but it was not widely implemented yet.",
      "start_char": 7394,
      "end_char": 7588,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Wait, perhaps using a bubble sort here would be necessary unless it's a compiler-specific function.",
      "start_char": 7591,
      "end_char": 7690,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, perhaps I can use a selection sort.",
      "start_char": 7692,
      "end_char": 7742,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Since the problem is for code submission, the programmer has to be sure that the code compiles.",
      "start_char": 7744,
      "end_char": 7839,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Well, perhaps this is the crux of the problem.",
      "start_char": 7842,
      "end_char": 7888,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "Since the user asks to translate the java code into Fortran, and in the Java code, Arrays.sort is used.",
      "start_char": 7889,
      "end_char": 7992,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Assuming the Fortran code is for a system where the sort function is available, perhaps it's better to proceed with that. Assuming that the Fortran compiler has access to a sort function via a = sort(a).",
      "start_char": 7995,
      "end_char": 8199,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, perhaps the 'sorted()' function is available in some compilers.",
      "start_char": 8202,
      "end_char": 8280,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Alternatively, perhaps the code can include the sort via a routine like:\n\nHere's an idea: perhaps use a simple bubble sort to sort the array.",
      "start_char": 8283,
      "end_char": 8424,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Since in the problem's scope, it might be acceptable, especially for small n.",
      "start_char": 8425,
      "end_char": 8502,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "Well, the problem might have a small n, but I should not assume. So maybe better to write a sort function.",
      "start_char": 8504,
      "end_char": 8610,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Let me proceed with writing a simple bubble sort, as it's easy to code, even if it's not the most efficient. So, here's the plan:",
      "start_char": 8612,
      "end_char": 8741,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Define a sub-routine to sort the array. Alternatively, here's the code with bubble sort:\n\nInside the main program:\n\n    do i = 1, n-1\n        do j = 1, n -i\n            if (a(j) > a(j+1)) then\n                temp = a(j)\n                a(j) = a(j+1)\n                a(j+1) = temp\n            end if\n        end do\n    end do\n\nThis is a ascending order bubble sort. So integrating this into the code. So replacing the 'a = sort(a)' step with this nested loop.",
      "start_char": 8744,
      "end_char": 9206,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Alternatively, maybe selection sort is better for code brevity.",
      "start_char": 9208,
      "end_char": 9271,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, perhaps the selection sort would be: But perhaps it's better to code a separate subroutine.",
      "start_char": 9273,
      "end_char": 9379,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, in any case, perhaps implementing bubble sort in-line.",
      "start_char": 9382,
      "end_char": 9451,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Therefore, let me adjust the code accordingly.",
      "start_char": 9453,
      "end_char": 9499,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "Putting it all together:\n\nThe code will be something like this:\n\nprogram codeforces_108b\n  implicit none\n  integer :: n, i, j, temp\n  integer, dimension(:), allocatable :: a\n\n  ! Read input\n  read(*, *) n\n  allocate(a(n))\n  read(*, *) (a(i), i = 1, n)\n\n  ! Sort using bubble sort\n  do i = 1, n - 1\n      do j = 1, n - i\n          if (a(j) > a(j+1)) then\n              temp = a(j)\n              a(j) = a(j+1)\n              a(j+1) = temp\n          end if\n      end do\n  end do\n\n  ! Check consecutive elements do i = 1, n-1\n      if (a(i+1) < 2*a(i) .and. a(i) /= a(i+1)) then\n          print*, 'YES'\n          stop\n      end if\n  end do\n\n  print*, 'NO'\n  deallocate(a)\nend program codeforces_108b\n\nHmm. That's one possible approach.",
      "start_char": 9501,
      "end_char": 10233,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Alternatively, using selection sort may be better (similar or better time, but perhaps easier?). For selection sort:\n\ndo i = 1 to n-1\n   min_index = i\n   for j = i+1 to n:\n      if a(j) < a(min_index), then min_index = j\n   swap a(i) and a(min_index)\nend do \n\nPerhaps that's better code? Let me see:\n\nThe selection sort code would look like:\n\ndo i = 1, n-1\n   imin = i\n    do j =i+1, n\n        if (a(j) < a(imin)) then\n            imin = j\n        end if\n    end do\n    ! Swap\n    temp = a(i)\n    a(i) = a(imin)\n    a(imin) = temp\nend do\n\nThis may be faster than bubble sort for larger arrays, but in any case, for the code submission's purpose, it may be acceptable.",
      "start_char": 10235,
      "end_char": 10903,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Hmm, but implementing it as part of the code may be straightforward.",
      "start_char": 10906,
      "end_char": 10974,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Using selection sort in the code might be better, but either way. In the previous bubble code, the sort part will take O(n\u00b2), which for the problem's constraints (since the Java code likely can handle that; the original problem must have constraints where n is okay with O(n^2).) Alternatively, perhaps the problem expects that a fortran sort like a=sort(a) can be used. But if the compiler supports that, then let's see.\n\nAlternatively, let me check if the 'SORT' function is present.",
      "start_char": 10976,
      "end_char": 11463,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "In some environments, the 'sort' function is available via the DIM module?",
      "start_char": 11465,
      "end_char": 11539,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Or perhaps in gfortran?\n\nWait, according to Gfortran documentation, they mention that the 'sort' function is available as an intrinsic in the library.",
      "start_char": 11540,
      "end_char": 11690,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Looking it up: in CPP's gfortran:\n\nThe Fortran intrinsic function sort is available in fortran 2003?",
      "start_char": 11692,
      "end_char": 11792,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Or perhaps in gfortran extensions. Wait according to the gfortran documentation here:\n\nhttps://gcc.gnu.org/onlinedocs/gfortran/Fortran-Intrinsic-Procedures.html\n\nNot seeing a sort function.",
      "start_char": 11793,
      "end_char": 11982,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Alternatively, looking for fortran sort function:\n\nUpon searching, I see some references to the 'sort' function for arrays being present in the max and min sections.",
      "start_char": 11985,
      "end_char": 12150,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Alternatively, perhaps using the 'heap sort' method?",
      "start_char": 12151,
      "end_char": 12203,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, perhaps a better approach here.",
      "start_char": 12205,
      "end_char": 12251,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Since this is a code translation, the user may expect that we use the quicksort intrinsic. But if the compiler does not allow that, then it's a problem.",
      "start_char": 12252,
      "end_char": 12404,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Since the problem's code is in a judge server, perhaps we have to rely on available functions?",
      "start_char": 12405,
      "end_char": 12499,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, the safest way perhaps to write a sort subroutine.",
      "start_char": 12501,
      "end_char": 12566,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, since code translation would require the same logic, but in Fortran.",
      "start_char": 12568,
      "end_char": 12651,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Alternatively, perhaps in fortran, the best approach is to use the built-in sort if it exists.",
      "start_char": 12653,
      "end_char": 12747,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Let me think of code written in a portable way without compiler extensions.",
      "start_char": 12748,
      "end_char": 12823,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Wait, perhaps the user just expects a direct translation, and the sort can be assumed to be available? For the purpose of this exercise, maybe proceed under the assumption that the sort function is available as a = sort(a). Let's try that. So here's the code with that assumption:\n\nprogram codeforces_108b\n  implicit none\n  integer :: n, i\n  integer, allocatable :: a(:)\n\n  read(*,*) n\n  allocate(a(n))\n  read(*,*) a\n\n  a = sort(a) do i = 1, n-1\n      if ( a(i+1) < 2*a(i) .and. a(i) /= a(i+1) ) then\n          print*, 'YES'\n          stop\n      end if\n  end do\n\n  print*, 'NO'\n  deallocate(a)\nend program codeforces_108b But again, the question is whether the sort function is available.",
      "start_char": 12825,
      "end_char": 13517,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Since in Java, the array is sorted with Arrays.sort(a). So perhaps in the problem's context, to translate literally, the expectation is to use the Fortran equivalent.",
      "start_char": 13519,
      "end_char": 13685,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Alternatively, perhaps the code will be compiled with GFortran and the 'sort' function works there. But in gfortran, does the sort function exist?",
      "start_char": 13688,
      "end_char": 13834,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Upon further checking, in some recent GFortran versions, the 'sort' function may be available, but I need to confirm.",
      "start_char": 13837,
      "end_char": 13954,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Wait, here's a link to a question where someone mentions 'sort' in Fortran:\n\nIn stackoverflow, someone says:\n\n\"For the standard sort function, one can use the sort function in Fortran 2008, which is part of the intrinsic functions.",
      "start_char": 13956,
      "end_char": 14187,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "However, its availability depends on the compiler.",
      "start_char": 14188,
      "end_char": 14238,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "\"\n\nAnother answer mentions that in GFortran 4.6+, the regular C qsort is called.",
      "start_char": 14238,
      "end_char": 14318,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Wait, perhaps it's an extended function in GFortran.",
      "start_char": 14320,
      "end_char": 14372,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Alternatively, looking into examples.",
      "start_char": 14375,
      "end_char": 14412,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "In the example here: \n\nhttps://gfortran.readthedocs.io/en/latest/testarray/ArrayExamples.html#sorting-an-array:\n\nNo, perhaps the function is not standard.",
      "start_char": 14414,
      "end_char": 14568,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Alternatively, searching a GFortran documentation for 'sort' shows that there's no intrinsic function of that name. Hmm.",
      "start_char": 14570,
      "end_char": 14690,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Therefore, I think the proper way is to implement the bubble or selection sort here.",
      "start_char": 14692,
      "end_char": 14776,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "So, it's better to write the sorting loop here.",
      "start_char": 14778,
      "end_char": 14825,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Thus, returning to previous code using bubble sort. Let's use that. So here's the main code step.",
      "start_char": 14827,
      "end_char": 14924,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Wait, here's the full code with bubble sort as above.",
      "start_char": 14927,
      "end_char": 14980,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "Wait, let me recheck the indices in the bubble sort loop. In the code I had:\n\n do i=1, n-1\n    do j=1, n-i\n       if (a(j) > a(j+1)), etc.",
      "start_char": 14982,
      "end_char": 15121,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Wait, this is standard bubble sort.",
      "start_char": 15123,
      "end_char": 15158,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The outer loop runs for n-1 times.",
      "start_char": 15159,
      "end_char": 15193,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Each time, the largest element \"bubbles\" to the top.",
      "start_char": 15194,
      "end_char": 15246,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "The inner loop goes up to n-i.\n\nWait, but in the inner loop,",
      "start_char": 15247,
      "end_char": 15307,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "how to?\n\nWait, in the inner loop:\n\nfor j from 1 to (n - i): Wait, in Fortran, the inner loop would be:\n\ndo j = 1, n - i\n\n    compare a(j) and a(j+1)\n\n    if (a(j) > a(j+1)), swap. end do\n\nSo that the inner loop runs from 1 to (n-i), which for the first iteration (i=1), the inner loop runs up to n-1, comparing all adjacent pairs. Then each subsequent outer loop iteration reduces the uppper limit by 1 because each pass puts the next highest element at the end. This should work. So the bubble sort is correctly implemented. Now proceeding with the code.",
      "start_char": 15308,
      "end_char": 15865,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Let me write it again:\n\nprogram codeforces_108b\n  implicit none\n  integer :: n, i_sorted, i, j, temp\n  integer, dimension(:), allocatable :: a\n\n  !",
      "start_char": 15868,
      "end_char": 16015,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Read the number of elements\n  read(*,*) n\n\n  !",
      "start_char": 16016,
      "end_char": 16062,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Allocate the array\n  allocate(a(n))\n\n  ! Read the array\n  read(*,*) (a(i), i=1, n)\n\n  ! Sort using bubble sort\n  do i_sorted = 1, n -1\n      do j = 1, n - i_sorted\n          if (a(j) > a(j+1)) then\n              temp = a(j)\n              a(j) = a(j+1)\n              a(j+1) = temp\n          end if\n      end do\n  end do\n\n  ! Check for required condition\n  do i =1, n-1\n      if ( a(i+1) < 2 * a(i) .and. a(i) /= a(i+1) ) then\n          print*, 'YES'\n          stop\n      end if\n  end do\n\n  !",
      "start_char": 16063,
      "end_char": 16553,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "If nothing found, output NO\n  print*, 'NO'\n\n  !",
      "start_char": 16554,
      "end_char": 16601,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Deallocate the array\n  deallocate(a)\nend program codeforces_108b\n\nWait, but when reading elements, in fortran, the read statement can also be read(*,*) a, which reads the entire array. Let me check:\n\nInstead of:\n\n  read(*,*) (a(i), i=1, n)\n\nYou can just do:\n\nread(*,*) a\n\nas 'a' is a one-dimensional array, the whole array can be read in a single statement. So the line can be simplified to read(*,*) a.\n\nThat would be better.",
      "start_char": 16602,
      "end_char": 17028,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Similarly, when using the allocation and read, that would be better. So adjusting that:\n\n  allocate(a(n))\n  read(*,*) a\n\nFaster and cleaner.",
      "start_char": 17032,
      "end_char": 17172,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Thus, the entire code is as follows, with bubble sort.",
      "start_char": 17175,
      "end_char": 17229,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, the selection sort may be more efficient but let's stick to bubble for now.",
      "start_char": 17231,
      "end_char": 17321,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Now, check for other discrepancy between Java and Fortran:",
      "start_char": 17323,
      "end_char": 17381,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "In Java, the condition is a[i+1] < a[i] * 2 and a[i] ! = a[i+1]).",
      "start_char": 17383,
      "end_char": 17447,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The Fortran code has the same condition: if (a(i+1) < 2*a(i) .and. a(i) /= a(i+1)) , then output yes.",
      "start_char": 17450,
      "end_char": 17551,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Yes, because 2*a(i) is the same as a[i] * 2.",
      "start_char": 17552,
      "end_char": 17596,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Wait, but maybe the multiplication order matters for integers? No, it's the same operation.",
      "start_char": 17599,
      "end_char": 17690,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Wait, a[i+1] has to be strictly less than double the previous element, and they are not equal.",
      "start_char": 17693,
      "end_char": 17787,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Because if they are equal, then even a[i]*2 might be larger than a[i+1], but since they are equal, the condition is triggered only when the next element is strictly less. Wait, the condition 'a[i] ! = a[i+1]' ensures that when elements are equal, even if the multiple is less, it's not counted. Wait, no, 2*a[i] when a[i] and a[j] are equal would be 2 a[i], so a[i+1] would have to be less than that, but since equal to it, a[i+1] is a[i], so 2 a[i] would be bigger, so \n\nIf a[i] = a[i+1], then (a[i+1] < 2a[i]) is true (because a[i+1] equals a[i], which is less than 2a[i] provided a[i]>0), but the second condition says a[i] must be not equal. Wait, right. So when a[i] equals a[i+1], even though a[i+1] is less than 2* a[i], the condition a[i] ! = a[i+1] would make the overall condition false. Thus, the code is correct. So the Fortran code condition is correct.",
      "start_char": 17788,
      "end_char": 18655,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Now, what about the data types?",
      "start_char": 18658,
      "end_char": 18689,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "Java uses int, which is typically 32 bits.",
      "start_char": 18691,
      "end_char": 18733,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "In Fortran, integers are 4 bytes (default), but in any case, unless specified, it's okay.",
      "start_char": 18734,
      "end_char": 18823,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "The code uses integer variables, so the type is correct.",
      "start_char": 18826,
      "end_char": 18882,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Also, the print statements output YES or NO correctly. Now, testing some cases.",
      "start_char": 18884,
      "end_char": 18963,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "For example, let's take Java code example.",
      "start_char": 18966,
      "end_char": 19008,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Test case where input is 3 1 2 3.",
      "start_char": 19010,
      "end_char": 19043,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "The array when sorted is [1,2,3].",
      "start_char": 19045,
      "end_char": 19078,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Checking pairs: \n\nBetween 1 and 2: 2 < 1*2? 2 is not <2, so no.",
      "start_char": 19081,
      "end_char": 19144,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Between 2 and 3: 3 < 2*2? 3 <4 yes. And 2 !=3. So the code would print YES. Wait but in Fortran code: Wait, first pair (1 and 2): 2 < 2 (2*a[i] is 2*1=2. 2 is not less than that. So first condition fails. Second pair between 2 and 3: 3 <4 (yes?), and 2 !=3. So yes.",
      "start_char": 19146,
      "end_char": 19413,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Thus, in that case, prints yes.",
      "start_char": 19416,
      "end_char": 19447,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Another test: input is 2 numbers 5 9.\n\nsorted as 5,9. Check 9 <10? yes. and 5 !=9. hence YES. So the code should output yes.",
      "start_char": 19449,
      "end_char": 19575,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Another test: input 3, numbers 4 5 8.\n\nsorted [4,5,8].",
      "start_char": 19578,
      "end_char": 19632,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Check:\n\n5 < 8? 5 <8, but 5 < 4*2 (8) ?",
      "start_char": 19634,
      "end_char": 19672,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Wait, the first check: between 4 and5: 5 < 8? 4*2 is 8. 5 < 8 is yes, but 5 < 8? yes. But the condition is a[i+1] <2*a[i]. Wait for first pair 4 and5:\n\na[i]=4, a[i+1] =5. \n\n5 < 2*4 =8. So yes. But also check that a[i] ! =a[i+1], which they are.",
      "start_char": 19674,
      "end_char": 19919,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Thus, the code would output YES right away here. Yes, correct.",
      "start_char": 19922,
      "end_char": 19984,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Another test case where the answer is NO : \n\nInput 3 numbers 1,3, 4. Sorted array is [1,3,4]\n\nCheck 3 <2? no. 3 not less than 2*1=2. 3 is more than 2. So first pair condition is false. Next, 4 < 3*2? 4 <6, yes. But 3 and4, so their difference. 3 ! =4. Thus condition holds, so it would output YES. Wait in this test, the code would say YES, because between 3 and4: 4 < 6 (yes). Another test case where answer is NO. \n\nSuppose the input is 2 numbers 3 and 6. \n\nsorted [3,6]\n\nCheck 6 < 2*3 =>6 <6? no. So 6 is not less than 6. so the first condition is not met. Also, 3 !=6, so the second condition is true. But since the first condition (6 <6?) is false, so condition is false.",
      "start_char": 19987,
      "end_char": 20667,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Thus, the code would loop over that and since no pairs found, output No.\n\nAnother test: two numbers 3 and 6. So the code returns NO.",
      "start_char": 20670,
      "end_char": 20802,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Another case where two numbers: 3 and 5. Check 5 <6 \u2192 yes.",
      "start_char": 20804,
      "end_char": 20862,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "and they are not equal, so returns YES. So all these cases work with the code.",
      "start_char": 20865,
      "end_char": 20943,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Therefore, the code should be correct.",
      "start_char": 20948,
      "end_char": 20986,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "Another test case where input is 5 elements: 4,2,1,3,5.",
      "start_char": 20988,
      "end_char": 21043,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "Converted to fortran, the code first sorts them as [1,2,3,4,5]. Then check between 1 and2: 2 <2 \u2192 no. 2<2*1 \u2192 2=2 \u2192 not less. Next pair between 2 and3: 3 <4 \u2192 yes. So the code would immediately output YES. Thus the code would catch it. Yes. Thus the translation is correct.",
      "start_char": 21045,
      "end_char": 21319,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    }
  ],
  "original_reasoning": "Okay, I need to translate this Java code into Fortran. Let me start by understanding what the Java code does. The problem seems to check if there are two consecutive elements in a sorted array where the next element is less than twice the previous one and they are not equal. If such a pair exists, it prints \"YES\", else \"NO\".\n\nFirst, I need to see how the Java code works step by step. The Java code reads an integer n, then reads n integers into an array a. It sorts the array, then loops through each element except the last, checking if the next element is less than twice the current and they are not equal. If found, returns YES.\n\nSo in Fortran, I need to replicate this. Let me think of the components:\n\n1. Reading input: In Fortran, we can use read(*,*) for input. The first input is n. Then, an array of size n needs to be read. But how to dynamically allocate that array? Since Fortran 90 and above supports dynamic arrays. \n\n2. Sorting the array: Fortran has the sort function. But I need to make sure to sort the array in ascending order. \n\n3. Looping through the array: Once sorted, loop from i=1 to n-1 (since Fortran arrays are usually 1-based, but in the Java code, it's 0-based; or wait, no, the array index starts at 1 here? Wait, in Fortran, the default is 1-based, unless specified otherwise. So I might need to adjust the indices.)\n\nWait, in Java, the array is 0-based. When the Java code loops for i from 0 to n-2, and checks a[i+1] < a[i] *2. So in Fortran, since arrays might start at 1, the loop should go from i=1 to n-1, and check a(i+1) < a(i)*2 and a(i) /=a(i+1). \n\nWait, let's make sure. Let's see:\n\nOriginal Java code's loop:\n\nfor (int i = 0; i < a.length -1; i++)\n   check a[i+1] < a[i] * 2 etc.\n\nIn Java's array, a has indices 0 to n-1. So a.length is n, so a.length -1 is n-1, so i runs from 0 to n-2, which means a[i+1] runs up to a[n-1]. That's correct. \n\nIn Fortran, arrays can be 1-based. Let's define the array to be of size n starting at 1. So the elements are 1 to n. So the loop would be for i=1 to n-1. \n\nSo steps in Fortran:\n\n- Read n from stdin.\n- Read the array of n integers.\n- Sort the array in ascending order.\n- Loop over each element from i=1 to n-1:\n   - if a(i+1) < a(i)*2 and a(i) /= a(i+1), then output YES and exit.\n- If none found after loop, output NO.\n\nOkay. Now let's structure the Fortran code.\n\nFirst, declare variables. n as integer, array a as integer array of size n. But in Fortran, arrays need to be declared with known dimensions. Since n is read first, this requires a dynamic allocation.\n\nPro tip: Use a dynamic array.\n\nSo code outline:\n\nprogram codeforces108b\n  implicit none\n  integer :: n, i\n  integer, dimension(:), allocatable :: a\n\n  ! Read n\n  read(*,*) n\n\n  ! Allocate array\n  allocate(a(n))\n\n  ! Read array elements\n  read(*,*) (a(i), i=1, n)\n\n  ! Sort the array in ascending order\n  call sort(a)\n\n  ! Loop through elements\n  do i = 1, n-1\n     if (a(i+1) < 2*a(i) .and. a(i) /= a(i+1)) then\n        print*, 'YES'\n        stop\n     end if\n  end do\n\n  ! If loop completes without stopping, output NO\n  print*, 'NO'\n\n  ! Deallocate array (not strictly needed as it's allocated in program scope and exit after)\n  deallocate(a)\n\nend program\n\nWait, but in Fortran, the sort routine. How do I sort? The intrinsic function isated with the merge sort?\n\nWait, Fortran's intrinsic function is the 'sort' routine, but I need to make sure. Or perhaps better to use the intrinsic function sort from the standard library.\n\nIn Fortran 90 and above, there is the function 'sort' which can be used as a function, or there's a subroutine? Let me recall.\n\nActually, the correct approach is to use the 'sort' intrinsic function. \n\nWait, here's an example: \n\ncall merge_sort(a) isn't right because there's no merge_sort in standard.\n\nAh right. The Fortran 95 language standard includes a fortran intrinsic like a=sort(a), but I think the correct syntax is using the intrinsic function sort. Wait, perhaps:\n\nStarting in Fortran 95, you can use the 'sort' function in the 'ieee' module, but perhaps the easiest way is to use the standard sort by using the function from the intrinsic. Alternatively, perhaps using the syntax:\n\ncall sort(a)\n\nBut that might not exist in the standard. Wait, maybe I'm confused between different versions or extensions. Wait, another approach. Alternatively, I remember that in some compilers, the sort may be available via iso_fortran_env modules? Not that I recall.\n\nAlternatively, perhaps I should use the provided Qsort in some way, but in Fortran, Qsort is not standard.\n\nWait, actually, the correct approach for Fortran is to use the intrinsic function \"SORT\", but the syntax is:\n\na = sort(a)\n\nWhich works. So yes. For kind=4 integers, the sort function can be used. Let me check.\n\nSuppose a is a rank-1 array, then sort(a) returns a sorted array in ascending order. So the code:\n\na = sort(a)\n\nwould sort the array.\n\nYes, that's probably the standard way.\n\nThus, the code will sort using a = sort(a). Then proceed with the loop.\n\nSo let's rewrite code accordingly.\n\nWait, code steps again:\n\nRead n.\n\nRead the array elements.\n\nSort the array.\n\nCheck for each consecutive pair.\n\nWait, in code:\n\nAfter reading the array, we need to sort it. So:\n\n   a = sort(a)\n\nBut in Fortran, the 'sort' function requires that we either have the same array type. Let me confirm the syntax.\n\nWait, perhaps in some compiler, the sort is available, but in standard Fortran (F90/95) there is no such intrinsic. Wait! Wait, actually I think I might be mistaken here. Let me check standards.\n\nWait, looking up Fortran sort intrinsics.\n\nHmm. Oh no, wait, maybe I was thinking of 'merge_sort' or similar. Alternatively, perhaps the sort is part of the ISO module, but not standard?\n\nAh yes, actually, the ISO Fortran does not have a sort intrinsic in the early versions.\n\nWait, for Fortran 90, there is no built-in sort function. Oh, that complicates things. Then I have to implement sorting here? Oh that's a problem.\n\nWait, the code I saw in the example might have to use other methods.\n\nWait, perhaps the user expects that the code will utilize Fortran's sort method via some intrinsic, but if the standard doesn't have one, then we need to implement a sort.\n\nHmm, this is a problem. Because the original Java code uses Arrays.sort, which is straightforward, but in Fortran without an intrinsic, we need to write a sort function.\n\nHmm. For simplicity's sake, maybe using a bubble sort would be manageable, since the problem probably has constraints on n? Or perhaps better use selection sort?\n\nAlternatively, since the problem likely allows any sorting method as long as it's correct.\n\nAlternatively, in some versions, perhaps the sort is available via the standard library function.\n\nWait, let me think again. Wait, according to Fortran 2003 and 2008 standards, there's still no built-in sort. \n\nHmm. So perhaps I need to write the sort subroutine.\n\nAlternatively, perhaps some intrinsics with the help of pointers? Hmm, probably not.\n\nAlternatively, use the 'SORT' function as an extension of the compiler.\n\nLike in gfortran, there is an intrinsic function called 'SORT', but is that standard? Let me check documentation.\n\nLooking up gfortran documentation. \n\nAh, according to some references, the library includes 'sort' as an intrinsic function. For GFortran, the sort function is available via the ISO_C_BINDING module? Or maybe it is part of the intrinsic functions.\n\nWait here's some info: \n\nIn some docs, it is said that the Fortran 2008 added an intrinsic function 'sort', but it was not widely implemented yet.\n\nWait, perhaps using a bubble sort here would be necessary unless it's a compiler-specific function.\n\nAlternatively, perhaps I can use a selection sort.\n\nSince the problem is for code submission, the programmer has to be sure that the code compiles. \n\nWell, perhaps this is the crux of the problem. Since the user asks to translate the java code into Fortran, and in the Java code, Arrays.sort is used. \n\nAssuming the Fortran code is for a system where the sort function is available, perhaps it's better to proceed with that.\n\nAssuming that the Fortran compiler has access to a sort function via a = sort(a). \n\nAlternatively, perhaps the 'sorted()' function is available in some compilers. \n\nAlternatively, perhaps the code can include the sort via a routine like:\n\nHere's an idea: perhaps use a simple bubble sort to sort the array. Since in the problem's scope, it might be acceptable, especially for small n.\n\nWell, the problem might have a small n, but I should not assume. So maybe better to write a sort function.\n\nLet me proceed with writing a simple bubble sort, as it's easy to code, even if it's not the most efficient.\n\nSo, here's the plan:\n\nDefine a sub-routine to sort the array. \n\nAlternatively, here's the code with bubble sort:\n\nInside the main program:\n\n    do i = 1, n-1\n        do j = 1, n -i\n            if (a(j) > a(j+1)) then\n                temp = a(j)\n                a(j) = a(j+1)\n                a(j+1) = temp\n            end if\n        end do\n    end do\n\nThis is a ascending order bubble sort. So integrating this into the code.\n\nSo replacing the 'a = sort(a)' step with this nested loop.\n\nAlternatively, maybe selection sort is better for code brevity.\n\nAlternatively, perhaps the selection sort would be:\n\nBut perhaps it's better to code a separate subroutine.\n\nAlternatively, in any case, perhaps implementing bubble sort in-line.\n\nTherefore, let me adjust the code accordingly.\n\nPutting it all together:\n\nThe code will be something like this:\n\nprogram codeforces_108b\n  implicit none\n  integer :: n, i, j, temp\n  integer, dimension(:), allocatable :: a\n\n  ! Read input\n  read(*, *) n\n  allocate(a(n))\n  read(*, *) (a(i), i = 1, n)\n\n  ! Sort using bubble sort\n  do i = 1, n - 1\n      do j = 1, n - i\n          if (a(j) > a(j+1)) then\n              temp = a(j)\n              a(j) = a(j+1)\n              a(j+1) = temp\n          end if\n      end do\n  end do\n\n  ! Check consecutive elements\n  do i = 1, n-1\n      if (a(i+1) < 2*a(i) .and. a(i) /= a(i+1)) then\n          print*, 'YES'\n          stop\n      end if\n  end do\n\n  print*, 'NO'\n  deallocate(a)\nend program codeforces_108b\n\nHmm. That's one possible approach.\n\nAlternatively, using selection sort may be better (similar or better time, but perhaps easier?).\n\nFor selection sort:\n\ndo i = 1 to n-1\n   min_index = i\n   for j = i+1 to n:\n      if a(j) < a(min_index), then min_index = j\n   swap a(i) and a(min_index)\nend do \n\nPerhaps that's better code? Let me see:\n\nThe selection sort code would look like:\n\ndo i = 1, n-1\n   imin = i\n    do j =i+1, n\n        if (a(j) < a(imin)) then\n            imin = j\n        end if\n    end do\n    ! Swap\n    temp = a(i)\n    a(i) = a(imin)\n    a(imin) = temp\nend do\n\nThis may be faster than bubble sort for larger arrays, but in any case, for the code submission's purpose, it may be acceptable. \n\nHmm, but implementing it as part of the code may be straightforward.\n\nUsing selection sort in the code might be better, but either way.\n\nIn the previous bubble code, the sort part will take O(n\u00b2), which for the problem's constraints (since the Java code likely can handle that; the original problem must have constraints where n is okay with O(n^2).)\n\nAlternatively, perhaps the problem expects that a fortran sort like a=sort(a) can be used. But if the compiler supports that, then let's see.\n\nAlternatively, let me check if the 'SORT' function is present.\n\nIn some environments, the 'sort' function is available via the DIM module? Or perhaps in gfortran?\n\nWait, according to Gfortran documentation, they mention that the 'sort' function is available as an intrinsic in the library.\n\nLooking it up: in CPP's gfortran:\n\nThe Fortran intrinsic function sort is available in fortran 2003? Or perhaps in gfortran extensions.\n\nWait according to the gfortran documentation here:\n\nhttps://gcc.gnu.org/onlinedocs/gfortran/Fortran-Intrinsic-Procedures.html\n\nNot seeing a sort function.\n\nAlternatively, looking for fortran sort function:\n\nUpon searching, I see some references to the 'sort' function for arrays being present in the max and min sections. Alternatively, perhaps using the 'heap sort' method?\n\nAlternatively, perhaps a better approach here. Since this is a code translation, the user may expect that we use the quicksort intrinsic. But if the compiler does not allow that, then it's a problem. Since the problem's code is in a judge server, perhaps we have to rely on available functions?\n\nAlternatively, the safest way perhaps to write a sort subroutine.\n\nAlternatively, since code translation would require the same logic, but in Fortran.\n\nAlternatively, perhaps in fortran, the best approach is to use the built-in sort if it exists. Let me think of code written in a portable way without compiler extensions.\n\nWait, perhaps the user just expects a direct translation, and the sort can be assumed to be available? For the purpose of this exercise, maybe proceed under the assumption that the sort function is available as a = sort(a). Let's try that.\n\nSo here's the code with that assumption:\n\nprogram codeforces_108b\n  implicit none\n  integer :: n, i\n  integer, allocatable :: a(:)\n\n  read(*,*) n\n  allocate(a(n))\n  read(*,*) a\n\n  a = sort(a)\n\n  do i = 1, n-1\n      if ( a(i+1) < 2*a(i) .and. a(i) /= a(i+1) ) then\n          print*, 'YES'\n          stop\n      end if\n  end do\n\n  print*, 'NO'\n  deallocate(a)\nend program codeforces_108b\n\nBut again, the question is whether the sort function is available. Since in Java, the array is sorted with Arrays.sort(a).\n\nSo perhaps in the problem's context, to translate literally, the expectation is to use the Fortran equivalent.\n\nAlternatively, perhaps the code will be compiled with GFortran and the 'sort' function works there.\n\nBut in gfortran, does the sort function exist?\n\nUpon further checking, in some recent GFortran versions, the 'sort' function may be available, but I need to confirm.\n\nWait, here's a link to a question where someone mentions 'sort' in Fortran:\n\nIn stackoverflow, someone says:\n\n\"For the standard sort function, one can use the sort function in Fortran 2008, which is part of the intrinsic functions. However, its availability depends on the compiler.\"\n\nAnother answer mentions that in GFortran 4.6+, the regular C qsort is called.\n\nWait, perhaps it's an extended function in GFortran. \n\nAlternatively, looking into examples.\n\nIn the example here: \n\nhttps://gfortran.readthedocs.io/en/latest/testarray/ArrayExamples.html#sorting-an-array:\n\nNo, perhaps the function is not standard.\n\nAlternatively, searching a GFortran documentation for 'sort' shows that there's no intrinsic function of that name.\n\nHmm. Therefore, I think the proper way is to implement the bubble or selection sort here.\n\nSo, it's better to write the sorting loop here.\n\nThus, returning to previous code using bubble sort. Let's use that.\n\nSo here's the main code step.\n\nWait, here's the full code with bubble sort as above.\n\nWait, let me recheck the indices in the bubble sort loop.\n\nIn the code I had:\n\n do i=1, n-1\n    do j=1, n-i\n       if (a(j) > a(j+1)), etc.\n\nWait, this is standard bubble sort. The outer loop runs for n-1 times. Each time, the largest element \"bubbles\" to the top. The inner loop goes up to n-i.\n\nWait, but in the inner loop, how to?\n\nWait, in the inner loop:\n\nfor j from 1 to (n - i):\n\nWait, in Fortran, the inner loop would be:\n\ndo j = 1, n - i\n\n    compare a(j) and a(j+1)\n\n    if (a(j) > a(j+1)), swap.\n\nend do\n\nSo that the inner loop runs from 1 to (n-i), which for the first iteration (i=1), the inner loop runs up to n-1, comparing all adjacent pairs. Then each subsequent outer loop iteration reduces the uppper limit by 1 because each pass puts the next highest element at the end.\n\nThis should work. So the bubble sort is correctly implemented.\n\nNow proceeding with the code. Let me write it again:\n\nprogram codeforces_108b\n  implicit none\n  integer :: n, i_sorted, i, j, temp\n  integer, dimension(:), allocatable :: a\n\n  ! Read the number of elements\n  read(*,*) n\n\n  ! Allocate the array\n  allocate(a(n))\n\n  ! Read the array\n  read(*,*) (a(i), i=1, n)\n\n  ! Sort using bubble sort\n  do i_sorted = 1, n -1\n      do j = 1, n - i_sorted\n          if (a(j) > a(j+1)) then\n              temp = a(j)\n              a(j) = a(j+1)\n              a(j+1) = temp\n          end if\n      end do\n  end do\n\n  ! Check for required condition\n  do i =1, n-1\n      if ( a(i+1) < 2 * a(i) .and. a(i) /= a(i+1) ) then\n          print*, 'YES'\n          stop\n      end if\n  end do\n\n  ! If nothing found, output NO\n  print*, 'NO'\n\n  ! Deallocate the array\n  deallocate(a)\nend program codeforces_108b\n\nWait, but when reading elements, in fortran, the read statement can also be read(*,*) a, which reads the entire array. Let me check:\n\nInstead of:\n\n  read(*,*) (a(i), i=1, n)\n\nYou can just do:\n\nread(*,*) a\n\nas 'a' is a one-dimensional array, the whole array can be read in a single statement.\n\nSo the line can be simplified to read(*,*) a.\n\nThat would be better. \n\nSimilarly, when using the allocation and read, that would be better.\n\nSo adjusting that:\n\n  allocate(a(n))\n  read(*,*) a\n\nFaster and cleaner.\n\nThus, the entire code is as follows, with bubble sort.\n\nAlternatively, the selection sort may be more efficient but let's stick to bubble for now.\n\nNow, check for other discrepancy between Java and Fortran:\n\nIn Java, the condition is a[i+1] < a[i] * 2 and a[i] != a[i+1]). \n\nThe Fortran code has the same condition: if (a(i+1) < 2*a(i) .and. a(i) /= a(i+1)), then output yes.\n\nYes, because 2*a(i) is the same as a[i] * 2. \n\nWait, but maybe the multiplication order matters for integers?\n\nNo, it's the same operation.\n\nWait, a[i+1] has to be strictly less than double the previous element, and they are not equal. Because if they are equal, then even a[i]*2 might be larger than a[i+1], but since they are equal, the condition is triggered only when the next element is strictly less.\n\nWait, the condition 'a[i] != a[i+1]' ensures that when elements are equal, even if the multiple is less, it's not counted. Wait, no, 2*a[i] when a[i] and a[j] are equal would be 2 a[i], so a[i+1] would have to be less than that, but since equal to it, a[i+1] is a[i], so 2 a[i] would be bigger, so \n\nIf a[i] = a[i+1], then (a[i+1] < 2a[i]) is true (because a[i+1] equals a[i], which is less than 2a[i] provided a[i]>0), but the second condition says a[i] must be not equal. \n\nWait, right. So when a[i] equals a[i+1], even though a[i+1] is less than 2* a[i], the condition a[i] != a[i+1] would make the overall condition false. Thus, the code is correct.\n\nSo the Fortran code condition is correct.\n\nNow, what about the data types?\n\nJava uses int, which is typically 32 bits. In Fortran, integers are 4 bytes (default), but in any case, unless specified, it's okay. \n\nThe code uses integer variables, so the type is correct.\n\nAlso, the print statements output YES or NO correctly.\n\nNow, testing some cases.\n\nFor example, let's take Java code example.\n\nTest case where input is 3 1 2 3.\n\nThe array when sorted is [1,2,3]. \n\nChecking pairs: \n\nBetween 1 and 2: 2 < 1*2? 2 is not <2, so no.\n\nBetween 2 and 3: 3 < 2*2? 3 <4 yes. And 2 !=3. So the code would print YES.\n\nWait but in Fortran code:\n\nWait, first pair (1 and 2): 2 < 2 (2*a[i] is 2*1=2. 2 is not less than that. So first condition fails. Second pair between 2 and 3: 3 <4 (yes?), and 2 !=3. So yes. \n\nThus, in that case, prints yes.\n\nAnother test: input is 2 numbers 5 9.\n\nsorted as 5,9. \n\nCheck 9 <10? yes. and 5 !=9. hence YES.\n\nSo the code should output yes.\n\nAnother test: input 3, numbers 4 5 8.\n\nsorted [4,5,8].\n\nCheck:\n\n5 < 8? 5 <8, but 5 < 4*2 (8) ?\n\nWait, the first check: between 4 and5: 5 < 8? 4*2 is 8. 5 < 8 is yes, but 5 < 8? yes. But the condition is a[i+1] <2*a[i]. \n\nWait for first pair 4 and5:\n\na[i]=4, a[i+1] =5. \n\n5 < 2*4 =8. So yes. But also check that a[i] !=a[i+1], which they are. \n\nThus, the code would output YES right away here.\n\nYes, correct.\n\nAnother test case where the answer is NO: \n\nInput 3 numbers 1,3, 4. \n\nSorted array is [1,3,4]\n\nCheck 3 <2? no. 3 not less than 2*1=2. 3 is more than 2. So first pair condition is false.\n\nNext, 4 < 3*2? 4 <6, yes. But 3 and4, so their difference. 3 !=4. Thus condition holds, so it would output YES.\n\nWait in this test, the code would say YES, because between 3 and4: 4 < 6 (yes). \n\nAnother test case where answer is NO. \n\nSuppose the input is 2 numbers 3 and 6. \n\nsorted [3,6]\n\nCheck 6 < 2*3 =>6 <6? no. So 6 is not less than 6. so the first condition is not met. Also, 3 !=6, so the second condition is true. But since the first condition (6 <6?) is false, so condition is false. \n\nThus, the code would loop over that and since no pairs found, output No.\n\nAnother test: two numbers 3 and 6. So the code returns NO.\n\nAnother case where two numbers: 3 and 5. \n\nCheck 5 <6 \u2192 yes. and they are not equal, so returns YES. \n\nSo all these cases work with the code. \n\nTherefore, the code should be correct.\n\nAnother test case where input is 5 elements: 4,2,1,3,5.\n\nConverted to fortran, the code first sorts them as [1,2,3,4,5].\n\nThen check between 1 and2: 2 <2 \u2192 no. 2<2*1 \u2192 2=2 \u2192 not less. \n\nNext pair between 2 and3: 3 <4 \u2192 yes. So the code would immediately output YES. \n\nThus the code would catch it.\n\nYes.\n\nThus the translation is correct."
}