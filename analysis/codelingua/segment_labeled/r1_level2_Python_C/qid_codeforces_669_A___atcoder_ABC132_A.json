{
  "segments": [
    {
      "text": "We are given two Python programs that run in sequence. First program:\n  Reads an integer `n`, computes `(n * 2 + 1) // 3` and prints it. Second program:\n  Reads a string `S` (which in the chain will be the output of the first program, but note: the first program outputs a number, so we have to consider that the input to the second program is a string of digits?",
      "start_char": 0,
      "end_char": 363,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "However, note the chain: the output of the first program is used as input to the second. But the second program expects a string. So the first program's output is a string representation of the number.",
      "start_char": 366,
      "end_char": 567,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "However, in the chain, the first program outputs a number (as a string) and the second program reads that string. But note: the second program is checking for a string that must have exactly two distinct characters and each character appears exactly twice. But the output of the first program is a number. For example, if we input 5 to the first program:\n  (5*2+1)//3 = (10+1)//3 = 11//3 = 3 (if using integer division, which in Python is //)\n\nSo the second program would get the string \"3\". Then:\n  Sa = set('3') -> {'3'} -> length 1 -> prints \"No\"\n\nBut wait, the example chain might not be meaningful? We must follow the specification. However, the problem says: translate the entire sequence into a single C program. We have to combine the two:\n\nSteps:\n1. Read an integer `n` (from standard input). 2. Compute `result1 = (n * 2 + 1) / 3` (using integer division: since in Python, `//` does floor division for integers, but note: if negative numbers? The problem does not specify, but we'll assume non-negative?",
      "start_char": 569,
      "end_char": 1586,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "However, the problem says \"behaves identically\", so we have to mimic integer division in Python. But note: in C, for positive integers, integer division truncates toward zero, but in Python, `//` for nonnegative is the same.",
      "start_char": 1587,
      "end_char": 1811,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "However, if negative, Python's floor division truncates toward minus infinity. But the problem doesn't specify the input range.",
      "start_char": 1812,
      "end_char": 1939,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Since the original first program uses `//` and the input is integer, we have to be cautious. But note: the problem says \"behaves identically\". We are not told the input range.",
      "start_char": 1940,
      "end_char": 2116,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "However, the second program expects a string that has exactly two distinct characters each appearing twice. The output of the first program is a number.",
      "start_char": 2117,
      "end_char": 2269,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "We have to output either \"Yes\" or \"No\" at the end. But observe: the output of the first program is a single integer. So the string we get for the second program is the string representation of that integer. For example, if the integer is 33, then the string is \"33\" -> distinct characters? Only one -> '3'. So it fails. But if the integer is 1122? Actually, the integer from the first program is computed as `(n*2+1)//3`. For typical `n`, it's a number that might be one or more digits. However, the chain is:\n\nInput: integer `n`\nFirst program: computes `x = (n*2+1)//3` and outputs `x` (as a string of digits)\nSecond program: reads that string and checks:\n   - There are exactly 2 distinct characters.\n   -",
      "start_char": 2270,
      "end_char": 2979,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Each character appears exactly twice. So the second program will only output \"Yes\" if the string representation of `x` has exactly two distinct digits and each appears exactly twice? Actually, the condition: \n   `len(Sa) ! = 2` -> fails if not exactly two distinct characters. `for i in Sa: if c[i] != 2` -> then fails. So the string must be of length 4? Actually, no: it must be of length 4? Not necessarily: two distinct characters, each appearing twice -> total length 4. But wait: what if the number has leading zeros? For example, 0011? But the first program outputs an integer, so it won't have leading zeros. So the string is the normal decimal representation of the integer without any leading zeros. Therefore, the integer `x` must be a 4-digit number? Actually, no: it could be a 2-digit number? For example, 11 -> but that has two same digits, so distinct characters would be one. So it must be a 4-digit number? Actually, no: what about 1122? That is 4 digits. But also 1212? That is 4 digits. But also 11? Then the string is \"11\" -> distinct set: {'1'} -> fails. 112? Then distinct set: {'1','2'} -> but counts: '1':2, '2':1 -> fails. So the only possibility for the second program to say \"Yes\" is that the integer `x` is a 4-digit number with exactly two distinct digits and each digit appears exactly twice?",
      "start_char": 2980,
      "end_char": 4308,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Actually, no: what about a 4-digit number with two distinct digits but one digit appearing 3 times and the other 1? Then it fails. So it must be two distinct digits, each twice. But note: the number might have more than 4 digits? Then the condition would fail because we have more than 4 characters? Actually, the condition is: \n   - exactly two distinct characters -> so the digits must be only two different ones.\n   - and each appears exactly twice -> so total length 4.",
      "start_char": 4310,
      "end_char": 4784,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Therefore, the second program will only output \"Yes\" if the string representation of `x` has exactly 4 characters and two distinct digits and each appears twice. But note: what if the number has 4 digits? Then the string length is 4. Then we require two distinct digits and each twice.",
      "start_char": 4786,
      "end_char": 5071,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "However, the problem does not specify the input `n`, so we have to do the computation as in the first program and then the check as in the second. Plan for the C program:\n\n1. Read an integer `n`.\n2. Compute `x = (n * 2 + 1) / 3` using integer division? But note: in Python, `//` does floor division.",
      "start_char": 5074,
      "end_char": 5374,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "However, the expression `(n*2+1)//3` for integers: we can do in C with integer arithmetic, but we have to be cautious for negative numbers. However, the problem does not specify that the input is positive. Let's consider: In Python, `//` for integers is floor division.",
      "start_char": 5375,
      "end_char": 5646,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "In C, when dividing two positive integers, truncation is the same as floor. But for negative, floor division is not the same as truncation. But note: the problem says \"behaves identically\".",
      "start_char": 5647,
      "end_char": 5836,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Without knowing the input range, we have to mimic Python. But the original first program: \n   `(n * 2 + 1) // 3`\n\nIn Python, for negative `n`, the expression `(n*2+1)` might be negative. Then `//3` would round towards -infinity. In C, we can use:\n   `x = (n * 2 + 1) / 3;` \nbut this would truncate toward zero for negative. So for negative numbers, we have to adjust. Alternatively, we can use:\n\n   if (n * 2 + 1 >= 0) {\n        x = (n * 2 + 1) / 3;\n   } else {\n        //",
      "start_char": 5838,
      "end_char": 6313,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "For negative: we want floor division: (n*2+1) // 3\n        // We can compute: (n*2+1 - 2) / 3? \n        // Actually, we can do: \n        // x = (n * 2 + 1) / 3 - ((n*2+1) % 3 != 0 ? 1 : 0);\n        // But this is messy.\n\n        // Alternatively, we can use: \n        // x = (n * 2 + 1) / 3;\n        // if ((n*2+1) % 3 != 0) x--;   // because truncation rounds towards zero, so for negative we might have to adjust by subtracting one for the remainder?\n        // But let's test: \n        // For n = -1: ( -2+1 = -1 ) // 3 -> in Python: -1 // 3 = -1 (because -1 divided by 3 is -0.333... and floor is -1)\n        // In C: -1/3 is 0 (if we do integer division) -> which is not the same. // Actually, the standard integer division in C truncates toward zero. So we need to adjust. // Formula for floor division: \n        //   x = (n*2+1) / 3; \n        //   if (x * 3 > (n*2+1)) then x--; \n        // but for negative, if we have a non-zero remainder, we adjust downward.\n\n        // Alternatively, we can do:\n        // x = (n*2+1) / 3;\n        //   if ((n*2+1) % 3 != 0 && (n*2+1) < 0) {\n        //        x--;\n        //   }\n\n        // Let me test with n=-1: \n        //   n*2+1 = -1\n        //   -1/3 in C: 0?",
      "start_char": 6314,
      "end_char": 7555,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Actually, no: integer division of -1/3 is 0? Actually, it is 0? But wait: in C, -1/3 is 0? \n        // Actually, in C: -1/3 is 0? Because -1 divided by 3 is 0 with remainder -1? \n        // But we want -1.\n\n        // Another way: we can use the fact that:\n        //   x = (n*2+1) / 3; \n        //   but if the division is not exact and the numerator is negative, then subtract one.\n\n        // However, to avoid depending on the sign of the modulus (which in C can be negative), we can do:\n\n        //   long num = (long)n * 2 + 1;\n        // if (num >= 0) {\n        //       x = num / 3;\n        //   } else {\n        //       x = (num - 2) / 3;   // because we want floor: but this doesn't work.\n\n        // Actually, we can use:\n        // x = (n*2+1) / 3;\n        //   if ((n*2+1) % 3 != 0 && (n*2+1) < 0) {\n        //       x = x - 1;\n        //   }\n\n        // Let me test with n=-1: \n        //   num = -1\n        // -1 % 3: in C, the modulus can be negative? Actually, the sign of the modulus is implementation-defined? //   We can avoid modulus by: \n        // if (num % 3 != 0) ... but we want to know if it's not divisible.\n\n        // Alternatively, we can do without modulus by checking the product:\n        // if (x*3 != num) {\n        //       if (num < 0) x--;\n        //   }\n\n        // But then we are doing two comparisons and an extra multiplication.\n\n        //",
      "start_char": 7556,
      "end_char": 8963,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Since the problem does not specify the input range, and the second program only outputs \"Yes\" for 4-digit numbers with two distinct digits each twice, which are positive, maybe the input `n` is intended to be nonnegative? \n\n        //",
      "start_char": 8964,
      "end_char": 9198,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "The problem says: \"behaves identically\". So we must handle negative if the original Python does.\n\n        // But note: the second program expects a string.",
      "start_char": 9199,
      "end_char": 9354,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "The first program: for negative n, the output would be a negative integer? Then the string would start with a minus sign. Then the second program would see the minus sign and a digit? So for example, n=-1: \n        // x = ( -2+1 ) // 3 = (-1) // 3 = -1 (in Python)\n        //   Then the string is \"-1\". Then set: {'-','1'} -> two distinct. Then count: \n        //      c['-'] = 1, c['1'] = 1 -> fails the condition (each must be twice). So it would output \"No\".\n\n        // So we have to output the negative number as a string.\n\n        // Therefore, we must handle negative numbers in the first step. // How to do floor division in C for negative? // We can use:\n        // x = (n*2+1) / 3;\n        //   if ((n*2+1) % 3 != 0 && (n*2+1) < 0) {\n        //       x--;\n        //   }\n\n        // But the modulus operator in C: \n        //   (a % b) has the same sign as a, so for negative a, the modulus is negative? \n        // Actually, the standard says: the remainder has the same sign as the dividend.\n\n        // Example: \n        //   -1 / 3: quotient is 0, remainder -1 -> then we can check: if remainder ! = 0 and num<0, then subtract one.\n\n        // So:\n        //   long num = (long)n * 2 + 1;\n        //   long x = num / 3;\n        //   long rem = num % 3;\n        //   if (rem != 0 && num < 0) {\n        //       x--;\n        //   }\n\n        // Test: n=-1 -> num=-1 -> x = -1/3 = 0? Actually, in C: \n        //   -1 / 3 is 0? and -1 % 3 is -1? \n        // Then: rem=-1 ! =0 and num<0 -> so x becomes -1 -> which is what we want.\n\n        // Another test: n=-2: \n        //   num = -4+1 = -3 -> x = -3/3 = -1, rem=0 -> no adjustment -> correct. // n=-3: \n        //   num = -6+1 = -5 -> x = -5/3: in C, -5/3 is -1? because truncation: -5 divided by 3 is -1.66... -> truncation to -1? \n        // Then rem = -5 % 3: in C, this is -2? because (-1)*3 = -3, and -5 - (-3) = -2 -> so rem=-2 !=0 and num<0 -> then x becomes -1-1 = -2.\n        // But in Python: (-5)//3 = -2 -> so that's correct. // So we do:\n        //   long num = (long)n * 2 + 1;\n        //   long x = num / 3;\n        //   long rem = num % 3;\n        // if (rem != 0 && num < 0) {\n        //       x--;\n        //   }\n\n        // But note: we must be cautious of overflow? The problem says `n` is integer, but we don't know the range. We use `long` to be safe.\n\n        //",
      "start_char": 9355,
      "end_char": 11751,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "However, the problem does not specify the range. But the second program requires the string representation. We can use `long` to handle larger numbers.\n\n        // Alternatively, we can use: \n        // x = (n*2+1) / 3;\n        // if (n*2+1 < 0 && (n*2+1) % 3) {\n        //       x--;\n        //   }\n\n        // But the modulus might be negative? and non-zero. So we can write:\n\n        // if (n*2+1 < 0 && (n*2+1) % 3 != 0) {\n        //       x--;\n        //   }\n\n        // But note: the modulus might be negative? and we check ! =0 -> so it's non-zero.\n\n        //",
      "start_char": 11752,
      "end_char": 12324,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "However, the expression (n*2+1) might overflow for large n? We are using `int n`? But the problem doesn't specify. We can use `long` for `n` as well.\n\n        //",
      "start_char": 12325,
      "end_char": 12486,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "Since the problem does not specify the range, we assume that the input integer is within the range of `int`. But to be safe for the computation, we use `long` for the intermediate.\n\n        // But the problem says: the first program does `n = int(input())` -> which in Python can handle arbitrary large integers? But in C we are limited.\n\n        // However, the problem does not specify the input range. We assume that the input is within the range of `long`.\n\n        // Alternatively, we can use: \n        //   long n;\n        //   scanf(\"%ld\", &n);\n\n        // Then compute:\n        //   long num = n * 2 + 1;\n        //   long x = num / 3;\n        // if (num % 3 != 0 && num < 0) {\n        //       x--;\n        //   }\n\n        // But note: the modulus operation in C: the sign of the result is the same as the dividend (num). So for negative num, the modulus is negative. So non-zero.\n\n        // This adjustment is for negative num.\n\n        // But what if the division is exact? Then modulus is 0 -> we don't adjust.\n\n        // So this works. 3. Now we have the integer `x` (which is the result of the first program). Then we have to convert it to a string (like the second program would read). 4. Then we check the string:\n   - If the string has exactly 2 distinct characters and each character appears exactly twice -> then output \"Yes\".\n   - Otherwise, output \"No\". But note: what if the number is negative? The string will have a minus sign. Then the string for `x` might be, for example, \"-1122\". Then the distinct characters: '-','1','2' -> three distinct -> fails. Or if we have \"-1111\", then distinct: '-','1' -> two distinct. But counts: \n   '-' : 1, '1': 4 -> fails. So the condition is only met for positive numbers?",
      "start_char": 12487,
      "end_char": 14229,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Actually, the condition requires two distinct non-minus digits and each twice? But then the string would be 4 digits? and no minus sign. But the first program: for negative n, we get a negative x? Then the string representation has a minus sign. Then the string length would be 5? (if 4 digits) and the minus sign. Then the distinct set would be 3? (if the digits are two distinct) because we have the minus and two digits? Or if the digits are one, then distinct set: two (minus and the digit). But then the counts: minus:1, digit:4 -> fails. So the second program will never output \"Yes\" for a negative x? Therefore, we can assume that the input n is nonnegative? But the problem does not specify.",
      "start_char": 14231,
      "end_char": 14934,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "We have to handle negative as well. But the chain: the first program might output a negative number as a string. Then the second program will check the string. So we do:\n\n   Step 1: Read long integer n.\n   Step 2: Compute x = (n*2+1) // 3 with the adjustment for negative to mimic Python. Step 3: Convert x to a string (including the minus sign if negative).",
      "start_char": 14935,
      "end_char": 15298,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Step 4: \n        - Count the frequency of each character in the string.\n        - Check the number of distinct characters: must be exactly 2.\n        - Check that each distinct character appears exactly 2 times. Step 5: Print \"Yes\" if both conditions hold, otherwise \"No\". Implementation:\n\n   How to convert the long integer to a string? We can use `sprintf`. Steps for the second part:\n\n        char s[100]; // we assume 100 is enough for the string representation of a long\n        sprintf(s, \"%ld\", x);\n\n        Then we can build a frequency array (for ASCII).",
      "start_char": 15302,
      "end_char": 15874,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "We can use an array of size 256 (for all 8-bit characters). But note: the string will only contain digits and possibly a minus. Steps:\n          int freq[256] = {0};\n          int len = strlen(s);\n          for (i=0; i<len; i++) {\n              unsigned char c = s[i];\n              freq[c]++;\n          }\n\n          Then, we want to know:\n            distinct_count = 0;\n            int valid = 1;\n            for (i=0; i<256; i++) { if (freq[i] > 0) {\n                    distinct_count++;\n                    if (freq[i] ! = 2) {\n                        valid = 0;\n                    }\n                }\n            }\n\n          But note: the condition is: exactly two distinct characters AND each appears exactly twice. However, the above loop would set valid=0 if any character does not appear twice. But we break the condition as soon as we see one that is not two? But note: we have to check every character? Actually, we can break early. Alternatively, we can do:\n\n            if (distinct_count != 2) {\n                valid = 0;\n            } else {\n                // and each one must be 2? Actually, we already set valid=0 if we see any frequency not 2? \n            }\n\n          But note: the above for-loop sets valid=0 if any character that appears has frequency not 2. Then we check distinct_count? Actually, we can do:\n\n            int distinct_count = 0;\n            int all_twos = 1;\n            for (int i=0; i<256; i++) { if (freq[i] > 0) {\n                    distinct_count++;\n                    if (freq[i] ! = 2) {\n                        all_twos = 0;\n                    }\n                }\n            }\n\n            if (distinct_count == 2 && all_twos) {\n                printf(\"Yes\\n\");\n            } else {\n                printf(\"No\\n\");\n            }\n\n          But wait: what if we have three distinct characters? Then distinct_count is 3 -> fails. But also, if we have two distinct characters, but one appears 3 times and the other 1, then distinct_count is 2 but all_twos is 0 -> fails. But note: the condition in the Python code:\n\n            if len(Sa) ! = 2: ... fails -> so if distinct_count ! = 2, we output \"No\".\n            else: then check each in Sa: if any frequency ! =2 -> output \"No\".",
      "start_char": 15875,
      "end_char": 18180,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Our code above: \n            distinct_count: counts the distinct characters that appear at least once. all_twos: set to 0 if any of the characters that appear have frequency not 2. Then we require distinct_count==2 and all_twos==1. However, note: the Python code uses the entire string?",
      "start_char": 18192,
      "end_char": 18512,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Our frequency array is built over the entire string. But what if the string has a character that does not appear? We only look at the indices where freq[i]>0. So it's correct.",
      "start_char": 18513,
      "end_char": 18699,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "However, note: the frequency array: we are iterating over all 256 indices? We can break earlier? But 256 is small.",
      "start_char": 18720,
      "end_char": 18834,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Alternatively, we can avoid iterating over 256 by using a set-like structure? But the string is short?",
      "start_char": 18844,
      "end_char": 18946,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "The maximum length of the string representation of a long is about 20? So we can iterate over the string to compute distinct characters and their frequencies? Actually, we already built the frequency array.",
      "start_char": 18947,
      "end_char": 19153,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "The 256 iteration is acceptable. But note: we are building the frequency array by iterating the string (which is short) and then iterating 256 (which is constant). So it's efficient.",
      "start_char": 19154,
      "end_char": 19336,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "However, we can optimize: we can break early if we find more than 2 distinct characters? But we are building the frequency array in the first loop. Then we have to do the second loop to check frequencies. Actually, we can combine:\n\n        We can do:\n\n          int distinct_count = 0;\n          int seen[256] = {0};   // or we can use the freq array, but we haven't built it? Alternatively, we can do:\n\n          char *p = s;\n          int freq[256] = {0};\n          while (*p) {\n              freq[(unsigned char)*p]++;\n              p++;\n          }\n\n          Then we do the distinct_count and check for non-2. But the original code uses a set and then a Counter. We are simulating that. Edge: what if the string is empty? Then distinct_count=0 -> then we output \"No\", which is correct. For example, if x=0: then the string is \"0\". distinct_count: 1 -> fails. So the program:\n\n        Read n (as long)\n        Compute x = (n*2+1) // 3 (with adjustment for negative)\n        Convert x to string -> s\n        Build frequency array for s\n        distinct_count = 0;\n        all_twos = 1;\n        for (int i=0; i<256; i++) {\n            if (freq[i]) {\n                distinct_count++;\n                if (freq[i] ! = 2) {\n                    all_twos = 0;\n                }\n            }\n        }\n        if (distinct_count == 2 && all_twos) {\n            printf(\"Yes\\n\");\n        } else {\n            printf(\"No\\n\");\n        } But note: the condition \"all_twos\" requires that every character that appears must appear exactly twice? Yes.",
      "start_char": 19350,
      "end_char": 20933,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "However, what if we have two distinct characters and one appears twice and the other appears twice? Then we output \"Yes\". But what if we have two distinct characters and one appears twice and the other appears three times? Then distinct_count=2, but all_twos=0 -> we output \"No\". This matches the Python code. However, note: the Python code:\n\n        for i in Sa:\n            if c[i] ! = 2:\n                print(\"No\")\n                exit() So it checks every distinct character: if any one is not 2, it fails. Our code: if any character in the entire string has frequency not 2, we set all_twos=0 -> then we output \"No\". But note: the distinct set `Sa` is the set of distinct characters. We are iterating over every distinct character? Actually, in the frequency array, we are iterating over every character in the ASCII set? But we skip if freq[i]==0. So we are iterating only over the distinct characters? Actually, we are iterating over all 256 bytes, but we skip the ones with freq[i]==0. So we are effectively iterating over the distinct characters? But note: we are checking the frequency of each distinct character? Yes.",
      "start_char": 20943,
      "end_char": 22102,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "However, we set `all_twos` to 0 if we see any distinct character that does not have frequency 2. Then after the loop, we check distinct_count and all_twos. But we don't break early. We can break early? But 256 is constant.",
      "start_char": 22112,
      "end_char": 22334,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Alternatively, we can break the loop when we find one that is not 2? But then we wouldn't know the distinct_count?",
      "start_char": 22343,
      "end_char": 22457,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Actually, we can break the condition: if we see a frequency that is not 2, then we know it fails? But we still have to count the distinct_count?",
      "start_char": 22458,
      "end_char": 22602,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "However, if we see a frequency that is not 2, we know we are going to output \"No\". But we also must know if distinct_count is not 2? So we have to complete the distinct_count?",
      "start_char": 22608,
      "end_char": 22783,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Actually, we can break early only if we already have distinct_count>2? But we are building the distinct_count as we go? Alternatively, we can do:\n\n        int distinct_count = 0;\n        for (int i=0; i<256; i++) { if (freq[i]) {\n                distinct_count++;\n                if (freq[i] ! = 2) {\n                    // we know it fails? but we have to check distinct_count at the end? // We can set a flag and break? but we still need the distinct_count? }\n            }\n        }\n\n        Then we check distinct_count and also we need to know if any freq[i] ! =2. So we can do:\n\n        int distinct_count = 0;\n        int has_non_two = 0;\n        for (int i=0; i<256; i++) { if (freq[i] > 0) {\n                distinct_count++;\n                if (freq[i] ! = 2) {\n                    has_non_two = 1;\n                }\n            }\n        }\n\n        if (distinct_count == 2 && !has_non_two) {\n            printf(\"Yes\\n\");\n        } else {\n            printf(\"No\\n\");\n        }\n\n   This is equivalent. But note: we can break early if distinct_count becomes more than 2?",
      "start_char": 22789,
      "end_char": 23935,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Actually, we can break the loop if distinct_count>2 and has_non_two? But we still have to check the rest? Because we need to know if there's a non-two?",
      "start_char": 23940,
      "end_char": 24091,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Actually, we can break only if we have distinct_count>2 and we don't care about non_two? But no: we have to check non_two even if distinct_count is 2?",
      "start_char": 24092,
      "end_char": 24242,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Alternatively, we can break the loop if distinct_count>2? But then we don't know if there is a non_two? Actually, if distinct_count>2, then the condition fails regardless of non_two? So we can break? int distinct_count = 0;\n        int has_non_two = 0;\n        for (int i=0; i<256; i++) {\n            if (freq[i]) {\n                distinct_count++;\n                if (freq[i] ! = 2) {\n                    has_non_two = 1;\n                }\n                // If distinct_count>2 and has_non_two?",
      "start_char": 24248,
      "end_char": 24754,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "we don't care, we know we are going to output \"No\", but we cannot break because we might have more distinct_count? \n                // But we can break only if distinct_count>2?",
      "start_char": 24755,
      "end_char": 24932,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Actually, if distinct_count>2, then we know the condition fails? But we still have to check the entire frequency? \n                // Actually, we can break early only if we know that distinct_count>2 and we don't care about the rest? But we are building the frequency array? The rest of the frequencies might be zero. // The loop is over 256, which is constant, so it's acceptable to not break.\n\n            }\n        }\n\n   Since 256 is small, we don't break. But note: the string is short, so the frequency array will have at most 10-20 non-zero entries? So we can break when we have more than 2 distinct_count and also we have seen a non_two? Actually, no: we have to count the distinct_count exactly?",
      "start_char": 24933,
      "end_char": 25658,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Actually, we cannot break early in the frequency array loop because we need to know the total distinct_count? So we do the full iteration.",
      "start_char": 25664,
      "end_char": 25802,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "However, we can do an alternative: iterate over the string and build a set of distinct characters and a frequency map? But we already built the frequency array. Then we have to iterate over the 256 to get distinct_count and non_two? We'll do the 256 iteration. Code structure:\n\n        #include <stdio.h>\n        #include <stdlib.h>\n        #include <string.h>\n        #include <ctype.h>\n\n        int main() {\n            long n;\n            scanf(\"%ld\", &n);\n\n            // Compute num = n*2+1\n            long num = n * 2 + 1;\n            long x = num / 3;\n            long rem = num % 3;\n\n            // Adjust for negative and non-divisible\n            if (rem != 0 && num < 0) {\n                x--;\n            }\n\n            // Convert x to string\n            char s[100];\n            sprintf(s, \"%ld\", x);\n\n            // Frequency array for 256 ASCII\n            int freq[256] = {0};\n            size_t len = strlen(s);\n            for (size_t i = 0; i < len; i++) {\n                unsigned char c = s[i];\n                freq[c]++;\n            }\n\n            int distinct_count = 0;\n            int has_non_two = 0;\n            for (int i = 0; i < 256; i++) {\n                if (freq[i]) {\n                    distinct_count++;\n                    if (freq[i] ! = 2) {\n                        has_non_two = 1;\n                    }\n                }\n            }\n\n            if (distinct_count == 2 && !has_non_two) {\n                printf(\"Yes\\n\");\n            } else {\n                printf(\"No\\n\");\n            }\n\n            return 0;\n        }\n\n   But note: the Python program chain: the first program outputs the integer, and the second program uses that as a string. The first program does not output a newline?",
      "start_char": 25812,
      "end_char": 27555,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Actually, in Python, `print((n * 2 + 1) // 3)` outputs the integer and then a newline? But the second program uses `input()` which by default reads a line? So the entire string including the newline?",
      "start_char": 27556,
      "end_char": 27755,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Actually, no: `input()` in Python reads a line and strips the trailing newline. So the string `S` is the integer without the newline.",
      "start_char": 27761,
      "end_char": 27894,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "In our C program, we are using `sprintf` to write to `s` without a newline. Then we build the frequency array of that string. So that matches.",
      "start_char": 27899,
      "end_char": 28041,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "However, the first program in Python outputs the integer and a newline. But the second program reads the integer without the newline?",
      "start_char": 28046,
      "end_char": 28179,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Because `input()` strips the newline. So the string in the second program is the integer string without the newline.",
      "start_char": 28180,
      "end_char": 28296,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "In our C program, we are not including a newline in the string `s`. So it's the same. But note: what if the integer is negative? We use `%ld` and it will put a minus sign. That is the same as Python. Let me test with a positive integer: \n        n=4: \n        num = 4*2+1 = 9 -> x=9/3=3 -> no adjustment -> string \"3\"\n        Then distinct_count: 1 -> fails -> output \"No\"\n\n   n=5: (5*2+1)//3 = 11//3 = 3 -> same. What about n=8: \n        (8*2+1)=17 -> 17//3 = 5 -> string \"5\" -> fails. How can we get a string of length 4? We need x to be a 4-digit number with two distinct digits and each twice. For example, x=1122 -> then we need (n*2+1)//3 = 1122 -> so n = (1122*3-1)/2 = (3366-1)/2 = 3365/2 = 1682.5 -> not integer. x=1212: then n = (1212*3-1)/2 = (3636-1)/2 = 3635/2 -> not integer. How about x=22? then the string is \"22\" -> distinct_count=1 -> fails. x=112? distinct set: {'1','2'} -> distinct_count=2, but frequencies: '1':2, '2':1 -> fails. x=1121: distinct set: {'1','2'} -> frequencies: '1':3, '2':1 -> fails. x=1122: distinct set: {'1','2'} -> frequencies: both 2 -> valid. Then we need: (n*2+1)//3 = 1122 -> so n*2+1 = 1122*3 = 3366 -> n*2 = 3365 -> n=3365/2 -> not integer. How about x=2211? same as 1122.\n\n        How about x=1221? Then n*2+1 = 1221*3 = 3663 -> n*2=3662 -> n=1831. Then we run the first program: \n            n=1831 -> (1831*2+1)=3662+1=3663 -> 3663//3=1221 -> so x=1221. Then the second program: \n            S=\"1221\"\n            distinct set: {'1','2'} -> size=2 -> then check: \n                c['1']=2, c['2']=2 -> \"Yes\"\n\n        So we can test with n=1831. In our C program: \n            n=1831\n            num = 1831*2+1 = 3663\n            x = 3663/3 = 1221 -> no adjustment. s = \"1221\"\n            frequencies: \n                '1':2, '2':2 -> distinct_count=2, has_non_two=0 -> output \"Yes\"\n\n        So it works. But note: the adjustment for negative? We tested with n=-1: \n        num = -1 x = -1/3 -> in C: -1/3=0? and rem = -1%3 = -1? then adjustment: rem!=0 and num<0 -> x becomes -1 -> string \"-1\"\n        frequencies: \n            '-':1 -> distinct_count=1? then we break? \n            and then check: distinct_count=2? no, and then output \"No\". But the distinct characters: \n            s[0] = '-' -> freq['-']=1\n            s[1] = '1' -> freq['1']=1\n            distinct_count=2? but then we see: freq['-']=1 ! =2 -> has_non_two=1 -> then output \"No\". So both conditions: distinct_count==2 is true, but has_non_two is true -> then output \"No\". But the condition: we require distinct_count==2 and ! has_non_two -> so we output \"No\", which is correct. Therefore, the code is:\n\n        #include <stdio.h>\n        #include <stdlib.h>\n        #include <string.h>\n\n        int main() {\n            long n;\n            scanf(\"%ld\", &n);\n\n            long num = n * 2 + 1;\n            long x = num / 3;\n            long rem = num % 3;\n            if (rem != 0 && num < 0) {\n                x--;\n            }\n\n            char s[100];\n            sprintf(s, \"%ld\", x);\n\n            int freq[256] = {0};\n            for (int i = 0; s[i] ! = '\\0'; i++) {\n                unsigned char c = s[i];\n                freq[c]++;\n            }\n\n            int distinct_count = 0;\n            int has_non_two = 0;\n            for (int i = 0; i < 256; i++) { if (freq[i]) {\n                    distinct_count++;\n                    if (freq[i] ! = 2) {\n                        has_non_two = 1;\n                    }\n                }\n            }\n\n            if (distinct_count == 2 && !has_non_two) {\n                printf(\"Yes\\n\");\n            } else {\n                printf(\"No\\n\");\n            }\n\n            return 0;\n        } However, note: the modulus operation for negative: the behavior of `%` in C for negative numbers: the standard says it should satisfy: (a/b)*b + a%b == a, and the sign of the remainder is the same as the dividend. So we are safe. But what if the division overflows? We are using `long` for `n`, and then `num = n*2+1` might overflow for very large `n`? But the problem doesn't specify the range. We assume that the input is such that `n*2+1` does not overflow `long`.",
      "start_char": 28301,
      "end_char": 32657,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Alternatively, we can use `long long` for `num`? \n\n   Let me use `long long` for `num` to avoid overflow? But the problem says the input is an integer. We don't know the range. But `long` might be 32-bit or 64-bit. We can use:\n\n        long long num = (long long)n * 2 + 1;\n\n   But we read `n` as `long`. Then we can do:\n\n        long n;\n        scanf(\"%ld\", &n);\n        long long num = (long long)n * 2 + 1;\n\n   Then do the division and modulus on `long long`. Then adjust:\n\n        long long x = num / 3;\n        long long rem = num % 3;\n\n        Then we have to convert x to a string? We use `sprintf(s, \"%lld\", x);`\n\n   But note: the problem says the input is integer, and we are using `long` for `n`, but if the input is very large, we use `long long` for the intermediate. Alternatively, we can read `n` as `long long`? Then we don't need two types. Let me do:\n\n        long long n;\n        scanf(\"%lld\", &n);\n\n        long long num = n * 2 + 1;\n        long long x = num / 3;\n        long long rem = num % 3;\n        if (rem != 0 && num < 0) {\n            x--;\n        }\n\n        char s[100];\n        sprintf(s, \"%lld\", x);\n\n   But the problem: the first program uses `int(input())` in Python, which can handle arbitrary large integers? But in C we are limited by `long long`. But the problem does not specify the input range. We assume it fits in `long long`.",
      "start_char": 32663,
      "end_char": 34043,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "Alternatively, we can use `long` for everything if we know the range is small. But to be safe, we use `long long`.",
      "start_char": 34048,
      "end_char": 34162,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "However, note: the second program: the string representation of a `long long` might be up to 20 characters? So `s[100]` is safe. So the final code:\n\n        #include <stdio.h>\n        #include <stdlib.h>\n        #include <string.h>\n\n        int main() {\n            long long n;\n            scanf(\"%lld\", &n);\n\n            long long num = n * 2 + 1;\n            long long x = num / 3;\n            long long rem = num % 3;\n            if (rem != 0 && num < 0) {\n                x--;\n            }\n\n            char s[100];\n            sprintf(s, \"%lld\", x);\n\n            int freq[256] = {0};\n            for (int i = 0; s[i] ! = '\\0'; i++) {\n                unsigned char c = s[i];\n                freq[c]++;\n            }\n\n            int distinct_count = 0;\n            int has_non_two = 0;\n            for (int i = 0; i < 256; i++) { if (freq[i]) {\n                    distinct_count++;\n                    if (freq[i] ! = 2) {\n                        has_non_two = 1;\n                    }\n                }\n            }\n\n            if (distinct_count == 2 && !has_non_two) {\n                printf(\"Yes\\n\");\n            } else {\n                printf(\"No\\n\");\n            }\n\n            return 0;\n        }\n\n   Let me test with n=1831: \n        num = 1831*2+1 = 3663\n        x = 3663/3 = 1221 -> no adjustment. s = \"1221\"\n        freq: \n            '1':2, '2':2\n        distinct_count: 2\n        has_non_two: 0 -> output \"Yes\"\n\n   Test with n=0:\n        num = 0*2+1 = 1\n        x = 1/3 = 0 (in C integer division) -> rem=1 -> but num>0 -> no adjustment -> x=0\n        s=\"0\"\n        distinct_count=1 -> output \"No\"\n\n   Test with n=-1:\n        num = -2+1 = -1\n        x = -1/3: in C, -1/3 is 0? and rem = -1? then: rem ! =0 and num<0 -> x = 0-1 = -1\n        s = \"-1\"\n        freq: '-'->1, '1'->1\n        distinct_count=2 -> but has_non_two=1 (because both are 1, not 2) -> output \"No\"\n\n   So it matches. However, note: the modulus for negative in C: For num=-1: \n            -1 / 3 is 0? because truncation toward zero. Then -1 % 3 is -1? Then we adjust: x = 0-1 = -1. So it's correct. We'll use this code. But note: the problem says \"Only the first block should handle reading input. Only the last block should handle producing output.\" -> We are reading once and printing once at the end. And no I/O in between. So we are good. Let me write the code accordingly.",
      "start_char": 34167,
      "end_char": 36616,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    }
  ],
  "original_reasoning": "We are given two Python programs that run in sequence.\n\nFirst program:\n  Reads an integer `n`, computes `(n * 2 + 1) // 3` and prints it.\n\nSecond program:\n  Reads a string `S` (which in the chain will be the output of the first program, but note: the first program outputs a number, so we have to consider that the input to the second program is a string of digits? However, note the chain: the output of the first program is used as input to the second. But the second program expects a string. So the first program's output is a string representation of the number.\n\nHowever, in the chain, the first program outputs a number (as a string) and the second program reads that string.\n\nBut note: the second program is checking for a string that must have exactly two distinct characters and each character appears exactly twice.\n\nBut the output of the first program is a number. For example, if we input 5 to the first program:\n  (5*2+1)//3 = (10+1)//3 = 11//3 = 3 (if using integer division, which in Python is //)\n\nSo the second program would get the string \"3\". Then:\n  Sa = set('3') -> {'3'} -> length 1 -> prints \"No\"\n\nBut wait, the example chain might not be meaningful? We must follow the specification.\n\nHowever, the problem says: translate the entire sequence into a single C program.\n\nWe have to combine the two:\n\nSteps:\n1. Read an integer `n` (from standard input).\n2. Compute `result1 = (n * 2 + 1) / 3` (using integer division: since in Python, `//` does floor division for integers, but note: if negative numbers? The problem does not specify, but we'll assume non-negative? However, the problem says \"behaves identically\", so we have to mimic integer division in Python. But note: in C, for positive integers, integer division truncates toward zero, but in Python, `//` for nonnegative is the same. However, if negative, Python's floor division truncates toward minus infinity. But the problem doesn't specify the input range. Since the original first program uses `//` and the input is integer, we have to be cautious.\n\nBut note: the problem says \"behaves identically\". We are not told the input range. However, the second program expects a string that has exactly two distinct characters each appearing twice. The output of the first program is a number. We have to output either \"Yes\" or \"No\" at the end.\n\nBut observe: the output of the first program is a single integer. So the string we get for the second program is the string representation of that integer. For example, if the integer is 33, then the string is \"33\" -> distinct characters? Only one -> '3'. So it fails. But if the integer is 1122? Actually, the integer from the first program is computed as `(n*2+1)//3`. For typical `n`, it's a number that might be one or more digits.\n\nHowever, the chain is:\n\nInput: integer `n`\nFirst program: computes `x = (n*2+1)//3` and outputs `x` (as a string of digits)\nSecond program: reads that string and checks:\n   - There are exactly 2 distinct characters.\n   - Each character appears exactly twice.\n\nSo the second program will only output \"Yes\" if the string representation of `x` has exactly two distinct digits and each appears exactly twice? Actually, the condition: \n   `len(Sa) != 2` -> fails if not exactly two distinct characters.\n   `for i in Sa: if c[i] != 2` -> then fails.\n\nSo the string must be of length 4? Actually, no: it must be of length 4? Not necessarily: two distinct characters, each appearing twice -> total length 4. But wait: what if the number has leading zeros? For example, 0011? But the first program outputs an integer, so it won't have leading zeros.\n\nSo the string is the normal decimal representation of the integer without any leading zeros.\n\nTherefore, the integer `x` must be a 4-digit number? Actually, no: it could be a 2-digit number? For example, 11 -> but that has two same digits, so distinct characters would be one. So it must be a 4-digit number? Actually, no: what about 1122? That is 4 digits. But also 1212? That is 4 digits. But also 11? Then the string is \"11\" -> distinct set: {'1'} -> fails. 112? Then distinct set: {'1','2'} -> but counts: '1':2, '2':1 -> fails.\n\nSo the only possibility for the second program to say \"Yes\" is that the integer `x` is a 4-digit number with exactly two distinct digits and each digit appears exactly twice? Actually, no: what about a 4-digit number with two distinct digits but one digit appearing 3 times and the other 1? Then it fails. So it must be two distinct digits, each twice.\n\nBut note: the number might have more than 4 digits? Then the condition would fail because we have more than 4 characters? Actually, the condition is: \n   - exactly two distinct characters -> so the digits must be only two different ones.\n   - and each appears exactly twice -> so total length 4.\n\nTherefore, the second program will only output \"Yes\" if the string representation of `x` has exactly 4 characters and two distinct digits and each appears twice.\n\nBut note: what if the number has 4 digits? Then the string length is 4. Then we require two distinct digits and each twice.\n\nHowever, the problem does not specify the input `n`, so we have to do the computation as in the first program and then the check as in the second.\n\nPlan for the C program:\n\n1. Read an integer `n`.\n2. Compute `x = (n * 2 + 1) / 3` using integer division? But note: in Python, `//` does floor division. However, the expression `(n*2+1)//3` for integers: we can do in C with integer arithmetic, but we have to be cautious for negative numbers.\n\nHowever, the problem does not specify that the input is positive. Let's consider:\n\nIn Python, `//` for integers is floor division. In C, when dividing two positive integers, truncation is the same as floor. But for negative, floor division is not the same as truncation.\n\nBut note: the problem says \"behaves identically\". Without knowing the input range, we have to mimic Python.\n\nBut the original first program: \n   `(n * 2 + 1) // 3`\n\nIn Python, for negative `n`, the expression `(n*2+1)` might be negative. Then `//3` would round towards -infinity.\n\nIn C, we can use:\n   `x = (n * 2 + 1) / 3;` \nbut this would truncate toward zero for negative. So for negative numbers, we have to adjust.\n\nAlternatively, we can use:\n\n   if (n * 2 + 1 >= 0) {\n        x = (n * 2 + 1) / 3;\n   } else {\n        // For negative: we want floor division: (n*2+1) // 3\n        // We can compute: (n*2+1 - 2) / 3? \n        // Actually, we can do: \n        //   x = (n * 2 + 1) / 3 - ((n*2+1) % 3 != 0 ? 1 : 0);\n        // But this is messy.\n\n        // Alternatively, we can use: \n        //   x = (n * 2 + 1) / 3;\n        //   if ((n*2+1) % 3 != 0) x--;   // because truncation rounds towards zero, so for negative we might have to adjust by subtracting one for the remainder?\n        // But let's test: \n        //   For n = -1: ( -2+1 = -1 ) // 3 -> in Python: -1 // 3 = -1 (because -1 divided by 3 is -0.333... and floor is -1)\n        //   In C: -1/3 is 0 (if we do integer division) -> which is not the same.\n\n        // Actually, the standard integer division in C truncates toward zero. So we need to adjust.\n\n        // Formula for floor division: \n        //   x = (n*2+1) / 3; \n        //   if (x * 3 > (n*2+1)) then x--; \n        // but for negative, if we have a non-zero remainder, we adjust downward.\n\n        // Alternatively, we can do:\n        //   x = (n*2+1) / 3;\n        //   if ((n*2+1) % 3 != 0 && (n*2+1) < 0) {\n        //        x--;\n        //   }\n\n        // Let me test with n=-1: \n        //   n*2+1 = -1\n        //   -1/3 in C: 0? Actually, no: integer division of -1/3 is 0? Actually, it is 0? But wait: in C, -1/3 is 0? \n        //   Actually, in C: -1/3 is 0? Because -1 divided by 3 is 0 with remainder -1? \n        //   But we want -1.\n\n        // Another way: we can use the fact that:\n        //   x = (n*2+1) / 3; \n        //   but if the division is not exact and the numerator is negative, then subtract one.\n\n        // However, to avoid depending on the sign of the modulus (which in C can be negative), we can do:\n\n        //   long num = (long)n * 2 + 1;\n        //   if (num >= 0) {\n        //       x = num / 3;\n        //   } else {\n        //       x = (num - 2) / 3;   // because we want floor: but this doesn't work.\n\n        // Actually, we can use:\n        //   x = (n*2+1) / 3;\n        //   if ((n*2+1) % 3 != 0 && (n*2+1) < 0) {\n        //       x = x - 1;\n        //   }\n\n        // Let me test with n=-1: \n        //   num = -1\n        //   -1 % 3: in C, the modulus can be negative? Actually, the sign of the modulus is implementation-defined? \n        //   We can avoid modulus by: \n        //   if (num % 3 != 0) ... but we want to know if it's not divisible.\n\n        // Alternatively, we can do without modulus by checking the product:\n        //   if (x*3 != num) {\n        //       if (num < 0) x--;\n        //   }\n\n        // But then we are doing two comparisons and an extra multiplication.\n\n        // Since the problem does not specify the input range, and the second program only outputs \"Yes\" for 4-digit numbers with two distinct digits each twice, which are positive, maybe the input `n` is intended to be nonnegative? \n\n        // The problem says: \"behaves identically\". So we must handle negative if the original Python does.\n\n        // But note: the second program expects a string. The first program: for negative n, the output would be a negative integer? Then the string would start with a minus sign. Then the second program would see the minus sign and a digit? So for example, n=-1: \n        //   x = ( -2+1 ) // 3 = (-1) // 3 = -1 (in Python)\n        //   Then the string is \"-1\". Then set: {'-','1'} -> two distinct. Then count: \n        //      c['-'] = 1, c['1'] = 1 -> fails the condition (each must be twice). So it would output \"No\".\n\n        // So we have to output the negative number as a string.\n\n        // Therefore, we must handle negative numbers in the first step.\n\n        // How to do floor division in C for negative? \n\n        // We can use:\n        //   x = (n*2+1) / 3;\n        //   if ((n*2+1) % 3 != 0 && (n*2+1) < 0) {\n        //       x--;\n        //   }\n\n        // But the modulus operator in C: \n        //   (a % b) has the same sign as a, so for negative a, the modulus is negative? \n        //   Actually, the standard says: the remainder has the same sign as the dividend.\n\n        // Example: \n        //   -1 / 3: quotient is 0, remainder -1 -> then we can check: if remainder != 0 and num<0, then subtract one.\n\n        // So:\n        //   long num = (long)n * 2 + 1;\n        //   long x = num / 3;\n        //   long rem = num % 3;\n        //   if (rem != 0 && num < 0) {\n        //       x--;\n        //   }\n\n        // Test: n=-1 -> num=-1 -> x = -1/3 = 0? Actually, in C: \n        //   -1 / 3 is 0? and -1 % 3 is -1? \n        //   Then: rem=-1 !=0 and num<0 -> so x becomes -1 -> which is what we want.\n\n        // Another test: n=-2: \n        //   num = -4+1 = -3 -> x = -3/3 = -1, rem=0 -> no adjustment -> correct.\n\n        // n=-3: \n        //   num = -6+1 = -5 -> x = -5/3: in C, -5/3 is -1? because truncation: -5 divided by 3 is -1.66... -> truncation to -1? \n        //   Then rem = -5 % 3: in C, this is -2? because (-1)*3 = -3, and -5 - (-3) = -2 -> so rem=-2 !=0 and num<0 -> then x becomes -1-1 = -2.\n        //   But in Python: (-5)//3 = -2 -> so that's correct.\n\n        // So we do:\n        //   long num = (long)n * 2 + 1;\n        //   long x = num / 3;\n        //   long rem = num % 3;\n        //   if (rem != 0 && num < 0) {\n        //       x--;\n        //   }\n\n        // But note: we must be cautious of overflow? The problem says `n` is integer, but we don't know the range. We use `long` to be safe.\n\n        // However, the problem does not specify the range. But the second program requires the string representation. We can use `long` to handle larger numbers.\n\n        // Alternatively, we can use: \n        //   x = (n*2+1) / 3;\n        //   if (n*2+1 < 0 && (n*2+1) % 3) {\n        //       x--;\n        //   }\n\n        // But the modulus might be negative? and non-zero. So we can write:\n\n        //   if (n*2+1 < 0 && (n*2+1) % 3 != 0) {\n        //       x--;\n        //   }\n\n        // But note: the modulus might be negative? and we check !=0 -> so it's non-zero.\n\n        // However, the expression (n*2+1) might overflow for large n? We are using `int n`? But the problem doesn't specify. We can use `long` for `n` as well.\n\n        // Since the problem does not specify the range, we assume that the input integer is within the range of `int`. But to be safe for the computation, we use `long` for the intermediate.\n\n        // But the problem says: the first program does `n = int(input())` -> which in Python can handle arbitrary large integers? But in C we are limited.\n\n        // However, the problem does not specify the input range. We assume that the input is within the range of `long`.\n\n        // Alternatively, we can use: \n        //   long n;\n        //   scanf(\"%ld\", &n);\n\n        // Then compute:\n        //   long num = n * 2 + 1;\n        //   long x = num / 3;\n        //   if (num % 3 != 0 && num < 0) {\n        //       x--;\n        //   }\n\n        // But note: the modulus operation in C: the sign of the result is the same as the dividend (num). So for negative num, the modulus is negative. So non-zero.\n\n        // This adjustment is for negative num.\n\n        // But what if the division is exact? Then modulus is 0 -> we don't adjust.\n\n        // So this works.\n\n3. Now we have the integer `x` (which is the result of the first program). Then we have to convert it to a string (like the second program would read).\n\n4. Then we check the string:\n   - If the string has exactly 2 distinct characters and each character appears exactly twice -> then output \"Yes\".\n   - Otherwise, output \"No\".\n\nBut note: what if the number is negative? The string will have a minus sign. Then the string for `x` might be, for example, \"-1122\". Then the distinct characters: '-','1','2' -> three distinct -> fails.\n\nOr if we have \"-1111\", then distinct: '-','1' -> two distinct. But counts: \n   '-' : 1, '1': 4 -> fails.\n\nSo the condition is only met for positive numbers? Actually, the condition requires two distinct non-minus digits and each twice? But then the string would be 4 digits? and no minus sign.\n\nBut the first program: for negative n, we get a negative x? Then the string representation has a minus sign. Then the string length would be 5? (if 4 digits) and the minus sign. Then the distinct set would be 3? (if the digits are two distinct) because we have the minus and two digits? Or if the digits are one, then distinct set: two (minus and the digit). But then the counts: minus:1, digit:4 -> fails.\n\nSo the second program will never output \"Yes\" for a negative x? \n\nTherefore, we can assume that the input n is nonnegative? But the problem does not specify. We have to handle negative as well.\n\nBut the chain: the first program might output a negative number as a string. Then the second program will check the string.\n\nSo we do:\n\n   Step 1: Read long integer n.\n   Step 2: Compute x = (n*2+1) // 3 with the adjustment for negative to mimic Python.\n   Step 3: Convert x to a string (including the minus sign if negative).\n   Step 4: \n        - Count the frequency of each character in the string.\n        - Check the number of distinct characters: must be exactly 2.\n        - Check that each distinct character appears exactly 2 times.\n\n   Step 5: Print \"Yes\" if both conditions hold, otherwise \"No\".\n\nImplementation:\n\n   How to convert the long integer to a string? We can use `sprintf`.\n\n   Steps for the second part:\n\n        char s[100]; // we assume 100 is enough for the string representation of a long\n        sprintf(s, \"%ld\", x);\n\n        Then we can build a frequency array (for ASCII). We can use an array of size 256 (for all 8-bit characters). But note: the string will only contain digits and possibly a minus.\n\n        Steps:\n          int freq[256] = {0};\n          int len = strlen(s);\n          for (i=0; i<len; i++) {\n              unsigned char c = s[i];\n              freq[c]++;\n          }\n\n          Then, we want to know:\n            distinct_count = 0;\n            int valid = 1;\n            for (i=0; i<256; i++) {\n                if (freq[i] > 0) {\n                    distinct_count++;\n                    if (freq[i] != 2) {\n                        valid = 0;\n                    }\n                }\n            }\n\n          But note: the condition is: exactly two distinct characters AND each appears exactly twice.\n\n          However, the above loop would set valid=0 if any character does not appear twice. But we break the condition as soon as we see one that is not two? But note: we have to check every character? Actually, we can break early.\n\n          Alternatively, we can do:\n\n            if (distinct_count != 2) {\n                valid = 0;\n            } else {\n                // and each one must be 2? Actually, we already set valid=0 if we see any frequency not 2? \n            }\n\n          But note: the above for-loop sets valid=0 if any character that appears has frequency not 2. Then we check distinct_count? Actually, we can do:\n\n            int distinct_count = 0;\n            int all_twos = 1;\n            for (int i=0; i<256; i++) {\n                if (freq[i] > 0) {\n                    distinct_count++;\n                    if (freq[i] != 2) {\n                        all_twos = 0;\n                    }\n                }\n            }\n\n            if (distinct_count == 2 && all_twos) {\n                printf(\"Yes\\n\");\n            } else {\n                printf(\"No\\n\");\n            }\n\n          But wait: what if we have three distinct characters? Then distinct_count is 3 -> fails. But also, if we have two distinct characters, but one appears 3 times and the other 1, then distinct_count is 2 but all_twos is 0 -> fails.\n\n          But note: the condition in the Python code:\n\n            if len(Sa) != 2: ... fails -> so if distinct_count != 2, we output \"No\".\n            else: then check each in Sa: if any frequency !=2 -> output \"No\".\n\n          Our code above: \n            distinct_count: counts the distinct characters that appear at least once.\n            all_twos: set to 0 if any of the characters that appear have frequency not 2.\n\n          Then we require distinct_count==2 and all_twos==1.\n\n          However, note: the Python code uses the entire string? Our frequency array is built over the entire string.\n\n          But what if the string has a character that does not appear? We only look at the indices where freq[i]>0.\n\n          So it's correct.\n\n        However, note: the frequency array: we are iterating over all 256 indices? We can break earlier? But 256 is small.\n\n        Alternatively, we can avoid iterating over 256 by using a set-like structure? But the string is short? The maximum length of the string representation of a long is about 20? So we can iterate over the string to compute distinct characters and their frequencies? Actually, we already built the frequency array. The 256 iteration is acceptable.\n\n        But note: we are building the frequency array by iterating the string (which is short) and then iterating 256 (which is constant). So it's efficient.\n\n   However, we can optimize: we can break early if we find more than 2 distinct characters? But we are building the frequency array in the first loop. Then we have to do the second loop to check frequencies. Actually, we can combine:\n\n        We can do:\n\n          int distinct_count = 0;\n          int seen[256] = {0};   // or we can use the freq array, but we haven't built it?\n\n          Alternatively, we can do:\n\n          char *p = s;\n          int freq[256] = {0};\n          while (*p) {\n              freq[(unsigned char)*p]++;\n              p++;\n          }\n\n          Then we do the distinct_count and check for non-2.\n\n   But the original code uses a set and then a Counter. We are simulating that.\n\n   Edge: what if the string is empty? \n        Then distinct_count=0 -> then we output \"No\", which is correct.\n\n   For example, if x=0: then the string is \"0\". \n        distinct_count: 1 -> fails.\n\n   So the program:\n\n        Read n (as long)\n        Compute x = (n*2+1) // 3 (with adjustment for negative)\n        Convert x to string -> s\n        Build frequency array for s\n        distinct_count = 0;\n        all_twos = 1;\n        for (int i=0; i<256; i++) {\n            if (freq[i]) {\n                distinct_count++;\n                if (freq[i] != 2) {\n                    all_twos = 0;\n                }\n            }\n        }\n        if (distinct_count == 2 && all_twos) {\n            printf(\"Yes\\n\");\n        } else {\n            printf(\"No\\n\");\n        }\n\n   But note: the condition \"all_twos\" requires that every character that appears must appear exactly twice? Yes. \n\n   However, what if we have two distinct characters and one appears twice and the other appears twice? Then we output \"Yes\". But what if we have two distinct characters and one appears twice and the other appears three times? Then distinct_count=2, but all_twos=0 -> we output \"No\".\n\n   This matches the Python code.\n\n   However, note: the Python code:\n\n        for i in Sa:\n            if c[i] != 2:\n                print(\"No\")\n                exit()\n\n        So it checks every distinct character: if any one is not 2, it fails.\n\n   Our code: if any character in the entire string has frequency not 2, we set all_twos=0 -> then we output \"No\". \n\n   But note: the distinct set `Sa` is the set of distinct characters. We are iterating over every distinct character? Actually, in the frequency array, we are iterating over every character in the ASCII set? But we skip if freq[i]==0. So we are iterating only over the distinct characters? \n\n   Actually, we are iterating over all 256 bytes, but we skip the ones with freq[i]==0. So we are effectively iterating over the distinct characters? \n\n   But note: we are checking the frequency of each distinct character? Yes.\n\n   However, we set `all_twos` to 0 if we see any distinct character that does not have frequency 2. Then after the loop, we check distinct_count and all_twos.\n\n   But we don't break early. We can break early? But 256 is constant.\n\n   Alternatively, we can break the loop when we find one that is not 2? But then we wouldn't know the distinct_count? Actually, we can break the condition: if we see a frequency that is not 2, then we know it fails? But we still have to count the distinct_count? \n\n   However, if we see a frequency that is not 2, we know we are going to output \"No\". But we also must know if distinct_count is not 2? So we have to complete the distinct_count? \n\n   Actually, we can break early only if we already have distinct_count>2? But we are building the distinct_count as we go? \n\n   Alternatively, we can do:\n\n        int distinct_count = 0;\n        for (int i=0; i<256; i++) {\n            if (freq[i]) {\n                distinct_count++;\n                if (freq[i] != 2) {\n                    // we know it fails? but we have to check distinct_count at the end? \n                    // We can set a flag and break? but we still need the distinct_count? \n                }\n            }\n        }\n\n        Then we check distinct_count and also we need to know if any freq[i] !=2.\n\n   So we can do:\n\n        int distinct_count = 0;\n        int has_non_two = 0;\n        for (int i=0; i<256; i++) {\n            if (freq[i] > 0) {\n                distinct_count++;\n                if (freq[i] != 2) {\n                    has_non_two = 1;\n                }\n            }\n        }\n\n        if (distinct_count == 2 && !has_non_two) {\n            printf(\"Yes\\n\");\n        } else {\n            printf(\"No\\n\");\n        }\n\n   This is equivalent.\n\n   But note: we can break early if distinct_count becomes more than 2? Actually, we can break the loop if distinct_count>2 and has_non_two? But we still have to check the rest? Because we need to know if there's a non-two? Actually, we can break only if we have distinct_count>2 and we don't care about non_two? But no: we have to check non_two even if distinct_count is 2? \n\n   Alternatively, we can break the loop if distinct_count>2? But then we don't know if there is a non_two? Actually, if distinct_count>2, then the condition fails regardless of non_two? So we can break? \n\n        int distinct_count = 0;\n        int has_non_two = 0;\n        for (int i=0; i<256; i++) {\n            if (freq[i]) {\n                distinct_count++;\n                if (freq[i] != 2) {\n                    has_non_two = 1;\n                }\n                // If distinct_count>2 and has_non_two? we don't care, we know we are going to output \"No\", but we cannot break because we might have more distinct_count? \n                // But we can break only if distinct_count>2? Actually, if distinct_count>2, then we know the condition fails? But we still have to check the entire frequency? \n                // Actually, we can break early only if we know that distinct_count>2 and we don't care about the rest? But we are building the frequency array? The rest of the frequencies might be zero. \n                // The loop is over 256, which is constant, so it's acceptable to not break.\n\n            }\n        }\n\n   Since 256 is small, we don't break.\n\n   But note: the string is short, so the frequency array will have at most 10-20 non-zero entries? So we can break when we have more than 2 distinct_count and also we have seen a non_two? Actually, no: we have to count the distinct_count exactly? \n\n   Actually, we cannot break early in the frequency array loop because we need to know the total distinct_count? \n\n   So we do the full iteration.\n\n   However, we can do an alternative: iterate over the string and build a set of distinct characters and a frequency map? But we already built the frequency array. Then we have to iterate over the 256 to get distinct_count and non_two? \n\n   We'll do the 256 iteration.\n\n   Code structure:\n\n        #include <stdio.h>\n        #include <stdlib.h>\n        #include <string.h>\n        #include <ctype.h>\n\n        int main() {\n            long n;\n            scanf(\"%ld\", &n);\n\n            // Compute num = n*2+1\n            long num = n * 2 + 1;\n            long x = num / 3;\n            long rem = num % 3;\n\n            // Adjust for negative and non-divisible\n            if (rem != 0 && num < 0) {\n                x--;\n            }\n\n            // Convert x to string\n            char s[100];\n            sprintf(s, \"%ld\", x);\n\n            // Frequency array for 256 ASCII\n            int freq[256] = {0};\n            size_t len = strlen(s);\n            for (size_t i = 0; i < len; i++) {\n                unsigned char c = s[i];\n                freq[c]++;\n            }\n\n            int distinct_count = 0;\n            int has_non_two = 0;\n            for (int i = 0; i < 256; i++) {\n                if (freq[i]) {\n                    distinct_count++;\n                    if (freq[i] != 2) {\n                        has_non_two = 1;\n                    }\n                }\n            }\n\n            if (distinct_count == 2 && !has_non_two) {\n                printf(\"Yes\\n\");\n            } else {\n                printf(\"No\\n\");\n            }\n\n            return 0;\n        }\n\n   But note: the Python program chain: the first program outputs the integer, and the second program uses that as a string. The first program does not output a newline? Actually, in Python, `print((n * 2 + 1) // 3)` outputs the integer and then a newline? \n\n   But the second program uses `input()` which by default reads a line? So the entire string including the newline? Actually, no: `input()` in Python reads a line and strips the trailing newline. So the string `S` is the integer without the newline.\n\n   In our C program, we are using `sprintf` to write to `s` without a newline. Then we build the frequency array of that string. So that matches.\n\n   However, the first program in Python outputs the integer and a newline. But the second program reads the integer without the newline? Because `input()` strips the newline. So the string in the second program is the integer string without the newline.\n\n   In our C program, we are not including a newline in the string `s`. So it's the same.\n\n   But note: what if the integer is negative? We use `%ld` and it will put a minus sign. That is the same as Python.\n\n   Let me test with a positive integer: \n        n=4: \n        num = 4*2+1 = 9 -> x=9/3=3 -> no adjustment -> string \"3\"\n        Then distinct_count: 1 -> fails -> output \"No\"\n\n   n=5: (5*2+1)//3 = 11//3 = 3 -> same.\n\n   What about n=8: \n        (8*2+1)=17 -> 17//3 = 5 -> string \"5\" -> fails.\n\n   How can we get a string of length 4? \n        We need x to be a 4-digit number with two distinct digits and each twice.\n\n        For example, x=1122 -> then we need (n*2+1)//3 = 1122 -> so n = (1122*3-1)/2 = (3366-1)/2 = 3365/2 = 1682.5 -> not integer.\n\n        x=1212: then n = (1212*3-1)/2 = (3636-1)/2 = 3635/2 -> not integer.\n\n        How about x=22? then the string is \"22\" -> distinct_count=1 -> fails.\n\n        x=112? distinct set: {'1','2'} -> distinct_count=2, but frequencies: '1':2, '2':1 -> fails.\n\n        x=1121: distinct set: {'1','2'} -> frequencies: '1':3, '2':1 -> fails.\n\n        x=1122: distinct set: {'1','2'} -> frequencies: both 2 -> valid.\n\n        Then we need: (n*2+1)//3 = 1122 -> so n*2+1 = 1122*3 = 3366 -> n*2 = 3365 -> n=3365/2 -> not integer.\n\n        How about x=2211? same as 1122.\n\n        How about x=1221? Then n*2+1 = 1221*3 = 3663 -> n*2=3662 -> n=1831.\n\n        Then we run the first program: \n            n=1831 -> (1831*2+1)=3662+1=3663 -> 3663//3=1221 -> so x=1221.\n\n        Then the second program: \n            S=\"1221\"\n            distinct set: {'1','2'} -> size=2 -> then check: \n                c['1']=2, c['2']=2 -> \"Yes\"\n\n        So we can test with n=1831.\n\n        In our C program: \n            n=1831\n            num = 1831*2+1 = 3663\n            x = 3663/3 = 1221 -> no adjustment.\n            s = \"1221\"\n            frequencies: \n                '1':2, '2':2 -> distinct_count=2, has_non_two=0 -> output \"Yes\"\n\n        So it works.\n\n   But note: the adjustment for negative? We tested with n=-1: \n        num = -1\n        x = -1/3 -> in C: -1/3=0? and rem = -1%3 = -1? \n        then adjustment: rem!=0 and num<0 -> x becomes -1 -> string \"-1\"\n        frequencies: \n            '-':1 -> distinct_count=1? then we break? \n            and then check: distinct_count=2? no, and then output \"No\".\n\n        But the distinct characters: \n            s[0] = '-' -> freq['-']=1\n            s[1] = '1' -> freq['1']=1\n            distinct_count=2? \n            but then we see: freq['-']=1 !=2 -> has_non_two=1 -> then output \"No\".\n\n        So both conditions: distinct_count==2 is true, but has_non_two is true -> then output \"No\".\n\n        But the condition: we require distinct_count==2 and !has_non_two -> so we output \"No\", which is correct.\n\n   Therefore, the code is:\n\n        #include <stdio.h>\n        #include <stdlib.h>\n        #include <string.h>\n\n        int main() {\n            long n;\n            scanf(\"%ld\", &n);\n\n            long num = n * 2 + 1;\n            long x = num / 3;\n            long rem = num % 3;\n            if (rem != 0 && num < 0) {\n                x--;\n            }\n\n            char s[100];\n            sprintf(s, \"%ld\", x);\n\n            int freq[256] = {0};\n            for (int i = 0; s[i] != '\\0'; i++) {\n                unsigned char c = s[i];\n                freq[c]++;\n            }\n\n            int distinct_count = 0;\n            int has_non_two = 0;\n            for (int i = 0; i < 256; i++) {\n                if (freq[i]) {\n                    distinct_count++;\n                    if (freq[i] != 2) {\n                        has_non_two = 1;\n                    }\n                }\n            }\n\n            if (distinct_count == 2 && !has_non_two) {\n                printf(\"Yes\\n\");\n            } else {\n                printf(\"No\\n\");\n            }\n\n            return 0;\n        }\n\n   However, note: the modulus operation for negative: the behavior of `%` in C for negative numbers: the standard says it should satisfy: (a/b)*b + a%b == a, and the sign of the remainder is the same as the dividend. So we are safe.\n\n   But what if the division overflows? We are using `long` for `n`, and then `num = n*2+1` might overflow for very large `n`? But the problem doesn't specify the range. We assume that the input is such that `n*2+1` does not overflow `long`. \n\n   Alternatively, we can use `long long` for `num`? \n\n   Let me use `long long` for `num` to avoid overflow? But the problem says the input is an integer. We don't know the range. But `long` might be 32-bit or 64-bit. We can use:\n\n        long long num = (long long)n * 2 + 1;\n\n   But we read `n` as `long`. Then we can do:\n\n        long n;\n        scanf(\"%ld\", &n);\n        long long num = (long long)n * 2 + 1;\n\n   Then do the division and modulus on `long long`.\n\n   Then adjust:\n\n        long long x = num / 3;\n        long long rem = num % 3;\n\n        Then we have to convert x to a string? We use `sprintf(s, \"%lld\", x);`\n\n   But note: the problem says the input is integer, and we are using `long` for `n`, but if the input is very large, we use `long long` for the intermediate.\n\n   Alternatively, we can read `n` as `long long`? Then we don't need two types.\n\n   Let me do:\n\n        long long n;\n        scanf(\"%lld\", &n);\n\n        long long num = n * 2 + 1;\n        long long x = num / 3;\n        long long rem = num % 3;\n        if (rem != 0 && num < 0) {\n            x--;\n        }\n\n        char s[100];\n        sprintf(s, \"%lld\", x);\n\n   But the problem: the first program uses `int(input())` in Python, which can handle arbitrary large integers? But in C we are limited by `long long`. But the problem does not specify the input range. We assume it fits in `long long`.\n\n   Alternatively, we can use `long` for everything if we know the range is small. But to be safe, we use `long long`.\n\n   However, note: the second program: the string representation of a `long long` might be up to 20 characters? So `s[100]` is safe.\n\n   So the final code:\n\n        #include <stdio.h>\n        #include <stdlib.h>\n        #include <string.h>\n\n        int main() {\n            long long n;\n            scanf(\"%lld\", &n);\n\n            long long num = n * 2 + 1;\n            long long x = num / 3;\n            long long rem = num % 3;\n            if (rem != 0 && num < 0) {\n                x--;\n            }\n\n            char s[100];\n            sprintf(s, \"%lld\", x);\n\n            int freq[256] = {0};\n            for (int i = 0; s[i] != '\\0'; i++) {\n                unsigned char c = s[i];\n                freq[c]++;\n            }\n\n            int distinct_count = 0;\n            int has_non_two = 0;\n            for (int i = 0; i < 256; i++) {\n                if (freq[i]) {\n                    distinct_count++;\n                    if (freq[i] != 2) {\n                        has_non_two = 1;\n                    }\n                }\n            }\n\n            if (distinct_count == 2 && !has_non_two) {\n                printf(\"Yes\\n\");\n            } else {\n                printf(\"No\\n\");\n            }\n\n            return 0;\n        }\n\n   Let me test with n=1831: \n        num = 1831*2+1 = 3663\n        x = 3663/3 = 1221 -> no adjustment.\n        s = \"1221\"\n        freq: \n            '1':2, '2':2\n        distinct_count: 2\n        has_non_two: 0 -> output \"Yes\"\n\n   Test with n=0:\n        num = 0*2+1 = 1\n        x = 1/3 = 0 (in C integer division) -> rem=1 -> but num>0 -> no adjustment -> x=0\n        s=\"0\"\n        distinct_count=1 -> output \"No\"\n\n   Test with n=-1:\n        num = -2+1 = -1\n        x = -1/3: in C, -1/3 is 0? and rem = -1? \n        then: rem !=0 and num<0 -> x = 0-1 = -1\n        s = \"-1\"\n        freq: '-'->1, '1'->1\n        distinct_count=2 -> but has_non_two=1 (because both are 1, not 2) -> output \"No\"\n\n   So it matches.\n\n   However, note: the modulus for negative in C: \n        For num=-1: \n            -1 / 3 is 0? because truncation toward zero. Then -1 % 3 is -1? \n        Then we adjust: x = 0-1 = -1.\n\n   So it's correct.\n\n   We'll use this code.\n\n   But note: the problem says \"Only the first block should handle reading input. Only the last block should handle producing output.\" -> We are reading once and printing once at the end.\n\n   And no I/O in between.\n\n   So we are good.\n\n   Let me write the code accordingly."
}