{
  "segments": [
    {
      "text": "Okay, let's see.",
      "start_char": 0,
      "end_char": 16,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "I need to translate this Java code into C. Let me first understand what the Java code is doing. So the program reads five integers into an array a. Then for each element, it calculates the remainder when divided by 10, which is stored in r.",
      "start_char": 17,
      "end_char": 257,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Then, if the remainder is not zero, it computes 10 minus that remainder (which gives how much you need to add to make it a multiple of 10), and puts this value along with the original a[i] into a TreeMap. TreeMap in Java is a sorted map, so the keys are ordered.",
      "start_char": 260,
      "end_char": 522,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "The idea here is probably to find the element that has the largest remainder, so that when adjusting the times to make all numbers multiples of 10, we can process that one last to minimize the total time. Because adding the minimal possible for others and then the last one as is.",
      "start_char": 523,
      "end_char": 803,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "The algorithm's goal is to sum all the numbers, but each number (except possibly one) is rounded up to the nearest multiple of 10. The one that's not rounded is the one that has the largest remainder when divided by 10. Because that way, the total sum is minimized.",
      "start_char": 805,
      "end_char": 1070,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "For example, if a number is 23, remainder 3, so we add 7 to make 30. But if another number is 25 (remainder 5), then adding 5 would make it 30. So the largest remainder (5 in this case) would be the one we process last without adding, to save the most time. So the TreeMap here is used to track the required additional time (b) for each number (unless it's already a multiple of 10).",
      "start_char": 1071,
      "end_char": 1454,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Since TreeMap is sorted, the last key is the largest 'b', which corresponds to the number with the largest remainder.",
      "start_char": 1456,
      "end_char": 1573,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "That's the number we leave as is (we don't add anything to it), and all others are adjusted up to the nearest 10. Now, translating this to C.",
      "start_char": 1574,
      "end_char": 1715,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "The first thing is that C doesn't have TreeMap. So we need to find another way to track the maximum 'b' value and the corresponding a[i]. The steps are:\n\n1. Read 5 integers into array a.\n2. For each a[i], compute r[i] = a[i] % 10.\n3. For each a[i], if r[i] != 0, compute b = 10 - r[i]. We need to track the maximum b.",
      "start_char": 1717,
      "end_char": 2035,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "The a[i] with the maximum b is the one we will not adjust (so we add a[i] as is, and others are adjusted up to the next multiple of 10).",
      "start_char": 2036,
      "end_char": 2172,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "4. Sum all the adjusted values, except for the a[i] with the maximum b, which is added as is. So in C, instead of using a TreeMap, we can track the maximum b and its corresponding a[i], and the index where it occurs. Then in the sum, for all elements except that one, add (a[i] + b) if a[i] is not a multiple of 10, else add a[i]. Wait, no.",
      "start_char": 2173,
      "end_char": 2513,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Wait, in the code, the Java code for others adds a[i] if it's a multiple of 10, otherwise adds a[i] + (10 - r[i]). So in C, the steps are:\n\n- Read 5 numbers into a[0] to a[4].\n- Find the maximum b (10 - r[i] where r[i] is a[i]%10 and r[i] ! =0). But wait, for numbers that are multiples of 10, r[i] is 0, so their b is not considered.",
      "start_char": 2515,
      "end_char": 2849,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Because in the Java code, if r[i] is 0, it's not added to the TreeMap. So the TreeMap only contains entries for a[i]s that are not multiples of 10. So the code's logic is:\n\nIf all a[i] are multiples of 10 (map.size() is 0), then sum all a[i] and output.",
      "start_char": 2850,
      "end_char": 3103,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Otherwise, find the a[i] with the largest b (10 - r[i], which is equivalent to the largest (10 - (a[i]%10)), which is the same as the smallest a[i]%10 (since 10 - r[i] is larger when r[i] is smaller). Wait no. For example, if r is 1, 10-1=9. If r is 3, 10-3=7. So the larger b is, the smaller r is. So the largest b is when r is the smallest (but non-zero). So the code is finding the a[i] with the largest b, which corresponds to the smallest remainder (non-zero). That's the element that requires the largest additional time. Wait, no.",
      "start_char": 3105,
      "end_char": 3642,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Wait, the code in the Java code uses the TreeMap to track the entries for which r[i] is not zero, and the key is b (10 - r[i]).",
      "start_char": 3643,
      "end_char": 3770,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The TreeMap is ordered, so the last key is the largest. So the a[i] with the largest b is the one that has the smallest remainder (non-zero). Because, for example, if a number has remainder 1, then 10-1=9 (b=9), which is larger than a remainder of 2 (b=8). So the largest b is 9, which occurs when r=1. So the code selects the a[i] with the largest b (i.e., the one with the smallest non-zero remainder). That way, when processing the other elements, their required additional time is minimal.",
      "start_char": 3771,
      "end_char": 4264,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Because for example, if one element has remainder 1 (needs 9 to reach next 10), but we process it last, so others are adjusted. Wait, perhaps I'm getting this backwards. Wait, the code's goal is to have all elements except one rounded up to the next multiple of 10.",
      "start_char": 4265,
      "end_char": 4531,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "The one that isn't rounded is the one that requires the most additional time (so we can save that time by not adding it). Wait, no. For example, if a number is 3, which has remainder 3, then 10-3=7. So adding 7 would make it 10.",
      "start_char": 4532,
      "end_char": 4760,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "If we leave this as the last element, then in the sum, we can avoid adding 7. So the total sum is sum of others (adjusted) plus 3. That's better than adding 7. So the element with the largest required additional time (b) is the one we leave unadjusted, to minimize the sum. So in that case, the code is correct: we find the element with the maximum b (i.e., the one that would need the most additional time) and leave it as is. So in the example where elements are 3 and 7. For 3: r=3, b=7. For 7: r=7, b=3. So the maximum b is 7. So we leave 3 unadjusted. Then sum would be 3 (unadjusted) and 7+3=10. So total is 13. But if we left 7 unadjusted, sum would be 3+7 = 10 (3+7=10, but 7's adjusted is 10, so sum is 10 +7=17. So leaving the one with the largest b unadjusted gives a lower total. So the logic is correct. Therefore, in the code, the element with the largest b is the one that is left as is.",
      "start_char": 4761,
      "end_char": 5664,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "So, in the C code, we need to find which element has the largest b (10 - r[i]) where r[i] is not zero. If all elements are multiples of 10, then sum all.",
      "start_char": 5666,
      "end_char": 5819,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Otherwise, process all elements except the one with maximum b (adding their adjusted values) and then add the unadjusted element. So how to implement this in C.\n\nFirst, read the 5 numbers. Then, for each a[i], compute r = a[i] %10. If r !=0, compute b=10 - r. Track the maximum b and the corresponding a[i] and its index. If all a[i] have r ==0, then sum all a[i], print. Else:\n\nSum all elements except the one with maximum b. For each element except that one: if r ==0, add a[i]. else add a[i] + (10 - r). Then add the a[i] with maximum b. So in code:\n\nint a[5], i;\n\nfor (i=0; i<5; i++) {\n   scanf(\"%d\", &a[i]);\n}\n\nint max_b = -1;\nint max_index = -1;\n\nfor (i=0; i<5; i++) {\n   int r = a[i] %10;\n   if (r !=0) {\n       int b = 10 - r;\n       if (b > max_b) {\n           max_b = b;\n           max_index = i;\n       }\n   }\n}\n\nif (max_index == -1) { // all are multiples of 10\n   int sum =0;\n   for (i=0; i<5; i++) sum += a[i];\n   printf(\"%d\\n\", sum);\n   return 0;\n}\n\n// else, process others\nint sum =0;\nfor (i=0; i<5; i++) {\n   if (i == max_index) continue;\n   int r = a[i] %10; if (r ==0) {\n       sum += a[i];\n   } else {\n       sum += a[i] + (10 - r);\n   }\n}\n\nsum += a[max_index];\nprintf(\"%d\\n\", sum);\n\nWait, but in the Java code, after finding the last element (the one with the largest b), the code loops through the array to find its index. But in our C code, during the initial loop, we track the max_index. So that part is handled.",
      "start_char": 5820,
      "end_char": 7265,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Wait, but in the Java code, when multiple elements have the same max b, the TreeMap's lastKey() would pick the last one (since TreeMap sorts the keys, and if there are duplicate keys, the later ones would overwrite the previous ones in the map). So the Java code would select the last occurrence of the maximum b. So in our C code, when updating max_b and max_index, if a[i] has the same b as current max_b, then we should update max_index to the current i. Because that way, in the case of multiple elements with same max_b, the last one is selected (as in Java's TreeMap, where the lastKey() would be the same, but the value stored would be the last one added with that key). Yes.",
      "start_char": 7267,
      "end_char": 7949,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Because in the Java code, when you have two elements with the same key (b), then map.put(b, a[i]) would overwrite the previous entry. So the last occurrence would be stored. So in C, when tracking max_b and max_index, when we find a b equal to current max_b, we should update the max_index to the current i, so that the last occurrence is chosen. So in the loop:\n\nif (r !=0) {\n   b = 10 - r;\n   if (b > max_b || (b == max_b && i > max_index)) { // No, wait. Because the initial max_b is -1, so the first element with r ! =0 will set max_b to b.",
      "start_char": 7951,
      "end_char": 8495,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Then, for each subsequent element with same or higher b.\n\nWait, perhaps the code for tracking the max_index should be: Initially, max_b is -1. For each a[i], compute r and b (if r !=0). Then, if (b > max_b) then update max_b and max_index. If (b == max_b) and if current i is later than previous max_index, then update.",
      "start_char": 8496,
      "end_char": 8816,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Because in Java, TreeMap will have entries ordered by key. So for entries with the same key, the later one (when added via put) will overwrite the previous one. So in the Java code, if two elements have the same b, the one that comes later in the array is the one that is stored in the TreeMap, and thus when you call map.get(map.lastKey()), you get the last a[i] with that b. So to replicate that behavior, in C, when we find a b equal to the current max_b, we should check if this is the same as max_b, and if so, update the max_index to this i only if this i is later than the current max_index. So in the loop:\n\nfor (i=0; i<5; i++) {\n   int r = a[i] %10;\n   if (r !=0) {\n       int b = 10 - r;\n       if (b > max_b) {\n           max_b = b;\n           max_index = i;\n       } else if (b == max_b) {\n           // if same b, overwrite if current index is larger than previous\n           if (i > max_index) {\n               max_index = i;\n           }\n       }\n   }\n}\n\nThis way, if multiple elements have the same max_b, the last one in the array is chosen. So that's important to replicate the Java code's behavior. So with that, the C code can be written. So putting it all together:\n\nRead the 5 numbers into array a.\n\nThen loop through each to find max_b and max_index. If max_index is -1 (all are multiples of 10), sum all and output. Else, sum all elements except the one at max_index.",
      "start_char": 8817,
      "end_char": 10215,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "For each element except that one, if their remainder is 0, add as is. Else, add a[i] + (10 - r). Then add the a[max_index] as is. So code:\n\n#include <stdio.h>\n\nint main() {\n    int a[5];\n    for (int i = 0; i < 5; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n\n    int max_b = -1;\n    int max_index = -1;\n\n    for (int i = 0; i < 5; i++) {\n        int r = a[i] % 10; if (r != 0) {\n            int b = 10 - r;\n            if (b > max_b) {\n                max_b = b;\n                max_index = i;\n            } else if (b == max_b) {\n                if (i > max_index) {\n                    max_index = i;\n                }\n            }\n        }\n    }\n\n    if (max_index == -1) { // all multiples of 10\n        int sum = 0;\n        for (int i = 0; i < 5; i++) {\n            sum += a[i];\n        }\n        printf(\"%d\\n\", sum);\n        return 0;\n    }\n\n    int sum = 0;\n    for (int i = 0; i < 5; i++) {\n        if (i == max_index) {\n            continue;\n        }\n        int r = a[i] % 10;\n        if (r == 0) {\n            sum += a[i];\n        } else {\n            sum += a[i] + (10 - r);\n        }\n    }\n\n    sum += a[max_index];\n    printf(\"%d\\n\", sum);\n\n    return 0;\n}\n\nThis should replicate the Java code's logic. Testing with sample inputs would be good, but given the time constraints, this should be correct.",
      "start_char": 10216,
      "end_char": 11540,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    }
  ],
  "original_reasoning": "Okay, let's see. I need to translate this Java code into C. Let me first understand what the Java code is doing. \n\nSo the program reads five integers into an array a. Then for each element, it calculates the remainder when divided by 10, which is stored in r. Then, if the remainder is not zero, it computes 10 minus that remainder (which gives how much you need to add to make it a multiple of 10), and puts this value along with the original a[i] into a TreeMap. TreeMap in Java is a sorted map, so the keys are ordered. The idea here is probably to find the element that has the largest remainder, so that when adjusting the times to make all numbers multiples of 10, we can process that one last to minimize the total time. Because adding the minimal possible for others and then the last one as is.\n\nThe algorithm's goal is to sum all the numbers, but each number (except possibly one) is rounded up to the nearest multiple of 10. The one that's not rounded is the one that has the largest remainder when divided by 10. Because that way, the total sum is minimized. For example, if a number is 23, remainder 3, so we add 7 to make 30. But if another number is 25 (remainder 5), then adding 5 would make it 30. So the largest remainder (5 in this case) would be the one we process last without adding, to save the most time.\n\nSo the TreeMap here is used to track the required additional time (b) for each number (unless it's already a multiple of 10). Since TreeMap is sorted, the last key is the largest 'b', which corresponds to the number with the largest remainder. That's the number we leave as is (we don't add anything to it), and all others are adjusted up to the nearest 10.\n\nNow, translating this to C. The first thing is that C doesn't have TreeMap. So we need to find another way to track the maximum 'b' value and the corresponding a[i].\n\nThe steps are:\n\n1. Read 5 integers into array a.\n2. For each a[i], compute r[i] = a[i] % 10.\n3. For each a[i], if r[i] != 0, compute b = 10 - r[i]. We need to track the maximum b. The a[i] with the maximum b is the one we will not adjust (so we add a[i] as is, and others are adjusted up to the next multiple of 10).\n4. Sum all the adjusted values, except for the a[i] with the maximum b, which is added as is.\n\nSo in C, instead of using a TreeMap, we can track the maximum b and its corresponding a[i], and the index where it occurs. Then in the sum, for all elements except that one, add (a[i] + b) if a[i] is not a multiple of 10, else add a[i]. Wait, no. Wait, in the code, the Java code for others adds a[i] if it's a multiple of 10, otherwise adds a[i] + (10 - r[i]).\n\nSo in C, the steps are:\n\n- Read 5 numbers into a[0] to a[4].\n- Find the maximum b (10 - r[i] where r[i] is a[i]%10 and r[i] !=0). But wait, for numbers that are multiples of 10, r[i] is 0, so their b is not considered. Because in the Java code, if r[i] is 0, it's not added to the TreeMap. So the TreeMap only contains entries for a[i]s that are not multiples of 10.\n\nSo the code's logic is:\n\nIf all a[i] are multiples of 10 (map.size() is 0), then sum all a[i] and output. Otherwise, find the a[i] with the largest b (10 - r[i], which is equivalent to the largest (10 - (a[i]%10)), which is the same as the smallest a[i]%10 (since 10 - r[i] is larger when r[i] is smaller). Wait no. For example, if r is 1, 10-1=9. If r is 3, 10-3=7. So the larger b is, the smaller r is. So the largest b is when r is the smallest (but non-zero). So the code is finding the a[i] with the largest b, which corresponds to the smallest remainder (non-zero). That's the element that requires the largest additional time. Wait, no. Wait, the code in the Java code uses the TreeMap to track the entries for which r[i] is not zero, and the key is b (10 - r[i]). The TreeMap is ordered, so the last key is the largest. So the a[i] with the largest b is the one that has the smallest remainder (non-zero). Because, for example, if a number has remainder 1, then 10-1=9 (b=9), which is larger than a remainder of 2 (b=8). So the largest b is 9, which occurs when r=1. So the code selects the a[i] with the largest b (i.e., the one with the smallest non-zero remainder). That way, when processing the other elements, their required additional time is minimal. Because for example, if one element has remainder 1 (needs 9 to reach next 10), but we process it last, so others are adjusted. Wait, perhaps I'm getting this backwards.\n\nWait, the code's goal is to have all elements except one rounded up to the next multiple of 10. The one that isn't rounded is the one that requires the most additional time (so we can save that time by not adding it). Wait, no. For example, if a number is 3, which has remainder 3, then 10-3=7. So adding 7 would make it 10. If we leave this as the last element, then in the sum, we can avoid adding 7. So the total sum is sum of others (adjusted) plus 3. That's better than adding 7. So the element with the largest required additional time (b) is the one we leave unadjusted, to minimize the sum. So in that case, the code is correct: we find the element with the maximum b (i.e., the one that would need the most additional time) and leave it as is. So in the example where elements are 3 and 7. For 3: r=3, b=7. For 7: r=7, b=3. So the maximum b is 7. So we leave 3 unadjusted. Then sum would be 3 (unadjusted) and 7+3=10. So total is 13. But if we left 7 unadjusted, sum would be 3+7 = 10 (3+7=10, but 7's adjusted is 10, so sum is 10 +7=17. So leaving the one with the largest b unadjusted gives a lower total.\n\nSo the logic is correct. Therefore, in the code, the element with the largest b is the one that is left as is.\n\nSo, in the C code, we need to find which element has the largest b (10 - r[i]) where r[i] is not zero. If all elements are multiples of 10, then sum all. Otherwise, process all elements except the one with maximum b (adding their adjusted values) and then add the unadjusted element.\n\nSo how to implement this in C.\n\nFirst, read the 5 numbers.\n\nThen, for each a[i], compute r = a[i] %10. If r !=0, compute b=10 - r. Track the maximum b and the corresponding a[i] and its index.\n\nIf all a[i] have r ==0, then sum all a[i], print.\n\nElse:\n\nSum all elements except the one with maximum b. For each element except that one: if r ==0, add a[i]. else add a[i] + (10 - r). Then add the a[i] with maximum b.\n\nSo in code:\n\nint a[5], i;\n\nfor (i=0; i<5; i++) {\n   scanf(\"%d\", &a[i]);\n}\n\nint max_b = -1;\nint max_index = -1;\n\nfor (i=0; i<5; i++) {\n   int r = a[i] %10;\n   if (r !=0) {\n       int b = 10 - r;\n       if (b > max_b) {\n           max_b = b;\n           max_index = i;\n       }\n   }\n}\n\nif (max_index == -1) { // all are multiples of 10\n   int sum =0;\n   for (i=0; i<5; i++) sum += a[i];\n   printf(\"%d\\n\", sum);\n   return 0;\n}\n\n// else, process others\nint sum =0;\nfor (i=0; i<5; i++) {\n   if (i == max_index) continue;\n   int r = a[i] %10;\n   if (r ==0) {\n       sum += a[i];\n   } else {\n       sum += a[i] + (10 - r);\n   }\n}\n\nsum += a[max_index];\nprintf(\"%d\\n\", sum);\n\nWait, but in the Java code, after finding the last element (the one with the largest b), the code loops through the array to find its index. But in our C code, during the initial loop, we track the max_index. So that part is handled.\n\nWait, but in the Java code, when multiple elements have the same max b, the TreeMap's lastKey() would pick the last one (since TreeMap sorts the keys, and if there are duplicate keys, the later ones would overwrite the previous ones in the map). So the Java code would select the last occurrence of the maximum b. So in our C code, when updating max_b and max_index, if a[i] has the same b as current max_b, then we should update max_index to the current i. Because that way, in the case of multiple elements with same max_b, the last one is selected (as in Java's TreeMap, where the lastKey() would be the same, but the value stored would be the last one added with that key).\n\nYes. Because in the Java code, when you have two elements with the same key (b), then map.put(b, a[i]) would overwrite the previous entry. So the last occurrence would be stored. So in C, when tracking max_b and max_index, when we find a b equal to current max_b, we should update the max_index to the current i, so that the last occurrence is chosen.\n\nSo in the loop:\n\nif (r !=0) {\n   b = 10 - r;\n   if (b > max_b || (b == max_b && i > max_index)) { // No, wait. Because the initial max_b is -1, so the first element with r !=0 will set max_b to b. Then, for each subsequent element with same or higher b.\n\nWait, perhaps the code for tracking the max_index should be:\n\nInitially, max_b is -1. For each a[i], compute r and b (if r !=0). Then, if (b > max_b) then update max_b and max_index. If (b == max_b) and if current i is later than previous max_index, then update. Because in Java, TreeMap will have entries ordered by key. So for entries with the same key, the later one (when added via put) will overwrite the previous one. So in the Java code, if two elements have the same b, the one that comes later in the array is the one that is stored in the TreeMap, and thus when you call map.get(map.lastKey()), you get the last a[i] with that b.\n\nSo to replicate that behavior, in C, when we find a b equal to the current max_b, we should check if this is the same as max_b, and if so, update the max_index to this i only if this i is later than the current max_index.\n\nSo in the loop:\n\nfor (i=0; i<5; i++) {\n   int r = a[i] %10;\n   if (r !=0) {\n       int b = 10 - r;\n       if (b > max_b) {\n           max_b = b;\n           max_index = i;\n       } else if (b == max_b) {\n           // if same b, overwrite if current index is larger than previous\n           if (i > max_index) {\n               max_index = i;\n           }\n       }\n   }\n}\n\nThis way, if multiple elements have the same max_b, the last one in the array is chosen.\n\nSo that's important to replicate the Java code's behavior.\n\nSo with that, the C code can be written.\n\nSo putting it all together:\n\nRead the 5 numbers into array a.\n\nThen loop through each to find max_b and max_index.\n\nIf max_index is -1 (all are multiples of 10), sum all and output.\n\nElse, sum all elements except the one at max_index. For each element except that one, if their remainder is 0, add as is. Else, add a[i] + (10 - r). Then add the a[max_index] as is.\n\nSo code:\n\n#include <stdio.h>\n\nint main() {\n    int a[5];\n    for (int i = 0; i < 5; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n\n    int max_b = -1;\n    int max_index = -1;\n\n    for (int i = 0; i < 5; i++) {\n        int r = a[i] % 10;\n        if (r != 0) {\n            int b = 10 - r;\n            if (b > max_b) {\n                max_b = b;\n                max_index = i;\n            } else if (b == max_b) {\n                if (i > max_index) {\n                    max_index = i;\n                }\n            }\n        }\n    }\n\n    if (max_index == -1) { // all multiples of 10\n        int sum = 0;\n        for (int i = 0; i < 5; i++) {\n            sum += a[i];\n        }\n        printf(\"%d\\n\", sum);\n        return 0;\n    }\n\n    int sum = 0;\n    for (int i = 0; i < 5; i++) {\n        if (i == max_index) {\n            continue;\n        }\n        int r = a[i] % 10;\n        if (r == 0) {\n            sum += a[i];\n        } else {\n            sum += a[i] + (10 - r);\n        }\n    }\n\n    sum += a[max_index];\n    printf(\"%d\\n\", sum);\n\n    return 0;\n}\n\nThis should replicate the Java code's logic.\n\nTesting with sample inputs would be good, but given the time constraints, this should be correct."
}