{
  "segments": [
    {
      "text": "Okay, I need to translate this Java code to C. Let's start by understanding what the Java code does.",
      "start_char": 0,
      "end_char": 100,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The program is solving a problem where nodes in a tree are colored based on the parity of the sum of the edge lengths from the root. If the sum is even, color 0; if odd, color 1. The approach uses DFS to traverse the tree and assign colors. First, let's note the data structures used in Java.",
      "start_char": 101,
      "end_char": 394,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "The Java code uses a Point class which has a name (index) and a map of friends (adjacent nodes) with the edge lengths.",
      "start_char": 395,
      "end_char": 513,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The main steps are reading the input, building the adjacency list, and then performing a DFS to color the nodes.",
      "start_char": 514,
      "end_char": 626,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "In C, I can't use objects like in Java. So I'll need to represent the graph using structures and arrays.",
      "start_char": 628,
      "end_char": 732,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Since it's a tree, each node can have a list of adjacent nodes. But in C, handling dynamic structures is more manual. So perhaps use an array of linked lists for adjacency.",
      "start_char": 733,
      "end_char": 905,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "The Java code's Point class instances have a friends map, which in C can be represented as an adjacency list. Each node (index) will have a list of connected nodes and the corresponding edge length. So, first, I need to represent the adjacency list. Let's think: for each node, store a list of pairs (connected node, length). In C, this can be done using structs for each edge, linked together. In Java, the colors array is initialized to -1, then filled with 0 or 1 during DFS. The same approach can be used in C with an integer array. Now, translating the main steps:\n\n1. Read n from input. Then n-1 edges. Each edge connects two nodes (0-based index in Java code) and has a length. Wait, in the Java code, the nodes are 0-based. The input is read as me = sc.nextInt() -1; you = ... etc. So in the C code, the nodes are 0-based as well. So for each edge, we need to add it to the adjacency lists of both nodes.",
      "start_char": 907,
      "end_char": 1823,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "In C, building the adjacency list:\n\nFor each node u, its adjacent nodes and lengths can be stored in a linked list. But since in C, dynamic structures are a bit tricky, perhaps using an array of structs where each struct contains the connected node and the length, and a next pointer. Alternatively, since we're dealing with a tree, each edge is stored twice (u to v and v to u). So, for each edge, when processing, add both directions. In the Java code, the adjacency is stored as a map in each Point.",
      "start_char": 1826,
      "end_char": 2330,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "For C, we can create a struct Edge with attributes to the connected node, the length, and a next pointer. Then, each node has a linked list of Edge structs. So, let's define:\n\ntypedef struct Edge {\n    int to;\n    int length;\n    struct Edge* next;\n} Edge; Then, for each node, we have a linked list of Edge pointers. So, Edge **adj; where adj is an array of pointers to Edge structs, each representing the adjacency list for a node. But handling dynamic memory in C can be error-prone, but manageable. Now, the main steps:\n\nRead n.\n\nInitialize adjacency list for each of the n nodes. Read n-1 edges. For each edge, u and v (converted to 0-based) and length. Add to u's adjacency list a new edge with to = v and length. Similarly add to v's adjacency list a new edge with to = u and length. Then, perform a DFS starting from node 0. The initial length is 0. For each node, if the cumulative length (sum of path from root) is even, color 0; else 1. In the Java code, the DFS function takes a Point (current node) and the current sum. It checks if the node's color is already known.",
      "start_char": 2331,
      "end_char": 3418,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "If not, sets the color based on sum mod 2, then recursively processes each adjacent node, adding the edge length to the sum.",
      "start_char": 3419,
      "end_char": 3543,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "In C, the DFS function will need to track the current node, the current sum, and the colors array. But in C, recursion depth could be an issue for large n. However, since it's a tree, the maximum depth is O(n), which for n up to 1e5 could cause stack overflow. Wait, but the problem statement's constraints aren't given.",
      "start_char": 3545,
      "end_char": 3865,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "However, in programming contests, the recursion depth can be a problem. But given that the original Java code uses recursion, perhaps the problem allows for n up to 1e5, which would cause stack overflow in C with a recursive approach.",
      "start_char": 3866,
      "end_char": 4100,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Hmm, but maybe for this problem, the intended solution is to use BFS instead of DFS to avoid stack issues. But the original code uses DFS. So, translating it directly. But perhaps the test cases are small.",
      "start_char": 4101,
      "end_char": 4306,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, we can implement an iterative DFS. But let's proceed with the recursive approach first, keeping in mind that for very large n, this could fail. However, given the code to translate, perhaps we proceed. So, the colors array in C: int colors[n], initialized to -1. The DFS function:\n\nvoid dfs(int node, int sum, Edge **adj, int *colors) {\n    if (colors[node] ! = -1) return; // already visited\n    colors[node] = sum % 2; Edge *current = adj[node];\n    while (current != NULL) {\n        int neighbor = current->to;\n        int length = current->length; if (colors[neighbor] == -1) {\n            dfs(neighbor, sum + length, adj, colors);\n        }\n        current = current->next;\n    }\n}\n\nWait, but in the Java code, the sum passed to the neighbor is sum + length. But in the original code, when moving to a neighbor, the current sum is added with the edge's length. But the edge's length is the length from the current node to the neighbor. So, the sum here represents the total distance from the root (node 0) to the current node.",
      "start_char": 4308,
      "end_char": 5368,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Then, when moving to neighbor, the sum is sum + length (the edge's length), which is the sum from root to neighbor. But since this is a tree, each node's sum is the sum of the path from the root to that node.",
      "start_char": 5369,
      "end_char": 5577,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Wait, but in the Java code, the sum starts at 0 for the root node. Then for each neighbor, we add the edge length. So the initial call is dfs(points[0], 0), which for node 0 (root) has sum 0.",
      "start_char": 5580,
      "end_char": 5771,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Then, for each neighbor, sum is 0 + length, and so on. So in the C code, the initial call is dfs(0, 0, adj, colors). Then for each neighbor, sum + current edge's length. So, the code should work. Now, handling the adjacency list. In the Java code, each Point (node) has a map of friends (adjacent nodes) with the edge length. In C, the adjacency list for each node is a linked list of Edge structs. Now, building the adjacency list. For each of the n-1 edges:\n\nRead u, v, length. But wait, in the original code, the input is read as:\n\nint me = sc.nextInt() -1;\n\nint you = sc.nextInt() -1;\n\nint length = sc.nextInt();\n\nSo the input nodes are 1-based, converted to 0-based. In C, the code must read three integers per line (u+1, v+1, length). So in the code, after reading u, subtract 1 to get 0-based, same for v.\n\nSo, for each edge:\n\nu = ...-1;\n\nv = ...-1;\n\nAdd to u's adjacency list an edge to v with length. Add to v's adjacency list an edge to u with length. So, in the code:\n\nfor (int i = 0; i < m; i++) { // m = n-1\n\n    int u, v, l;\n\n    scanf(\"%d %d %d\", &u, &v, &l);\n\n    u--;\n\n    v--;\n\n    Edge *e1 = malloc(sizeof(Edge));\n\n    e1->to = v;\n\n    e1->length = l;\n\n    e1->next = adj[u];\n\n    adj[u] = e1;\n\n    Edge *e2 = malloc(sizeof(Edge));\n\n    e2->to = u;\n\n    e2->length = l;\n\n    e2->next = adj[v];\n\n    adj[v] = e2;\n\n} Wait, but in C, we need to allocate the edges.",
      "start_char": 5772,
      "end_char": 7161,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "So, the adjacency list is an array of pointers to Edge structs. So adj is a pointer to an array of pointers. But how to initialize this. For example:\n\nEdge **adj = (Edge **)calloc(n, sizeof(Edge *));\n\nEach adj[i] starts as NULL. So, when adding edges, each new edge is inserted at the head of the linked list. Now, after building the adjacency list, we call dfs(0, 0, adj, colors). Once the colors are filled, we print each color in order. Now, the colors array is initialized to -1.",
      "start_char": 7163,
      "end_char": 7651,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The initial call to dfs starts at node 0, sum 0. But in the Java code, colors is an array of size n, initialized to -1. So in C, we do the same. Now, putting it all together:\n\nThe steps:\n\n1. Read n.\n\n2. Initialize adj array (adj is an array of Edge pointers, size n, initialized to NULL). 3. Read n-1 edges and build adjacency list. 4. Initialize colors array to all -1. 5. Perform DFS from node 0 with sum 0.\n\n6. Print colors array.",
      "start_char": 7652,
      "end_char": 8090,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Potential issues:\n\n- Memory management: in C, the edges are dynamically allocated. But since the program ends after printing, maybe it's not necessary to free them. But in practice, for a programming competition, the code may not free memory, which is acceptable.\n\n- Stack overflow: for large n, recursive DFS may hit stack limits.",
      "start_char": 8092,
      "end_char": 8423,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "For example, if n is 1e5, the recursion depth could be up to 1e5, which is way beyond the default stack size. So for such cases, the code will crash. But the original Java code uses recursion.",
      "start_char": 8424,
      "end_char": 8616,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "However, Java typically has a larger default stack size, but in programming contests, sometimes stack size can be increased. But in C, using recursive DFS for n up to 1e5 is not feasible. Wait, this is a problem. So perhaps the original Java code would fail for large n. But in the problem statement, maybe n is small.",
      "start_char": 8617,
      "end_char": 8935,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "However, since the problem is from AtCoder ABC126, which is a beginner contest, the constraints may be up to 1e5. For example, ABC problems typically have n up to 1e5. In that case, using recursion would cause stack overflow. Therefore, the code must use an iterative approach for DFS or BFS. So, perhaps the correct approach is to reimplement the DFS iteratively. So, how to do iterative DFS in C.\n\nWe can use a stack.",
      "start_char": 8937,
      "end_char": 9359,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Each element in the stack contains the current node and the current sum. But since we need to process each node once, and the sum is cumulative along the path, perhaps using a stack that keeps track of the node and the sum from the root to that node.\n\nAlternatively, since the sum is passed as a parameter in the recursive call, in the iterative approach, each stack element must store the current node and the current sum. So, for each node in the stack, we process it as follows:\n\nIf the color is already set, skip. Otherwise, set the color based on sum % 2.",
      "start_char": 9360,
      "end_char": 9923,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Then, push all adjacent nodes into the stack, with sum + edge length. But wait, this is not correct because the order of processing would matter.",
      "start_char": 9925,
      "end_char": 10070,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "In a recursive DFS, when processing a node, all adjacent nodes are processed in order. But in iterative DFS, the order may vary (stack is LIFO, so pushing them in reverse order of adjacency would mimic the recursive order). But in this problem, the order does not matter as long as each node is processed once, and once the color is set, it's not reprocessed.",
      "start_char": 10072,
      "end_char": 10431,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Wait, in the original Java code, when you process a node, you set its color, and then for each adjacent node, you call dfs recursively. So, if the color is not set, it's processed.",
      "start_char": 10434,
      "end_char": 10614,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "So, in iterative code, we can push all adjacent nodes, and when we pop them from the stack, we check if they've been processed. If not, process them and push their neighbors. But in this approach, how to track the sum. So, perhaps the stack elements are structs with the node and the sum. But let's think: Initialize stack with (node 0, sum 0). Then, while the stack is not empty:\n\n    Pop (current_node, current_sum). If colors[current_node] is not -1, skip. Set colors[current_node] = current_sum % 2.",
      "start_char": 10615,
      "end_char": 11133,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "For each neighbor in adj[current_node], add (neighbor, current_sum + edge_length) to the stack. But this would be a depth-first approach, but it's not exactly the same as the original recursive code.",
      "start_char": 11139,
      "end_char": 11338,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Because the original code processes each neighbor in the order they are in the adjacency list, but the stack would process them in reverse order. However, since the color is set once, the order shouldn't affect correctness. Wait, but the original code may process the neighbors in any order.",
      "start_char": 11340,
      "end_char": 11632,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "The problem is that, in the iterative approach, when processing the current node, you push all the neighbors to the stack, and then they are processed in LIFO order (so the last neighbor added is processed first). But in the recursive approach, the first neighbor is processed first. But in this problem, the order of processing doesn't affect the result.",
      "start_char": 11633,
      "end_char": 11988,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "The color depends only on the sum from the root to the node, which is fixed. So regardless of the order of processing, the color is determined correctly once the sum is known. Thus, using a stack (iterative DFS) should work. So, to avoid stack overflow, it's better to implement iterative DFS. So, modifying the code to use an iterative DFS. Let's adjust the code.",
      "start_char": 11990,
      "end_char": 12357,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Implementing the stack:\n\nWe can use a dynamic stack (like a linked list-based stack) or use an array-based stack with sufficient size. However, for n up to 1e5, the stack could grow up to O(n) elements.",
      "start_char": 12360,
      "end_char": 12562,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "So, using a dynamic array (like a vector in C++) is not possible in C, but we can preallocate a large array.",
      "start_char": 12563,
      "end_char": 12671,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, for the purposes of programming competition, using an array-based stack with size up to 1e5 is feasible. But in C, dynamic allocation is possible. So, perhaps use a stack struct that holds an array of pointers to structs containing node and sum. Alternatively, use a struct like:\n\ntypedef struct StackNode {\n    int node;\n    int sum;\n    struct StackNode* next;\n} StackNode; Then, the stack is managed via a linked list. But this can be slow for large n.\n\nAlternatively, since the maximum stack size is O(n), we can preallocate an array of size 1e5 or more. But let's proceed with an array-based approach. So, declare:\n\nstruct StackElement {\n    int node;\n    int sum;\n};\n\nstruct StackElement *stack = malloc(sizeof(struct StackElement) * (2 * (n + 1))); // assuming n can be up to 1e5, but better to allocate dynamically. But for the code, since n is read at runtime, we can allocate the stack dynamically.",
      "start_char": 12673,
      "end_char": 13601,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, since each node is pushed once (once the color is set, we don't process it again), the maximum stack size is O(n). So, the stack can be an array of size n. But for each node, how many times can it be pushed? Once when it's first encountered, but once its color is set, subsequent pushes will be skipped. So, here's the plan:\n\nInitialize the stack with the starting node (0) and sum (0). While the stack is not empty:\n\n    Pop the top element (current_node, current_sum). If colors[current_node] is not -1, skip. Set colors[current_node] = current_sum % 2. For each adjacent edge in adj[current_node], push (edge->to, current_sum + edge->length) onto the stack. But wait, since this is a tree, each node is visited exactly once.",
      "start_char": 13604,
      "end_char": 14364,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Because once a node is processed (color set), any subsequent entries in the stack for that node will be skipped. So, the stack can be implemented as a LIFO structure. Each time, we process the node, then push all its children (adjacent nodes) into the stack.",
      "start_char": 14366,
      "end_char": 14625,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "However, since the parent node is processed first (assuming the tree is traversed from root), the children's entries in the stack will be processed later. But in this approach, the nodes are processed in a depth-first manner, but the order might vary depending on the order in which adjacent nodes are pushed. But the color assignment is correct regardless of the order. So, let's code this. In code:\n\nint n;\n\n// Read n.\n\nstruct StackElement {\n    int node;\n    int sum;\n};\n\nint stack_top = 0;\nstruct StackElement *stack = malloc(sizeof(struct StackElement) * (n * 2)); // Allocate enough space. // Push the initial element\nstack[stack_top].node = 0;\nstack[stack_top].sum = 0;\nstack_top++;\n\nwhile (stack_top > 0) {\n    stack_top--;\n    struct StackElement current = stack[stack_top];\n    int node = current.node;\n    int sum = current.sum;\n\n    if (colors[node] ! = -1) {\n        continue;\n    }\n\n    colors[node] = sum % 2;\n\n    Edge *edge = adj[node];\n    while (edge != NULL) {\n        int neighbor = edge->to;\n        int length = edge->length;\n        // Push neighbor onto stack with sum + length\n        if (colors[neighbor] == -1) {\n            stack[stack_top].node = neighbor; stack[stack_top].sum = sum + length;\n            stack_top++;\n        }\n        edge = edge->next;\n    }\n} Wait, but this code may not work correctly.",
      "start_char": 14626,
      "end_char": 15978,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Because when pushing the neighbors, even if the neighbor has not been processed, but if it's already in the stack (but not yet processed), it may be pushed multiple times.",
      "start_char": 15980,
      "end_char": 16151,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "However, once it's popped and processed, subsequent entries will be skipped because colors is checked. This is acceptable, but may use more memory.",
      "start_char": 16152,
      "end_char": 16300,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "However, for the worst case, each node can be pushed multiple times, leading to O(n^2) stack size, which is not acceptable. Wait, no.",
      "start_char": 16301,
      "end_char": 16434,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Because once a node's color is set, any subsequent processing (even if it's in the stack multiple times) will skip it.",
      "start_char": 16436,
      "end_char": 16554,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "So, the number of times a node is processed is exactly once. But the number of times it's pushed into the stack depends on the number of edges. But for a tree with n nodes, there are n-1 edges.",
      "start_char": 16555,
      "end_char": 16748,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Each edge is processed twice (since each edge is added to two nodes' adjacency lists). So each edge is processed once per direction. For each edge (u, v), when u is processed, we push v into the stack if v hasn't been processed yet.",
      "start_char": 16750,
      "end_char": 16982,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Similarly, when v is processed, we push u if u hasn't been processed. But in a tree, during traversal, each node except the root is visited exactly once via exactly one parent. So, for each node other than the root, it is pushed into the stack once by its parent.",
      "start_char": 16983,
      "end_char": 17247,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "However, due to the adjacency list being bidirectional, when processing a child node (v), it will push its parent (u) into the stack again. But since the parent's color is already set, this push will not cause any action. But this leads to O(n + m) stack operations, which for m = 2(n-1) is manageable. But in the worst case, the stack can have O(m) elements, which is acceptable. But this approach is not efficient, but for the purposes of passing the problem's test cases, it should be okay.",
      "start_char": 17248,
      "end_char": 17742,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Alternatively, to prevent pushing nodes that are already in the stack but not processed, but that's more complex and may not be necessary. So, in the code, when processing node u, we check all adjacent edges.",
      "start_char": 17746,
      "end_char": 17955,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "For each neighbor v, even if it's the parent (which has already been processed), we push it into the stack. But when it's popped, colors[v] is already set, so it's skipped. But this is redundant.",
      "start_char": 17956,
      "end_char": 18151,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "For example, when processing a child node, it's parent's color is already set, so pushing the parent into the stack is unnecessary. But since the adjacency list includes all edges (including the ones leading back to parents), this will happen. But this is unavoidable unless we track the parent during traversal. So, perhaps a better approach is to track the parent to avoid re-processing. In the iterative approach, we can track the parent node. For example, when processing node u, for each neighbor v, if v is not the parent, process it.",
      "start_char": 18153,
      "end_char": 18695,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "This way, we avoid pushing the parent back into the stack. But how to track the parent in the stack. We can modify the stack element to include the parent node. So, the stack element would be:\n\nstruct StackElement {\n    int node;\n    int sum;\n    int parent;\n}; Then, when processing node u with parent p, for each neighbor v, if v != p, then push v with sum + length and parent u.\n\nThis way, we avoid pushing the parent back into the stack, thus reducing the number of stack elements and avoiding redundant processing. This is similar to the standard BFS approach where each node is visited once. So, modifying the code:\n\nInitialize the stack with (node 0, sum 0, parent -1). Then, in the loop:\n\nPop current element (node, sum, parent). If colors[node] is not -1, skip. Set colors[node] = sum % 2. For each adjacent edge in adj[node], which is to v:\n\nIf v != parent, push (v, sum + edge length, node) into the stack.",
      "start_char": 18696,
      "end_char": 19623,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "This way, each node is pushed once (since each node has only one parent in the tree), and the adjacency list is traversed in a way that avoids revisiting the parent. This approach should prevent adding redundant elements to the stack. So, the code becomes:\n\nstruct StackElement {\n    int node;\n    int sum;\n    int parent;\n};\n\nstack[stack_top].node = 0;\nstack[stack_top].sum = 0;\nstack[stack_top].parent = -1;\nstack_top++;\n\nwhile (stack_top > 0) {\n    stack_top--;\n    struct StackElement current = stack[stack_top];\n    int u = current.node;\n    int sum_u = current.sum;\n    int parent_u = current.parent;\n\n    if (colors[u] ! = -1) continue;\n\n    colors[u] = sum_u % 2;\n\n    Edge *edge = adj[u];\n    while (edge != NULL) {\n        int v = edge->to;\n        int length = edge->length; if (v != parent_u) {\n            // Push v onto the stack with sum_u + length and parent u\n            if (stack_top >= allocated_size) {\n                // Need to realloc, but for code brevity, assuming stack is big enough. }\n            stack[stack_top].node = v;\n            stack[stack_top].sum = sum_u + length;\n            stack[stack_top].parent = u;\n            stack_top++;\n        }\n        edge = edge->next;\n    }\n}\n\nThis way, each node is pushed into the stack exactly once.",
      "start_char": 19625,
      "end_char": 20920,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Because each node (except root) has exactly one parent, and when processing a node u, we push all its children (i.e., neighbors except the parent). So each node is pushed once, processed once, leading to O(n) stack elements. This is more efficient and avoids redundant processing. So, this iterative DFS approach is better and avoids stack overflow issues. Now, integrating this into the C code. Now, let's outline the steps: Read n.\n\nAllocate adj as an array of Edge pointers, size n, initialized to NULL. Read n-1 edges, for each:\n\n    u, v, l (converted to 0-based).",
      "start_char": 20921,
      "end_char": 21496,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Add to u's adj list an Edge to v with length l.\n\n    Add to v's adj list an Edge to u with length l.\n\nInitialize colors array to -1. Allocate stack.",
      "start_char": 21502,
      "end_char": 21650,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Since each node is pushed once, stack size can be n.\n\nPush the initial element (0, 0, -1). Process stack as described. Finally, print colors[0] to colors[n-1]. Now, code in C:\n\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Edge {\n    int to;\n    int length;\n    struct Edge *next ;\n} Edge;\n\ntypedef struct StackElement {\n    int node;\n    int sum;\n    int parent;\n} StackElement;\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    Edge **adj = (Edge **)calloc(n, sizeof(Edge *));\n    \n    for (int i = 0; i < n - 1; ++i) {\n        int u, v, l;\n        scanf(\"%d %d %d\", &u, &v, &l);\n        u--; v--;\n        \n        Edge *e1 = (Edge *)malloc(sizeof(Edge));\n        e1->to = v;\n        e1->length = l;\n        e1->next = adj[u];\n        adj[u] = e1;\n        \n        Edge *e2 = (Edge *)malloc(sizeof(Edge));\n        e2->to = u;\n        e2->length = l;\n        e2->next = adj[v];\n        adj[v] = e2;\n    }\n    \n    int *colors = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; ++i) {\n        colors[i] = -1;\n    }\n    \n    StackElement *stack = (StackElement *)malloc(n * sizeof(StackElement));\n    int stack_top = 0;\n    \n    stack[stack_top].node = 0;\n    stack[stack_top].sum = 0;\n    stack[stack_top].parent = -1;\n    stack_top++;\n    \n    while (stack_top > 0) {\n        stack_top--;\n        int u = stack[stack_top].node;\n        int sum_u = stack[stack_top].sum;\n        int parent_u = stack[stack_top].parent;\n        \n        if (colors[u] ! = -1) continue;\n        \n        colors[u] = sum_u % 2;\n        \n        Edge *edge = adj[u];\n        while (edge != NULL) {\n            int v = edge->to;\n            int length = edge->length; if (v != parent_u) {\n                stack[stack_top].node = v;\n                stack[stack_top].sum = sum_u + length;\n                stack[stack_top].parent = u;\n                stack_top++;\n            }\n            edge = edge->next;\n        }\n    }\n    \n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\\n\", colors[i]);\n    }\n    \n    // Free allocated memory (optional for a programming contest)\n    for (int i = 0; i < n; ++i) {\n        Edge *edge = adj[i];\n        while (edge != NULL) {\n            Edge *temp = edge;\n            edge = edge->next;\n            free(temp);\n        }\n    }\n    free(adj);\n    free(colors);\n    free(stack);\n    \n    return 0;\n} Wait, but when reading the edges, the code uses 'n-1' iterations.",
      "start_char": 21652,
      "end_char": 24072,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Each edge is read once, and added twice (since the input is n-1 edges, each being added to both u and v). So that part is correct. In the stack processing, each node is processed once.",
      "start_char": 24074,
      "end_char": 24259,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The stack starts with the root node (0), and each time a node is processed, all its adjacent nodes (except the parent) are added to the stack. This ensures that each node is processed exactly once. Testing this code: for a simple case where n=2. Input:\n\n2\n\n1 2 3\n\nNodes 0 and 1. Adj list for 0: an edge to 1 with length 3. Adj list for 1: an edge to 0 with length 3. Processing:\n\nstack starts with (0, 0, -1). Process 0: color is 0 % 2 = 0. Adjacent edges: 1. Since parent is -1, push 1 with sum 0+3=3, parent 0. Stack now has 1 element: (1, 3, 0). Process 1: color is 3 % 2 = 1. Adjacent edges: 0 (parent is 0, so skip). No other edges. So nothing pushed. Print colors: 0 and 1.\n\nWhich is correct. Another test case.\n\nn=3:\n\nEdges:\n\n1 2 1\n\n2 3 2\n\n1 3 3\n\nWait, no, n=3 has two edges. Suppose input is:\n\n3\n\n1 2 1\n\n1 3 2\n\nAfter conversion to 0-based:\n\nedges are:\n\n0-1 (",
      "start_char": 24260,
      "end_char": 25138,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "length 1)\n\n0-2 (length 2)\n\nColors:\n\n0 (sum 0)\n\n1 (sum 1)\n\n2 (sum 2) mod 2 is 0. Wait, no. The root is 0. The sum for node 0 is 0. Node 1 is connected to 0 with length 1. Sum 1: color 1.",
      "start_char": 25138,
      "end_char": 25324,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Node 2 is connected to 0 with length 2: sum 2, color 0. So the output should be:\n\n0\n\n1\n\n0\n\nIn the code: When processing node 0, push nodes 1 and 2 (sum 1 and 2). The order depends on how the edges are added to the adjacency list.",
      "start_char": 25325,
      "end_char": 25556,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Since the edges are added in reverse order (since each new edge is added at the head of the list), the first edge added for node 0 is the second edge in the input. Wait, when processing edges:\n\nFirst edge: 1-2 \u2192 u=0, v=1, l=1. Add to adj[0] a pointer to v=1, and to adj[1] a pointer to 0. Then the second edge: 1-3 \u2192 u=0, v=2, l=2. Add to adj[0] a pointer to v=2, and to adj[2] a pointer to 0. So the adjacency list for node 0 is: first the edge to 2 (added later, so it's the head of the list), then the edge to 1. So when processing node 0, the edges are iterated in reverse order. So the first edge in the loop is to node 2, then to node 1.",
      "start_char": 25557,
      "end_char": 26202,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "So, when node 0 is processed, the edges are 2 and 1. So the stack is pushed with node 2 (sum 2, parent 0), then node 1 (sum 1, parent 0). So the stack is:\n\nstack_top increments after each push. So the stack is [ (0,0,-1) ] \u2192 after processing, push 2 and 1. So the stack_top after pushing becomes 2.",
      "start_char": 26206,
      "end_char": 26504,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Then, when popping, we process the elements in the order of the stack:\n\nInitially, stack_top is 1 (after pushing initial element). Then, after processing node 0, stack_top is 2 (elements 1 and 2 are pushed).",
      "start_char": 26506,
      "end_char": 26713,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Then, when popping, the first popped is the top element (stack_top is 2, then subtract 1, so index 1: node 1, sum 1, parent 0). Wait, no.",
      "start_char": 26714,
      "end_char": 26851,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "The stack is managed as an array where stack_top is the next free spot. So when stack_top is 2, the elements are indices 0 and 1. When popping, we subtract 1 first, so take element at index 1. Wait, code: stack_top starts at 0. Then, we push elements by writing to stack[stack_top] and incrementing stack_top. So, after the initial push, stack_top is 1. Then, in the loop:\n\nstack_top starts at 1. We subtract 1 (to 0), pop element 0, process it. After processing node 0, we push two elements (node 2 and node 1), so stack_top becomes 0 + 2 = 2. Then, the loop continues: stack_top is 2. Subtract 1 (to 1), pop element at 1 (node 1, sum 1, parent 0). Process node 1. In node 1's adjacency list, edges are to 0 (parent, so skipped) and any other nodes.",
      "start_char": 26852,
      "end_char": 27608,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "If the input had other edges, but in this case, node 1's adjacency list has only the edge to 0. So nothing is pushed. Then stack_top becomes 1. Next, subtract 1 to 0, pop element 0 (node 2, sum 2, parent 0). Process node 2. Sum is 2, color 0.",
      "start_char": 27609,
      "end_char": 27852,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Adjacency list has edge to 0 (parent, skipped), and any others? No. So nothing is pushed. Thus, the colors are correct. So the code should work.",
      "start_char": 27853,
      "end_char": 27997,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Thus, the translated C code uses an iterative DFS with a stack to avoid recursion depth issues and correctly assigns colors based on the sum's parity.",
      "start_char": 28001,
      "end_char": 28151,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    }
  ],
  "original_reasoning": "Okay, I need to translate this Java code to C. Let's start by understanding what the Java code does. The program is solving a problem where nodes in a tree are colored based on the parity of the sum of the edge lengths from the root. If the sum is even, color 0; if odd, color 1. The approach uses DFS to traverse the tree and assign colors.\n\nFirst, let's note the data structures used in Java. The Java code uses a Point class which has a name (index) and a map of friends (adjacent nodes) with the edge lengths. The main steps are reading the input, building the adjacency list, and then performing a DFS to color the nodes.\n\nIn C, I can't use objects like in Java. So I'll need to represent the graph using structures and arrays. Since it's a tree, each node can have a list of adjacent nodes. But in C, handling dynamic structures is more manual. So perhaps use an array of linked lists for adjacency.\n\nThe Java code's Point class instances have a friends map, which in C can be represented as an adjacency list. Each node (index) will have a list of connected nodes and the corresponding edge length.\n\nSo, first, I need to represent the adjacency list. Let's think: for each node, store a list of pairs (connected node, length). In C, this can be done using structs for each edge, linked together.\n\nIn Java, the colors array is initialized to -1, then filled with 0 or 1 during DFS. The same approach can be used in C with an integer array.\n\nNow, translating the main steps:\n\n1. Read n from input. Then n-1 edges. Each edge connects two nodes (0-based index in Java code) and has a length.\n\nWait, in the Java code, the nodes are 0-based. The input is read as me = sc.nextInt() -1; you = ... etc. So in the C code, the nodes are 0-based as well.\n\nSo for each edge, we need to add it to the adjacency lists of both nodes.\n\nIn C, building the adjacency list:\n\nFor each node u, its adjacent nodes and lengths can be stored in a linked list. But since in C, dynamic structures are a bit tricky, perhaps using an array of structs where each struct contains the connected node and the length, and a next pointer.\n\nAlternatively, since we're dealing with a tree, each edge is stored twice (u to v and v to u). So, for each edge, when processing, add both directions.\n\nIn the Java code, the adjacency is stored as a map in each Point. For C, we can create a struct Edge with attributes to the connected node, the length, and a next pointer. Then, each node has a linked list of Edge structs.\n\nSo, let's define:\n\ntypedef struct Edge {\n    int to;\n    int length;\n    struct Edge* next;\n} Edge;\n\nThen, for each node, we have a linked list of Edge pointers. So, Edge **adj; where adj is an array of pointers to Edge structs, each representing the adjacency list for a node.\n\nBut handling dynamic memory in C can be error-prone, but manageable.\n\nNow, the main steps:\n\nRead n.\n\nInitialize adjacency list for each of the n nodes.\n\nRead n-1 edges. For each edge, u and v (converted to 0-based) and length. Add to u's adjacency list a new edge with to = v and length. Similarly add to v's adjacency list a new edge with to = u and length.\n\nThen, perform a DFS starting from node 0. The initial length is 0. For each node, if the cumulative length (sum of path from root) is even, color 0; else 1.\n\nIn the Java code, the DFS function takes a Point (current node) and the current sum. It checks if the node's color is already known. If not, sets the color based on sum mod 2, then recursively processes each adjacent node, adding the edge length to the sum.\n\nIn C, the DFS function will need to track the current node, the current sum, and the colors array. But in C, recursion depth could be an issue for large n. However, since it's a tree, the maximum depth is O(n), which for n up to 1e5 could cause stack overflow. Wait, but the problem statement's constraints aren't given. However, in programming contests, the recursion depth can be a problem. But given that the original Java code uses recursion, perhaps the problem allows for n up to 1e5, which would cause stack overflow in C with a recursive approach. Hmm, but maybe for this problem, the intended solution is to use BFS instead of DFS to avoid stack issues. But the original code uses DFS. So, translating it directly.\n\nBut perhaps the test cases are small. Alternatively, we can implement an iterative DFS.\n\nBut let's proceed with the recursive approach first, keeping in mind that for very large n, this could fail. However, given the code to translate, perhaps we proceed.\n\nSo, the colors array in C: int colors[n], initialized to -1.\n\nThe DFS function:\n\nvoid dfs(int node, int sum, Edge **adj, int *colors) {\n    if (colors[node] != -1) return; // already visited\n    colors[node] = sum % 2;\n    Edge *current = adj[node];\n    while (current != NULL) {\n        int neighbor = current->to;\n        int length = current->length;\n        if (colors[neighbor] == -1) {\n            dfs(neighbor, sum + length, adj, colors);\n        }\n        current = current->next;\n    }\n}\n\nWait, but in the Java code, the sum passed to the neighbor is sum + length. But in the original code, when moving to a neighbor, the current sum is added with the edge's length. But the edge's length is the length from the current node to the neighbor. So, the sum here represents the total distance from the root (node 0) to the current node. Then, when moving to neighbor, the sum is sum + length (the edge's length), which is the sum from root to neighbor.\n\nBut since this is a tree, each node's sum is the sum of the path from the root to that node.\n\nWait, but in the Java code, the sum starts at 0 for the root node. Then for each neighbor, we add the edge length. So the initial call is dfs(points[0], 0), which for node 0 (root) has sum 0. Then, for each neighbor, sum is 0 + length, and so on.\n\nSo in the C code, the initial call is dfs(0, 0, adj, colors). Then for each neighbor, sum + current edge's length.\n\nSo, the code should work.\n\nNow, handling the adjacency list.\n\nIn the Java code, each Point (node) has a map of friends (adjacent nodes) with the edge length. In C, the adjacency list for each node is a linked list of Edge structs.\n\nNow, building the adjacency list.\n\nFor each of the n-1 edges:\n\nRead u, v, length. But wait, in the original code, the input is read as:\n\nint me = sc.nextInt() -1;\n\nint you = sc.nextInt() -1;\n\nint length = sc.nextInt();\n\nSo the input nodes are 1-based, converted to 0-based.\n\nIn C, the code must read three integers per line (u+1, v+1, length). So in the code, after reading u, subtract 1 to get 0-based, same for v.\n\nSo, for each edge:\n\nu = ...-1;\n\nv = ...-1;\n\nAdd to u's adjacency list an edge to v with length.\n\nAdd to v's adjacency list an edge to u with length.\n\nSo, in the code:\n\nfor (int i = 0; i < m; i++) { // m = n-1\n\n    int u, v, l;\n\n    scanf(\"%d %d %d\", &u, &v, &l);\n\n    u--;\n\n    v--;\n\n    Edge *e1 = malloc(sizeof(Edge));\n\n    e1->to = v;\n\n    e1->length = l;\n\n    e1->next = adj[u];\n\n    adj[u] = e1;\n\n    Edge *e2 = malloc(sizeof(Edge));\n\n    e2->to = u;\n\n    e2->length = l;\n\n    e2->next = adj[v];\n\n    adj[v] = e2;\n\n}\n\nWait, but in C, we need to allocate the edges. So, the adjacency list is an array of pointers to Edge structs. So adj is a pointer to an array of pointers.\n\nBut how to initialize this. For example:\n\nEdge **adj = (Edge **)calloc(n, sizeof(Edge *));\n\nEach adj[i] starts as NULL.\n\nSo, when adding edges, each new edge is inserted at the head of the linked list.\n\nNow, after building the adjacency list, we call dfs(0, 0, adj, colors).\n\nOnce the colors are filled, we print each color in order.\n\nNow, the colors array is initialized to -1. The initial call to dfs starts at node 0, sum 0.\n\nBut in the Java code, colors is an array of size n, initialized to -1. So in C, we do the same.\n\nNow, putting it all together:\n\nThe steps:\n\n1. Read n.\n\n2. Initialize adj array (adj is an array of Edge pointers, size n, initialized to NULL).\n\n3. Read n-1 edges and build adjacency list.\n\n4. Initialize colors array to all -1.\n\n5. Perform DFS from node 0 with sum 0.\n\n6. Print colors array.\n\nPotential issues:\n\n- Memory management: in C, the edges are dynamically allocated. But since the program ends after printing, maybe it's not necessary to free them. But in practice, for a programming competition, the code may not free memory, which is acceptable.\n\n- Stack overflow: for large n, recursive DFS may hit stack limits. For example, if n is 1e5, the recursion depth could be up to 1e5, which is way beyond the default stack size. So for such cases, the code will crash. But the original Java code uses recursion. However, Java typically has a larger default stack size, but in programming contests, sometimes stack size can be increased. But in C, using recursive DFS for n up to 1e5 is not feasible.\n\nWait, this is a problem. So perhaps the original Java code would fail for large n. But in the problem statement, maybe n is small. However, since the problem is from AtCoder ABC126, which is a beginner contest, the constraints may be up to 1e5. For example, ABC problems typically have n up to 1e5.\n\nIn that case, using recursion would cause stack overflow. Therefore, the code must use an iterative approach for DFS or BFS.\n\nSo, perhaps the correct approach is to reimplement the DFS iteratively.\n\nSo, how to do iterative DFS in C.\n\nWe can use a stack. Each element in the stack contains the current node and the current sum.\n\nBut since we need to process each node once, and the sum is cumulative along the path, perhaps using a stack that keeps track of the node and the sum from the root to that node.\n\nAlternatively, since the sum is passed as a parameter in the recursive call, in the iterative approach, each stack element must store the current node and the current sum.\n\nSo, for each node in the stack, we process it as follows:\n\nIf the color is already set, skip.\n\nOtherwise, set the color based on sum % 2.\n\nThen, push all adjacent nodes into the stack, with sum + edge length.\n\nBut wait, this is not correct because the order of processing would matter. In a recursive DFS, when processing a node, all adjacent nodes are processed in order. But in iterative DFS, the order may vary (stack is LIFO, so pushing them in reverse order of adjacency would mimic the recursive order).\n\nBut in this problem, the order does not matter as long as each node is processed once, and once the color is set, it's not reprocessed.\n\nWait, in the original Java code, when you process a node, you set its color, and then for each adjacent node, you call dfs recursively. So, if the color is not set, it's processed. So, in iterative code, we can push all adjacent nodes, and when we pop them from the stack, we check if they've been processed. If not, process them and push their neighbors.\n\nBut in this approach, how to track the sum.\n\nSo, perhaps the stack elements are structs with the node and the sum.\n\nBut let's think:\n\nInitialize stack with (node 0, sum 0).\n\nThen, while the stack is not empty:\n\n    Pop (current_node, current_sum).\n\n    If colors[current_node] is not -1, skip.\n\n    Set colors[current_node] = current_sum % 2.\n\n    For each neighbor in adj[current_node], add (neighbor, current_sum + edge_length) to the stack.\n\nBut this would be a depth-first approach, but it's not exactly the same as the original recursive code. Because the original code processes each neighbor in the order they are in the adjacency list, but the stack would process them in reverse order. However, since the color is set once, the order shouldn't affect correctness.\n\nWait, but the original code may process the neighbors in any order. The problem is that, in the iterative approach, when processing the current node, you push all the neighbors to the stack, and then they are processed in LIFO order (so the last neighbor added is processed first). But in the recursive approach, the first neighbor is processed first.\n\nBut in this problem, the order of processing doesn't affect the result. The color depends only on the sum from the root to the node, which is fixed. So regardless of the order of processing, the color is determined correctly once the sum is known.\n\nThus, using a stack (iterative DFS) should work.\n\nSo, to avoid stack overflow, it's better to implement iterative DFS.\n\nSo, modifying the code to use an iterative DFS.\n\nLet's adjust the code.\n\nImplementing the stack:\n\nWe can use a dynamic stack (like a linked list-based stack) or use an array-based stack with sufficient size. However, for n up to 1e5, the stack could grow up to O(n) elements. So, using a dynamic array (like a vector in C++) is not possible in C, but we can preallocate a large array.\n\nAlternatively, for the purposes of programming competition, using an array-based stack with size up to 1e5 is feasible.\n\nBut in C, dynamic allocation is possible. So, perhaps use a stack struct that holds an array of pointers to structs containing node and sum.\n\nAlternatively, use a struct like:\n\ntypedef struct StackNode {\n    int node;\n    int sum;\n    struct StackNode* next;\n} StackNode;\n\nThen, the stack is managed via a linked list. But this can be slow for large n.\n\nAlternatively, since the maximum stack size is O(n), we can preallocate an array of size 1e5 or more.\n\nBut let's proceed with an array-based approach.\n\nSo, declare:\n\nstruct StackElement {\n    int node;\n    int sum;\n};\n\nstruct StackElement *stack = malloc(sizeof(struct StackElement) * (2 * (n + 1))); // assuming n can be up to 1e5, but better to allocate dynamically.\n\nBut for the code, since n is read at runtime, we can allocate the stack dynamically.\n\nAlternatively, since each node is pushed once (once the color is set, we don't process it again), the maximum stack size is O(n). So, the stack can be an array of size n.\n\nBut for each node, how many times can it be pushed? Once when it's first encountered, but once its color is set, subsequent pushes will be skipped.\n\nSo, here's the plan:\n\nInitialize the stack with the starting node (0) and sum (0).\n\nWhile the stack is not empty:\n\n    Pop the top element (current_node, current_sum).\n\n    If colors[current_node] is not -1, skip.\n\n    Set colors[current_node] = current_sum % 2.\n\n    For each adjacent edge in adj[current_node], push (edge->to, current_sum + edge->length) onto the stack.\n\nBut wait, since this is a tree, each node is visited exactly once. Because once a node is processed (color set), any subsequent entries in the stack for that node will be skipped.\n\nSo, the stack can be implemented as a LIFO structure. Each time, we process the node, then push all its children (adjacent nodes) into the stack. However, since the parent node is processed first (assuming the tree is traversed from root), the children's entries in the stack will be processed later. But in this approach, the nodes are processed in a depth-first manner, but the order might vary depending on the order in which adjacent nodes are pushed.\n\nBut the color assignment is correct regardless of the order.\n\nSo, let's code this.\n\nIn code:\n\nint n;\n\n// Read n.\n\nstruct StackElement {\n    int node;\n    int sum;\n};\n\nint stack_top = 0;\nstruct StackElement *stack = malloc(sizeof(struct StackElement) * (n * 2)); // Allocate enough space.\n\n// Push the initial element\nstack[stack_top].node = 0;\nstack[stack_top].sum = 0;\nstack_top++;\n\nwhile (stack_top > 0) {\n    stack_top--;\n    struct StackElement current = stack[stack_top];\n    int node = current.node;\n    int sum = current.sum;\n\n    if (colors[node] != -1) {\n        continue;\n    }\n\n    colors[node] = sum % 2;\n\n    Edge *edge = adj[node];\n    while (edge != NULL) {\n        int neighbor = edge->to;\n        int length = edge->length;\n        // Push neighbor onto stack with sum + length\n        if (colors[neighbor] == -1) {\n            stack[stack_top].node = neighbor;\n            stack[stack_top].sum = sum + length;\n            stack_top++;\n        }\n        edge = edge->next;\n    }\n}\n\nWait, but this code may not work correctly. Because when pushing the neighbors, even if the neighbor has not been processed, but if it's already in the stack (but not yet processed), it may be pushed multiple times. However, once it's popped and processed, subsequent entries will be skipped because colors is checked.\n\nThis is acceptable, but may use more memory. However, for the worst case, each node can be pushed multiple times, leading to O(n^2) stack size, which is not acceptable.\n\nWait, no. Because once a node's color is set, any subsequent processing (even if it's in the stack multiple times) will skip it. So, the number of times a node is processed is exactly once. But the number of times it's pushed into the stack depends on the number of edges.\n\nBut for a tree with n nodes, there are n-1 edges. Each edge is processed twice (since each edge is added to two nodes' adjacency lists). So each edge is processed once per direction. For each edge (u, v), when u is processed, we push v into the stack if v hasn't been processed yet. Similarly, when v is processed, we push u if u hasn't been processed.\n\nBut in a tree, during traversal, each node except the root is visited exactly once via exactly one parent. So, for each node other than the root, it is pushed into the stack once by its parent. However, due to the adjacency list being bidirectional, when processing a child node (v), it will push its parent (u) into the stack again. But since the parent's color is already set, this push will not cause any action.\n\nBut this leads to O(n + m) stack operations, which for m = 2(n-1) is manageable.\n\nBut in the worst case, the stack can have O(m) elements, which is acceptable.\n\nBut this approach is not efficient, but for the purposes of passing the problem's test cases, it should be okay.\n\nAlternatively, to prevent pushing nodes that are already in the stack but not processed, but that's more complex and may not be necessary.\n\nSo, in the code, when processing node u, we check all adjacent edges. For each neighbor v, even if it's the parent (which has already been processed), we push it into the stack. But when it's popped, colors[v] is already set, so it's skipped.\n\nBut this is redundant. For example, when processing a child node, it's parent's color is already set, so pushing the parent into the stack is unnecessary. But since the adjacency list includes all edges (including the ones leading back to parents), this will happen.\n\nBut this is unavoidable unless we track the parent during traversal. So, perhaps a better approach is to track the parent to avoid re-processing.\n\nIn the iterative approach, we can track the parent node. For example, when processing node u, for each neighbor v, if v is not the parent, process it. This way, we avoid pushing the parent back into the stack.\n\nBut how to track the parent in the stack.\n\nWe can modify the stack element to include the parent node.\n\nSo, the stack element would be:\n\nstruct StackElement {\n    int node;\n    int sum;\n    int parent;\n};\n\nThen, when processing node u with parent p, for each neighbor v, if v != p, then push v with sum + length and parent u.\n\nThis way, we avoid pushing the parent back into the stack, thus reducing the number of stack elements and avoiding redundant processing.\n\nThis is similar to the standard BFS approach where each node is visited once.\n\nSo, modifying the code:\n\nInitialize the stack with (node 0, sum 0, parent -1).\n\nThen, in the loop:\n\nPop current element (node, sum, parent).\n\nIf colors[node] is not -1, skip.\n\nSet colors[node] = sum % 2.\n\nFor each adjacent edge in adj[node], which is to v:\n\nIf v != parent, push (v, sum + edge length, node) into the stack.\n\nThis way, each node is pushed once (since each node has only one parent in the tree), and the adjacency list is traversed in a way that avoids revisiting the parent.\n\nThis approach should prevent adding redundant elements to the stack.\n\nSo, the code becomes:\n\nstruct StackElement {\n    int node;\n    int sum;\n    int parent;\n};\n\nstack[stack_top].node = 0;\nstack[stack_top].sum = 0;\nstack[stack_top].parent = -1;\nstack_top++;\n\nwhile (stack_top > 0) {\n    stack_top--;\n    struct StackElement current = stack[stack_top];\n    int u = current.node;\n    int sum_u = current.sum;\n    int parent_u = current.parent;\n\n    if (colors[u] != -1) continue;\n\n    colors[u] = sum_u % 2;\n\n    Edge *edge = adj[u];\n    while (edge != NULL) {\n        int v = edge->to;\n        int length = edge->length;\n        if (v != parent_u) {\n            // Push v onto the stack with sum_u + length and parent u\n            if (stack_top >= allocated_size) {\n                // Need to realloc, but for code brevity, assuming stack is big enough.\n            }\n            stack[stack_top].node = v;\n            stack[stack_top].sum = sum_u + length;\n            stack[stack_top].parent = u;\n            stack_top++;\n        }\n        edge = edge->next;\n    }\n}\n\nThis way, each node is pushed into the stack exactly once. Because each node (except root) has exactly one parent, and when processing a node u, we push all its children (i.e., neighbors except the parent). So each node is pushed once, processed once, leading to O(n) stack elements.\n\nThis is more efficient and avoids redundant processing.\n\nSo, this iterative DFS approach is better and avoids stack overflow issues.\n\nNow, integrating this into the C code.\n\nNow, let's outline the steps:\n\nRead n.\n\nAllocate adj as an array of Edge pointers, size n, initialized to NULL.\n\nRead n-1 edges, for each:\n\n    u, v, l (converted to 0-based).\n\n    Add to u's adj list an Edge to v with length l.\n\n    Add to v's adj list an Edge to u with length l.\n\nInitialize colors array to -1.\n\nAllocate stack. Since each node is pushed once, stack size can be n.\n\nPush the initial element (0, 0, -1).\n\nProcess stack as described.\n\nFinally, print colors[0] to colors[n-1].\n\nNow, code in C:\n\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Edge {\n    int to;\n    int length;\n    struct Edge *next;\n} Edge;\n\ntypedef struct StackElement {\n    int node;\n    int sum;\n    int parent;\n} StackElement;\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    Edge **adj = (Edge **)calloc(n, sizeof(Edge *));\n    \n    for (int i = 0; i < n - 1; ++i) {\n        int u, v, l;\n        scanf(\"%d %d %d\", &u, &v, &l);\n        u--; v--;\n        \n        Edge *e1 = (Edge *)malloc(sizeof(Edge));\n        e1->to = v;\n        e1->length = l;\n        e1->next = adj[u];\n        adj[u] = e1;\n        \n        Edge *e2 = (Edge *)malloc(sizeof(Edge));\n        e2->to = u;\n        e2->length = l;\n        e2->next = adj[v];\n        adj[v] = e2;\n    }\n    \n    int *colors = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; ++i) {\n        colors[i] = -1;\n    }\n    \n    StackElement *stack = (StackElement *)malloc(n * sizeof(StackElement));\n    int stack_top = 0;\n    \n    stack[stack_top].node = 0;\n    stack[stack_top].sum = 0;\n    stack[stack_top].parent = -1;\n    stack_top++;\n    \n    while (stack_top > 0) {\n        stack_top--;\n        int u = stack[stack_top].node;\n        int sum_u = stack[stack_top].sum;\n        int parent_u = stack[stack_top].parent;\n        \n        if (colors[u] != -1) continue;\n        \n        colors[u] = sum_u % 2;\n        \n        Edge *edge = adj[u];\n        while (edge != NULL) {\n            int v = edge->to;\n            int length = edge->length;\n            if (v != parent_u) {\n                stack[stack_top].node = v;\n                stack[stack_top].sum = sum_u + length;\n                stack[stack_top].parent = u;\n                stack_top++;\n            }\n            edge = edge->next;\n        }\n    }\n    \n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\\n\", colors[i]);\n    }\n    \n    // Free allocated memory (optional for a programming contest)\n    for (int i = 0; i < n; ++i) {\n        Edge *edge = adj[i];\n        while (edge != NULL) {\n            Edge *temp = edge;\n            edge = edge->next;\n            free(temp);\n        }\n    }\n    free(adj);\n    free(colors);\n    free(stack);\n    \n    return 0;\n}\n\nWait, but when reading the edges, the code uses 'n-1' iterations. Each edge is read once, and added twice (since the input is n-1 edges, each being added to both u and v). So that part is correct.\n\nIn the stack processing, each node is processed once. The stack starts with the root node (0), and each time a node is processed, all its adjacent nodes (except the parent) are added to the stack. This ensures that each node is processed exactly once.\n\nTesting this code: for a simple case where n=2.\n\nInput:\n\n2\n\n1 2 3\n\nNodes 0 and 1.\n\nAdj list for 0: an edge to 1 with length 3.\n\nAdj list for 1: an edge to 0 with length 3.\n\nProcessing:\n\nstack starts with (0, 0, -1).\n\nProcess 0: color is 0 % 2 = 0.\n\nAdjacent edges: 1. Since parent is -1, push 1 with sum 0+3=3, parent 0.\n\nStack now has 1 element: (1, 3, 0).\n\nProcess 1: color is 3 % 2 = 1.\n\nAdjacent edges: 0 (parent is 0, so skip). No other edges. So nothing pushed.\n\nPrint colors: 0 and 1.\n\nWhich is correct.\n\nAnother test case.\n\nn=3:\n\nEdges:\n\n1 2 1\n\n2 3 2\n\n1 3 3\n\nWait, no, n=3 has two edges. Suppose input is:\n\n3\n\n1 2 1\n\n1 3 2\n\nAfter conversion to 0-based:\n\nedges are:\n\n0-1 (length 1)\n\n0-2 (length 2)\n\nColors:\n\n0 (sum 0)\n\n1 (sum 1)\n\n2 (sum 2) mod 2 is 0.\n\nWait, no. The root is 0. The sum for node 0 is 0. Node 1 is connected to 0 with length 1. Sum 1: color 1. Node 2 is connected to 0 with length 2: sum 2, color 0.\n\nSo the output should be:\n\n0\n\n1\n\n0\n\nIn the code:\n\nWhen processing node 0, push nodes 1 and 2 (sum 1 and 2). The order depends on how the edges are added to the adjacency list. Since the edges are added in reverse order (since each new edge is added at the head of the list), the first edge added for node 0 is the second edge in the input.\n\nWait, when processing edges:\n\nFirst edge: 1-2 \u2192 u=0, v=1, l=1. Add to adj[0] a pointer to v=1, and to adj[1] a pointer to 0.\n\nThen the second edge: 1-3 \u2192 u=0, v=2, l=2. Add to adj[0] a pointer to v=2, and to adj[2] a pointer to 0.\n\nSo the adjacency list for node 0 is: first the edge to 2 (added later, so it's the head of the list), then the edge to 1.\n\nSo when processing node 0, the edges are iterated in reverse order. So the first edge in the loop is to node 2, then to node 1.\n\nSo, when node 0 is processed, the edges are 2 and 1. So the stack is pushed with node 2 (sum 2, parent 0), then node 1 (sum 1, parent 0). So the stack is:\n\nstack_top increments after each push. So the stack is [ (0,0,-1) ] \u2192 after processing, push 2 and 1.\n\nSo the stack_top after pushing becomes 2. Then, when popping, we process the elements in the order of the stack:\n\nInitially, stack_top is 1 (after pushing initial element). Then, after processing node 0, stack_top is 2 (elements 1 and 2 are pushed). Then, when popping, the first popped is the top element (stack_top is 2, then subtract 1, so index 1: node 1, sum 1, parent 0). Wait, no. The stack is managed as an array where stack_top is the next free spot. So when stack_top is 2, the elements are indices 0 and 1. When popping, we subtract 1 first, so take element at index 1.\n\nWait, code:\n\nstack_top starts at 0. Then, we push elements by writing to stack[stack_top] and incrementing stack_top. So, after the initial push, stack_top is 1.\n\nThen, in the loop:\n\nstack_top starts at 1. We subtract 1 (to 0), pop element 0, process it.\n\nAfter processing node 0, we push two elements (node 2 and node 1), so stack_top becomes 0 + 2 = 2.\n\nThen, the loop continues: stack_top is 2. Subtract 1 (to 1), pop element at 1 (node 1, sum 1, parent 0). Process node 1.\n\nIn node 1's adjacency list, edges are to 0 (parent, so skipped) and any other nodes. If the input had other edges, but in this case, node 1's adjacency list has only the edge to 0. So nothing is pushed. Then stack_top becomes 1.\n\nNext, subtract 1 to 0, pop element 0 (node 2, sum 2, parent 0). Process node 2. Sum is 2, color 0. Adjacency list has edge to 0 (parent, skipped), and any others? No. So nothing is pushed.\n\nThus, the colors are correct.\n\nSo the code should work.\n\nThus, the translated C code uses an iterative DFS with a stack to avoid recursion depth issues and correctly assigns colors based on the sum's parity."
}