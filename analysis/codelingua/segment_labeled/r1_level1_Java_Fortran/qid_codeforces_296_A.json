{
  "segments": [
    {
      "text": "Okay, I need to translate this Java code into Fortran.",
      "start_char": 0,
      "end_char": 54,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Let's look at what the Java code does.",
      "start_char": 55,
      "end_char": 93,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The main part is the solve method.",
      "start_char": 96,
      "end_char": 130,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "It reads an integer n, then creates an array of size 1001. Then it reads n integers, increments the corresponding index in the array. Then it finds the maximum count in the array.",
      "start_char": 131,
      "end_char": 310,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Depending on whether n is even or odd, it checks if the maximum count is less than or equal to n/2 or (n/2 +1). If yes, prints YES, else NO. So first, I need to replicate this logic in Fortran. Fortran has some differences. Let's think step by step. 1.",
      "start_char": 311,
      "end_char": 563,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Reading input: The Java code uses a custom InputReader class with buffered reader and tokenizer.",
      "start_char": 568,
      "end_char": 664,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "In Fortran, I can read from standard input using READ statements.",
      "start_char": 665,
      "end_char": 730,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Since the input is a sequence of integers, the first integer is n, followed by n integers. So for Fortran, I can read n, then read a list of n integers. But wait, the original code uses an array of size 1001 (indices from 0 to 1000?), but in Java, array indices start at 0. But in the code, when they read the index, they just increment array[index]. So the possible values of the input integers can be up to 1000. Because array is size 1001. So in Fortran, I can create an array of size 0:1000, or maybe 1:1001 and adjust.",
      "start_char": 731,
      "end_char": 1254,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Wait, in Java, the array is new int[1001], so indices from 0 to 1000. But the code in the for loop for checking starts from i=1 to array.length (which is 1001).",
      "start_char": 1256,
      "end_char": 1416,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Wait, wait, the array is initialized as size 1001, so indices 0-1000. Then the loop runs from i=1 to array.length (1001). Wait, that's a mistake?",
      "start_char": 1417,
      "end_char": 1562,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Because array.length is 1001, so the loop is i < 1001, so i runs from 1 to 1000.",
      "start_char": 1563,
      "end_char": 1643,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Because array indices are 0 to 1000, but the code checks starting at 1.",
      "start_char": 1644,
      "end_char": 1715,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "Oh, so perhaps the input numbers are from 1 to 1000. Because in the code, when they read the index, it's stored in array[index], and the loop starts at i=1. So in the Java code, the frequencies are counted for numbers 1 to 1000. So in Fortran, perhaps the array can be dimension 1000, indexes 1 to 1000. Or maybe 0 to 1000, but the code starts checking from i=1. So in Fortran, we can have an array from 1 to 1000. So first, the array in Fortran can be dimensioned as array(1000), initialized to zero.",
      "start_char": 1716,
      "end_char": 2218,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Then, for each input number, increment array(index).",
      "start_char": 2220,
      "end_char": 2272,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Next, find the maximum count in the array. Then check if the maximum count is within the allowed limit based on n's parity.",
      "start_char": 2274,
      "end_char": 2397,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "In Fortran, reading the input: first read n, then read n integers. Then process. So the steps in Fortran:\n\nRead n.\n\nInitialize array(1000) to zero.",
      "start_char": 2399,
      "end_char": 2546,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Read n values, each time increment array(value).",
      "start_char": 2549,
      "end_char": 2597,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Find the maximum value in array. Check if n is even or odd. If even, check if max <= n/2. If odd, check if max <= (n/2 +1). If yes, print YES, else NO.",
      "start_char": 2599,
      "end_char": 2753,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Now, how to read the input in Fortran.",
      "start_char": 2756,
      "end_char": 2794,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "The input is a line with n, followed by a line with n integers. But sometimes, the input might have all the numbers in a single line, but the Java code uses nextInt(), which splits on any whitespace. So in Fortran, read the first number as n, then read the next n numbers, possibly from the same line or subsequent lines.",
      "start_char": 2795,
      "end_char": 3116,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "In Fortran, using list-directed input (using *), which skips over whitespace, so it should handle that. So code outline:\n\nprogram main\n  implicit none\n  integer :: n, i, index, max_count\n  integer, dimension(1000) :: counts = 0\n  logical :: possible\n\n  read(*,*) n\n  do i = 1, n\n    read(*,*) index\n    counts(index) = counts(index) + 1\n  end do\n\n  max_count = maxval(counts)\n\n  if (mod(n,2) == 0) then\n    possible = (max_count <= n / 2)\n  else\n    possible = (max_count <= (n / 2) + 1)\n  end if\n\n  if (possible) then\n    print *, \"YES\"\n  else\n    print *, \"NO\"\n  end if\nend program main\n\nWait, but what if the input numbers are 0?",
      "start_char": 3119,
      "end_char": 3752,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "Because in the original code, the array is of size 1001, so indices 0-1000. But in the loop, they check i from 1 to array.length (1001), but array.length is 1001, so the loop is i < array.length \u2192 i up to 1000. So the code checks indices 1 to 1000 (since i starts at 1). Wait no, array has 1001 elements (indices 0-1000). The loop is for (i=1; i < array.length; i++), array.length is 1001. So i runs from 1 to 1000. So in Java code, they check array[1] to array[1000]. So the input numbers must be between 1 and 1000, otherwise the array[index] would be out of bounds. But in the Java code, the code allows any index (since it's read as a nextInt()), which could be 0, but that would increment array[0], which is not checked in the loop. So the code's logic is incorrect if the input contains 0, because it's not considered when finding the max count. But according to the problem statement, maybe the input numbers are between 1 and 1000. But the original code is written that way. So in the Fortran code, to replicate this, perhaps we need to have the array from 1 to 1000. So if the input contains 0, the Fortran code would have an array index out of bounds. But the Java code, when the input is 0, the array has index 0, but the loop checks from 1, so array[0] is not considered. So the maximum count in Java code could be wrong if the input includes 0. But the Fortran code's array is from 1 to 1000, so if the input includes 0, it would crash. But the original Java code allows 0 as input but ignores it in the max calculation. So perhaps the problem's constraints are that the input numbers are between 1 and 1000, so the code is correct. So in Fortran, the array is 1 to 1000. So any input number must be between 1 and 1000. But in the code, if the input is 0, Fortran would crash. So perhaps the problem's test cases do not include 0. So we proceed. So in Fortran, the array is dimension(1000), and indices are 1 to 1000. So any input number should be in 1..1000. So the Fortran code should work. Testing: for example, if n=2, and numbers 1 and 1, then count is 2 for index 1. For even n=2, check if 2 <= 2/2 \u2192 2 <=1 \u2192 no \u2192 output NO. But according to the Java code, when n is even, check if countMax <= n/2. So in this case, 2 <=1 \u2192 false \u2192 output NO. Another example: n=3, and numbers 1,1,2. Max count is 2. n is odd. Check if 2 <= 3/2 +1 \u2192 1 +1=2 \u2192 yes. So output YES. So the code seems to handle that.",
      "start_char": 3753,
      "end_char": 6174,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Now, the Fortran code would need to read the n numbers. So the code uses a loop to read each number.",
      "start_char": 6177,
      "end_char": 6277,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "In Fortran, list-directed input (using *) reads from the input, so even if the numbers are on the same line or different lines, it works.",
      "start_char": 6278,
      "end_char": 6415,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Another point: in Fortran, integer division uses /, which truncates towards zero. So for n even, n/2 is correct. For n odd, (n/2) is integer division, e.g., 3/2=1, then add 1 gives 2. Which is correct. So the code should work. So the final Fortran code would look like:\n\nprogram main\n  implicit none\n  integer :: n, i, idx, max_count\n  integer :: counts(1000) = 0  ! Assuming input numbers are 1-based\n\n  read(*, *) n\n  do i = 1, n\n    read(*, *) idx\n    counts(idx) = counts(idx) + 1\n  end do\n\n  max_count = maxval(counts)\n\n  if (mod(n, 2) == 0) then\n    if (max_count <= n / 2) then\n      print *, \"YES\"\n    else\n      print *, \"NO\"\n    end if\n  else\n    if (max_count <= n / 2 + 1) then\n      print *, \"YES\"\n    else\n      print *, \"NO\"\n    end if\n  end if\nend program main\n\nWait, but in the original Java code, the array is size 1001 (0-1000), but in the code, the loop checks from i=1 to i<array.length (1001). So in Java, the loop is for i=1 to 1000. So the code is checking the counts for indices 1-1000, but the array includes index 0. But the Java code's logic would not consider index 0. So if the input contains 0, then array[0] is incremented, but the max count is not considered. So the Java code is incorrect for input containing 0, but perhaps the problem's constraints ensure that input numbers are between 1 and 1000. So in the Fortran code, using array(1:1000) is correct.",
      "start_char": 6417,
      "end_char": 7809,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Therefore, the Fortran code as written should work.",
      "start_char": 7811,
      "end_char": 7862,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    }
  ],
  "original_reasoning": "Okay, I need to translate this Java code into Fortran. Let's look at what the Java code does. \n\nThe main part is the solve method. It reads an integer n, then creates an array of size 1001. Then it reads n integers, increments the corresponding index in the array. Then it finds the maximum count in the array. Depending on whether n is even or odd, it checks if the maximum count is less than or equal to n/2 or (n/2 +1). If yes, prints YES, else NO.\n\nSo first, I need to replicate this logic in Fortran. \n\nFortran has some differences. Let's think step by step.\n\n1. Reading input: The Java code uses a custom InputReader class with buffered reader and tokenizer. In Fortran, I can read from standard input using READ statements. Since the input is a sequence of integers, the first integer is n, followed by n integers. So for Fortran, I can read n, then read a list of n integers.\n\nBut wait, the original code uses an array of size 1001 (indices from 0 to 1000?), but in Java, array indices start at 0. But in the code, when they read the index, they just increment array[index]. So the possible values of the input integers can be up to 1000. Because array is size 1001. So in Fortran, I can create an array of size 0:1000, or maybe 1:1001 and adjust. Wait, in Java, the array is new int[1001], so indices from 0 to 1000. But the code in the for loop for checking starts from i=1 to array.length (which is 1001). Wait, wait, the array is initialized as size 1001, so indices 0-1000. Then the loop runs from i=1 to array.length (1001). Wait, that's a mistake? Because array.length is 1001, so the loop is i < 1001, so i runs from 1 to 1000. Because array indices are 0 to 1000, but the code checks starting at 1. Oh, so perhaps the input numbers are from 1 to 1000. Because in the code, when they read the index, it's stored in array[index], and the loop starts at i=1. So in the Java code, the frequencies are counted for numbers 1 to 1000.\n\nSo in Fortran, perhaps the array can be dimension 1000, indexes 1 to 1000. Or maybe 0 to 1000, but the code starts checking from i=1. So in Fortran, we can have an array from 1 to 1000.\n\nSo first, the array in Fortran can be dimensioned as array(1000), initialized to zero. Then, for each input number, increment array(index).\n\nNext, find the maximum count in the array. Then check if the maximum count is within the allowed limit based on n's parity.\n\nIn Fortran, reading the input: first read n, then read n integers. Then process.\n\nSo the steps in Fortran:\n\nRead n.\n\nInitialize array(1000) to zero.\n\nRead n values, each time increment array(value).\n\nFind the maximum value in array.\n\nCheck if n is even or odd.\n\nIf even, check if max <= n/2.\n\nIf odd, check if max <= (n/2 +1).\n\nIf yes, print YES, else NO.\n\nNow, how to read the input in Fortran. The input is a line with n, followed by a line with n integers.\n\nBut sometimes, the input might have all the numbers in a single line, but the Java code uses nextInt(), which splits on any whitespace. So in Fortran, read the first number as n, then read the next n numbers, possibly from the same line or subsequent lines.\n\nIn Fortran, using list-directed input (using *), which skips over whitespace, so it should handle that.\n\nSo code outline:\n\nprogram main\n  implicit none\n  integer :: n, i, index, max_count\n  integer, dimension(1000) :: counts = 0\n  logical :: possible\n\n  read(*,*) n\n  do i = 1, n\n    read(*,*) index\n    counts(index) = counts(index) + 1\n  end do\n\n  max_count = maxval(counts)\n\n  if (mod(n,2) == 0) then\n    possible = (max_count <= n / 2)\n  else\n    possible = (max_count <= (n / 2) + 1)\n  end if\n\n  if (possible) then\n    print *, \"YES\"\n  else\n    print *, \"NO\"\n  end if\nend program main\n\nWait, but what if the input numbers are 0? Because in the original code, the array is of size 1001, so indices 0-1000. But in the loop, they check i from 1 to array.length (1001), but array.length is 1001, so the loop is i < array.length \u2192 i up to 1000. So the code checks indices 1 to 1000 (since i starts at 1). Wait no, array has 1001 elements (indices 0-1000). The loop is for (i=1; i < array.length; i++), array.length is 1001. So i runs from 1 to 1000. So in Java code, they check array[1] to array[1000]. So the input numbers must be between 1 and 1000, otherwise the array[index] would be out of bounds. But in the Java code, the code allows any index (since it's read as a nextInt()), which could be 0, but that would increment array[0], which is not checked in the loop. So the code's logic is incorrect if the input contains 0, because it's not considered when finding the max count.\n\nBut according to the problem statement, maybe the input numbers are between 1 and 1000. But the original code is written that way. So in the Fortran code, to replicate this, perhaps we need to have the array from 1 to 1000. So if the input contains 0, the Fortran code would have an array index out of bounds. But the Java code, when the input is 0, the array has index 0, but the loop checks from 1, so array[0] is not considered. So the maximum count in Java code could be wrong if the input includes 0.\n\nBut the Fortran code's array is from 1 to 1000, so if the input includes 0, it would crash. But the original Java code allows 0 as input but ignores it in the max calculation. So perhaps the problem's constraints are that the input numbers are between 1 and 1000, so the code is correct. So in Fortran, the array is 1 to 1000. So any input number must be between 1 and 1000. But in the code, if the input is 0, Fortran would crash. So perhaps the problem's test cases do not include 0. So we proceed.\n\nSo in Fortran, the array is dimension(1000), and indices are 1 to 1000. So any input number should be in 1..1000.\n\nSo the Fortran code should work.\n\nTesting: for example, if n=2, and numbers 1 and 1, then count is 2 for index 1. For even n=2, check if 2 <= 2/2 \u2192 2 <=1 \u2192 no \u2192 output NO.\n\nBut according to the Java code, when n is even, check if countMax <= n/2. So in this case, 2 <=1 \u2192 false \u2192 output NO.\n\nAnother example: n=3, and numbers 1,1,2. Max count is 2. n is odd. Check if 2 <= 3/2 +1 \u2192 1 +1=2 \u2192 yes. So output YES.\n\nSo the code seems to handle that.\n\nNow, the Fortran code would need to read the n numbers. So the code uses a loop to read each number. In Fortran, list-directed input (using *) reads from the input, so even if the numbers are on the same line or different lines, it works.\n\nAnother point: in Fortran, integer division uses /, which truncates towards zero. So for n even, n/2 is correct. For n odd, (n/2) is integer division, e.g., 3/2=1, then add 1 gives 2. Which is correct.\n\nSo the code should work.\n\nSo the final Fortran code would look like:\n\nprogram main\n  implicit none\n  integer :: n, i, idx, max_count\n  integer :: counts(1000) = 0  ! Assuming input numbers are 1-based\n\n  read(*, *) n\n  do i = 1, n\n    read(*, *) idx\n    counts(idx) = counts(idx) + 1\n  end do\n\n  max_count = maxval(counts)\n\n  if (mod(n, 2) == 0) then\n    if (max_count <= n / 2) then\n      print *, \"YES\"\n    else\n      print *, \"NO\"\n    end if\n  else\n    if (max_count <= n / 2 + 1) then\n      print *, \"YES\"\n    else\n      print *, \"NO\"\n    end if\n  end if\nend program main\n\nWait, but in the original Java code, the array is size 1001 (0-1000), but in the code, the loop checks from i=1 to i<array.length (1001). So in Java, the loop is for i=1 to 1000. So the code is checking the counts for indices 1-1000, but the array includes index 0. But the Java code's logic would not consider index 0. So if the input contains 0, then array[0] is incremented, but the max count is not considered. So the Java code is incorrect for input containing 0, but perhaps the problem's constraints ensure that input numbers are between 1 and 1000. So in the Fortran code, using array(1:1000) is correct.\n\nTherefore, the Fortran code as written should work."
}