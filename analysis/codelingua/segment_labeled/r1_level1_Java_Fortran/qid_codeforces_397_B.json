{
  "segments": [
    {
      "text": "Okay, so I need to translate this Java code into Fortran.",
      "start_char": 0,
      "end_char": 57,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Let me start by understanding what the Java code is doing.",
      "start_char": 58,
      "end_char": 116,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The code reads some test cases and for each case, it checks certain conditions based on the values of n, a, and b.",
      "start_char": 117,
      "end_char": 231,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "The main logic seems to be determining whether it's possible to represent n using combinations of a and b under some constraints.",
      "start_char": 232,
      "end_char": 361,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "First, let's look at the structure.",
      "start_char": 364,
      "end_char": 399,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The Java code uses a Scanner for input and a PrintWriter for output.",
      "start_char": 400,
      "end_char": 468,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The main loop runs for t test cases. Each case processes n, a, b.",
      "start_char": 469,
      "end_char": 534,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "There are several conditional checks.",
      "start_char": 535,
      "end_char": 572,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Fortran handles input and output a bit differently.",
      "start_char": 575,
      "end_char": 626,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "I'll need to read from standard input, probably using READ statements, and write to standard output using PRINT.",
      "start_char": 627,
      "end_char": 739,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Fortran doesn't have a built-in equivalent to Java's Scanner, so I'll have to read the inputs using formatted reads. Let's break down the steps.",
      "start_char": 740,
      "end_char": 884,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "1. Read the number of test cases, t. In Java, that's in.nextInt().",
      "start_char": 889,
      "end_char": 955,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "In Fortran, I'll read using READ(*,*) t.\n\n2.",
      "start_char": 956,
      "end_char": 1000,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "For each test case, read n, a, b. Wait, in the Java code, n is read as a long, but initially using in.nextInt().",
      "start_char": 1001,
      "end_char": 1113,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "Wait, wait, looking at the Java code: the variables n, a, b are declared as long, but they are read using in.nextInt().",
      "start_char": 1114,
      "end_char": 1233,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Oh, that's a mistake in the Java code.",
      "start_char": 1234,
      "end_char": 1272,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "Because nextInt() returns an int, but then stored in a long. But perhaps in the problem statement, the inputs are integers. So in Fortran, I'll read them as integers. So the Fortran variables can be INTEGER.",
      "start_char": 1273,
      "end_char": 1480,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Wait, but the problem might require handling large numbers.",
      "start_char": 1482,
      "end_char": 1541,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "Let me check the original code again.",
      "start_char": 1542,
      "end_char": 1579,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "For example, in Java, the variables are long, which are 64-bit integers. So in Fortran, perhaps use INTEGER*8 or the equivalent to handle 64-bit integers. But since in Java they read using nextInt(), which is 32-bit, but stored into a long.",
      "start_char": 1580,
      "end_char": 1820,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Wait, but in Java, even if you read a 32-bit int, assigning it to a long is okay. So the inputs are 32-bit integers. So in Fortran, using INTEGER (4 bytes) should be sufficient. But maybe the code performs calculations that could overflow. Let me check.",
      "start_char": 1821,
      "end_char": 2074,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Looking at the code, for example, x is calculated as b/(b-a). So if b and a are integers, but b-a is small, this could be a large value. But in Java, since the variables are long, which is 64-bit. So in Fortran, using INTEGER*8 would be safer to prevent overflow. So perhaps all variables should be INTEGER(8). Hmm. So I need to declare them as such in Fortran. So in Fortran, variables are declared with types. Let's plan that.",
      "start_char": 2076,
      "end_char": 2504,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The main variables will be t, n, a, b, x, low, high, ans, mid.",
      "start_char": 2506,
      "end_char": 2568,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "All these should be 8-byte integers. Next, the logic.",
      "start_char": 2569,
      "end_char": 2622,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "Let's go through each condition. First, if n < a, output \"No\". Then, if a == b, check if n is divisible by a. If yes, \"Yes\", else \"No\". Otherwise, compute x = b/(b-a). Then check if n > x*a. If yes, output \"Yes\".",
      "start_char": 2625,
      "end_char": 2840,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Otherwise, perform a binary search to find ans, and then check if n is between (ans-1)*b and ans*a.",
      "start_char": 2841,
      "end_char": 2940,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "If so, output \"No\", else \"Yes\".",
      "start_char": 2941,
      "end_char": 2972,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Now, translating the binary search part. The loop in Java is while (low <= high), mid is (low + high)/2.",
      "start_char": 2974,
      "end_char": 3078,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "If mid*a < n, set low to mid+1, else set ans to mid and high to mid-1.",
      "start_char": 3079,
      "end_char": 3149,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "In Fortran, loops are done with DO loops, but the binary search is a while loop. So perhaps using a DO loop with an exit condition. Or use a DO WHILE loop. Fortran has DO WHILE, yes. So the structure would be:\n\nlow = 1\nhigh = x + 1\nans = 1\nDO WHILE (low <= high) mid = (low + high) / 2\n    IF (mid * a < n) THEN\n        low = mid + 1\n    ELSE\n        ans = mid\n        high = mid - 1\n    END",
      "start_char": 3152,
      "end_char": 3549,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "IF\nEND DO\n\nBut wait, in Java, integers are signed, and division is integer division. So in Fortran, when using / operator with integers, it does integer division. But need to make sure that mid is calculated as (low + high) divided by 2, using integer division.",
      "start_char": 3550,
      "end_char": 3811,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "After finding ans, check if n is greater than (ans-1)*b and less than ans*a.",
      "start_char": 3814,
      "end_char": 3890,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "If so, output \"No\", else \"Yes\".",
      "start_char": 3891,
      "end_char": 3922,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Now, handling the input and output.",
      "start_char": 3924,
      "end_char": 3959,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "In Fortran, each read statement reads a line unless specified otherwise. So when reading t, then for each test case, read n, a, b. So for each test case, the code would have:\n\nREAD(*,*) n, a, b\n\nWait, but in Java, the code reads three integers per test case. So in Fortran, each test case is three integers. So the input format would be like:\n\nt\nn1 a1 b1\nn2 a2 b2\n... So each line after the first has three integers. So the READ statements would be inside the loop over t, reading each line as a, n, b. Wait, no: in Java, the code reads n, a, b in that order. So the input lines for each test case are n a b. So in Fortran, the code would read n, a, b. So the code for the test case loop would be:\n\nDO i = 1, t\n    READ(*,*) n, a, b\n    !",
      "start_char": 3960,
      "end_char": 4699,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "process\nEND DO\n\nNow, for the output, in Java, it's either \"Yes\" or \"No\" per test case. So in Fortran, for each case, after processing, print either \"Yes\" or \"No\".",
      "start_char": 4700,
      "end_char": 4862,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Putting it all together, let's outline the steps.",
      "start_char": 4864,
      "end_char": 4913,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Declare variables:\n\nINTEGER(8) :: t, n, a, b, x, low, high, ans, mid, i\nCHARACTER(3) :: res\n\nRead t:\n\nREAD(*,*) t\n\nLoop over test cases:\n\nDO i = 1, t\n    READ(*,*) n, a, b\n\n    IF (n < a) THEN\n        PRINT *, \"No\"\n        CYCLE\n    END IF\n\n    IF (a == b) THEN\n        IF (MOD(n, a) == 0) THEN\n            PRINT *, \"Yes\"\n        ELSE\n            PRINT *, \"No\"\n        END IF\n        CYCLE\n    END IF\n\n    x = b / (b - a)  ! But what if b - a is zero? But in Java code, a and b are different here.",
      "start_char": 4915,
      "end_char": 5412,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "IF (n > x * a) THEN\n        PRINT *, \"Yes\"\n        CYCLE\n    END IF\n\n    low = 1\n    high = x + 1\n    ans = 1\n\n    DO WHILE (low <= high)\n        mid = (low + high) / 2\n        IF (mid * a < n) THEN\n            low = mid + 1\n        ELSE\n            ans = mid\n            high = mid - 1\n        END",
      "start_char": 5418,
      "end_char": 5716,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "IF\n    END DO\n\n    IF (n > (ans-1)*b .AND.",
      "start_char": 5717,
      "end_char": 5759,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "n < ans*a) THEN\n        PRINT *, \"No\"\n    ELSE\n        PRINT *, \"Yes\"\n    END",
      "start_char": 5760,
      "end_char": 5837,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "IF\n\nEND DO\n\nWait, but Fortran uses .LT. and .GT. for comparisons.",
      "start_char": 5838,
      "end_char": 5903,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Wait, no: in Fortran, the syntax is .LT., .LE., .GT., .GE., .EQ., .NE. for <, <=, >, >=, ==, != respectively. So in the code, the condition (mid * a < n) in Java would be (mid * a .LT. n) in Fortran. So adjusting the conditions:\n\nIn the binary search loop:\n\nIF (mid * a < n) becomes IF (mid * a .LT. n).",
      "start_char": 5904,
      "end_char": 6207,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Similarly for other conditions.",
      "start_char": 6210,
      "end_char": 6241,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Another thing: in Fortran, when you use integer division with /, if the operands are integers, it truncates towards zero.",
      "start_char": 6243,
      "end_char": 6364,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Java's integer division also truncates towards zero. So that should be okay.",
      "start_char": 6365,
      "end_char": 6441,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Now, possible edge cases: when (b - a) is zero? But in Java code, when a == b is handled in the earlier condition. So in Fortran, when a and b are not equal, (b - a) is non-zero, so division is safe.",
      "start_char": 6443,
      "end_char": 6642,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "Wait, no: what if a and b are different, but b - a is negative? For example, a=5, b=3. Then (b - a) is -2. Then x = 3/(3-5) = 3 / (-2) = -1. Then x * a is -5. Then the condition n > x*a is n > -5, which would be true for any n >=0.",
      "start_char": 6644,
      "end_char": 6875,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Then, in that case, the code would print \"Yes\" immediately. But perhaps that's intended. So in the code, when a < b, then (b -a) is positive, x is positive. But if a > b, then (b -a) is negative, so x becomes negative, which would make x * a negative, and since n is a positive integer (as per problem statement?), then n > x*a (which is negative) would be true, leading to \"Yes\". So perhaps that's correct. So the code should handle a and b in any order, as long as they are different. So no problem.",
      "start_char": 6876,
      "end_char": 7377,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Now, in Fortran, the code should replicate this logic. Testing some sample cases. But perhaps the code can be written as is, translating each Java line to Fortran.",
      "start_char": 7382,
      "end_char": 7545,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Now, handling the binary search loop.",
      "start_char": 7549,
      "end_char": 7586,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Wait, in Fortran, the DO WHILE loop syntax is:\n\nDO WHILE (condition)\n    ... END DO\n\nYes. So the code for the binary search loop is:\n\nlow = 1\nhigh = x + 1\nans = 1\nDO WHILE (low <= high) mid = (low + high) / 2\n    IF (mid * a < n) THEN\n        low = mid + 1\n    ELSE\n        ans = mid\n        high = mid - 1\n    END",
      "start_char": 7588,
      "end_char": 7907,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "IF\nEND DO\n\nBut wait, in Fortran, the division of integers (low + high) / 2 may be different from Java.",
      "start_char": 7908,
      "end_char": 8010,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "For example, in Java, when (low + high) is even, it's straightforward, but when it's odd, it truncates.",
      "start_char": 8011,
      "end_char": 8114,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "In Fortran, since it's integer division, same as Java. So mid is computed correctly.",
      "start_char": 8115,
      "end_char": 8199,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Now, after the loop, check if n is in the range (ans-1)*b < n < ans*a.",
      "start_char": 8201,
      "end_char": 8271,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "If so, output \"No\", else \"Yes\".",
      "start_char": 8272,
      "end_char": 8303,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "In Fortran, the condition would be:\n\nIF (n > (ans-1)*b .AND. n < ans*a) THEN\n\nBut since in Fortran, the logical operators are .AND., .OR., etc. So the code is correct. But in Java, the code uses (n > (ans-1)*b && n < ans*a). So same as Fortran.",
      "start_char": 8305,
      "end_char": 8549,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Now, possible edge cases:\n\nIf ans is 1, then (ans-1)*b is 0, and if n is between 0 and a, but earlier checks may have already handled that. But according to the code's logic, after the binary search, if this condition is true, then output \"No\", else \"Yes\".",
      "start_char": 8552,
      "end_char": 8808,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "Now, compiling all these into Fortran code.",
      "start_char": 8811,
      "end_char": 8854,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Another thing to note: in Fortran, variables need to be declared before use. So variables like t, n, a, b, x, low, high, ans, mid, i should be declared as INTEGER(8).",
      "start_char": 8856,
      "end_char": 9022,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The MOD is not used here, except in the Java code as a class variable, but in the Fortran code, the modulus operation is done using MOD(n, a). So in Fortran, the code would start with:\n\nPROGRAM main\n    IMPLICIT NONE\n    INTEGER(8) :: t, n, a, b, x, low, high, ans, mid, i\n\n    READ(*,*) t\n    DO i = 1, t\n        READ(*,*) n, a, b\n        IF (n < a) THEN\n            PRINT *, \"No\"\n            CYCLE\n        END IF\n        IF (a == b) THEN\n            IF (MOD(n, a) == 0) THEN\n                PRINT *, \"Yes\"\n            ELSE\n                PRINT *, \"No\"\n            END IF\n            CYCLE\n        END IF\n        x = b / (b - a)\n        IF (n > x * a) THEN\n            PRINT *, \"Yes\"\n            CYCLE\n        END IF\n        low = 1\n        high = x + 1\n        ans = 1\n        DO WHILE (low <= high)\n            mid = (low + high) / 2\n            IF (mid * a < n) THEN\n                low = mid + 1\n            ELSE\n                ans = mid\n                high = mid - 1\n            END",
      "start_char": 9023,
      "end_char": 10015,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "IF\n        END DO\n        IF (n > (ans - 1)*b .AND.",
      "start_char": 10016,
      "end_char": 10067,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "n < ans*a) THEN\n            PRINT *, \"No\"\n        ELSE\n            PRINT *, \"Yes\"\n        END",
      "start_char": 10068,
      "end_char": 10161,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "IF\n    END DO\nEND PROGRAM main\n\nWait, but in Fortran, the code requires that all variables are declared with the correct type. So in the code above, variables are declared as INTEGER(8).",
      "start_char": 10162,
      "end_char": 10348,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Also, the MOD function in Fortran returns the same as in Java when the arguments are positive, but may differ if one is negative. But in the code, since a and b are positive (as per the problem's input?), the MOD function should work correctly.",
      "start_char": 10349,
      "end_char": 10593,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Another thing: in the binary search loop, when low and high are large, adding them could overflow. But in Java, since they are longs, 64-bit integers.",
      "start_char": 10595,
      "end_char": 10745,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "In Fortran, using INTEGER(8) should handle that.",
      "start_char": 10746,
      "end_char": 10794,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Testing the code with some inputs. For example, when t=1, n=5, a=3, b=4. Let's see.",
      "start_char": 10796,
      "end_char": 10880,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "In Java:\n\nIf a and b are 3 and 4. Since a != b.\n\nx =4/(4-3) =4/1=4. Check if 5>4*3=12? No. So proceed to binary search. low=1, high=5. First iteration: low=1, high=5. mid=(1+5)/2=3. mid*a=3*3=9. 9 <5? No. So ans=3, high=2. Loop continues since low <= high (1 <=2). mid = (1+2)/2=1. mid*a=3. 3 <5 \u2192 yes. So low=2. Loop condition: 2 <=2. mid=(2+2)/2=2. mid*a=6 <5? No. So ans=2, high=1. Now loop ends. Check if 5 > (2-1)*4 \u2192 4 and <2*3=6. 5 is between 4 and6 \u2192 yes. So output No. So the Fortran code would output \"No\" here. Which is correct? But what's the actual logic here. The problem is a bit unclear. But according to the Java code's logic, this is correct. Another example: n=6, a=3, b=4. After binary search:\n\nx=4/(1) =4. 6 is not greater than 12. So binary search. low=1, high=5.\n\nmid=3 \u2192 3*3=9 >=6 \u2192 ans=3, high=2. low=1, high=2 \u2192 mid=1.5 \u2192 1.5 truncated to 1. mid*a=3 < 6 \u2192 low=2. mid=2 \u2192 2*3=6 >=6 \u2192 ans=2, high=1. Loop ends. Check if 6> (2-1)*4=4 and <2*3=6 \u2192 6 is not <6. So condition is false. Output \"Yes\". Which is correct because 6 can be written as 3*2 (since a=3, and 2*a=6). So the code works.",
      "start_char": 10882,
      "end_char": 12008,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Therefore, the Fortran code should replicate the Java code's logic correctly.",
      "start_char": 12011,
      "end_char": 12088,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    }
  ],
  "original_reasoning": "Okay, so I need to translate this Java code into Fortran. Let me start by understanding what the Java code is doing. The code reads some test cases and for each case, it checks certain conditions based on the values of n, a, and b. The main logic seems to be determining whether it's possible to represent n using combinations of a and b under some constraints. \n\nFirst, let's look at the structure. The Java code uses a Scanner for input and a PrintWriter for output. The main loop runs for t test cases. Each case processes n, a, b. There are several conditional checks. \n\nFortran handles input and output a bit differently. I'll need to read from standard input, probably using READ statements, and write to standard output using PRINT. Fortran doesn't have a built-in equivalent to Java's Scanner, so I'll have to read the inputs using formatted reads. \n\nLet's break down the steps. \n\n1. Read the number of test cases, t. In Java, that's in.nextInt(). In Fortran, I'll read using READ(*,*) t.\n\n2. For each test case, read n, a, b. Wait, in the Java code, n is read as a long, but initially using in.nextInt(). Wait, wait, looking at the Java code: the variables n, a, b are declared as long, but they are read using in.nextInt(). Oh, that's a mistake in the Java code. Because nextInt() returns an int, but then stored in a long. But perhaps in the problem statement, the inputs are integers. So in Fortran, I'll read them as integers. So the Fortran variables can be INTEGER.\n\nWait, but the problem might require handling large numbers. Let me check the original code again. For example, in Java, the variables are long, which are 64-bit integers. So in Fortran, perhaps use INTEGER*8 or the equivalent to handle 64-bit integers. But since in Java they read using nextInt(), which is 32-bit, but stored into a long. Wait, but in Java, even if you read a 32-bit int, assigning it to a long is okay. So the inputs are 32-bit integers. So in Fortran, using INTEGER (4 bytes) should be sufficient. But maybe the code performs calculations that could overflow. Let me check.\n\nLooking at the code, for example, x is calculated as b/(b-a). So if b and a are integers, but b-a is small, this could be a large value. But in Java, since the variables are long, which is 64-bit. So in Fortran, using INTEGER*8 would be safer to prevent overflow. So perhaps all variables should be INTEGER(8). Hmm. So I need to declare them as such in Fortran.\n\nSo in Fortran, variables are declared with types. Let's plan that. The main variables will be t, n, a, b, x, low, high, ans, mid. All these should be 8-byte integers. \n\nNext, the logic. Let's go through each condition.\n\nFirst, if n < a, output \"No\". Then, if a == b, check if n is divisible by a. If yes, \"Yes\", else \"No\". \n\nOtherwise, compute x = b/(b-a). Then check if n > x*a. If yes, output \"Yes\". Otherwise, perform a binary search to find ans, and then check if n is between (ans-1)*b and ans*a. If so, output \"No\", else \"Yes\".\n\nNow, translating the binary search part. The loop in Java is while (low <= high), mid is (low + high)/2. If mid*a < n, set low to mid+1, else set ans to mid and high to mid-1. \n\nIn Fortran, loops are done with DO loops, but the binary search is a while loop. So perhaps using a DO loop with an exit condition. Or use a DO WHILE loop. Fortran has DO WHILE, yes. \n\nSo the structure would be:\n\nlow = 1\nhigh = x + 1\nans = 1\nDO WHILE (low <= high)\n    mid = (low + high) / 2\n    IF (mid * a < n) THEN\n        low = mid + 1\n    ELSE\n        ans = mid\n        high = mid - 1\n    END IF\nEND DO\n\nBut wait, in Java, integers are signed, and division is integer division. So in Fortran, when using / operator with integers, it does integer division. But need to make sure that mid is calculated as (low + high) divided by 2, using integer division. \n\nAfter finding ans, check if n is greater than (ans-1)*b and less than ans*a. If so, output \"No\", else \"Yes\".\n\nNow, handling the input and output. In Fortran, each read statement reads a line unless specified otherwise. So when reading t, then for each test case, read n, a, b. So for each test case, the code would have:\n\nREAD(*,*) n, a, b\n\nWait, but in Java, the code reads three integers per test case. So in Fortran, each test case is three integers. So the input format would be like:\n\nt\nn1 a1 b1\nn2 a2 b2\n...\n\nSo each line after the first has three integers. So the READ statements would be inside the loop over t, reading each line as a, n, b. Wait, no: in Java, the code reads n, a, b in that order. So the input lines for each test case are n a b. So in Fortran, the code would read n, a, b. So the code for the test case loop would be:\n\nDO i = 1, t\n    READ(*,*) n, a, b\n    ! process\nEND DO\n\nNow, for the output, in Java, it's either \"Yes\" or \"No\" per test case. So in Fortran, for each case, after processing, print either \"Yes\" or \"No\".\n\nPutting it all together, let's outline the steps.\n\nDeclare variables:\n\nINTEGER(8) :: t, n, a, b, x, low, high, ans, mid, i\nCHARACTER(3) :: res\n\nRead t:\n\nREAD(*,*) t\n\nLoop over test cases:\n\nDO i = 1, t\n    READ(*,*) n, a, b\n\n    IF (n < a) THEN\n        PRINT *, \"No\"\n        CYCLE\n    END IF\n\n    IF (a == b) THEN\n        IF (MOD(n, a) == 0) THEN\n            PRINT *, \"Yes\"\n        ELSE\n            PRINT *, \"No\"\n        END IF\n        CYCLE\n    END IF\n\n    x = b / (b - a)  ! But what if b - a is zero? But in Java code, a and b are different here.\n\n    IF (n > x * a) THEN\n        PRINT *, \"Yes\"\n        CYCLE\n    END IF\n\n    low = 1\n    high = x + 1\n    ans = 1\n\n    DO WHILE (low <= high)\n        mid = (low + high) / 2\n        IF (mid * a < n) THEN\n            low = mid + 1\n        ELSE\n            ans = mid\n            high = mid - 1\n        END IF\n    END DO\n\n    IF (n > (ans-1)*b .AND. n < ans*a) THEN\n        PRINT *, \"No\"\n    ELSE\n        PRINT *, \"Yes\"\n    END IF\n\nEND DO\n\nWait, but Fortran uses .LT. and .GT. for comparisons. Wait, no: in Fortran, the syntax is .LT., .LE., .GT., .GE., .EQ., .NE. for <, <=, >, >=, ==, != respectively. So in the code, the condition (mid * a < n) in Java would be (mid * a .LT. n) in Fortran.\n\nSo adjusting the conditions:\n\nIn the binary search loop:\n\nIF (mid * a < n) becomes IF (mid * a .LT. n).\n\nSimilarly for other conditions.\n\nAnother thing: in Fortran, when you use integer division with /, if the operands are integers, it truncates towards zero. Java's integer division also truncates towards zero. So that should be okay.\n\nNow, possible edge cases: when (b - a) is zero? But in Java code, when a == b is handled in the earlier condition. So in Fortran, when a and b are not equal, (b - a) is non-zero, so division is safe.\n\nWait, no: what if a and b are different, but b - a is negative? For example, a=5, b=3. Then (b - a) is -2. Then x = 3/(3-5) = 3 / (-2) = -1. Then x * a is -5. Then the condition n > x*a is n > -5, which would be true for any n >=0. Then, in that case, the code would print \"Yes\" immediately. But perhaps that's intended. \n\nSo in the code, when a < b, then (b -a) is positive, x is positive. But if a > b, then (b -a) is negative, so x becomes negative, which would make x * a negative, and since n is a positive integer (as per problem statement?), then n > x*a (which is negative) would be true, leading to \"Yes\". So perhaps that's correct.\n\nSo the code should handle a and b in any order, as long as they are different. So no problem.\n\nNow, in Fortran, the code should replicate this logic.\n\nTesting some sample cases.\n\nBut perhaps the code can be written as is, translating each Java line to Fortran.\n\nNow, handling the binary search loop.\n\nWait, in Fortran, the DO WHILE loop syntax is:\n\nDO WHILE (condition)\n    ...\nEND DO\n\nYes.\n\nSo the code for the binary search loop is:\n\nlow = 1\nhigh = x + 1\nans = 1\nDO WHILE (low <= high)\n    mid = (low + high) / 2\n    IF (mid * a < n) THEN\n        low = mid + 1\n    ELSE\n        ans = mid\n        high = mid - 1\n    END IF\nEND DO\n\nBut wait, in Fortran, the division of integers (low + high) / 2 may be different from Java. For example, in Java, when (low + high) is even, it's straightforward, but when it's odd, it truncates. In Fortran, since it's integer division, same as Java. So mid is computed correctly.\n\nNow, after the loop, check if n is in the range (ans-1)*b < n < ans*a. If so, output \"No\", else \"Yes\".\n\nIn Fortran, the condition would be:\n\nIF (n > (ans-1)*b .AND. n < ans*a) THEN\n\nBut since in Fortran, the logical operators are .AND., .OR., etc. So the code is correct.\n\nBut in Java, the code uses (n > (ans-1)*b && n < ans*a). So same as Fortran.\n\nNow, possible edge cases:\n\nIf ans is 1, then (ans-1)*b is 0, and if n is between 0 and a, but earlier checks may have already handled that.\n\nBut according to the code's logic, after the binary search, if this condition is true, then output \"No\", else \"Yes\".\n\nNow, compiling all these into Fortran code.\n\nAnother thing to note: in Fortran, variables need to be declared before use. So variables like t, n, a, b, x, low, high, ans, mid, i should be declared as INTEGER(8). The MOD is not used here, except in the Java code as a class variable, but in the Fortran code, the modulus operation is done using MOD(n, a).\n\nSo in Fortran, the code would start with:\n\nPROGRAM main\n    IMPLICIT NONE\n    INTEGER(8) :: t, n, a, b, x, low, high, ans, mid, i\n\n    READ(*,*) t\n    DO i = 1, t\n        READ(*,*) n, a, b\n        IF (n < a) THEN\n            PRINT *, \"No\"\n            CYCLE\n        END IF\n        IF (a == b) THEN\n            IF (MOD(n, a) == 0) THEN\n                PRINT *, \"Yes\"\n            ELSE\n                PRINT *, \"No\"\n            END IF\n            CYCLE\n        END IF\n        x = b / (b - a)\n        IF (n > x * a) THEN\n            PRINT *, \"Yes\"\n            CYCLE\n        END IF\n        low = 1\n        high = x + 1\n        ans = 1\n        DO WHILE (low <= high)\n            mid = (low + high) / 2\n            IF (mid * a < n) THEN\n                low = mid + 1\n            ELSE\n                ans = mid\n                high = mid - 1\n            END IF\n        END DO\n        IF (n > (ans - 1)*b .AND. n < ans*a) THEN\n            PRINT *, \"No\"\n        ELSE\n            PRINT *, \"Yes\"\n        END IF\n    END DO\nEND PROGRAM main\n\nWait, but in Fortran, the code requires that all variables are declared with the correct type. So in the code above, variables are declared as INTEGER(8). Also, the MOD function in Fortran returns the same as in Java when the arguments are positive, but may differ if one is negative. But in the code, since a and b are positive (as per the problem's input?), the MOD function should work correctly.\n\nAnother thing: in the binary search loop, when low and high are large, adding them could overflow. But in Java, since they are longs, 64-bit integers. In Fortran, using INTEGER(8) should handle that.\n\nTesting the code with some inputs.\n\nFor example, when t=1, n=5, a=3, b=4. Let's see.\n\nIn Java:\n\nIf a and b are 3 and 4. Since a != b.\n\nx =4/(4-3) =4/1=4. Check if 5>4*3=12? No. So proceed to binary search.\n\nlow=1, high=5.\n\nFirst iteration: low=1, high=5. mid=(1+5)/2=3. mid*a=3*3=9. 9 <5? No. So ans=3, high=2.\n\nLoop continues since low <= high (1 <=2).\n\nmid = (1+2)/2=1. mid*a=3. 3 <5 \u2192 yes. So low=2.\n\nLoop condition: 2 <=2. mid=(2+2)/2=2. mid*a=6 <5? No. So ans=2, high=1.\n\nNow loop ends. Check if 5 > (2-1)*4 \u2192 4 and <2*3=6. 5 is between 4 and6 \u2192 yes. So output No.\n\nSo the Fortran code would output \"No\" here. Which is correct?\n\nBut what's the actual logic here. The problem is a bit unclear. But according to the Java code's logic, this is correct.\n\nAnother example: n=6, a=3, b=4.\n\nAfter binary search:\n\nx=4/(1) =4. 6 is not greater than 12. So binary search.\n\nlow=1, high=5.\n\nmid=3 \u2192 3*3=9 >=6 \u2192 ans=3, high=2.\n\nlow=1, high=2 \u2192 mid=1.5 \u2192 1.5 truncated to 1. mid*a=3 <6 \u2192 low=2.\n\nmid=2 \u2192 2*3=6 >=6 \u2192 ans=2, high=1.\n\nLoop ends.\n\nCheck if 6> (2-1)*4=4 and <2*3=6 \u2192 6 is not <6. So condition is false. Output \"Yes\".\n\nWhich is correct because 6 can be written as 3*2 (since a=3, and 2*a=6).\n\nSo the code works.\n\nTherefore, the Fortran code should replicate the Java code's logic correctly."
}