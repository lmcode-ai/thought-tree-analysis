{
  "segments": [
    {
      "text": "Okay, I need to translate this Java code to Fortran.",
      "start_char": 0,
      "end_char": 52,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Let's look at the Java code first.",
      "start_char": 53,
      "end_char": 87,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The code reads two time inputs in HH:MM format, parses them into hours and minutes, then subtracts the second time from the first and prints the result.",
      "start_char": 88,
      "end_char": 240,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Java uses LocalTime to handle the time operations.",
      "start_char": 242,
      "end_char": 292,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Fortran doesn't have a built-in time type like that, so I'll have to handle the calculations manually.",
      "start_char": 293,
      "end_char": 395,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "First, let's think about input handling.",
      "start_char": 398,
      "end_char": 438,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "The Java code splits the input strings on the colon to get hours and minutes.",
      "start_char": 439,
      "end_char": 516,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "In Fortran, I can read the entire string and then split it into parts.",
      "start_char": 517,
      "end_char": 587,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Maybe using the index function to find the colon's position.",
      "start_char": 588,
      "end_char": 648,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "For example, for string s, find the colon's position, then extract the hours before and minutes after.",
      "start_char": 649,
      "end_char": 751,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "So, for each input line, split into h1, m1 and h2, m2. Then compute the total minutes of the first time and subtract the total minutes of the second time.",
      "start_char": 753,
      "end_char": 907,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Wait, the Java code is subtracting the second time (y) from the first (x). So x - y.",
      "start_char": 908,
      "end_char": 992,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "For example, if x is 10:00 and y is 2:30, then result is 7:30. But how to handle negative values?",
      "start_char": 993,
      "end_char": 1090,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Like if x is 1:00 and y is 2:00. Then x - y would be negative.",
      "start_char": 1092,
      "end_char": 1154,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Java's LocalTime probably wraps around, since times are modulo 24 hours. But in Fortran, I need to handle that manually. So steps:\n\n1.",
      "start_char": 1155,
      "end_char": 1289,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Read the two times as strings.",
      "start_char": 1291,
      "end_char": 1321,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "2. Split each into hours and minutes.",
      "start_char": 1322,
      "end_char": 1359,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "3. Convert both times into total minutes since 00:00.\n4.",
      "start_char": 1360,
      "end_char": 1416,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Subtract the second time's total minutes from the first. 5.",
      "start_char": 1417,
      "end_char": 1476,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Compute the result modulo 1440 (minutes in a day) to handle wrap-around. 6. Then convert back to hours and minutes.",
      "start_char": 1477,
      "end_char": 1592,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Wait, but in the Java code, when you subtract, for example, if x is 00:30 and y is 00:45, then x.minus would be 23:45.",
      "start_char": 1594,
      "end_char": 1712,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Because 00:30 minus 45 minutes is 23:45. So the calculation is (x's total minutes - y's total minutes) mod 1440. But if the result is negative, adding 1440 would give the correct positive equivalent. So the algorithm should be:\n\ntotal_minutes = (x_total - y_total + 1440) mod 1440 But wait, let's see.",
      "start_char": 1713,
      "end_char": 2015,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Let's take x_total as the first time's total minutes, y_total as the second's. x_total = h1*60 + m1\n\ny_total = h2*60 + m2\n\ndifference = x_total - y_total\n\nresult_total = difference mod 1440 (but mod in Fortran might behave differently with negative numbers)",
      "start_char": 2017,
      "end_char": 2275,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "In Java, if the difference is negative, mod 1440 would wrap around. For example, -45 mod 1440 would be 1395, which is 23*60 + 15 = 23:15.",
      "start_char": 2277,
      "end_char": 2414,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Wait, but Java's LocalTime handles it correctly. So to replicate that in Fortran, when we subtract, we can compute (x_total - y_total) and then add 1440 if the result is negative before taking mod 1440. Wait no.",
      "start_char": 2415,
      "end_char": 2626,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "For example, x_total is 30 minutes (00:30), y_total is 45. Difference is -15. Then adding 1440 gives 1425.",
      "start_char": 2627,
      "end_char": 2733,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "1425 mod 1440 is 1425, which is 23 hours and 45 minutes, which is correct. So the correct formula is (x_total - y_total) mod 1440. But in Fortran, the mod function with negative numbers can be tricky.",
      "start_char": 2734,
      "end_char": 2934,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "For instance, mod(-15,1440) in Fortran gives -15, which is not desired. So we need to compute it as (difference + 1440)",
      "start_char": 2936,
      "end_char": 3055,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "% 1440 to ensure it's positive. Wait, but (difference + 1440)",
      "start_char": 3056,
      "end_char": 3117,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "mod 1440 is equivalent to (difference mod 1440 + 1440 mod 1440)",
      "start_char": 3119,
      "end_char": 3182,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "mod 1440, which is same as difference mod 1440. Hmm, maybe better to compute result_total = mod(x_total - y_total, 1440). But if the result is negative, mod in Fortran returns a negative value. So for example, mod(-15,1440) is -15.",
      "start_char": 3183,
      "end_char": 3414,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "To avoid negative, we can add 1440 and then take mod again. So:\n\nresult_total = mod(x_total - y_total, 1440) if (result_total < 0) then\n    result_total = result_total + 1440\nend if\n\nBut maybe a better way is to compute:\n\nresult_total = mod(x_total - y_total + 1440, 1440)",
      "start_char": 3415,
      "end_char": 3688,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "Adding 1440 ensures that the numerator is positive, so mod gives a positive result.",
      "start_char": 3690,
      "end_char": 3773,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "Because if (x_total - y_total) is negative, adding 1440 makes it positive, then mod 1440 gives the correct value. For example, x=30, y=45: 30-45 = -15. -15 +1440=1425. 1425 mod 1440 is 1425, which is correct. If x=100 (1:40), y=50 (0:50). 100-50=50.",
      "start_char": 3774,
      "end_char": 4025,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "50 mod 1440 is 50 \u2192 00:50, correct. Another example: x=0 (00:00), y=1440 (24:00 \u2192 which is 0). 0 - 1440 = -1440. mod(-1440,1440) is 0. So result is 00:00. Correct. So using result_total = mod(x_total - y_total + 1440, 1440) would work.",
      "start_char": 4026,
      "end_char": 4263,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Once we have result_total, we can compute the hours as result_total / 60, and minutes as mod(result_total,60). But since in Fortran, integer division truncates towards zero, so for positive numbers, it's okay. For example, 1425 /60 = 23, mod 1425 60 =45. So now, the steps for the Fortran code:\n\nRead the two times as strings.",
      "start_char": 4265,
      "end_char": 4592,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "For each time, split into hours and minutes. Convert to integers. Compute x_total and y_total as h*60 + m.\n\nCompute difference = x_total - y_total. result_total = mod(difference + 1440, 1440)\n\nThen hh = result_total / 60\n\nmm = mod(result_total, 60)\n\nThen output hh and mm with leading zeros if necessary. Now, handling the input.",
      "start_char": 4595,
      "end_char": 4927,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "How to split the string on the colon.",
      "start_char": 4929,
      "end_char": 4966,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "In Fortran, the input can be read as a 5-character string (like 'HH:MM'), then split into the first two characters as hours, next two as minutes (after the colon).",
      "start_char": 4968,
      "end_char": 5131,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Wait, for example, input is '12:34' \u2192 split into 12 and 34.",
      "start_char": 5132,
      "end_char": 5191,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "So, for a string s, we can find the position of the colon, then take the substring before as hours, after as minutes.",
      "start_char": 5193,
      "end_char": 5310,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, read the string as two parts separated by colon. But in Fortran, reading with a format might work.",
      "start_char": 5312,
      "end_char": 5425,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "For example, read(s, '(I2,1X,I2)') h, m. Wait, but the colon is the separator. So perhaps using the format (I2,1X,I2) won't work.",
      "start_char": 5426,
      "end_char": 5555,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Wait, the format for 'HH:MM' would be two integers separated by a colon. So perhaps using a format like (I2,1X,I2), but the colon is not a space. Hmm.",
      "start_char": 5556,
      "end_char": 5706,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Alternatively, read the entire string and split using the colon.",
      "start_char": 5707,
      "end_char": 5771,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "In Fortran, we can use the index function to find the position of the colon. For example, for s = '12:34', index(s, ':') returns 3. Then hours are s(1:2), minutes s(4:5). So code for splitting a time string into hours and minutes:\n\ncharacter(len=5) :: time_str\ninteger :: h, m, colon_pos\n\nread(*, '(a)') time_str\ncolon_pos = index(time_str, ':')\nread(time_str(1:colon_pos-1), *) h\nread(time_str(colon_pos+1:), *) m But need to handle cases where hours or minutes are single digits.",
      "start_char": 5773,
      "end_char": 6256,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "For example, '1:05' \u2192 colon_pos is 2. So hours is 1, minutes 05 \u2192 5. But in Fortran, when reading '05' as integer, leading zeros are allowed, so it's okay. So in the code, read the two time strings, split each into h1, m1 and h2, m2. Then compute x_total = h1 *60 + m1\n\ny_total = h2 *60 + m2\n\ndifference = x_total - y_total\n\nresult_total = mod(difference + 1440, 1440)\n\nThen hh = result_total /60\n\nmm = mod(result_total,60)\n\nThen output as hh:mm, with leading zeros.",
      "start_char": 6258,
      "end_char": 6727,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "In Fortran, when writing, to format the numbers with leading zeros, use I0.2 for two digits.",
      "start_char": 6729,
      "end_char": 6821,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Wait, the format specifier for integers with leading zeros is I2.2, which pads with zeros to two digits.",
      "start_char": 6822,
      "end_char": 6926,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "For example:\n\nwrite(*, '(I2.2, \":\", I2.2)') hh, mm\n\nBut if hh is a single-digit number, like 3, then I2.2 would write '03'. So that's correct.",
      "start_char": 6927,
      "end_char": 7069,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Putting it all together:\n\nThe Fortran program will:\n\n1. Read the first time string. 2. Split into h1 and m1.",
      "start_char": 7071,
      "end_char": 7179,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "3. Read the second time string. 4. Split into h2 and m2. 5. Compute the totals. 6. Compute the result total. 7. Split into hh and mm.\n\n8.",
      "start_char": 7182,
      "end_char": 7319,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Print hh:mm with leading zeros. Now, code structure. Fortran code:\n\nprogram codeforces_387_A\nimplicit none\n\ncharacter(len=5) :: s, t\ninteger :: h1, m1, h2, m2\ninteger :: x_total, y_total, difference, result_total, hh, mm\ninteger :: colon_pos\n\n!",
      "start_char": 7324,
      "end_char": 7570,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Read input times\nread(*, '(a)') s\nread(*, '(a)') t\n\n! Parse s into h1 and m1\ncolon_pos = index(s, ':')\nread(s(1:colon_pos-1), *) h1\nread(s(colon_pos+1:), *) m1\n\n! Parse t into h2 and m2\ncolon_pos = index(t, ':')\nread(t(1:colon_pos-1), *) h2\nread(t(colon_pos+1:), *) m2\n\n! Compute totals\nx_total = h1 * 60 + m1\ny_total = h2 * 60 + m2\n\ndifference = x_total - y_total\nresult_total = mod(difference + 1440, 1440)  ! Ensure positive mod\n\nhh = result_total / 60\nmm = mod(result_total, 60)\n\n!",
      "start_char": 7571,
      "end_char": 8056,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Output with leading zeros\nwrite(*, '(I2.2, \":\", I2.2)') hh, mm\n\nend program codeforces_387_A\n\nTesting this code with sample inputs.",
      "start_char": 8057,
      "end_char": 8188,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Sample Input 1:\n\n10:00\n02:30\n\nJava code outputs 07:30. In Fortran:\n\nh1=10, m1=0 \u2192 x_total=600\n\nh2=2, m2=30 \u2192 y_total=150\n\ndifference = 600-150=450. result_total = 450 mod 1440 \u2192 450. hh=7, mm=30 \u2192 outputs 07:30. Which is correct. Sample Input 2:\n\n00:30\n00:45 Java code outputs 23:45. In Fortran:\n\nx_total=30, y_total=45. difference = -15.\n\nresult_total = (-15 +1440) mod 1440 \u2192 1425 mod 1440 \u2192 1425. hh=23, mm=45 \u2192 23:45. Correct.",
      "start_char": 8190,
      "end_char": 8628,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Another test case where the subtraction results in a negative time. Sample Input 3:\n\n01:00\n02:15\n\nJava code would subtract 2h15m from 1h00m \u2192 22h45m.\n\nFortran code:\n\nx_total = 60, y_total=135 \u2192 difference= -75. result_total = (-75 +1440) mod 1440 \u2192 1365 \u2192 1365 mod 1440 is 1365. hh=1365/60=22.75 \u2192 22, mm=1365%60=45 \u2192 22:45. Which is correct. Thus, the code should work.",
      "start_char": 8630,
      "end_char": 9003,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    }
  ],
  "original_reasoning": "Okay, I need to translate this Java code to Fortran. Let's look at the Java code first. The code reads two time inputs in HH:MM format, parses them into hours and minutes, then subtracts the second time from the first and prints the result.\n\nJava uses LocalTime to handle the time operations. Fortran doesn't have a built-in time type like that, so I'll have to handle the calculations manually. \n\nFirst, let's think about input handling. The Java code splits the input strings on the colon to get hours and minutes. In Fortran, I can read the entire string and then split it into parts. Maybe using the index function to find the colon's position. For example, for string s, find the colon's position, then extract the hours before and minutes after.\n\nSo, for each input line, split into h1, m1 and h2, m2. Then compute the total minutes of the first time and subtract the total minutes of the second time. Wait, the Java code is subtracting the second time (y) from the first (x). So x - y. For example, if x is 10:00 and y is 2:30, then result is 7:30.\n\nBut how to handle negative values? Like if x is 1:00 and y is 2:00. Then x - y would be negative. Java's LocalTime probably wraps around, since times are modulo 24 hours. But in Fortran, I need to handle that manually.\n\nSo steps:\n\n1. Read the two times as strings.\n2. Split each into hours and minutes.\n3. Convert both times into total minutes since 00:00.\n4. Subtract the second time's total minutes from the first.\n5. Compute the result modulo 1440 (minutes in a day) to handle wrap-around.\n6. Then convert back to hours and minutes.\n\nWait, but in the Java code, when you subtract, for example, if x is 00:30 and y is 00:45, then x.minus would be 23:45. Because 00:30 minus 45 minutes is 23:45. So the calculation is (x's total minutes - y's total minutes) mod 1440. But if the result is negative, adding 1440 would give the correct positive equivalent.\n\nSo the algorithm should be:\n\ntotal_minutes = (x_total - y_total + 1440) mod 1440\n\nBut wait, let's see. Let's take x_total as the first time's total minutes, y_total as the second's.\n\nx_total = h1*60 + m1\n\ny_total = h2*60 + m2\n\ndifference = x_total - y_total\n\nresult_total = difference mod 1440 (but mod in Fortran might behave differently with negative numbers)\n\nIn Java, if the difference is negative, mod 1440 would wrap around. For example, -45 mod 1440 would be 1395, which is 23*60 + 15 = 23:15. Wait, but Java's LocalTime handles it correctly. So to replicate that in Fortran, when we subtract, we can compute (x_total - y_total) and then add 1440 if the result is negative before taking mod 1440. Wait no. For example, x_total is 30 minutes (00:30), y_total is 45. Difference is -15. Then adding 1440 gives 1425. 1425 mod 1440 is 1425, which is 23 hours and 45 minutes, which is correct.\n\nSo the correct formula is (x_total - y_total) mod 1440. But in Fortran, the mod function with negative numbers can be tricky. For instance, mod(-15,1440) in Fortran gives -15, which is not desired. So we need to compute it as (difference + 1440) % 1440 to ensure it's positive.\n\nWait, but (difference + 1440) mod 1440 is equivalent to (difference mod 1440 + 1440 mod 1440) mod 1440, which is same as difference mod 1440. Hmm, maybe better to compute result_total = mod(x_total - y_total, 1440). But if the result is negative, mod in Fortran returns a negative value. So for example, mod(-15,1440) is -15. To avoid negative, we can add 1440 and then take mod again. So:\n\nresult_total = mod(x_total - y_total, 1440)\n\nif (result_total < 0) then\n    result_total = result_total + 1440\nend if\n\nBut maybe a better way is to compute:\n\nresult_total = mod(x_total - y_total + 1440, 1440)\n\nAdding 1440 ensures that the numerator is positive, so mod gives a positive result. Because if (x_total - y_total) is negative, adding 1440 makes it positive, then mod 1440 gives the correct value.\n\nFor example, x=30, y=45: 30-45 = -15. -15 +1440=1425. 1425 mod 1440 is 1425, which is correct.\n\nIf x=100 (1:40), y=50 (0:50). 100-50=50. 50 mod 1440 is 50 \u2192 00:50, correct.\n\nAnother example: x=0 (00:00), y=1440 (24:00 \u2192 which is 0). 0 - 1440 = -1440. mod(-1440,1440) is 0. So result is 00:00. Correct.\n\nSo using result_total = mod(x_total - y_total + 1440, 1440) would work.\n\nOnce we have result_total, we can compute the hours as result_total / 60, and minutes as mod(result_total,60).\n\nBut since in Fortran, integer division truncates towards zero, so for positive numbers, it's okay. For example, 1425 /60 = 23, mod 1425 60 =45.\n\nSo now, the steps for the Fortran code:\n\nRead the two times as strings.\n\nFor each time, split into hours and minutes.\n\nConvert to integers.\n\nCompute x_total and y_total as h*60 + m.\n\nCompute difference = x_total - y_total.\n\nresult_total = mod(difference + 1440, 1440)\n\nThen hh = result_total / 60\n\nmm = mod(result_total, 60)\n\nThen output hh and mm with leading zeros if necessary.\n\nNow, handling the input. How to split the string on the colon.\n\nIn Fortran, the input can be read as a 5-character string (like 'HH:MM'), then split into the first two characters as hours, next two as minutes (after the colon). Wait, for example, input is '12:34' \u2192 split into 12 and 34.\n\nSo, for a string s, we can find the position of the colon, then take the substring before as hours, after as minutes.\n\nAlternatively, read the string as two parts separated by colon. But in Fortran, reading with a format might work. For example, read(s, '(I2,1X,I2)') h, m. Wait, but the colon is the separator. So perhaps using the format (I2,1X,I2) won't work. Wait, the format for 'HH:MM' would be two integers separated by a colon. So perhaps using a format like (I2,1X,I2), but the colon is not a space. Hmm. Alternatively, read the entire string and split using the colon.\n\nIn Fortran, we can use the index function to find the position of the colon.\n\nFor example, for s = '12:34', index(s, ':') returns 3. Then hours are s(1:2), minutes s(4:5).\n\nSo code for splitting a time string into hours and minutes:\n\ncharacter(len=5) :: time_str\ninteger :: h, m, colon_pos\n\nread(*, '(a)') time_str\ncolon_pos = index(time_str, ':')\nread(time_str(1:colon_pos-1), *) h\nread(time_str(colon_pos+1:), *) m\n\nBut need to handle cases where hours or minutes are single digits. For example, '1:05' \u2192 colon_pos is 2. So hours is 1, minutes 05 \u2192 5.\n\nBut in Fortran, when reading '05' as integer, leading zeros are allowed, so it's okay.\n\nSo in the code, read the two time strings, split each into h1, m1 and h2, m2.\n\nThen compute x_total = h1 *60 + m1\n\ny_total = h2 *60 + m2\n\ndifference = x_total - y_total\n\nresult_total = mod(difference + 1440, 1440)\n\nThen hh = result_total /60\n\nmm = mod(result_total,60)\n\nThen output as hh:mm, with leading zeros.\n\nIn Fortran, when writing, to format the numbers with leading zeros, use I0.2 for two digits. Wait, the format specifier for integers with leading zeros is I2.2, which pads with zeros to two digits. For example:\n\nwrite(*, '(I2.2, \":\", I2.2)') hh, mm\n\nBut if hh is a single-digit number, like 3, then I2.2 would write '03'. So that's correct.\n\nPutting it all together:\n\nThe Fortran program will:\n\n1. Read the first time string.\n\n2. Split into h1 and m1.\n\n3. Read the second time string.\n\n4. Split into h2 and m2.\n\n5. Compute the totals.\n\n6. Compute the result total.\n\n7. Split into hh and mm.\n\n8. Print hh:mm with leading zeros.\n\nNow, code structure.\n\nFortran code:\n\nprogram codeforces_387_A\nimplicit none\n\ncharacter(len=5) :: s, t\ninteger :: h1, m1, h2, m2\ninteger :: x_total, y_total, difference, result_total, hh, mm\ninteger :: colon_pos\n\n! Read input times\nread(*, '(a)') s\nread(*, '(a)') t\n\n! Parse s into h1 and m1\ncolon_pos = index(s, ':')\nread(s(1:colon_pos-1), *) h1\nread(s(colon_pos+1:), *) m1\n\n! Parse t into h2 and m2\ncolon_pos = index(t, ':')\nread(t(1:colon_pos-1), *) h2\nread(t(colon_pos+1:), *) m2\n\n! Compute totals\nx_total = h1 * 60 + m1\ny_total = h2 * 60 + m2\n\ndifference = x_total - y_total\nresult_total = mod(difference + 1440, 1440)  ! Ensure positive mod\n\nhh = result_total / 60\nmm = mod(result_total, 60)\n\n! Output with leading zeros\nwrite(*, '(I2.2, \":\", I2.2)') hh, mm\n\nend program codeforces_387_A\n\nTesting this code with sample inputs.\n\nSample Input 1:\n\n10:00\n02:30\n\nJava code outputs 07:30.\n\nIn Fortran:\n\nh1=10, m1=0 \u2192 x_total=600\n\nh2=2, m2=30 \u2192 y_total=150\n\ndifference = 600-150=450.\n\nresult_total = 450 mod 1440 \u2192 450.\n\nhh=7, mm=30 \u2192 outputs 07:30.\n\nWhich is correct.\n\nSample Input 2:\n\n00:30\n00:45\n\nJava code outputs 23:45.\n\nIn Fortran:\n\nx_total=30, y_total=45. difference = -15.\n\nresult_total = (-15 +1440) mod 1440 \u2192 1425 mod 1440 \u2192 1425.\n\nhh=23, mm=45 \u2192 23:45. Correct.\n\nAnother test case where the subtraction results in a negative time.\n\nSample Input 3:\n\n01:00\n02:15\n\nJava code would subtract 2h15m from 1h00m \u2192 22h45m.\n\nFortran code:\n\nx_total = 60, y_total=135 \u2192 difference= -75.\n\nresult_total = (-75 +1440) mod 1440 \u2192 1365 \u2192 1365 mod 1440 is 1365.\n\nhh=1365/60=22.75 \u2192 22, mm=1365%60=45 \u2192 22:45.\n\nWhich is correct.\n\nThus, the code should work."
}