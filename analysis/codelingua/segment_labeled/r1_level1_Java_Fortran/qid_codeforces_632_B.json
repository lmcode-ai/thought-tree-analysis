{
  "segments": [
    {
      "text": "Okay, I need to translate this Java code into Fortran.",
      "start_char": 0,
      "end_char": 54,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Let me first understand what the Java code does.",
      "start_char": 55,
      "end_char": 103,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "So, the program reads an integer n, then an array a of n integers, followed by a string s of length n.",
      "start_char": 106,
      "end_char": 208,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "The initial sum is calculated by adding a[i] for each 'B' in the string.",
      "start_char": 209,
      "end_char": 281,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Then, there are two passes: one from left to right and another from right to left.",
      "start_char": 282,
      "end_char": 364,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "In each pass, they adjust the sum by adding or subtracting a[i] based on whether the character is 'A' or 'B', tracking the maximum sum encountered.",
      "start_char": 365,
      "end_char": 512,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "The final answer is the maximum of all these sums.",
      "start_char": 513,
      "end_char": 563,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "First, I need to figure out how to read inputs in Fortran.",
      "start_char": 565,
      "end_char": 623,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "The original code uses Scanner, but Fortran reads from standard input with READ statements. So for n, then the array a, then the string s.\n\nIn Fortran, the array a would be dimensioned as integer, but the Java code uses int, which is 32-bit. But in the Java code, the sum is a long, which is 64-bit.",
      "start_char": 624,
      "end_char": 923,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "However, looking at the code, a's elements are summed into sum, which is a long. So in Fortran, maybe we should use integer(kind=8) for variables that can hold large sums to prevent overflow.",
      "start_char": 924,
      "end_char": 1115,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Wait, the initial sum is the sum of a[i] where s[i] is 'B'.",
      "start_char": 1116,
      "end_char": 1175,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Then, when processing, adding and subtracting a[i]. So the sum can get quite large. So we need to use 64-bit integers for sum variables.",
      "start_char": 1176,
      "end_char": 1312,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "In Fortran, variables default to integer unless specified. So variables like sum, ans, sum1 should be declared as integer*8 or using kind parameters. Let me outline the steps:\n\n1. Read integer n.\n2.",
      "start_char": 1314,
      "end_char": 1512,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Read n integers into array a.\n3. Read string s.\n4.",
      "start_char": 1514,
      "end_char": 1564,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Compute initial sum by summing a(i) where s(i) is 'B'. 5. Initialize ans to sum. 6. Do a forward pass: iterate from i=1 to n (assuming 1-based in Fortran), adjust sum1, track max ans.\n7. Then do a backward pass: iterate from i=n down to 1, adjust sum1 again, track max ans.\n8. Print ans. But in the Java code, the indices are 0-based. So in Fortran, when reading the string, the first character is s(1), but in Java it's s.charAt(0). So when translating, the loop indices will need to adjust accordingly.",
      "start_char": 1565,
      "end_char": 2069,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Wait, in Java, the string s has length n, each character corresponds to a[i] for i from 0 to n-1. So in Fortran, the string s will be of length n, and the elements are s(1) to s(n). So when looping from i=0 to n-1 in Java, in Fortran, it's i+1.",
      "start_char": 2072,
      "end_char": 2316,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "For example, in Java, s.charAt(i) is equivalent to s(i+1) in Fortran. So, for the initial sum:\n\nIn Java:\nfor (i from 0 to n-1)\n   if s.charAt(i) == 'B', sum += a[i]\n\nIn Fortran:\nsum = 0\ndo i = 1, n\n   if (s(i:i) == 'B') sum = sum + a(i)\nend do\n\nWait, the array a in Java is 0-based. So in Fortran, the a array is 1-based. So when the Java code uses a[i], in Fortran it's a(i+1) if the loop variable i is 0-based.",
      "start_char": 2317,
      "end_char": 2730,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Wait, no: the Java code's array a is of size n, indexes 0..n-1, and the string s is length n, indexes 0..n-1. So in Fortran, the array a would be 1..n, and the string s is 1..n. So each element i in Java (0-based) corresponds to i+1 in Fortran. So, for the initial sum loop in Java:\n\nfor i from 0 to n-1:\n   if s[i] is 'B', sum += a[i]\n\nIn Fortran, this is equivalent to:\n\ndo i = 1, n\n   if (s(i:i) == 'B') then\n       sum = sum + a(i)\n   end if\nend do",
      "start_char": 2731,
      "end_char": 3184,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Yes, because in Java, i runs from 0 to n-1 (total n elements), and in Fortran, i runs from 1 to n, and s is a string of length n, each character accessed via s(i:i).",
      "start_char": 3186,
      "end_char": 3351,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Then, for the forward pass in Java:\n\nsum1 is initialized to sum. Then, for each i from 0 to n-1:\n\nif s.charAt(i) is 'A', sum1 += a[i], else subtract. In Fortran, this would be:\n\nsum1 = sum do i = 1, n\n   if (s(i:i) == 'A') then\n       sum1 = sum1 + a(i)\n   else\n       sum1 = sum1 - a(i)\n   end if\n   ans = max(ans, sum1)\nend do\n\nSimilarly for the backward pass in Java:\n\nsum1 is reset to sum. Then, loop i from n-1 down to 0:\n\nif s.charAt(i) is 'A', sum1 += a[i], else subtract. In Fortran:\n\nsum1 = sum\ndo i = n, 1, -1\n   if (s(i:i) == 'A') then\n       sum1 = sum1 + a(i)\n   else\n       sum1 = sum1 - a(i)\n   end if\n   ans = max(ans, sum1)\nend do So the structure seems manageable. Now, handling the input.",
      "start_char": 3353,
      "end_char": 4062,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "How to read the array and the string.",
      "start_char": 4065,
      "end_char": 4102,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "In Java, the array a is read as n integers.",
      "start_char": 4104,
      "end_char": 4147,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "In Fortran, we can read them as a single line, but the code uses Scanner which reads from standard input, possibly separated by whitespace.",
      "start_char": 4148,
      "end_char": 4287,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "So, in Fortran, after reading n, we read the array a as n integers.",
      "start_char": 4289,
      "end_char": 4356,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Similarly, the string s is read next. But in Fortran, when reading a string, the input is read as a single line. So if the user inputs the string as a line (without leading/trailing spaces), then the read statement would capture it. So the code would be:\n\nread(*,*) n\nallocate(a(n))",
      "start_char": 4357,
      "end_char": 4639,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "read(*,*) a\nread(*,*) s\n\nBut need to ensure that the string s is read correctly.",
      "start_char": 4641,
      "end_char": 4721,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "For example, if the input is like:\n\n3\n\n1 2 3\n\nABA\n\nThen the read(*,*) s would read 'ABA' correctly. But in Fortran, when using list-directed input (read(*,*) s), leading and trailing spaces are ignored. So if the string is supposed to have leading or trailing spaces, this might be an issue, but according to the problem statement, the string s is of length n, so assuming it's read correctly. Now, variable declarations. Variables:\n\nn is an integer. a is an integer array, allocated to size n.\n\ns is a character(len=n) string.",
      "start_char": 4722,
      "end_char": 5253,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "sum, sum1, ans are integers, but since they can be large (summing up all a[i], which could be up to 1e5 each, and n up to 1e5, sum can be up to 1e10, which fits in 64-bit integer. So in Fortran, we should use integer(kind=8) for sum, sum1, ans. So in Fortran:\n\ninteger :: n\ninteger, allocatable :: a(:)\ncharacter(len=:), allocatable :: s\ninteger(kind=8) :: sum, sum1, ans\n\nWait, but the length of s is n. So when reading s, we need to read a string of exactly n characters. So in Fortran, the variable s must be declared as a character of length n. But when using read(*,*) s, the variable's length must be sufficient.",
      "start_char": 5255,
      "end_char": 5874,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Alternatively, read it as a variable with a large enough length, then trim it. But that's risky.",
      "start_char": 5875,
      "end_char": 5971,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, read the entire line, then take the first n characters.",
      "start_char": 5973,
      "end_char": 6043,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Wait, but according to the problem statement, the input string is exactly of length",
      "start_char": 6044,
      "end_char": 6127,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "n. So perhaps read the line into a variable and check the length. But perhaps the problem ensures that the input is correct. So in code:\n\nAfter reading n, allocate a(n), read a, then read s.\n\nBut how to read s as a string of exactly n characters. In Fortran, if you read a variable declared as character(len=n) with read(*, *), then if the input line is shorter than n, it will be padded with spaces on the right.",
      "start_char": 6128,
      "end_char": 6543,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "If longer, it will take the first n characters. So perhaps:\n\nread(*, *) s would require s to be declared as a character(len=n) variable. But in Fortran, you can't declare a variable with a length that depends on a runtime value (like n) unless you use an allocatable string.",
      "start_char": 6544,
      "end_char": 6818,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "So, in Fortran, the steps would be:\n\n- Read n.\n\n- Read the array a.\n\n- Read the string s.",
      "start_char": 6821,
      "end_char": 6910,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Since s has length n, read a line and store it as a string of length n. So:\n\ncharacter(len=:), allocatable :: s\n... read(*, *) ! skip any remaining input after reading a (assuming that the next input is the string)\nread(*, '(a)') line\ns = trim(line) Wait, no. Let's think.",
      "start_char": 6911,
      "end_char": 7183,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "For example, after reading the array a with read(*,*) a, the input buffer may have a newline. Then reading the string may take the next line. So perhaps:\n\nAfter reading the array a with read(*,*), then read the string s as a line. But in Fortran, the read(*,*) will read until the end of the line. So if the array a is read with read(*,*), then the next read(*,*) s will read the next line. But for the string s, which is of length n, perhaps the user input is a single line with exactly n characters (no spaces). So in Fortran:\n\nread(*, *) n\nallocate(a(n))",
      "start_char": 7185,
      "end_char": 7742,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "read(*, *) a\nread(*, '(a)') s_temp  ! reads the entire line into s_temp\ns = s_temp(1:n)  !",
      "start_char": 7744,
      "end_char": 7834,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "takes the first n characters\n\nBut how to handle if the line is shorter than n?",
      "start_char": 7835,
      "end_char": 7913,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "According to the problem statement, the input is correct, so the string s has exactly n characters. So we can assume that. But to read the entire line, perhaps use a temporary variable of sufficient length. For example, in Fortran:\n\ncharacter(len=1000000) :: s_temp  ! assuming n is up to 1e5 or so\nread(*, '(a)') s_temp\ns = s_temp(1:n) But s needs to be declared as a deferred-length allocatable string:\n\ncharacter(len=:), allocatable :: s\n...\ns = s_temp(1:n)\n\nSo, putting it together:\n\nprogram main\n    implicit none\n    integer :: n, i\n    integer, allocatable :: a(:)\n    character(len=:), allocatable :: s\n    character(len=1000000) :: s_temp  ! buffer to read the string\n    integer(kind=8) :: sum, sum1, ans\n\n    read(*, *) n\n    allocate(a(n)) read(*, *) a\n    read(*, '(a)') s_temp\n    s = s_temp(1:n)\n\n    sum = 0 do i = 1, n\n        if (s(i:i) == 'B') then\n            sum = sum + a(i)\n        end if\n    end do\n    ans = sum\n\n    sum1 = sum\n    do i = 1, n\n        if (s(i:i) == 'A') then\n            sum1 = sum1 + a(i)\n        else\n            sum1 = sum1 - a(i)\n        end if\n        if (sum1 > ans) ans = sum1\n    end do\n\n    sum1 = sum\n    do i = n, 1, -1\n        if (s(i:i) == 'A') then\n            sum1 = sum1 + a(i)\n        else\n            sum1 = sum1 - a(i)\n        end if\n        if (sum1 > ans) ans = sum1\n    end do\n\n    print '(i0)', ans\n\nend program main\n\nWait, but in the code, the variables sum, sum1, ans need to be initialized.",
      "start_char": 7914,
      "end_char": 9382,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "Also, in Fortran, variables are not automatically initialized, so sum must start at 0.",
      "start_char": 9383,
      "end_char": 9469,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Yes, in the code above, sum is initialized to 0 before the first loop.",
      "start_char": 9471,
      "end_char": 9541,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Testing this code with sample input. Let's take the sample input where n=3, a=[1,2,3], s=ABA.",
      "start_char": 9543,
      "end_char": 9637,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Initial sum is B's: positions where s is B. s is 'ABA', so indices 1: 'A', 2: 'B', 3: 'A'. So sum is 2. Then forward pass:\n\nsum1 starts at 2.\n\ni=1: 'A' \u2192 sum1 +=1 \u2192 sum1=3. ans is max(2,3)=3.\n\ni=2: 'B' \u2192 sum1 -=2 \u2192 3-2=1. ans remains 3.\n\ni=3: 'A' \u2192 sum1 +=3 \u2192 4. ans is 4. Then backward pass:\n\nsum1 is reset to 2.\n\ni=3: 'A' \u2192 sum1 +=3 \u21925. ans is 5.\n\ni=2: 'B' \u2192 sum1 -=2 \u21923. ans remains 5.\n\ni=1: 'A' \u2192 sum1 +=1 \u21924. ans remains5. So total ans is5. Which would be the output. But according to the Java code, what's the output for this input?",
      "start_char": 9639,
      "end_char": 10179,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Java code:\n\nsum starts as 2 (since s[1] is B, a[1] is 2). Forward pass:\n\nsum1 =2. i=0 (s[0] is 'A'), sum1 becomes 2+1=3. ans is3.\n\ni=1 (s[1] is 'B'), sum1=3-2=1. ans remains3. i=2 (s[2] is 'A'), sum1=1+3=4. ans is4. Backward pass:\n\nsum1=2. i=2 (s[2] is 'A') sum1=2+3=5. ans is5.\n\ni=1 (s[1] is 'B') sum1=5-2=3. i=0 (s[0] is 'A') sum1=3+1=4. ans remains5. So output is5.",
      "start_char": 10183,
      "end_char": 10557,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "The Fortran code would output5 as well. So the code seems correct. Now, edge cases. For example, all 'B's. Then sum is sum of all a[i]. Then during passes, sum1 would decrease when 'B's are subtracted, but ans would remain as the initial sum. Another case: all 'A's. Then initial sum is 0. Then forward pass adds all a[i], ans becomes sum of all a.\n\nNow, in Fortran, the code uses integer(kind=8), which is 64-bit. So large numbers are handled. So the code should be correct.",
      "start_char": 10559,
      "end_char": 11037,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    }
  ],
  "original_reasoning": "Okay, I need to translate this Java code into Fortran. Let me first understand what the Java code does. \n\nSo, the program reads an integer n, then an array a of n integers, followed by a string s of length n. The initial sum is calculated by adding a[i] for each 'B' in the string. Then, there are two passes: one from left to right and another from right to left. In each pass, they adjust the sum by adding or subtracting a[i] based on whether the character is 'A' or 'B', tracking the maximum sum encountered. The final answer is the maximum of all these sums.\n\nFirst, I need to figure out how to read inputs in Fortran. The original code uses Scanner, but Fortran reads from standard input with READ statements. So for n, then the array a, then the string s.\n\nIn Fortran, the array a would be dimensioned as integer, but the Java code uses int, which is 32-bit. But in the Java code, the sum is a long, which is 64-bit. However, looking at the code, a's elements are summed into sum, which is a long. So in Fortran, maybe we should use integer(kind=8) for variables that can hold large sums to prevent overflow. Wait, the initial sum is the sum of a[i] where s[i] is 'B'. Then, when processing, adding and subtracting a[i]. So the sum can get quite large. So we need to use 64-bit integers for sum variables.\n\nIn Fortran, variables default to integer unless specified. So variables like sum, ans, sum1 should be declared as integer*8 or using kind parameters.\n\nLet me outline the steps:\n\n1. Read integer n.\n2. Read n integers into array a.\n3. Read string s.\n4. Compute initial sum by summing a(i) where s(i) is 'B'.\n5. Initialize ans to sum.\n6. Do a forward pass: iterate from i=1 to n (assuming 1-based in Fortran), adjust sum1, track max ans.\n7. Then do a backward pass: iterate from i=n down to 1, adjust sum1 again, track max ans.\n8. Print ans.\n\nBut in the Java code, the indices are 0-based. So in Fortran, when reading the string, the first character is s(1), but in Java it's s.charAt(0). So when translating, the loop indices will need to adjust accordingly.\n\nWait, in Java, the string s has length n, each character corresponds to a[i] for i from 0 to n-1. So in Fortran, the string s will be of length n, and the elements are s(1) to s(n). So when looping from i=0 to n-1 in Java, in Fortran, it's i+1. For example, in Java, s.charAt(i) is equivalent to s(i+1) in Fortran.\n\nSo, for the initial sum:\n\nIn Java:\nfor (i from 0 to n-1)\n   if s.charAt(i) == 'B', sum += a[i]\n\nIn Fortran:\nsum = 0\ndo i = 1, n\n   if (s(i:i) == 'B') sum = sum + a(i)\nend do\n\nWait, the array a in Java is 0-based. So in Fortran, the a array is 1-based. So when the Java code uses a[i], in Fortran it's a(i+1) if the loop variable i is 0-based. Wait, no: the Java code's array a is of size n, indexes 0..n-1, and the string s is length n, indexes 0..n-1. So in Fortran, the array a would be 1..n, and the string s is 1..n. So each element i in Java (0-based) corresponds to i+1 in Fortran.\n\nSo, for the initial sum loop in Java:\n\nfor i from 0 to n-1:\n   if s[i] is 'B', sum += a[i]\n\nIn Fortran, this is equivalent to:\n\ndo i = 1, n\n   if (s(i:i) == 'B') then\n       sum = sum + a(i)\n   end if\nend do\n\nYes, because in Java, i runs from 0 to n-1 (total n elements), and in Fortran, i runs from 1 to n, and s is a string of length n, each character accessed via s(i:i).\n\nThen, for the forward pass in Java:\n\nsum1 is initialized to sum. Then, for each i from 0 to n-1:\n\nif s.charAt(i) is 'A', sum1 += a[i], else subtract.\n\nIn Fortran, this would be:\n\nsum1 = sum\ndo i = 1, n\n   if (s(i:i) == 'A') then\n       sum1 = sum1 + a(i)\n   else\n       sum1 = sum1 - a(i)\n   end if\n   ans = max(ans, sum1)\nend do\n\nSimilarly for the backward pass in Java:\n\nsum1 is reset to sum. Then, loop i from n-1 down to 0:\n\nif s.charAt(i) is 'A', sum1 += a[i], else subtract.\n\nIn Fortran:\n\nsum1 = sum\ndo i = n, 1, -1\n   if (s(i:i) == 'A') then\n       sum1 = sum1 + a(i)\n   else\n       sum1 = sum1 - a(i)\n   end if\n   ans = max(ans, sum1)\nend do\n\nSo the structure seems manageable.\n\nNow, handling the input. How to read the array and the string.\n\nIn Java, the array a is read as n integers. In Fortran, we can read them as a single line, but the code uses Scanner which reads from standard input, possibly separated by whitespace.\n\nSo, in Fortran, after reading n, we read the array a as n integers. Similarly, the string s is read next.\n\nBut in Fortran, when reading a string, the input is read as a single line. So if the user inputs the string as a line (without leading/trailing spaces), then the read statement would capture it. So the code would be:\n\nread(*,*) n\nallocate(a(n))\nread(*,*) a\nread(*,*) s\n\nBut need to ensure that the string s is read correctly. For example, if the input is like:\n\n3\n\n1 2 3\n\nABA\n\nThen the read(*,*) s would read 'ABA' correctly.\n\nBut in Fortran, when using list-directed input (read(*,*) s), leading and trailing spaces are ignored. So if the string is supposed to have leading or trailing spaces, this might be an issue, but according to the problem statement, the string s is of length n, so assuming it's read correctly.\n\nNow, variable declarations.\n\nVariables:\n\nn is an integer.\n\na is an integer array, allocated to size n.\n\ns is a character(len=n) string.\n\nsum, sum1, ans are integers, but since they can be large (summing up all a[i], which could be up to 1e5 each, and n up to 1e5, sum can be up to 1e10, which fits in 64-bit integer. So in Fortran, we should use integer(kind=8) for sum, sum1, ans.\n\nSo in Fortran:\n\ninteger :: n\ninteger, allocatable :: a(:)\ncharacter(len=:), allocatable :: s\ninteger(kind=8) :: sum, sum1, ans\n\nWait, but the length of s is n. So when reading s, we need to read a string of exactly n characters. So in Fortran, the variable s must be declared as a character of length n. But when using read(*,*) s, the variable's length must be sufficient. Alternatively, read it as a variable with a large enough length, then trim it. But that's risky.\n\nAlternatively, read the entire line, then take the first n characters. Wait, but according to the problem statement, the input string is exactly of length n. So perhaps read the line into a variable and check the length.\n\nBut perhaps the problem ensures that the input is correct. So in code:\n\nAfter reading n, allocate a(n), read a, then read s.\n\nBut how to read s as a string of exactly n characters.\n\nIn Fortran, if you read a variable declared as character(len=n) with read(*, *), then if the input line is shorter than n, it will be padded with spaces on the right. If longer, it will take the first n characters. So perhaps:\n\nread(*, *) s would require s to be declared as a character(len=n) variable.\n\nBut in Fortran, you can't declare a variable with a length that depends on a runtime value (like n) unless you use an allocatable string.\n\nSo, in Fortran, the steps would be:\n\n- Read n.\n\n- Read the array a.\n\n- Read the string s. Since s has length n, read a line and store it as a string of length n. So:\n\ncharacter(len=:), allocatable :: s\n...\nread(*, *) ! skip any remaining input after reading a (assuming that the next input is the string)\nread(*, '(a)') line\ns = trim(line)\n\nWait, no. Let's think. For example, after reading the array a with read(*,*) a, the input buffer may have a newline. Then reading the string may take the next line. So perhaps:\n\nAfter reading the array a with read(*,*), then read the string s as a line. But in Fortran, the read(*,*) will read until the end of the line. So if the array a is read with read(*,*), then the next read(*,*) s will read the next line.\n\nBut for the string s, which is of length n, perhaps the user input is a single line with exactly n characters (no spaces). So in Fortran:\n\nread(*, *) n\nallocate(a(n))\nread(*, *) a\nread(*, '(a)') s_temp  ! reads the entire line into s_temp\ns = s_temp(1:n)  ! takes the first n characters\n\nBut how to handle if the line is shorter than n? According to the problem statement, the input is correct, so the string s has exactly n characters. So we can assume that.\n\nBut to read the entire line, perhaps use a temporary variable of sufficient length. For example, in Fortran:\n\ncharacter(len=1000000) :: s_temp  ! assuming n is up to 1e5 or so\nread(*, '(a)') s_temp\ns = s_temp(1:n)\n\nBut s needs to be declared as a deferred-length allocatable string:\n\ncharacter(len=:), allocatable :: s\n...\ns = s_temp(1:n)\n\nSo, putting it together:\n\nprogram main\n    implicit none\n    integer :: n, i\n    integer, allocatable :: a(:)\n    character(len=:), allocatable :: s\n    character(len=1000000) :: s_temp  ! buffer to read the string\n    integer(kind=8) :: sum, sum1, ans\n\n    read(*, *) n\n    allocate(a(n))\n    read(*, *) a\n    read(*, '(a)') s_temp\n    s = s_temp(1:n)\n\n    sum = 0\n    do i = 1, n\n        if (s(i:i) == 'B') then\n            sum = sum + a(i)\n        end if\n    end do\n    ans = sum\n\n    sum1 = sum\n    do i = 1, n\n        if (s(i:i) == 'A') then\n            sum1 = sum1 + a(i)\n        else\n            sum1 = sum1 - a(i)\n        end if\n        if (sum1 > ans) ans = sum1\n    end do\n\n    sum1 = sum\n    do i = n, 1, -1\n        if (s(i:i) == 'A') then\n            sum1 = sum1 + a(i)\n        else\n            sum1 = sum1 - a(i)\n        end if\n        if (sum1 > ans) ans = sum1\n    end do\n\n    print '(i0)', ans\n\nend program main\n\nWait, but in the code, the variables sum, sum1, ans need to be initialized. Also, in Fortran, variables are not automatically initialized, so sum must start at 0.\n\nYes, in the code above, sum is initialized to 0 before the first loop.\n\nTesting this code with sample input.\n\nLet's take the sample input where n=3, a=[1,2,3], s=ABA.\n\nInitial sum is B's: positions where s is B. s is 'ABA', so indices 1: 'A', 2: 'B', 3: 'A'. So sum is 2.\n\nThen forward pass:\n\nsum1 starts at 2.\n\ni=1: 'A' \u2192 sum1 +=1 \u2192 sum1=3. ans is max(2,3)=3.\n\ni=2: 'B' \u2192 sum1 -=2 \u2192 3-2=1. ans remains 3.\n\ni=3: 'A' \u2192 sum1 +=3 \u2192 4. ans is 4.\n\nThen backward pass:\n\nsum1 is reset to 2.\n\ni=3: 'A' \u2192 sum1 +=3 \u21925. ans is 5.\n\ni=2: 'B' \u2192 sum1 -=2 \u21923. ans remains 5.\n\ni=1: 'A' \u2192 sum1 +=1 \u21924. ans remains5.\n\nSo total ans is5. Which would be the output.\n\nBut according to the Java code, what's the output for this input?\n\nJava code:\n\nsum starts as 2 (since s[1] is B, a[1] is 2).\n\nForward pass:\n\nsum1 =2.\n\ni=0 (s[0] is 'A'), sum1 becomes 2+1=3. ans is3.\n\ni=1 (s[1] is 'B'), sum1=3-2=1. ans remains3.\n\ni=2 (s[2] is 'A'), sum1=1+3=4. ans is4.\n\nBackward pass:\n\nsum1=2.\n\ni=2 (s[2] is 'A') sum1=2+3=5. ans is5.\n\ni=1 (s[1] is 'B') sum1=5-2=3.\n\ni=0 (s[0] is 'A') sum1=3+1=4. ans remains5.\n\nSo output is5. The Fortran code would output5 as well.\n\nSo the code seems correct.\n\nNow, edge cases. For example, all 'B's. Then sum is sum of all a[i]. Then during passes, sum1 would decrease when 'B's are subtracted, but ans would remain as the initial sum.\n\nAnother case: all 'A's. Then initial sum is 0. Then forward pass adds all a[i], ans becomes sum of all a.\n\nNow, in Fortran, the code uses integer(kind=8), which is 64-bit. So large numbers are handled.\n\nSo the code should be correct."
}