{
  "segments": [
    {
      "text": "Okay, I need to translate this Java code into Fortran.",
      "start_char": 0,
      "end_char": 54,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Let's see what the Java code is doing.",
      "start_char": 55,
      "end_char": 93,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "First, the Java code reads an integer n from input, then reads n integers into a list.",
      "start_char": 95,
      "end_char": 181,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "It then processes this list by removing duplicates, sorting, and collecting back into a list. Then it checks if there are three consecutive numbers in the sorted list, like x, x+1, x+2.",
      "start_char": 182,
      "end_char": 367,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "If such a triplet exists, it outputs YES, else NO. So, the steps are:\n\n1. Read n.\n2. Read n integers into a list.",
      "start_char": 368,
      "end_char": 481,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "3. Remove duplicates and sort the list.",
      "start_char": 483,
      "end_char": 522,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "4. Check for three consecutive numbers.",
      "start_char": 523,
      "end_char": 562,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "In Fortran, I need to replicate these steps.",
      "start_char": 564,
      "end_char": 608,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Let's think about how to handle each part. First, reading the input. Fortran uses READ statements.",
      "start_char": 609,
      "end_char": 707,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "For the list, I can use an array. But handling duplicates and sorting might be a bit more involved.",
      "start_char": 709,
      "end_char": 808,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "In Java, after collecting the stream, the list is sorted and has unique elements. So in Fortran, I need to:\n\n- Take the array, remove duplicates, sort it, then check for consecutive triplets. But how to remove duplicates in Fortran?",
      "start_char": 810,
      "end_char": 1042,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "There's no built-in function, so I'll have to do it manually.",
      "start_char": 1044,
      "end_char": 1105,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "One approach is to first sort the array, then iterate through and keep only elements that are not the same as the previous. So maybe sort first, then create a new array with unique elements.",
      "start_char": 1106,
      "end_char": 1296,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Wait, but Java's stream.distinct() removes duplicates, then sorts.",
      "start_char": 1298,
      "end_char": 1364,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Wait, no: in the Java code, after the stream is processed with distinct(), then sorted(). So the order is: remove duplicates, then sort. Wait, no, no.",
      "start_char": 1365,
      "end_char": 1515,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Wait, the code is:\n\na.stream().distinct().sorted().collect(...). So first, the distinct() is applied to the original list, then sorted. So the process is: first get the unique elements, then sort them. So in Fortran, the steps would be:\n\n1. Read n and the array.",
      "start_char": 1516,
      "end_char": 1778,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "2. Remove duplicates from the array. 3. Sort the array. 4.",
      "start_char": 1780,
      "end_char": 1838,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Check if there exists three consecutive elements.",
      "start_char": 1839,
      "end_char": 1888,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Wait, but maybe in Fortran, after removing duplicates, we sort the array, then check for consecutive triplets. But how to remove duplicates before sorting? Hmm.",
      "start_char": 1890,
      "end_char": 2050,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, perhaps it's easier to first sort the array, then remove adjacent duplicates.",
      "start_char": 2052,
      "end_char": 2144,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Because if the array is sorted, duplicates are adjacent. That might be more efficient.",
      "start_char": 2145,
      "end_char": 2231,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Wait, in Java, the code first takes the original array, applies distinct() which removes duplicates in the order they appear, then sorts. So the order of operations is distinct followed by sorted. So the unique elements are taken in their original order, then sorted. But if we first sort the array, then remove duplicates (adjacent), then the result would be the same as applying distinct and then sorted.",
      "start_char": 2233,
      "end_char": 2639,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Because when you apply distinct first, the order is preserved, but then sorted would sort them. But if you first sort the array (including duplicates), then remove duplicates (keeping the first occurrence of each), the resulting unique array is sorted. So the order might be the same.",
      "start_char": 2640,
      "end_char": 2924,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "So, perhaps in Fortran, the steps could be:\n\n1.",
      "start_char": 2926,
      "end_char": 2973,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Sort the array (with duplicates)\n2.",
      "start_char": 2974,
      "end_char": 3009,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Remove adjacent duplicates, creating a new array of unique elements, which is sorted.",
      "start_char": 3010,
      "end_char": 3095,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Yes, because after sorting, duplicates are adjacent, so removing adjacent duplicates would give a sorted array of unique elements.",
      "start_char": 3097,
      "end_char": 3227,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "That's equivalent to the Java code's distinct followed by sorted, because the Java code's distinct would collect unique elements in the original order, then sorted would sort them. So the final array in Java is sorted unique elements, which is the same as sorting first and then removing duplicates (but in that case, duplicates are adjacent, so removing them gives the same sorted unique array as in Java). Wait, no. Let me think.",
      "start_char": 3228,
      "end_char": 3659,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Suppose the original array is [3, 2, 2, 1].",
      "start_char": 3661,
      "end_char": 3704,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "In Java, distinct would give [3,2,1], then sorted would be [1,2,3]. But if we first sort the array (with duplicates) to [1,2,2,3], then remove adjacent duplicates, we get [1,2,3]. So the end result is the same.",
      "start_char": 3705,
      "end_char": 3915,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Therefore, the approach of first sorting and then removing duplicates gives the same unique sorted array as the Java code's approach. So for the purpose of this problem, the approach can be used.",
      "start_char": 3916,
      "end_char": 4111,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "So, steps in Fortran:\n\nRead n, then read n integers into an array.",
      "start_char": 4113,
      "end_char": 4179,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Sort the array (including duplicates). Then remove duplicates by creating a new array where each element is different from the previous. Then check if in this new array there are three consecutive numbers.",
      "start_char": 4181,
      "end_char": 4386,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "So, first, handling the input.",
      "start_char": 4390,
      "end_char": 4420,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "In Fortran, to read n, then read n integers:\n\ninteger :: n\ninteger, allocatable :: a(:), unique_a(:)\nread(*,*) n\nallocate(a(n))",
      "start_char": 4422,
      "end_char": 4549,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "read(*,*) a\n\nThen, sort a. Using the Fortran intrinsic function, perhaps using a simple sort.",
      "start_char": 4550,
      "end_char": 4643,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Wait, but Fortran doesn't have a built-in sort function. Oh right. So I need to implement a sorting algorithm. Hmm.",
      "start_char": 4644,
      "end_char": 4759,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "For small n, a bubble sort would be acceptable, but perhaps for larger n, it's better to use a more efficient one. But since the problem is about code translation, perhaps the original code is for codeforces, where n can be up to, say, 1e5, but in this problem, maybe it's acceptable.",
      "start_char": 4760,
      "end_char": 5044,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Wait, the original Java code uses a list and streams, which for codeforces problems is acceptable because the time constraints are manageable. So perhaps in the Fortran code, using a quick sort is better.",
      "start_char": 5045,
      "end_char": 5249,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, use the Fortran 90's intrinsic sort, but Fortran doesn't have a built-in sort function.",
      "start_char": 5251,
      "end_char": 5353,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "So, perhaps the code can use a simple bubble sort, or implement a quick sort.",
      "start_char": 5354,
      "end_char": 5431,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, use the `SORT` function from the Fortran standard library?",
      "start_char": 5433,
      "end_char": 5506,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Wait, no, Fortran doesn't have that.",
      "start_char": 5507,
      "end_char": 5543,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "So, I need to implement a sort.",
      "start_char": 5544,
      "end_char": 5575,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, perhaps use the `SORT` intrinsic from some compilers, but that's not standard. So perhaps the answer should implement a sort. But maybe the original array is small, so a bubble sort is okay.",
      "start_char": 5577,
      "end_char": 5782,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "So, for the code, I'll need to sort the array. Let me proceed.",
      "start_char": 5785,
      "end_char": 5847,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "So, after reading the array, sort it. Then, remove duplicates. Let's implement that. First, sorted array.",
      "start_char": 5850,
      "end_char": 5955,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Then, iterate through it, and collect elements that are different from the previous.",
      "start_char": 5958,
      "end_char": 6042,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Initialize a list (array) unique_a. The first element is a(1). Then for each element from 2 to n, if a(i) is different from a(i-1), add to unique_a. But in Fortran, arrays are not dynamically sized, so perhaps the easiest way is to first count the number of unique elements, then create the array.",
      "start_char": 6044,
      "end_char": 6341,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, create a temporary array of the same size as a, and then copy the unique elements into it, then trim it.",
      "start_char": 6344,
      "end_char": 6463,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "So, code steps:\n\nSort the array.",
      "start_char": 6465,
      "end_char": 6497,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Compute the number of unique elements. Then create the unique_a array of that size. Let's see. After sorting, a is sorted. count_unique = 1\ndo i = 2, n\n    if (a(i) /= a(i-1)) then\n        count_unique = count_unique + 1\n    end if\nend do\n\nThen allocate unique_a with count_unique elements. Then fill it:\n\nj = 1\nunique_a(1) = a(1) do i = 2, n\n    if (a(i) /= a(i-1)) then\n        j = j + 1\n        unique_a(j) = a(i)\n    end if\nend do\n\nBut wait, if the original array is empty? But n is given as input, and in the Java code, n is read as an integer. So n >=0, but according to the problem, probably n >=1. But code can handle n=0. But in the Java code, after the initial reading, if n=0, then a is empty.",
      "start_char": 6499,
      "end_char": 7209,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Then, the loop to check for consecutive elements is skipped, and found remains false, so output is NO.",
      "start_char": 7210,
      "end_char": 7312,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "So, in Fortran, need to handle the case when n is 0. But the problem says that the code is reading n, then n integers. So n can be 0? But according to the problem statement, perhaps n is at least 1. But in code, perhaps the input n is correct.",
      "start_char": 7314,
      "end_char": 7557,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "So, after sorting, the unique array is built as above.",
      "start_char": 7559,
      "end_char": 7613,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Once the unique array is built, check if there are three consecutive elements where each is one more than the previous. In the Java code, the loop runs from i=0 to i < a.size().",
      "start_char": 7615,
      "end_char": 7793,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "For each i, check if i+1 and i+2 are within bounds. If a[i] +1 == a[i+1] and a[i+1] +1 == a[i+2], then found is true. So in Fortran, after building unique_a, which is sorted, we need to check if there exists any index i such that unique_a(i+1) = unique_a(i) +1 and unique_a(i+2) = unique_a(i+1) +1. But Fortran arrays are 1-based by default, so for i from 1 to m-2, where m is the size of unique_a.",
      "start_char": 7794,
      "end_char": 8193,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "So, loop over i from 1 to m-2.",
      "start_char": 8196,
      "end_char": 8226,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "If m <3, then it's impossible, so output NO.\n\nElse, check for any i in 1..m-2, whether unique_a(i+1) - unique_a(i) ==1 and unique_a(i+2) - unique_a(i+1) ==1.",
      "start_char": 8228,
      "end_char": 8385,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "If any such triplet exists, output YES, else NO. So putting this all together.",
      "start_char": 8387,
      "end_char": 8465,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Now, the steps:\n\nRead n.\n\nRead a array (n elements). Sort a (with duplicates).",
      "start_char": 8468,
      "end_char": 8546,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Remove duplicates to get unique_a.",
      "start_char": 8549,
      "end_char": 8583,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Check if any triplet in unique_a is consecutive.",
      "start_char": 8585,
      "end_char": 8633,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Now, the main challenges are:\n\n1. Implementing the sort.\n\n2. Removing duplicates.",
      "start_char": 8635,
      "end_char": 8716,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "So, for the sort, perhaps the easiest way is to use a simple algorithm.",
      "start_char": 8718,
      "end_char": 8789,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Since in Fortran, there's no built-in sort, but code submission is for programming contests, perhaps the code uses a bubble sort.",
      "start_char": 8790,
      "end_char": 8919,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "However, for larger n, that's inefficient. But given that the problem is from codeforces, the test cases may have n up to 1e5, but perhaps for this problem, n is small.",
      "start_char": 8920,
      "end_char": 9088,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "Alternatively, perhaps the problem's code uses the Java code, which uses the default sort (probably efficient). So in Fortran, implementing a quick sort is better. But writing a quick sort in Fortran can be a bit tedious.",
      "start_char": 9089,
      "end_char": 9310,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, use a built-in function.",
      "start_char": 9313,
      "end_char": 9352,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Wait, some Fortran compilers have a sort function, but it's not standard. So for code submission, the code must be standard.",
      "start_char": 9353,
      "end_char": 9477,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "So, perhaps implement a simple quick sort.",
      "start_char": 9479,
      "end_char": 9521,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, use the intrinsic function `sort` from the `iso_varying_string` module, but I don't think that's standard.",
      "start_char": 9523,
      "end_char": 9644,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "So, perhaps, implement a quick sort.",
      "start_char": 9646,
      "end_char": 9682,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Let me look up a quick sort implementation in Fortran.",
      "start_char": 9684,
      "end_char": 9738,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Alternatively, use a simple implementation. Here's an example of a quick sort in Fortran for an integer array:\n\nrecursive subroutine quicksort(a, first, last)\n  implicit none\n  integer, intent(inout) :: a(:)\n  integer, intent(in) :: first, last\n  integer :: pivot, i, j, temp\n\n  if (first < last) then\n    pivot = a((first + last)/2) i = first\n    j = last\n    do\n      do while (a(i) < pivot) i = i + 1\n      end do\n      do while (a(j) > pivot)\n        j = j - 1\n      end do\n      if (i >= j) exit\n      temp = a(i)\n      a(i) = a(j)\n      a(j) = temp i = i + 1\n      j = j - 1\n    end do\n    call quicksort(a, first, j)\n    call quicksort(a, j+1, last)\n  end if\nend subroutine quicksort\n\nBut in Fortran, recursive subroutines may have some issues with some compilers, but generally, it's acceptable.",
      "start_char": 9740,
      "end_char": 10562,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Alternatively, use a different sorting method. But for the purposes of code translation, perhaps the user expects a code that works, even if it's not the most efficient.",
      "start_char": 10564,
      "end_char": 10733,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, since the array is small, perhaps use a bubble sort. But given that the problem is codeforces, perhaps the code needs to handle larger n. So quick sort is better.",
      "start_char": 10736,
      "end_char": 10913,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "So, code steps:\n\nImplement a quick sort for the array. Then, proceed. Putting all together.",
      "start_char": 10916,
      "end_char": 11007,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "So, the code outline:\n\nprogram main\n  implicit none\n  integer :: n, i, count_unique, j\n  integer, allocatable :: a(:), unique_a(:)\n  logical :: found\n\n  read(*,*) n\n  allocate(a(n)) read(*,*) a\n\n  !",
      "start_char": 11011,
      "end_char": 11209,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Sort the array\n  call quicksort(a, 1, n)\n\n  ! Remove duplicates\n  if (n == 0) then\n    count_unique = 0\n  else\n    count_unique = 1 do i = 2, n\n      if (a(i) /= a(i-1)) then\n        count_unique = count_unique + 1\n      end if\n    end do\n  end if\n\n  allocate(unique_a(count_unique)) if (count_unique >= 1) then\n    unique_a(1) = a(1)\n    j = 1\n    do i = 2, n\n      if (a(i) /= a(i-1)) then\n        j = j + 1\n        unique_a(j) = a(i)\n      end if\n    end do\n  end if\n\n  ! Check for three consecutive numbers\n  found = .false. do i = 1, count_unique - 2\n    if (unique_a(i+1) == unique_a(i) + 1 .and. unique_a(i+2) == unique_a(i+1) + 1) then\n      found = .true. exit\n    end if\n  end do\n\n  if (found) then\n    write(*,*) \"YES\"\n  else\n    write(*,*) \"NO\"\n  end if\n\n  deallocate(a)\n  deallocate(unique_a)\n\ncontains\n\n  recursive subroutine quicksort(a, first, last)\n    implicit none\n    integer, intent(inout) :: a(:)\n    integer, intent(in) :: first, last\n    integer :: pivot, i, j, temp\n\n    if (first < last) then\n      pivot = a((first + last)/2) i = first\n      j = last\n      do\n        do while (a(i) < pivot) i = i + 1\n        end do\n        do while (a(j) > pivot)\n          j = j - 1\n        end do\n        if (i >= j) exit\n        temp = a(i)\n        a(i) = a(j)\n        a(j) = temp i = i + 1\n        j = j - 1\n      end do\n      call quicksort(a, first, j)\n      call quicksort(a, j+1, last)\n    end if\n  end subroutine quicksort\n\nend program main\n\nWait, but in Fortran, arrays are usually 1-based, but the code here uses first and last indices. So for the initial call, after reading the array, the indices are from 1 to n.\n\nYes. But what if the array has zero elements?",
      "start_char": 11212,
      "end_char": 12935,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "The code checks if n is zero before allocating a, but in the read statement, when n is zero, allocating a(0) is allowed in Fortran, but reading into it may be a problem.",
      "start_char": 12937,
      "end_char": 13106,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Wait, the code first reads n, then allocates a(n).",
      "start_char": 13108,
      "end_char": 13158,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "If n is zero, then a is a zero-length array. Then trying to read into it may cause issues.",
      "start_char": 13159,
      "end_char": 13249,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "For example, in Fortran, when you read(*,*) a, if a is zero-length, the program will wait for input, which is not correct.",
      "start_char": 13250,
      "end_char": 13372,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "So, in the original Java code, the code reads n, then reads n integers. So if n is zero, the loop for reading the array runs zero times, and the array is empty.",
      "start_char": 13374,
      "end_char": 13534,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "In Fortran, if n is zero, then the array is size zero. But when reading into a zero-sized array, the read statement may not require input, which depends on the compiler. But according to the problem statement, the input is correct. So perhaps we can assume that when n is zero, the code is not called. But according to the original code, n is read from input, which could be zero, but in that case, the code would proceed. But in the Java code, if n is zero, the a list is empty, then a.stream().distinct().sorted() is empty. Then the loop checking for triplets is not entered, so found is false. Output is NO.",
      "start_char": 13535,
      "end_char": 14145,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "In Fortran code, when n is zero, the code allocates a(0) and unique_a(0). Then the check for triplets (count_unique is zero) would skip the loop, found remains false, output is NO. Which is correct. But when reading a(0), how does the read statement work?",
      "start_char": 14148,
      "end_char": 14403,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "For example, in the code:\n\nread(*,*) a",
      "start_char": 14405,
      "end_char": 14443,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "If a is a zero-length array, then the read statement will read zero elements. So when the input line is for the array, even if n is zero, it's expected that there's nothing to read. But if the input has more elements, that's a problem. But the problem's test cases would provide correct input. So in the Fortran code, when n is zero, the code should read the array (zero elements), which would skip over the input line.",
      "start_char": 14445,
      "end_char": 14864,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Wait, but in practice, in Fortran, if you have a read(*,*) a where a is a zero-length array, the program will skip to the next line. But if the input has n=0 followed by some numbers, that's a problem. But according to the problem's input format, when n=0, there are no numbers. So the code is correct. But perhaps in the code, when n is zero, the code should not read the array. So in the code:\n\nread(*,*) n\nif (n > 0) then\n  allocate(a(n))",
      "start_char": 14866,
      "end_char": 15307,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "read(*,*) a\nelse\n  allocate(a(0))",
      "start_char": 15311,
      "end_char": 15344,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "end if\n\nBut in the original Java code, even if n is zero, it reads n integers. So perhaps the input for n=0 has zero integers, which the Java code would read correctly, but the Fortran code would read a zero-length array. So perhaps the code is okay. So, the code as written should handle n=0.",
      "start_char": 15345,
      "end_char": 15639,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Another possible issue: when count_unique is less than 3, the loop for checking triplets is not entered, so found is .false., which is correct. So, putting it all together.",
      "start_char": 15641,
      "end_char": 15813,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Now, testing with some sample inputs.",
      "start_char": 15816,
      "end_char": 15853,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Sample Input 1:\n\n5\n3 1 2 4 5\n\nJava code:",
      "start_char": 15855,
      "end_char": 15895,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "After distinct and sorted: [1,2,3,4,5]. Check for triplets.",
      "start_char": 15897,
      "end_char": 15956,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "There are 1,2,3 which are consecutive. So output YES.",
      "start_char": 15957,
      "end_char": 16010,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Fortran code:\n\nAfter sorting a becomes [1,2,3,4,5]. unique_a is same. Check 1,2,3: yes.",
      "start_char": 16012,
      "end_char": 16099,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Sample Input 2:\n\n4\n4 1 3 2\n\nAfter distinct and sorted: [1,2,3,4]. Check for 1,2,3 or 2,3,4.",
      "start_char": 16101,
      "end_char": 16192,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Both are consecutive triplets. So output YES.",
      "start_char": 16193,
      "end_char": 16238,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "Sample Input 3:\n\n3\n1 1 1\n\nAfter distinct and sorted: [1]. Size is 1. So output NO.",
      "start_char": 16240,
      "end_char": 16322,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Sample Input 4:\n\n6\n3 1 4 1 5 3\n\nOriginal array: [3,1,4,1,5,3].",
      "start_char": 16324,
      "end_char": 16386,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Distinct gives [3,1,4,5], sorted becomes [1,3,4,5].",
      "start_char": 16387,
      "end_char": 16438,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Check for consecutive triplets.",
      "start_char": 16439,
      "end_char": 16470,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "3,4,5: no, since they are 3,4,5, which is consecutive.",
      "start_char": 16471,
      "end_char": 16525,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Wait, 1,3,4,5: there are no three consecutive numbers. So the output is NO. Wait, wait:",
      "start_char": 16526,
      "end_char": 16613,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Wait, after distinct and sorted, the array is [1,3,4,5]. Then the triplet check is for three consecutive numbers.",
      "start_char": 16616,
      "end_char": 16729,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "3,4,5 is consecutive (each step increases by 1). So output should be YES. Wait, 3,4,5 are consecutive. So the code would detect this. So the code would return YES. But according to the code's logic, the loop runs from i=1 to count_unique-2. For count_unique=4, i runs from 1 to 2.\n\ni=1: check elements 1,2,3: 1,3,4 \u2192 differences are 2 and 1 \u2192 no.\n\ni=2: check elements 2,3,4: 3,4,5 \u2192 differences are 1 and 1 \u2192 yes. So found is true. So output is YES. So the code would output YES. But in the original code, the array after distinct and sorted would be [1,3,4,5], and the code checks each triplet. So it would find 3,4,5 and output YES. So the Fortran code is correct. So the code seems to handle the cases. Another possible test case:\n\nn=5\n\nInput: 5 3 4 5 6\n\nSorted and unique: 3,4,5,6. Check 3,4,5 \u2192 yes. So output YES. So the code would output YES. Another test case:\n\nn=3\n\nInput: 1 3 5 \u2192 sorted and unique \u2192 1,3,5 \u2192 no triplet. Output NO. So the code works. So the code is correct. Now, check for edge cases. Edge case 1: n=0 \u2192 output NO. Edge case 2: n=3, elements 1,2,3 \u2192 output YES. Edge case 3: n=3, elements 1,1,2 \u2192 after processing, array is [1,2]. Size 2 \u2192 output NO. So the code should handle all these.",
      "start_char": 16730,
      "end_char": 17958,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Thus, the Fortran code seems correct.",
      "start_char": 17961,
      "end_char": 17998,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    }
  ],
  "original_reasoning": "Okay, I need to translate this Java code into Fortran. Let's see what the Java code is doing.\n\nFirst, the Java code reads an integer n from input, then reads n integers into a list. It then processes this list by removing duplicates, sorting, and collecting back into a list. Then it checks if there are three consecutive numbers in the sorted list, like x, x+1, x+2. If such a triplet exists, it outputs YES, else NO.\n\nSo, the steps are:\n\n1. Read n.\n2. Read n integers into a list.\n3. Remove duplicates and sort the list.\n4. Check for three consecutive numbers.\n\nIn Fortran, I need to replicate these steps. Let's think about how to handle each part.\n\nFirst, reading the input. Fortran uses READ statements. For the list, I can use an array. But handling duplicates and sorting might be a bit more involved.\n\nIn Java, after collecting the stream, the list is sorted and has unique elements. So in Fortran, I need to:\n\n- Take the array, remove duplicates, sort it, then check for consecutive triplets.\n\nBut how to remove duplicates in Fortran? There's no built-in function, so I'll have to do it manually. One approach is to first sort the array, then iterate through and keep only elements that are not the same as the previous. So maybe sort first, then create a new array with unique elements.\n\nWait, but Java's stream.distinct() removes duplicates, then sorts. Wait, no: in the Java code, after the stream is processed with distinct(), then sorted(). So the order is: remove duplicates, then sort. Wait, no, no. Wait, the code is:\n\na.stream().distinct().sorted().collect(...). So first, the distinct() is applied to the original list, then sorted. So the process is: first get the unique elements, then sort them.\n\nSo in Fortran, the steps would be:\n\n1. Read n and the array.\n2. Remove duplicates from the array.\n3. Sort the array.\n4. Check if there exists three consecutive elements.\n\nWait, but maybe in Fortran, after removing duplicates, we sort the array, then check for consecutive triplets.\n\nBut how to remove duplicates before sorting? Hmm. Alternatively, perhaps it's easier to first sort the array, then remove adjacent duplicates. Because if the array is sorted, duplicates are adjacent. That might be more efficient.\n\nWait, in Java, the code first takes the original array, applies distinct() which removes duplicates in the order they appear, then sorts. So the order of operations is distinct followed by sorted. So the unique elements are taken in their original order, then sorted. But if we first sort the array, then remove duplicates (adjacent), then the result would be the same as applying distinct and then sorted. Because when you apply distinct first, the order is preserved, but then sorted would sort them. But if you first sort the array (including duplicates), then remove duplicates (keeping the first occurrence of each), the resulting unique array is sorted. So the order might be the same.\n\nSo, perhaps in Fortran, the steps could be:\n\n1. Sort the array (with duplicates)\n2. Remove adjacent duplicates, creating a new array of unique elements, which is sorted.\n\nYes, because after sorting, duplicates are adjacent, so removing adjacent duplicates would give a sorted array of unique elements. That's equivalent to the Java code's distinct followed by sorted, because the Java code's distinct would collect unique elements in the original order, then sorted would sort them. So the final array in Java is sorted unique elements, which is the same as sorting first and then removing duplicates (but in that case, duplicates are adjacent, so removing them gives the same sorted unique array as in Java). Wait, no. Let me think.\n\nSuppose the original array is [3, 2, 2, 1]. In Java, distinct would give [3,2,1], then sorted would be [1,2,3]. But if we first sort the array (with duplicates) to [1,2,2,3], then remove adjacent duplicates, we get [1,2,3]. So the end result is the same. Therefore, the approach of first sorting and then removing duplicates gives the same unique sorted array as the Java code's approach. So for the purpose of this problem, the approach can be used.\n\nSo, steps in Fortran:\n\nRead n, then read n integers into an array.\n\nSort the array (including duplicates).\n\nThen remove duplicates by creating a new array where each element is different from the previous.\n\nThen check if in this new array there are three consecutive numbers.\n\nSo, first, handling the input.\n\nIn Fortran, to read n, then read n integers:\n\ninteger :: n\ninteger, allocatable :: a(:), unique_a(:)\nread(*,*) n\nallocate(a(n))\nread(*,*) a\n\nThen, sort a. Using the Fortran intrinsic function, perhaps using a simple sort. Wait, but Fortran doesn't have a built-in sort function. Oh right. So I need to implement a sorting algorithm. Hmm. For small n, a bubble sort would be acceptable, but perhaps for larger n, it's better to use a more efficient one. But since the problem is about code translation, perhaps the original code is for codeforces, where n can be up to, say, 1e5, but in this problem, maybe it's acceptable. Wait, the original Java code uses a list and streams, which for codeforces problems is acceptable because the time constraints are manageable. So perhaps in the Fortran code, using a quick sort is better.\n\nAlternatively, use the Fortran 90's intrinsic sort, but Fortran doesn't have a built-in sort function. So, perhaps the code can use a simple bubble sort, or implement a quick sort.\n\nAlternatively, use the `SORT` function from the Fortran standard library? Wait, no, Fortran doesn't have that. So, I need to implement a sort.\n\nAlternatively, perhaps use the `SORT` intrinsic from some compilers, but that's not standard. So perhaps the answer should implement a sort.\n\nBut maybe the original array is small, so a bubble sort is okay.\n\nSo, for the code, I'll need to sort the array.\n\nLet me proceed.\n\nSo, after reading the array, sort it.\n\nThen, remove duplicates. Let's implement that.\n\nFirst, sorted array. Then, iterate through it, and collect elements that are different from the previous.\n\nInitialize a list (array) unique_a. The first element is a(1). Then for each element from 2 to n, if a(i) is different from a(i-1), add to unique_a.\n\nBut in Fortran, arrays are not dynamically sized, so perhaps the easiest way is to first count the number of unique elements, then create the array.\n\nAlternatively, create a temporary array of the same size as a, and then copy the unique elements into it, then trim it.\n\nSo, code steps:\n\nSort the array.\n\nCompute the number of unique elements.\n\nThen create the unique_a array of that size.\n\nLet's see.\n\nAfter sorting, a is sorted.\n\ncount_unique = 1\ndo i = 2, n\n    if (a(i) /= a(i-1)) then\n        count_unique = count_unique + 1\n    end if\nend do\n\nThen allocate unique_a with count_unique elements.\n\nThen fill it:\n\nj = 1\nunique_a(1) = a(1)\ndo i = 2, n\n    if (a(i) /= a(i-1)) then\n        j = j + 1\n        unique_a(j) = a(i)\n    end if\nend do\n\nBut wait, if the original array is empty? But n is given as input, and in the Java code, n is read as an integer. So n >=0, but according to the problem, probably n >=1. But code can handle n=0.\n\nBut in the Java code, after the initial reading, if n=0, then a is empty. Then, the loop to check for consecutive elements is skipped, and found remains false, so output is NO.\n\nSo, in Fortran, need to handle the case when n is 0. But the problem says that the code is reading n, then n integers. So n can be 0? But according to the problem statement, perhaps n is at least 1. But in code, perhaps the input n is correct.\n\nSo, after sorting, the unique array is built as above.\n\nOnce the unique array is built, check if there are three consecutive elements where each is one more than the previous.\n\nIn the Java code, the loop runs from i=0 to i < a.size(). For each i, check if i+1 and i+2 are within bounds. If a[i] +1 == a[i+1] and a[i+1] +1 == a[i+2], then found is true.\n\nSo in Fortran, after building unique_a, which is sorted, we need to check if there exists any index i such that unique_a(i+1) = unique_a(i) +1 and unique_a(i+2) = unique_a(i+1) +1.\n\nBut Fortran arrays are 1-based by default, so for i from 1 to m-2, where m is the size of unique_a.\n\nSo, loop over i from 1 to m-2.\n\nIf m <3, then it's impossible, so output NO.\n\nElse, check for any i in 1..m-2, whether unique_a(i+1) - unique_a(i) ==1 and unique_a(i+2) - unique_a(i+1) ==1.\n\nIf any such triplet exists, output YES, else NO.\n\nSo putting this all together.\n\nNow, the steps:\n\nRead n.\n\nRead a array (n elements).\n\nSort a (with duplicates).\n\nRemove duplicates to get unique_a.\n\nCheck if any triplet in unique_a is consecutive.\n\nNow, the main challenges are:\n\n1. Implementing the sort.\n\n2. Removing duplicates.\n\nSo, for the sort, perhaps the easiest way is to use a simple algorithm. Since in Fortran, there's no built-in sort, but code submission is for programming contests, perhaps the code uses a bubble sort. However, for larger n, that's inefficient. But given that the problem is from codeforces, the test cases may have n up to 1e5, but perhaps for this problem, n is small. Alternatively, perhaps the problem's code uses the Java code, which uses the default sort (probably efficient). So in Fortran, implementing a quick sort is better.\n\nBut writing a quick sort in Fortran can be a bit tedious.\n\nAlternatively, use a built-in function. Wait, some Fortran compilers have a sort function, but it's not standard. So for code submission, the code must be standard.\n\nSo, perhaps implement a simple quick sort.\n\nAlternatively, use the intrinsic function `sort` from the `iso_varying_string` module, but I don't think that's standard.\n\nSo, perhaps, implement a quick sort.\n\nLet me look up a quick sort implementation in Fortran.\n\nAlternatively, use a simple implementation.\n\nHere's an example of a quick sort in Fortran for an integer array:\n\nrecursive subroutine quicksort(a, first, last)\n  implicit none\n  integer, intent(inout) :: a(:)\n  integer, intent(in) :: first, last\n  integer :: pivot, i, j, temp\n\n  if (first < last) then\n    pivot = a((first + last)/2)\n    i = first\n    j = last\n    do\n      do while (a(i) < pivot)\n        i = i + 1\n      end do\n      do while (a(j) > pivot)\n        j = j - 1\n      end do\n      if (i >= j) exit\n      temp = a(i)\n      a(i) = a(j)\n      a(j) = temp\n      i = i + 1\n      j = j - 1\n    end do\n    call quicksort(a, first, j)\n    call quicksort(a, j+1, last)\n  end if\nend subroutine quicksort\n\nBut in Fortran, recursive subroutines may have some issues with some compilers, but generally, it's acceptable.\n\nAlternatively, use a different sorting method.\n\nBut for the purposes of code translation, perhaps the user expects a code that works, even if it's not the most efficient.\n\nAlternatively, since the array is small, perhaps use a bubble sort.\n\nBut given that the problem is codeforces, perhaps the code needs to handle larger n. So quick sort is better.\n\nSo, code steps:\n\nImplement a quick sort for the array.\n\nThen, proceed.\n\nPutting all together.\n\nSo, the code outline:\n\nprogram main\n  implicit none\n  integer :: n, i, count_unique, j\n  integer, allocatable :: a(:), unique_a(:)\n  logical :: found\n\n  read(*,*) n\n  allocate(a(n))\n  read(*,*) a\n\n  ! Sort the array\n  call quicksort(a, 1, n)\n\n  ! Remove duplicates\n  if (n == 0) then\n    count_unique = 0\n  else\n    count_unique = 1\n    do i = 2, n\n      if (a(i) /= a(i-1)) then\n        count_unique = count_unique + 1\n      end if\n    end do\n  end if\n\n  allocate(unique_a(count_unique))\n  if (count_unique >= 1) then\n    unique_a(1) = a(1)\n    j = 1\n    do i = 2, n\n      if (a(i) /= a(i-1)) then\n        j = j + 1\n        unique_a(j) = a(i)\n      end if\n    end do\n  end if\n\n  ! Check for three consecutive numbers\n  found = .false.\n  do i = 1, count_unique - 2\n    if (unique_a(i+1) == unique_a(i) + 1 .and. unique_a(i+2) == unique_a(i+1) + 1) then\n      found = .true.\n      exit\n    end if\n  end do\n\n  if (found) then\n    write(*,*) \"YES\"\n  else\n    write(*,*) \"NO\"\n  end if\n\n  deallocate(a)\n  deallocate(unique_a)\n\ncontains\n\n  recursive subroutine quicksort(a, first, last)\n    implicit none\n    integer, intent(inout) :: a(:)\n    integer, intent(in) :: first, last\n    integer :: pivot, i, j, temp\n\n    if (first < last) then\n      pivot = a((first + last)/2)\n      i = first\n      j = last\n      do\n        do while (a(i) < pivot)\n          i = i + 1\n        end do\n        do while (a(j) > pivot)\n          j = j - 1\n        end do\n        if (i >= j) exit\n        temp = a(i)\n        a(i) = a(j)\n        a(j) = temp\n        i = i + 1\n        j = j - 1\n      end do\n      call quicksort(a, first, j)\n      call quicksort(a, j+1, last)\n    end if\n  end subroutine quicksort\n\nend program main\n\nWait, but in Fortran, arrays are usually 1-based, but the code here uses first and last indices. So for the initial call, after reading the array, the indices are from 1 to n.\n\nYes.\n\nBut what if the array has zero elements? The code checks if n is zero before allocating a, but in the read statement, when n is zero, allocating a(0) is allowed in Fortran, but reading into it may be a problem.\n\nWait, the code first reads n, then allocates a(n). If n is zero, then a is a zero-length array. Then trying to read into it may cause issues. For example, in Fortran, when you read(*,*) a, if a is zero-length, the program will wait for input, which is not correct.\n\nSo, in the original Java code, the code reads n, then reads n integers. So if n is zero, the loop for reading the array runs zero times, and the array is empty. In Fortran, if n is zero, then the array is size zero. But when reading into a zero-sized array, the read statement may not require input, which depends on the compiler. But according to the problem statement, the input is correct. So perhaps we can assume that when n is zero, the code is not called. But according to the original code, n is read from input, which could be zero, but in that case, the code would proceed.\n\nBut in the Java code, if n is zero, the a list is empty, then a.stream().distinct().sorted() is empty. Then the loop checking for triplets is not entered, so found is false. Output is NO.\n\nIn Fortran code, when n is zero, the code allocates a(0) and unique_a(0). Then the check for triplets (count_unique is zero) would skip the loop, found remains false, output is NO. Which is correct.\n\nBut when reading a(0), how does the read statement work? For example, in the code:\n\nread(*,*) a\n\nIf a is a zero-length array, then the read statement will read zero elements. So when the input line is for the array, even if n is zero, it's expected that there's nothing to read. But if the input has more elements, that's a problem. But the problem's test cases would provide correct input.\n\nSo in the Fortran code, when n is zero, the code should read the array (zero elements), which would skip over the input line. Wait, but in practice, in Fortran, if you have a read(*,*) a where a is a zero-length array, the program will skip to the next line. But if the input has n=0 followed by some numbers, that's a problem. But according to the problem's input format, when n=0, there are no numbers. So the code is correct.\n\nBut perhaps in the code, when n is zero, the code should not read the array. So in the code:\n\nread(*,*) n\nif (n > 0) then\n  allocate(a(n))\n  read(*,*) a\nelse\n  allocate(a(0))\nend if\n\nBut in the original Java code, even if n is zero, it reads n integers. So perhaps the input for n=0 has zero integers, which the Java code would read correctly, but the Fortran code would read a zero-length array. So perhaps the code is okay.\n\nSo, the code as written should handle n=0.\n\nAnother possible issue: when count_unique is less than 3, the loop for checking triplets is not entered, so found is .false., which is correct.\n\nSo, putting it all together.\n\nNow, testing with some sample inputs.\n\nSample Input 1:\n\n5\n3 1 2 4 5\n\nJava code:\n\nAfter distinct and sorted: [1,2,3,4,5]. Check for triplets. There are 1,2,3 which are consecutive. So output YES.\n\nFortran code:\n\nAfter sorting a becomes [1,2,3,4,5]. unique_a is same. Check 1,2,3: yes.\n\nSample Input 2:\n\n4\n4 1 3 2\n\nAfter distinct and sorted: [1,2,3,4]. Check for 1,2,3 or 2,3,4. Both are consecutive triplets. So output YES.\n\nSample Input 3:\n\n3\n1 1 1\n\nAfter distinct and sorted: [1]. Size is 1. So output NO.\n\nSample Input 4:\n\n6\n3 1 4 1 5 3\n\nOriginal array: [3,1,4,1,5,3]. Distinct gives [3,1,4,5], sorted becomes [1,3,4,5]. Check for consecutive triplets. 3,4,5: no, since they are 3,4,5, which is consecutive. Wait, 1,3,4,5: there are no three consecutive numbers. So the output is NO.\n\nWait, wait:\n\nWait, after distinct and sorted, the array is [1,3,4,5]. Then the triplet check is for three consecutive numbers. 3,4,5 is consecutive (each step increases by 1). So output should be YES.\n\nWait, 3,4,5 are consecutive. So the code would detect this. So the code would return YES.\n\nBut according to the code's logic, the loop runs from i=1 to count_unique-2. For count_unique=4, i runs from 1 to 2.\n\ni=1: check elements 1,2,3: 1,3,4 \u2192 differences are 2 and 1 \u2192 no.\n\ni=2: check elements 2,3,4: 3,4,5 \u2192 differences are 1 and 1 \u2192 yes. So found is true. So output is YES.\n\nSo the code would output YES.\n\nBut in the original code, the array after distinct and sorted would be [1,3,4,5], and the code checks each triplet. So it would find 3,4,5 and output YES.\n\nSo the Fortran code is correct.\n\nSo the code seems to handle the cases.\n\nAnother possible test case:\n\nn=5\n\nInput: 5 3 4 5 6\n\nSorted and unique: 3,4,5,6. Check 3,4,5 \u2192 yes. So output YES.\n\nSo the code would output YES.\n\nAnother test case:\n\nn=3\n\nInput: 1 3 5 \u2192 sorted and unique \u2192 1,3,5 \u2192 no triplet. Output NO.\n\nSo the code works.\n\nSo the code is correct.\n\nNow, check for edge cases.\n\nEdge case 1: n=0 \u2192 output NO.\n\nEdge case 2: n=3, elements 1,2,3 \u2192 output YES.\n\nEdge case 3: n=3, elements 1,1,2 \u2192 after processing, array is [1,2]. Size 2 \u2192 output NO.\n\nSo the code should handle all these.\n\nThus, the Fortran code seems correct."
}