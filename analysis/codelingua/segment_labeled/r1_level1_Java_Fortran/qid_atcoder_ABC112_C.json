{
  "segments": [
    {
      "text": "Okay, I need to translate this Java code into Fortran.",
      "start_char": 0,
      "end_char": 54,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Let's start by understanding what the Java code does.",
      "start_char": 55,
      "end_char": 108,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The program seems to solve a problem where given some points with their heights, we need to determine the correct center coordinates (cx, cy) and height (ch) such that all the given points satisfy the condition h[i] = max(ch - |x[i]-cx| - |y[i]-cy|, 0).",
      "start_char": 109,
      "end_char": 362,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Looking at the main method: It reads input values for n, then reads n entries of x, y, h. Then it iterates over possible cx and cy values from 0 to 100.",
      "start_char": 365,
      "end_char": 517,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "For each (cx, cy), it calls the check function to determine if there's a valid ch. If so, it prints the result.",
      "start_char": 518,
      "end_char": 629,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The check function first finds a non-zero h[i] to compute the candidate ch. Then it verifies that for all points, their h[i] matches the expected value based on ch, cx, and cy. If any point fails, it returns -1; else returns ch. Now, translating to Fortran. Let's consider the steps.",
      "start_char": 631,
      "end_char": 914,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "First, Fortran uses static typing, so I need to declare all variables.",
      "start_char": 917,
      "end_char": 987,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "The main variables are n, x, y, h arrays. In Java, they are int arrays. So in Fortran, they can be integer arrays.",
      "start_char": 988,
      "end_char": 1102,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "The input is read from standard input.",
      "start_char": 1104,
      "end_char": 1142,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "In Fortran, we can read using read(*,*) statements.",
      "start_char": 1143,
      "end_char": 1194,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "The loops in Java for i from 0 to MAX (inclusive) would translate to do loops in Fortran.",
      "start_char": 1197,
      "end_char": 1286,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Since Java's MAX is 100, the Fortran loops will go from 0 to 100 for both i and j.\n\nThe check function in Java is a static method.",
      "start_char": 1287,
      "end_char": 1417,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "In Fortran, functions can be written, but need to be declared properly.",
      "start_char": 1418,
      "end_char": 1489,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "The check function takes n, x, y, h arrays, cx, cy and returns an integer. But Fortran passes arrays by reference, so we can handle that.",
      "start_char": 1490,
      "end_char": 1627,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "However, in Fortran, the dummy arguments in functions must match in type and rank. So the x, y, h arrays in the check function must be declared as such.",
      "start_char": 1630,
      "end_char": 1782,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Now, for the check function logic:\n\nIn Java, the first loop finds the first h[i] > 0 to compute ch. Then the second loop checks all points against this ch.",
      "start_char": 1784,
      "end_char": 1939,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "If any point's h[i] doesn't match max(ch - distance, 0), return -1. Else return ch.",
      "start_char": 1940,
      "end_char": 2023,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "In Fortran, we can replicate this logic. Let's see. First, handling the input.",
      "start_char": 2025,
      "end_char": 2103,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "The Java code reads n, then n lines of x, y, h.",
      "start_char": 2105,
      "end_char": 2152,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "In Fortran, after reading n, we need to allocate arrays for x, y, h. But in Fortran, fixed-size arrays are easier if we know the maximum possible n.",
      "start_char": 2153,
      "end_char": 2301,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "The problem statement doesn't specify, but the original code uses n up to whatever input gives. So maybe we can assume a maximum size. But the Java code uses dynamic arrays.",
      "start_char": 2302,
      "end_char": 2475,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "In Fortran, we can use allocatable arrays. So read n, then allocate x(n), y(n), h(n), then read each element.",
      "start_char": 2476,
      "end_char": 2585,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Wait, the original Java code reads x[i], y[i], h[i] for each i from 0 to n-1. But in Fortran, array indices start at 1 by default. So when translating, maybe the Fortran code will use 1-based indexing for the arrays.",
      "start_char": 2587,
      "end_char": 2803,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "However, the logic of the check function relies on array indices from 0 to n-1. So perhaps in Fortran, we can loop from 1 to n. Let me check: In Java:\n\nfor (i from 0 to n-1) { x[i], y[i], h[i] } In Fortran, the arrays would be 1-based. So when we read into x(1), y(1), h(1), etc. So the loops in the check function would go from 1 to n. That's manageable.",
      "start_char": 2804,
      "end_char": 3160,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Now, the check function in Fortran.",
      "start_char": 3163,
      "end_char": 3198,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Let's outline it:\n\ninteger function check(n, x, y, h, cx, cy)\n  integer, intent(in) :: n, cx, cy\n  integer, intent(in) :: x(n), y(n), h(n)\n  integer :: ch, i, tmp\n\n  ch = -1\n  do i = 1, n\n    if (h(i) > 0) then\n      ch = abs(x(i) - cx) + abs(y(i) - cy) + h(i)\n      exit\n    end if\n  end do\n\n  if (ch == -1) then\n    ! All h were zero?",
      "start_char": 3199,
      "end_char": 3535,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Need to see how Java handles that. But according to problem, there is at least one h[i] >0.\n    ! So maybe this case won't happen. But need to handle it, perhaps return -1. check = -1\n    return\n  end if\n\n  do i = 1, n\n    tmp = max( ch - abs(x(i)-cx) - abs(y(i)-cy ), 0 ) if ( h(i) /= tmp ) then\n      check = -1\n      return\n    end if\n  end do\n\n  check = ch\nend function\n\nWait, but in the original Java code, for the first loop, if all h[i] are zero, then ch remains -1. Then when checking, for each h[i], which is zero, it checks if zero equals max( ch - ... , 0 ).",
      "start_char": 3536,
      "end_char": 4113,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Since ch is -1, then ch - ... would be negative, so max is zero. So h[i] (0) would equal zero, so it passes. But then check returns ch which is -1. But in the main code, when check returns a value >0, it outputs. So perhaps in the Java code, the check function will return ch = -1, which the main loop will ignore. But in the problem's context, there must be at least one h[i] >0. Otherwise, all h[i] are zero, and any cx, cy with ch=0 would be valid. But according to the problem statement, the correct ch is determined by the first h[i] >0. So perhaps the input ensures that there's at least one h[i] >0.",
      "start_char": 4114,
      "end_char": 4721,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "In the check function, if all h[i] are zero, then ch remains -1.",
      "start_char": 4723,
      "end_char": 4787,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Then, when checking each h[i], we compute max( ch - ... , 0 ).",
      "start_char": 4788,
      "end_char": 4850,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Since ch is -1, which is negative, then ch - ... would be even more negative. So max is zero. So h[i] is zero, which matches. So check returns ch=-1. Then the main loop will check if ch>0. But in this case, ch is -1, so it's not printed. But in the problem scenario, there's at least one h[i] positive, so the first loop in check will set ch to a positive value. So perhaps the code is okay.",
      "start_char": 4851,
      "end_char": 5242,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Now, in Fortran, when the check function returns a positive value, the main loop will print cx, cy, ch.",
      "start_char": 5245,
      "end_char": 5348,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Now, translating the main function.",
      "start_char": 5350,
      "end_char": 5385,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "In Java, the main reads n, then x, y, h arrays. Then loops over cx from 0 to 100, cy from 0 to 100. For each, calls check.",
      "start_char": 5387,
      "end_char": 5509,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "If check returns >0, output cx, cy, ch.",
      "start_char": 5510,
      "end_char": 5549,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "In Fortran, the main program would look like this:\n\nprogram atcoder_ABC112_C\n  implicit none\n  integer :: n, i, cx, cy, ch_val, check\n  integer, allocatable :: x(:), y(:), h(:)\n\n  read(*,*) n\n  allocate( x(n), y(n), h(n) ) do i = 1, n\n    read(*,*) x(i), y(i), h(i)\n  end do\n\n  do cx = 0, 100\n    do cy = 0, 100\n      ch_val = check(n, x, y, h, cx, cy)",
      "start_char": 5551,
      "end_char": 5905,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "if (ch_val > 0) then\n        print *, cx, cy, ch_val\n        stop\n      end if\n    end do\n  end do\n\n  deallocate(x, y, h)\ncontains\n\n  integer function check(n, x, y, h, cx, cy)\n    integer, intent(in) :: n, cx, cy\n    integer, intent(in) :: x(n), y(n), h(n)\n    integer :: i, tmp, ch\n\n    ch = -1\n    do i = 1, n\n      if (h(i) > 0) then\n        ch = abs(x(i) - cx) + abs(y(i) - cy) + h(i)\n        exit\n      end if\n    end do\n\n    if (ch == -1) then\n      check = -1\n      return\n    end if\n\n    do i = 1, n\n      tmp = ch - abs(x(i) - cx) - abs(y(i) - cy) if (tmp < 0) tmp = 0\n      if (h(i) /= tmp) then\n        check = -1\n        return\n      end if\n    end do\n\n    check = ch\n  end function check\n\nend program atcoder_ABC112_C\n\nWait, but in Java, the check function returns -1 if any point doesn't match. Otherwise returns ch.",
      "start_char": 5912,
      "end_char": 6749,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "In Fortran, the function check is written to return ch if all points are valid. But in the main loop, when ch_val is greater than 0, the code prints and stops. So the first valid (cx, cy) found is printed and the program stops.",
      "start_char": 6751,
      "end_char": 6978,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Because in Java, the loops start from 0 to 100, and the first valid one is output. But wait, in Java, the code loops through all possible cx and cy, and for each, check.",
      "start_char": 6980,
      "end_char": 7149,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "If check returns >0, it outputs. But there could be multiple valid solutions.",
      "start_char": 7150,
      "end_char": 7227,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "However, according to the problem's condition, there should be exactly one correct solution. So the code in Java prints all possible (cx, cy, ch) where check returns positive. But in the problem, it's guaranteed that there's only one. So the code will find it and output.",
      "start_char": 7228,
      "end_char": 7499,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "However, in Java, the code may print multiple solutions, but the problem says that the input is such that there's exactly one. So in practice, the first valid one found would be the correct one, but perhaps the code checks all possibilities and if multiple, outputs all. But according to the problem's context, there's only one.",
      "start_char": 7500,
      "end_char": 7828,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "However, in the Java code, the loops are from 0 to 100 for cx and cy, in order, and when a valid ch is found, it is printed immediately, but the code continues to check other possibilities.",
      "start_char": 7829,
      "end_char": 8018,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Wait, no: in the Java code, the code loops over cx and cy, and for each, calls check.",
      "start_char": 8019,
      "end_char": 8104,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "If check returns a positive value, it outputs the triplet. But the Java code does not stop after the first one. So multiple outputs are possible, but according to the problem statement, there's exactly one. So the code outputs all possible candidates.",
      "start_char": 8105,
      "end_char": 8356,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "However, in the actual problem, perhaps the correct solution is unique, so the code will find it once. But in the Java code, even if multiple candidates exist, all are printed. But in the Fortran code, the code would print the first valid (cx, cy) pair, and then stop.",
      "start_char": 8357,
      "end_char": 8625,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Wait, looking at the Fortran code I wrote, in the main loop, when a ch_val >0 is found, it prints and stops. But in the Java code, it prints each valid ch and continues. So there's a difference here. Ah, right!",
      "start_char": 8626,
      "end_char": 8836,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "In the original Java code, when a valid (cx, cy) is found (check returns ch>0), the code outputs it and continues. But since the problem has a unique solution, once found, perhaps there's only one.",
      "start_char": 8838,
      "end_char": 9035,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "However, the code may output multiple lines. But according to the problem's statement, there's exactly one possible solution, so the code will output that one. But the Java code doesn't stop after finding the first one, but the problem's test cases are designed to have only one correct solution. But in the Fortran code, as written, upon finding the first valid (cx, cy) pair, it prints and stops.",
      "start_char": 9036,
      "end_char": 9434,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Which would differ from the Java code's behavior if there are multiple valid candidates. So this could be a problem.",
      "start_char": 9436,
      "end_char": 9552,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "However, the problem's correct solution is unique, so it's okay. But to be accurate in translation, the Fortran code should output all valid candidates, not just the first one.",
      "start_char": 9553,
      "end_char": 9729,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Wait, looking at the original Java code: In the main loop:\n\nfor (int i = 0; i <= MAX; i++) {\n    for (int j = 0; j <= MAX; j++) {\n        int ch = check(n, x, y, h, i, j);\n        if (ch > 0) {\n            System.out.println(i + \" \" + j + \" \" + ch);\n        }\n    }\n} So for each (i,j) in 0-100, check.",
      "start_char": 9731,
      "end_char": 10034,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "If check returns positive, output. So it's possible that multiple (i,j) pairs could be valid, but according to the problem, there's exactly one.",
      "start_char": 10036,
      "end_char": 10180,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Thus, the code outputs that one. But in Fortran, the code I wrote would print the first valid one and exit. So that's a discrepancy. So to fix this, the Fortran code should loop through all possible (cx, cy) and print all valid ch values. But the original Java code does not stop early.",
      "start_char": 10181,
      "end_char": 10467,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "It checks all possible (cx, cy) pairs. So the Fortran code needs to do the same. So the main loop should not have a 'stop' after printing. So in the code I wrote, the main loop is:\n\ndo cx = 0, 100\n  do cy = 0, 100\n    ch_val = check(...)",
      "start_char": 10469,
      "end_char": 10706,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "if (ch_val >0) then\n      print ...\n    end if\n  end do\nend do So this would correctly mimic the Java code's behavior, outputting all valid (cx, cy) pairs. But the problem likely expects only one, and the code will output that.",
      "start_char": 10711,
      "end_char": 10938,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "However, in some test cases, perhaps multiple candidates exist. But according to the problem's constraints, there's exactly one. So the code is correct. But the original Java code doesn't have a 'break' or 'stop' after printing. So the Fortran code shouldn't either. So in my initial draft, the code uses 'stop' after printing. That's incorrect. So the main loop should just print, and after all loops, deallocate and end.",
      "start_char": 10940,
      "end_char": 11362,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "Wait, looking back at the original Java code, when a valid (i,j) is found, the code prints it immediately and continues checking others. So in Fortran, the same approach is needed. So the code should loop through all possible cx and cy, compute check, and print if ch_val>0. So the Fortran main loop should look like:\n\ndo cx = 0, 100\n    do cy = 0, 100\n        ch_val = check(n, x, y, h, cx, cy)",
      "start_char": 11365,
      "end_char": 11760,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "if (ch_val > 0) then\n            write(*,*) cx, cy, ch_val\n        end if\n    end do\nend do\n\nThen, after all loops, deallocate and stop.",
      "start_char": 11769,
      "end_char": 11905,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "However, according to the problem's condition, there's exactly one solution, so the code will output one line. But if multiple, the code would output them all.",
      "start_char": 11906,
      "end_char": 12065,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Thus, the 'stop' in my previous Fortran code is incorrect. So I need to remove the 'stop' and let the loop continue. Ah, right! So in the Java code, after printing a solution, the code continues checking other possible (i,j) pairs.",
      "start_char": 12067,
      "end_char": 12298,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "Therefore, in Fortran, the code should not stop after printing, but let all possibilities be checked and printed. So the main loop in Fortran should not have the 'stop' statement. That was a mistake. So the corrected code would have:\n\nif (ch_val > 0) then\n    print *, cx, cy, ch_val\nend if\n\nBut then, in the problem's context, the code will print the correct solution, possibly multiple times if there are multiple valid (cx, cy) pairs. But according to the problem, there is exactly one solution, so it's printed once.",
      "start_char": 12300,
      "end_char": 12820,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "Thus, the Fortran code needs to remove the 'stop' statement.",
      "start_char": 12823,
      "end_char": 12883,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "Otherwise, it would miss other possible solutions. So in the initial draft, the code would exit after the first valid solution, but Java code continues. So that's an error in the translation. So correcting the main loop:\n\ndo cx = 0, 100\n  do cy = 0, 100\n    ch_val = check(n, x, y, h, cx, cy)\n    if (ch_val > 0) then\n      print *, cx, cy, ch_val\n    end if\n  end do\nend do Yes, that's correct.",
      "start_char": 12884,
      "end_char": 13280,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "Now, handling the check function's logic.",
      "start_char": 13283,
      "end_char": 13324,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "The Fortran function 'check' is inside the program's 'contains' section, so it has access to the variables in the main program. Wait, no.",
      "start_char": 13325,
      "end_char": 13462,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The 'contains' allows internal procedures to access the host's variables, but in this case, the check function is passed all the necessary variables as arguments. So it should be okay.",
      "start_char": 13463,
      "end_char": 13647,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Another point: in Fortran, the function's name is 'check', but in the main program, we have 'integer :: check'.",
      "start_char": 13649,
      "end_char": 13760,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "This would create a variable named 'check' in the main program, but the function is also named 'check'.",
      "start_char": 13761,
      "end_char": 13864,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "This is a problem because the function's name would conflict with the variable's name. So that's a mistake.",
      "start_char": 13865,
      "end_char": 13972,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "In Fortran, the function's name should not be the same as a variable in the same scope. So in the main program, the line:\n\ninteger :: n, i, cx, cy, ch_val, check\n\nDeclares 'check' as an integer variable. But then, the function 'check' is defined in the contains section. This causes a conflict. So the variable 'check' in the main program should not be declared. So the correct code would not have 'check' in the variable declaration list. So the main program variables should be:\n\ninteger :: n, i, cx, cy, ch_val",
      "start_char": 13975,
      "end_char": 14488,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "And the function is named 'check' in the contains section. So the code in the main program calls 'ch_val = check(...)', which refers to the function, not a variable.",
      "start_char": 14491,
      "end_char": 14656,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Thus, the variable declaration in the main program is incorrect. So need to remove 'check' from the variable list. So the corrected code would have:\n\ninteger :: n, i, cx, cy, ch_val\n\nThus, fixing that.",
      "start_char": 14658,
      "end_char": 14859,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "Another possible issue is the use of 'abs' for integers.",
      "start_char": 14862,
      "end_char": 14918,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "In Fortran, the 'abs' function works for integers, so that's okay.",
      "start_char": 14919,
      "end_char": 14985,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Now, testing for h(i) >0: in Fortran, that's the same as in Java.",
      "start_char": 14987,
      "end_char": 15052,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "In the check function's second loop:\n\nIn Java, the code computes Math.max( ch - Math.abs(...) - Math.abs(...), 0 )",
      "start_char": 15054,
      "end_char": 15168,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "In Fortran, the max function is used as max(a, b), but since we have an expression, we can compute tmp as the difference, and then set it to max(tmp, 0). But in Fortran, the 'max' function for two integers works. So tmp = max( ch - (abs(x(i)-cx) + abs(y(i)-cy)), 0 ) So the code in Fortran's check function:\n\ntmp = ch - abs(x(i) - cx) - abs(y(i) - cy)\nif (tmp <0) tmp = 0\nif (h(i) /= tmp) then\n    check = -1\n    return\nend if\n\nAlternatively, using the max function:\n\ntmp = max( ch - abs(x(i)-cx) - abs(y(i)-cy), 0 ) Yes, that's better. So in Fortran, that would be:\n\ntmp = max( ch - abs(x(i) - cx) - abs(y(i) - cy), 0 )\n\nBut in Fortran, the 'max' function can take multiple arguments, but for two values, it's max(a, b). So the code should be:\n\ntmp = max( ch - (abs(x(i) - cx) + abs(y(i) - cy)), 0 ) But the order of operations is important. So subtracting the two absolute values from ch, then compare with zero. Yes, that's correct. So the code in the check function's loop:\n\ndo i = 1, n\n    tmp = max( ch - (abs(x(i) - cx) + abs(y(i) - cy)), 0 )\n    if (h(i) /= tmp) then\n        check = -1\n        return\n    end if\nend do\n\nYes. But wait, in Java, the code uses h[i] ! = Math.max(...). So if any h[i] does not equal the computed max, returns -1.",
      "start_char": 15170,
      "end_char": 16426,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "In Fortran, this is replicated by comparing h(i) with tmp. If any mismatch, return -1. So the code is correct.",
      "start_char": 16428,
      "end_char": 16538,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Now, the Fortran code's check function returns ch if all are valid, else -1.",
      "start_char": 16541,
      "end_char": 16617,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "In the main program, after checking all cx and cy from 0 to 100, the code would print all possible valid (cx, cy, ch) triplets. But according to the problem, there's only one, so it's printed once.",
      "start_char": 16619,
      "end_char": 16816,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Another thing: in Fortran, the print statement uses list-directed output (print *, ...), which may add extra spaces. But the problem's output format is space-separated integers. So that's acceptable.",
      "start_char": 16818,
      "end_char": 17017,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Now, testing the code with sample input.",
      "start_char": 17019,
      "end_char": 17059,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "For example, sample input 1:\n\n4\n0 0 10\n10 10 10\n0 10 10\n10 0 10\n\nBut I'm not sure what the correct output is, but the code should find the correct (cx, cy, ch). But this is just to check syntax.",
      "start_char": 17061,
      "end_char": 17255,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Another possible issue is that Fortran's 'abs' function for integers works correctly. Now, compiling the code.",
      "start_char": 17258,
      "end_char": 17368,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The code uses allocatable arrays, which is fine.",
      "start_char": 17370,
      "end_char": 17418,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The check function is inside the program's contains section, which is correct.",
      "start_char": 17419,
      "end_char": 17497,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Another possible error: in the check function, after finding ch from the first h[i] >0, what if all h[i] are zero? Then ch is -1, and in the check function, the code returns -1. Then the main loop would not print anything. But according to the problem's statement, there is at least one h[i] >0. So this case should not happen.",
      "start_char": 17499,
      "end_char": 17826,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "Thus, the code should handle all cases correctly. So the final Fortran code should be:\n\nprogram atcoder_ABC112_C\n  implicit none\n  integer :: n, i, cx, cy, ch_val\n  integer, allocatable :: x(:), y(:), h(:)\n\n  read(*,*) n\n  allocate( x(n), y(n), h(n) ) do i = 1, n\n    read(*,*) x(i), y(i), h(i)\n  end do\n\n  do cx = 0, 100\n    do cy = 0, 100\n      ch_val = check(n, x, y, h, cx, cy)",
      "start_char": 17828,
      "end_char": 18212,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "if (ch_val > 0) then\n        write(*, '(I0, \" \", I0, \" \", I0)') cx, cy, ch_val\n      end if\n    end do\n  end do\n\n  deallocate(x, y, h)\ncontains\n\n  integer function check(n, x, y, h, cx, cy)\n    integer, intent(in) :: n, cx, cy\n    integer, intent(in) :: x(n), y(n), h(n)\n    integer :: i, tmp, ch\n\n    ch = -1\n    do i = 1, n\n      if (h(i) > 0) then\n        ch = abs(x(i) - cx) + abs(y(i) - cy) + h(i)\n        exit\n      end if\n    end do\n\n    if (ch == -1) then\n      check = -1\n      return\n    end if\n\n    do i = 1, n\n      tmp = max( ch - (abs(x(i) - cx) + abs(y(i) - cy)), 0 ) if (h(i) /= tmp) then\n        check = -1\n        return\n      end if\n    end do\n\n    check = ch\n  end function check\n\nend program atcoder_ABC112_C\n\nWait, but in the line:\n\ntmp = max( ch - (abs(x(i) - cx) + abs(y(i) - cy)), 0 )",
      "start_char": 18219,
      "end_char": 19034,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Wait, the parentheses are mismatched. The correct expression is:\n\ntmp = max( ch - ( abs(x(i) - cx) + abs(y(i) - cy) ), 0 )\n\nBecause in Java, it's ch - (Math.abs(x[i] - cx) + Math.abs(y[i] - cy)). So the sum of the two absolute differences is subtracted from ch. Then, max of that and 0. So in Fortran, the expression is ch - (abs(x(i)-cx) + abs(y(i)-cy)), then max with zero. So the code should have:\n\ntmp = max( ch - (abs(x(i) - cx) + abs(y(i) - cy) ), 0 )",
      "start_char": 19036,
      "end_char": 19495,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "Wait, but the order of operations: subtraction has lower precedence than addition. Wait, no.",
      "start_char": 19497,
      "end_char": 19589,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "In Fortran, addition and subtraction have the same precedence and are evaluated left to right. So ch minus the sum of the two absolute values. So parentheses are needed around the sum. Yes.",
      "start_char": 19590,
      "end_char": 19779,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "So:\n\nch - ( abs(x(i)-cx) + abs(y(i)-cy) ) So in code:\n\ntmp = max( ch - (abs(x(i)-cx) + abs(y(i)-cy)), 0 ) Yes. So the parentheses are necessary to sum the two absolute differences first. So the code in the check function:\n\ntmp = max( ch - (abs(x(i) - cx) + abs(y(i) - cy)), 0 )\n\nBut in Fortran, the max function takes two arguments. So the code is correct. Now, testing the code.",
      "start_char": 19781,
      "end_char": 20163,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Let's think about a sample input.",
      "start_char": 20165,
      "end_char": 20198,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Sample Input 1:\n\n3\n0 0 10\n10 10 10\n0 10 10\n\nSample Output: 5 5 15 (hypothetically).",
      "start_char": 20200,
      "end_char": 20283,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "Not sure, but the code should compute correctly. But this part is more about the logic, and the code seems to correctly implement the Java logic.",
      "start_char": 20284,
      "end_char": 20429,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Thus, the translated Fortran code should work as expected.",
      "start_char": 20432,
      "end_char": 20490,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    }
  ],
  "original_reasoning": "Okay, I need to translate this Java code into Fortran. Let's start by understanding what the Java code does. The program seems to solve a problem where given some points with their heights, we need to determine the correct center coordinates (cx, cy) and height (ch) such that all the given points satisfy the condition h[i] = max(ch - |x[i]-cx| - |y[i]-cy|, 0). \n\nLooking at the main method: It reads input values for n, then reads n entries of x, y, h. Then it iterates over possible cx and cy values from 0 to 100. For each (cx, cy), it calls the check function to determine if there's a valid ch. If so, it prints the result.\n\nThe check function first finds a non-zero h[i] to compute the candidate ch. Then it verifies that for all points, their h[i] matches the expected value based on ch, cx, and cy. If any point fails, it returns -1; else returns ch.\n\nNow, translating to Fortran. Let's consider the steps.\n\nFirst, Fortran uses static typing, so I need to declare all variables. The main variables are n, x, y, h arrays. In Java, they are int arrays. So in Fortran, they can be integer arrays.\n\nThe input is read from standard input. In Fortran, we can read using read(*,*) statements. \n\nThe loops in Java for i from 0 to MAX (inclusive) would translate to do loops in Fortran. Since Java's MAX is 100, the Fortran loops will go from 0 to 100 for both i and j.\n\nThe check function in Java is a static method. In Fortran, functions can be written, but need to be declared properly. The check function takes n, x, y, h arrays, cx, cy and returns an integer. \n\nBut Fortran passes arrays by reference, so we can handle that. However, in Fortran, the dummy arguments in functions must match in type and rank. So the x, y, h arrays in the check function must be declared as such.\n\nNow, for the check function logic:\n\nIn Java, the first loop finds the first h[i] > 0 to compute ch. Then the second loop checks all points against this ch. If any point's h[i] doesn't match max(ch - distance, 0), return -1. Else return ch.\n\nIn Fortran, we can replicate this logic. Let's see.\n\nFirst, handling the input. The Java code reads n, then n lines of x, y, h. In Fortran, after reading n, we need to allocate arrays for x, y, h. But in Fortran, fixed-size arrays are easier if we know the maximum possible n. The problem statement doesn't specify, but the original code uses n up to whatever input gives. So maybe we can assume a maximum size. But the Java code uses dynamic arrays. In Fortran, we can use allocatable arrays. So read n, then allocate x(n), y(n), h(n), then read each element.\n\nWait, the original Java code reads x[i], y[i], h[i] for each i from 0 to n-1. But in Fortran, array indices start at 1 by default. So when translating, maybe the Fortran code will use 1-based indexing for the arrays. However, the logic of the check function relies on array indices from 0 to n-1. So perhaps in Fortran, we can loop from 1 to n. Let me check:\n\nIn Java:\n\nfor (i from 0 to n-1) { x[i], y[i], h[i] }\n\nIn Fortran, the arrays would be 1-based. So when we read into x(1), y(1), h(1), etc. So the loops in the check function would go from 1 to n. That's manageable.\n\nNow, the check function in Fortran. Let's outline it:\n\ninteger function check(n, x, y, h, cx, cy)\n  integer, intent(in) :: n, cx, cy\n  integer, intent(in) :: x(n), y(n), h(n)\n  integer :: ch, i, tmp\n\n  ch = -1\n  do i = 1, n\n    if (h(i) > 0) then\n      ch = abs(x(i) - cx) + abs(y(i) - cy) + h(i)\n      exit\n    end if\n  end do\n\n  if (ch == -1) then\n    ! All h were zero? Need to see how Java handles that. But according to problem, there is at least one h[i] >0.\n    ! So maybe this case won't happen. But need to handle it, perhaps return -1.\n    check = -1\n    return\n  end if\n\n  do i = 1, n\n    tmp = max( ch - abs(x(i)-cx) - abs(y(i)-cy ), 0 )\n    if ( h(i) /= tmp ) then\n      check = -1\n      return\n    end if\n  end do\n\n  check = ch\nend function\n\nWait, but in the original Java code, for the first loop, if all h[i] are zero, then ch remains -1. Then when checking, for each h[i], which is zero, it checks if zero equals max( ch - ... , 0 ). Since ch is -1, then ch - ... would be negative, so max is zero. So h[i] (0) would equal zero, so it passes. But then check returns ch which is -1. But in the main code, when check returns a value >0, it outputs. So perhaps in the Java code, the check function will return ch = -1, which the main loop will ignore.\n\nBut in the problem's context, there must be at least one h[i] >0. Otherwise, all h[i] are zero, and any cx, cy with ch=0 would be valid. But according to the problem statement, the correct ch is determined by the first h[i] >0. So perhaps the input ensures that there's at least one h[i] >0.\n\nIn the check function, if all h[i] are zero, then ch remains -1. Then, when checking each h[i], we compute max( ch - ... , 0 ). Since ch is -1, which is negative, then ch - ... would be even more negative. So max is zero. So h[i] is zero, which matches. So check returns ch=-1. Then the main loop will check if ch>0. But in this case, ch is -1, so it's not printed.\n\nBut in the problem scenario, there's at least one h[i] positive, so the first loop in check will set ch to a positive value. So perhaps the code is okay.\n\nNow, in Fortran, when the check function returns a positive value, the main loop will print cx, cy, ch.\n\nNow, translating the main function.\n\nIn Java, the main reads n, then x, y, h arrays. Then loops over cx from 0 to 100, cy from 0 to 100. For each, calls check. If check returns >0, output cx, cy, ch.\n\nIn Fortran, the main program would look like this:\n\nprogram atcoder_ABC112_C\n  implicit none\n  integer :: n, i, cx, cy, ch_val, check\n  integer, allocatable :: x(:), y(:), h(:)\n\n  read(*,*) n\n  allocate( x(n), y(n), h(n) )\n  do i = 1, n\n    read(*,*) x(i), y(i), h(i)\n  end do\n\n  do cx = 0, 100\n    do cy = 0, 100\n      ch_val = check(n, x, y, h, cx, cy)\n      if (ch_val > 0) then\n        print *, cx, cy, ch_val\n        stop\n      end if\n    end do\n  end do\n\n  deallocate(x, y, h)\ncontains\n\n  integer function check(n, x, y, h, cx, cy)\n    integer, intent(in) :: n, cx, cy\n    integer, intent(in) :: x(n), y(n), h(n)\n    integer :: i, tmp, ch\n\n    ch = -1\n    do i = 1, n\n      if (h(i) > 0) then\n        ch = abs(x(i) - cx) + abs(y(i) - cy) + h(i)\n        exit\n      end if\n    end do\n\n    if (ch == -1) then\n      check = -1\n      return\n    end if\n\n    do i = 1, n\n      tmp = ch - abs(x(i) - cx) - abs(y(i) - cy)\n      if (tmp < 0) tmp = 0\n      if (h(i) /= tmp) then\n        check = -1\n        return\n      end if\n    end do\n\n    check = ch\n  end function check\n\nend program atcoder_ABC112_C\n\nWait, but in Java, the check function returns -1 if any point doesn't match. Otherwise returns ch.\n\nIn Fortran, the function check is written to return ch if all points are valid.\n\nBut in the main loop, when ch_val is greater than 0, the code prints and stops. So the first valid (cx, cy) found is printed and the program stops. Because in Java, the loops start from 0 to 100, and the first valid one is output. But wait, in Java, the code loops through all possible cx and cy, and for each, check. If check returns >0, it outputs. But there could be multiple valid solutions. However, according to the problem's condition, there should be exactly one correct solution. So the code in Java prints all possible (cx, cy, ch) where check returns positive. But in the problem, it's guaranteed that there's only one. So the code will find it and output. However, in Java, the code may print multiple solutions, but the problem says that the input is such that there's exactly one. So in practice, the first valid one found would be the correct one, but perhaps the code checks all possibilities and if multiple, outputs all. But according to the problem's context, there's only one. However, in the Java code, the loops are from 0 to 100 for cx and cy, in order, and when a valid ch is found, it is printed immediately, but the code continues to check other possibilities. Wait, no: in the Java code, the code loops over cx and cy, and for each, calls check. If check returns a positive value, it outputs the triplet. But the Java code does not stop after the first one. So multiple outputs are possible, but according to the problem statement, there's exactly one. So the code outputs all possible candidates. However, in the actual problem, perhaps the correct solution is unique, so the code will find it once. But in the Java code, even if multiple candidates exist, all are printed. But in the Fortran code, the code would print the first valid (cx, cy) pair, and then stop. Wait, looking at the Fortran code I wrote, in the main loop, when a ch_val >0 is found, it prints and stops. But in the Java code, it prints each valid ch and continues. So there's a difference here.\n\nAh, right! In the original Java code, when a valid (cx, cy) is found (check returns ch>0), the code outputs it and continues. But since the problem has a unique solution, once found, perhaps there's only one. However, the code may output multiple lines. But according to the problem's statement, there's exactly one possible solution, so the code will output that one. But the Java code doesn't stop after finding the first one, but the problem's test cases are designed to have only one correct solution.\n\nBut in the Fortran code, as written, upon finding the first valid (cx, cy) pair, it prints and stops. Which would differ from the Java code's behavior if there are multiple valid candidates. So this could be a problem. However, the problem's correct solution is unique, so it's okay. But to be accurate in translation, the Fortran code should output all valid candidates, not just the first one.\n\nWait, looking at the original Java code:\n\nIn the main loop:\n\nfor (int i = 0; i <= MAX; i++) {\n    for (int j = 0; j <= MAX; j++) {\n        int ch = check(n, x, y, h, i, j);\n        if (ch > 0) {\n            System.out.println(i + \" \" + j + \" \" + ch);\n        }\n    }\n}\n\nSo for each (i,j) in 0-100, check. If check returns positive, output. So it's possible that multiple (i,j) pairs could be valid, but according to the problem, there's exactly one. Thus, the code outputs that one. But in Fortran, the code I wrote would print the first valid one and exit. So that's a discrepancy. So to fix this, the Fortran code should loop through all possible (cx, cy) and print all valid ch values.\n\nBut the original Java code does not stop early. It checks all possible (cx, cy) pairs. So the Fortran code needs to do the same. So the main loop should not have a 'stop' after printing. So in the code I wrote, the main loop is:\n\ndo cx = 0, 100\n  do cy = 0, 100\n    ch_val = check(...)\n    if (ch_val >0) then\n      print ...\n    end if\n  end do\nend do\n\nSo this would correctly mimic the Java code's behavior, outputting all valid (cx, cy) pairs. But the problem likely expects only one, and the code will output that. However, in some test cases, perhaps multiple candidates exist. But according to the problem's constraints, there's exactly one. So the code is correct.\n\nBut the original Java code doesn't have a 'break' or 'stop' after printing. So the Fortran code shouldn't either. So in my initial draft, the code uses 'stop' after printing. That's incorrect. So the main loop should just print, and after all loops, deallocate and end.\n\nWait, looking back at the original Java code, when a valid (i,j) is found, the code prints it immediately and continues checking others. So in Fortran, the same approach is needed. So the code should loop through all possible cx and cy, compute check, and print if ch_val>0. So the Fortran main loop should look like:\n\ndo cx = 0, 100\n    do cy = 0, 100\n        ch_val = check(n, x, y, h, cx, cy)\n        if (ch_val > 0) then\n            write(*,*) cx, cy, ch_val\n        end if\n    end do\nend do\n\nThen, after all loops, deallocate and stop. However, according to the problem's condition, there's exactly one solution, so the code will output one line. But if multiple, the code would output them all.\n\nThus, the 'stop' in my previous Fortran code is incorrect. So I need to remove the 'stop' and let the loop continue.\n\nAh, right! So in the Java code, after printing a solution, the code continues checking other possible (i,j) pairs. Therefore, in Fortran, the code should not stop after printing, but let all possibilities be checked and printed.\n\nSo the main loop in Fortran should not have the 'stop' statement. That was a mistake. So the corrected code would have:\n\nif (ch_val > 0) then\n    print *, cx, cy, ch_val\nend if\n\nBut then, in the problem's context, the code will print the correct solution, possibly multiple times if there are multiple valid (cx, cy) pairs. But according to the problem, there is exactly one solution, so it's printed once.\n\nThus, the Fortran code needs to remove the 'stop' statement. Otherwise, it would miss other possible solutions. So in the initial draft, the code would exit after the first valid solution, but Java code continues. So that's an error in the translation.\n\nSo correcting the main loop:\n\ndo cx = 0, 100\n  do cy = 0, 100\n    ch_val = check(n, x, y, h, cx, cy)\n    if (ch_val > 0) then\n      print *, cx, cy, ch_val\n    end if\n  end do\nend do\n\nYes, that's correct.\n\nNow, handling the check function's logic. The Fortran function 'check' is inside the program's 'contains' section, so it has access to the variables in the main program. Wait, no. The 'contains' allows internal procedures to access the host's variables, but in this case, the check function is passed all the necessary variables as arguments. So it should be okay.\n\nAnother point: in Fortran, the function's name is 'check', but in the main program, we have 'integer :: check'. This would create a variable named 'check' in the main program, but the function is also named 'check'. This is a problem because the function's name would conflict with the variable's name. So that's a mistake. \n\nIn Fortran, the function's name should not be the same as a variable in the same scope. So in the main program, the line:\n\ninteger :: n, i, cx, cy, ch_val, check\n\nDeclares 'check' as an integer variable. But then, the function 'check' is defined in the contains section. This causes a conflict. So the variable 'check' in the main program should not be declared. So the correct code would not have 'check' in the variable declaration list.\n\nSo the main program variables should be:\n\ninteger :: n, i, cx, cy, ch_val\n\nAnd the function is named 'check' in the contains section. So the code in the main program calls 'ch_val = check(...)', which refers to the function, not a variable.\n\nThus, the variable declaration in the main program is incorrect. So need to remove 'check' from the variable list.\n\nSo the corrected code would have:\n\ninteger :: n, i, cx, cy, ch_val\n\nThus, fixing that.\n\nAnother possible issue is the use of 'abs' for integers. In Fortran, the 'abs' function works for integers, so that's okay.\n\nNow, testing for h(i) >0: in Fortran, that's the same as in Java.\n\nIn the check function's second loop:\n\nIn Java, the code computes Math.max( ch - Math.abs(...) - Math.abs(...), 0 )\n\nIn Fortran, the max function is used as max(a, b), but since we have an expression, we can compute tmp as the difference, and then set it to max(tmp, 0).\n\nBut in Fortran, the 'max' function for two integers works. So tmp = max( ch - (abs(x(i)-cx) + abs(y(i)-cy)), 0 )\n\nSo the code in Fortran's check function:\n\ntmp = ch - abs(x(i) - cx) - abs(y(i) - cy)\nif (tmp <0) tmp = 0\nif (h(i) /= tmp) then\n    check = -1\n    return\nend if\n\nAlternatively, using the max function:\n\ntmp = max( ch - abs(x(i)-cx) - abs(y(i)-cy), 0 )\n\nYes, that's better. So in Fortran, that would be:\n\ntmp = max( ch - abs(x(i) - cx) - abs(y(i) - cy), 0 )\n\nBut in Fortran, the 'max' function can take multiple arguments, but for two values, it's max(a, b). So the code should be:\n\ntmp = max( ch - (abs(x(i) - cx) + abs(y(i) - cy)), 0 )\n\nBut the order of operations is important. So subtracting the two absolute values from ch, then compare with zero.\n\nYes, that's correct.\n\nSo the code in the check function's loop:\n\ndo i = 1, n\n    tmp = max( ch - (abs(x(i) - cx) + abs(y(i) - cy)), 0 )\n    if (h(i) /= tmp) then\n        check = -1\n        return\n    end if\nend do\n\nYes.\n\nBut wait, in Java, the code uses h[i] != Math.max(...). So if any h[i] does not equal the computed max, returns -1.\n\nIn Fortran, this is replicated by comparing h(i) with tmp. If any mismatch, return -1.\n\nSo the code is correct.\n\nNow, the Fortran code's check function returns ch if all are valid, else -1.\n\nIn the main program, after checking all cx and cy from 0 to 100, the code would print all possible valid (cx, cy, ch) triplets. But according to the problem, there's only one, so it's printed once.\n\nAnother thing: in Fortran, the print statement uses list-directed output (print *, ...), which may add extra spaces. But the problem's output format is space-separated integers. So that's acceptable.\n\nNow, testing the code with sample input.\n\nFor example, sample input 1:\n\n4\n0 0 10\n10 10 10\n0 10 10\n10 0 10\n\nBut I'm not sure what the correct output is, but the code should find the correct (cx, cy, ch).\n\nBut this is just to check syntax.\n\nAnother possible issue is that Fortran's 'abs' function for integers works correctly.\n\nNow, compiling the code. The code uses allocatable arrays, which is fine. The check function is inside the program's contains section, which is correct.\n\nAnother possible error: in the check function, after finding ch from the first h[i] >0, what if all h[i] are zero? Then ch is -1, and in the check function, the code returns -1. Then the main loop would not print anything. But according to the problem's statement, there is at least one h[i] >0. So this case should not happen.\n\nThus, the code should handle all cases correctly.\n\nSo the final Fortran code should be:\n\nprogram atcoder_ABC112_C\n  implicit none\n  integer :: n, i, cx, cy, ch_val\n  integer, allocatable :: x(:), y(:), h(:)\n\n  read(*,*) n\n  allocate( x(n), y(n), h(n) )\n  do i = 1, n\n    read(*,*) x(i), y(i), h(i)\n  end do\n\n  do cx = 0, 100\n    do cy = 0, 100\n      ch_val = check(n, x, y, h, cx, cy)\n      if (ch_val > 0) then\n        write(*, '(I0, \" \", I0, \" \", I0)') cx, cy, ch_val\n      end if\n    end do\n  end do\n\n  deallocate(x, y, h)\ncontains\n\n  integer function check(n, x, y, h, cx, cy)\n    integer, intent(in) :: n, cx, cy\n    integer, intent(in) :: x(n), y(n), h(n)\n    integer :: i, tmp, ch\n\n    ch = -1\n    do i = 1, n\n      if (h(i) > 0) then\n        ch = abs(x(i) - cx) + abs(y(i) - cy) + h(i)\n        exit\n      end if\n    end do\n\n    if (ch == -1) then\n      check = -1\n      return\n    end if\n\n    do i = 1, n\n      tmp = max( ch - (abs(x(i) - cx) + abs(y(i) - cy)), 0 )\n      if (h(i) /= tmp) then\n        check = -1\n        return\n      end if\n    end do\n\n    check = ch\n  end function check\n\nend program atcoder_ABC112_C\n\nWait, but in the line:\n\ntmp = max( ch - (abs(x(i) - cx) + abs(y(i) - cy)), 0 )\n\nWait, the parentheses are mismatched. The correct expression is:\n\ntmp = max( ch - ( abs(x(i) - cx) + abs(y(i) - cy) ), 0 )\n\nBecause in Java, it's ch - (Math.abs(x[i] - cx) + Math.abs(y[i] - cy)). So the sum of the two absolute differences is subtracted from ch. Then, max of that and 0.\n\nSo in Fortran, the expression is ch - (abs(x(i)-cx) + abs(y(i)-cy)), then max with zero.\n\nSo the code should have:\n\ntmp = max( ch - (abs(x(i) - cx) + abs(y(i) - cy) ), 0 )\n\nWait, but the order of operations: subtraction has lower precedence than addition. Wait, no. In Fortran, addition and subtraction have the same precedence and are evaluated left to right. So ch minus the sum of the two absolute values. So parentheses are needed around the sum.\n\nYes. So:\n\nch - ( abs(x(i)-cx) + abs(y(i)-cy) )\n\nSo in code:\n\ntmp = max( ch - (abs(x(i)-cx) + abs(y(i)-cy)), 0 )\n\nYes. So the parentheses are necessary to sum the two absolute differences first.\n\nSo the code in the check function:\n\ntmp = max( ch - (abs(x(i) - cx) + abs(y(i) - cy)), 0 )\n\nBut in Fortran, the max function takes two arguments. So the code is correct.\n\nNow, testing the code. Let's think about a sample input.\n\nSample Input 1:\n\n3\n0 0 10\n10 10 10\n0 10 10\n\nSample Output: 5 5 15 (hypothetically). Not sure, but the code should compute correctly.\n\nBut this part is more about the logic, and the code seems to correctly implement the Java logic.\n\nThus, the translated Fortran code should work as expected."
}