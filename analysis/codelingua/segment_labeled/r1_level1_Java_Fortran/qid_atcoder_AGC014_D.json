{
  "segments": [
    {
      "text": "Okay, I need to translate this Java code into Fortran.",
      "start_char": 0,
      "end_char": 54,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Let's start by understanding what the Java code does.",
      "start_char": 55,
      "end_char": 108,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The main part is the maxMatching function, which seems to perform some kind of tree traversal to calculate a maximum matching.",
      "start_char": 111,
      "end_char": 237,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The program reads a tree structure and determines if the game result is \"First\" or \"Second\" based on whether twice the matching equals the number of nodes.",
      "start_char": 238,
      "end_char": 393,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "First, I need to represent the tree structure in Fortran.",
      "start_char": 395,
      "end_char": 452,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "In Java, they use an ArrayList of ArrayLists for adjacency.",
      "start_char": 453,
      "end_char": 512,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Fortran doesn't have dynamic arrays of arrays, but I can use an array of allocatable arrays or perhaps a fixed-size 2D array. But since each node can have a variable number of edges, maybe using an array of pointers to arrays would work.",
      "start_char": 513,
      "end_char": 750,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Alternatively, use a list structure. Hmm.",
      "start_char": 751,
      "end_char": 792,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "Wait, Fortran has derived types.",
      "start_char": 794,
      "end_char": 826,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Maybe I can create a type that holds a dynamic array for each node's children. But handling that in Fortran might be a bit tricky.",
      "start_char": 827,
      "end_char": 957,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, since the nodes are numbered up to n, perhaps preallocate a 2D array where each row holds the children, with the first element indicating the count.",
      "start_char": 958,
      "end_char": 1121,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "For example, a 2D array g where g(1,i) is the number of children for node i, and g(2:,i) are the children indices. But that's a bit old-school.",
      "start_char": 1122,
      "end_char": 1265,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Alternatively, use a jagged array approach with allocatable arrays for each node.",
      "start_char": 1266,
      "end_char": 1347,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, maybe using a linked list structure. But that's complicated.",
      "start_char": 1349,
      "end_char": 1424,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Let's think: in Fortran, perhaps we can have an array of allocatable arrays.",
      "start_char": 1425,
      "end_char": 1501,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "So, each element of the array is an allocatable integer array.",
      "start_char": 1502,
      "end_char": 1564,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "That's possible with Fortran 2003 and later.",
      "start_char": 1565,
      "end_char": 1609,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "So, for example:\n\ntype IntArray\n    integer, allocatable :: elements(:)\nend type\n\ntype(IntArray), allocatable :: g(:)",
      "start_char": 1610,
      "end_char": 1727,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Then, for each node, we can have an allocatable array of connected nodes. But how to handle that in practice. Let's see.",
      "start_char": 1729,
      "end_char": 1849,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "The Java code initializes g as an array of ArrayLists. So in Fortran, I can allocate g as an array of allocatable arrays, each initially empty.",
      "start_char": 1851,
      "end_char": 1994,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Then, when adding edges, append to the respective arrays. But Fortran doesn't have a built-in dynamic list like ArrayList. So every time we add an element, we need to reallocate and copy.",
      "start_char": 1995,
      "end_char": 2182,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Alternatively, preallocate a certain size and track the count. But for simplicity, maybe use a maximum possible size. But the problem is that the tree can have up to n-1 edges per node. But n can be up to, say, 1e5, but for the purposes of this code, maybe the input is manageable.",
      "start_char": 2184,
      "end_char": 2465,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, when reading the edges, for each a and b, append to both g(a) and g(b). So for each node, collect all adjacent nodes.",
      "start_char": 2467,
      "end_char": 2599,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "So, first, in the main program, after reading n, we need to allocate g as an array of allocatable arrays.",
      "start_char": 2601,
      "end_char": 2706,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Then, for each of the n-1 edges, read a and b, convert them to 0-based (since the Java code subtracts 1), then append b to g(a) and a to g(b). But in Fortran, indices typically start at 1.",
      "start_char": 2707,
      "end_char": 2895,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Wait, in the Java code, the nodes are 0-based. So when reading a and b, subtract 1. So in Fortran, perhaps use 1-based indices. Wait, no. Let's see.",
      "start_char": 2897,
      "end_char": 3045,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The Java code reads a and b, subtracts 1, and adds each to the other's adjacency list. So in Fortran, perhaps keep the nodes as 1-based. So when reading, subtract 1, then add 1 again? No, maybe not. Let me think.",
      "start_char": 3046,
      "end_char": 3258,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Let's stick with 0-based indices for Fortran, since the original code uses 0-based.",
      "start_char": 3259,
      "end_char": 3342,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Wait, but in Fortran, array indices start at 1 by default. Hmm, this could be a problem.",
      "start_char": 3343,
      "end_char": 3431,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Alternatively, switch to 1-based indices. So when reading a and b from input, subtract 1 to get 0-based, then add 1 to convert to 1-based in Fortran.",
      "start_char": 3433,
      "end_char": 3582,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Because in Fortran, the adjacency list would then be 1-based.",
      "start_char": 3583,
      "end_char": 3644,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "For example, node 1 in Fortran corresponds to node 0 in Java. So when building the adjacency list, after reading a and b (0-based in Java), add 1 to both, then add each to the other's list.",
      "start_char": 3645,
      "end_char": 3834,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Wait, the original code reads a and b as 1-based (since they are input as node numbers), subtracts 1 to make them 0-based. Then builds the adjacency list. So in Fortran, we can read a and b, subtract 1 to get 0-based, then add 1 to make them 1-based in Fortran.",
      "start_char": 3836,
      "end_char": 4097,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Because in Fortran, arrays are typically 1-based. So the code can use 1-based indexing. Let's proceed that way. So the steps for the main program:\n\nRead n.\n\nInitialize g as an array of size n, each element is an allocatable array of integers. Initially empty.",
      "start_char": 4098,
      "end_char": 4357,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "For each of the n-1 edges:\n\n   read a and b (input is 1-based in Java code, then subtract 1 to get 0-based). But in Fortran, since we want 1-based indices, a and b would be read, subtract 1 (so they are 0-based in Java terms), then add 1 to get 1-based for Fortran. Wait, no. Let's clarify.",
      "start_char": 4360,
      "end_char": 4650,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The input in the Java code is given as a series of edges where each node is 1-based.",
      "start_char": 4652,
      "end_char": 4736,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Then, the code subtracts 1 to make them 0-based. So in Fortran, when reading a and b, we read them as integers, subtract 1 (to get 0-based as per Java code), but then use them as 1-based in Fortran. Wait, no.",
      "start_char": 4737,
      "end_char": 4945,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Because in the Java code, the nodes are 0-based. So in Fortran, perhaps the nodes are 0-based, but in Fortran arrays, that's allowed. So in Fortran, the code can use 0-based indexing for the nodes, and the adjacency list would start from index 0. But Fortran arrays can start from 0. So for example:\n\ninteger, allocatable :: g(:,:)\n\nBut no, it's an array of arrays. So each node's adjacency list is an array. So in Fortran, we can have:\n\ntype :: AdjList\n    integer, allocatable :: nodes(:)",
      "start_char": 4946,
      "end_char": 5436,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "end type\n\ntype(AdjList), allocatable :: g(:)\n\nThen, allocate g(0:n-1) (since in Java, nodes are 0-based).",
      "start_char": 5438,
      "end_char": 5543,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Then, for each edge a and b (after subtracting 1), add each to the other's list.",
      "start_char": 5544,
      "end_char": 5624,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Wait, but when the user inputs a and b, they are 1-based. So in Java, after subtracting 1, they are 0-based. So in Fortran, when reading, we do the same. So in Fortran:\n\nread a and b (from input as integers), then a = a-1, b = b-1.",
      "start_char": 5626,
      "end_char": 5857,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Then, for each, add to the adjacency list. So in Fortran, the adjacency list is 0-based. So the nodes are 0-based. So the g array is allocated from 0 to n-1. But in Fortran, arrays can be declared with any lower bound. So:\n\nallocate(g(0:n-1))",
      "start_char": 5859,
      "end_char": 6101,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Each g(i) is a list of adjacent nodes (0-based) for node i. So when reading the edges, for each a and b, subtract 1 (so they become 0-based), then add each to the other's adjacency list.",
      "start_char": 6104,
      "end_char": 6290,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Now, how to manage the adjacency list in Fortran.",
      "start_char": 6293,
      "end_char": 6342,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "For each node, the adjacency list is an allocatable array.",
      "start_char": 6343,
      "end_char": 6401,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "When adding a new node to the list, we need to append it. So, for example, in Java:\n\ng[a].add(b);\n\nIn Fortran, that would be:\n\ncall append(g(a)%nodes, b) But how to implement the append function.",
      "start_char": 6402,
      "end_char": 6597,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Because in Fortran, when you want to append an element to an array, you have to reallocate and copy. So write a subroutine that takes an array and an element, and appends it. So a possible approach:\n\nmodule utils\ncontains\n    subroutine append(arr, element)\n        integer, allocatable, intent(inout) :: arr(:)\n        integer, intent(in) :: element\n        integer, allocatable :: tmp(:)",
      "start_char": 6599,
      "end_char": 6988,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "if (.not. allocated(arr)) then\n            allocate(arr(1))\n            arr(1) = element\n        else\n            allocate(tmp(size(arr)+1))\n            tmp(1:size(arr)) = arr\n            tmp(size(arr)+1) = element\n            call move_alloc(tmp, arr)\n        end if\n    end subroutine append\nend module utils\n\nThen, when adding a node to the adjacency list, use this subroutine.",
      "start_char": 6998,
      "end_char": 7378,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Now, the main program structure. Read n from input.",
      "start_char": 7380,
      "end_char": 7431,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Allocate g(0:n-1), each g(i) is an allocatable array. Read n-1 edges.",
      "start_char": 7434,
      "end_char": 7503,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "For each, read a and b (1-based input), subtract 1 to make 0-based. Then append b to g(a), and a to g(b). Then call the maxMatching function, starting at node 0, parent -1",
      "start_char": 7505,
      "end_char": 7676,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "(since Fortran uses 0-based, but parent can be -1 as in Java).",
      "start_char": 7678,
      "end_char": 7740,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Wait, but in Fortran, integers can be negative. So parent is passed as -1, as in Java.",
      "start_char": 7742,
      "end_char": 7828,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "The maxMatching function in Java returns an integer. Let's translate that. In Java:\n\nint maxMatching(int v, int p) {\n    int a = 0;\n    int o = 0;\n    for (int w : g[v]) {\n        if (w == p) continue;\n        int r = maxMatching(w, v);\n        a += r / 2;\n        o += r % 2;\n    }\n    return 2 * a + Math.min(1, o) + 1;\n} In Fortran, this is a recursive function. But Fortran can handle recursion if the function is declared as recursive. So, the function would look like:\n\nrecursive integer function max_matching(v, p) result(res)\n    integer, intent(in) :: v, p\n    integer :: a, o, r, w, i\n    a = 0\n    o = 0 do i = 1, size(g(v)%nodes)\n        w = g(v)%nodes(i)\n        if (w == p) cycle\n        r = max_matching(w, v) a = a + r / 2\n        o = o + mod(r, 2)\n    end do\n    res = 2*a + min(1, o) + 1\nend function\n\nWait, but the adjacency list for v is stored in g(v)%nodes. So for each w in g(v)%nodes, we process them, skipping if w is p.",
      "start_char": 7830,
      "end_char": 8790,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Then, compute the sum a and o.",
      "start_char": 8792,
      "end_char": 8822,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "The return value is 2*a + min(1, o) + 1.",
      "start_char": 8824,
      "end_char": 8864,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "In Fortran, the min function can take multiple arguments, but to get the minimum of two values, use min(1, o). So that's the function.",
      "start_char": 8866,
      "end_char": 9000,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Now, the main program calls max_matching(0, -1), then divides by 2. Then checks if 2*m == n.",
      "start_char": 9003,
      "end_char": 9095,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "If so, output \"Second\", else \"First\". So the main steps in Fortran:\n\nAfter building the adjacency list, call the function:\n\nm = max_matching(0, -1) / 2\n\nThen, if (2*m == n) then print \"Second\", else \"First\". Now, handling input.",
      "start_char": 9096,
      "end_char": 9325,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "The Java code uses a custom scanner class.",
      "start_char": 9327,
      "end_char": 9369,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "In Fortran, we can read from standard input using read statements. But the problem is that in the Java code, the input is read line by line, using a tokenizer. So each input line can contain multiple integers. So in Fortran, we can read the entire line, split into tokens, and process them. But for simplicity, perhaps assume that each input is given as one integer per line. But the original code's input may have multiple integers per line.",
      "start_char": 9370,
      "end_char": 9812,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "For example, the edges are given as two integers per line. So in Fortran, to read the input correctly, perhaps read the entire line and split into tokens. But how to do that in Fortran?",
      "start_char": 9815,
      "end_char": 10000,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Alternatively, use list-directed input. So for each line, read a and b with:\n\nread(*,*) a, b\n\nBut that may not handle cases where input has leading/trailing spaces, but generally, list-directed input handles that. So in Fortran:\n\nread n from input. Then read n-1 lines, each with a and b. Then subtract 1 to make them 0-based, and append to the adjacency lists. So the code for reading edges would be:\n\ndo i = 1, n-1\n    read(*, *) a, b\n    a = a -1\n    b = b -1\n    call append(g(a)%nodes, b)\n    call append(g(b)%nodes, a)\nend do\n\nBut need to handle 0-based indices here. Now, putting all together.",
      "start_char": 10003,
      "end_char": 10606,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "First, the utils module with the append subroutine. Then, the main program. But in Fortran, the order of modules and program matters.",
      "start_char": 10609,
      "end_char": 10742,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The main program should come after the modules. So the code structure would be:\n\nmodule utils\ncontains\n    subroutine append(arr, element)\n        ! ...",
      "start_char": 10745,
      "end_char": 10897,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "as before ...\n    end subroutine\nend module\n\nprogram main\n    use utils\n    implicit none\n    type(AdjList)",
      "start_char": 10899,
      "end_char": 11006,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": ", allocatable :: g(:)\n    integer :: n, i, a, b, m\n    integer, external :: max_matching\n\n    ! Read n\n    read(*,*) n\n\n    !",
      "start_char": 11006,
      "end_char": 11131,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Allocate g(0:n-1)\n    allocate(g(0:n-1))\n\n    ! Read edges\n    do i = 1, n-1\n        read(*,*) a, b\n        a = a - 1\n        b = b - 1\n        call append(g(a)%nodes, b)\n        call append(g(b)%nodes, a)\n    end do\n\n    ! Compute max matching\n    m = max_matching(0, -1) / 2\n\n    ! Determine and print result\n    if (2 * m == n) then\n        print *, \"Second\"\n    else\n        print *, \"First\"\n    end if\n\nend program\n\nBut wait, the type AdjList is not defined. So need to define it.",
      "start_char": 11132,
      "end_char": 11617,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "At the top:\n\nmodule types\n    type AdjList\n        integer, allocatable :: nodes(:)\n    end type\nend module\n\nThen, use the types module in the main program and the function.",
      "start_char": 11619,
      "end_char": 11792,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Wait, but the max_matching function also needs access to the adjacency list g. How to pass it?",
      "start_char": 11794,
      "end_char": 11888,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Because in Java, the g is a static variable.",
      "start_char": 11889,
      "end_char": 11933,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "In Fortran, the function would need to have access to the adjacency list. So perhaps pass it as an argument. But since the function is recursive, passing it each time would be cumbersome.",
      "start_char": 11934,
      "end_char": 12121,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, make g a module variable. So the adjacency list is in a module. So restructuring the code.",
      "start_char": 12123,
      "end_char": 12228,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "We can have a module that contains the adjacency list.",
      "start_char": 12231,
      "end_char": 12285,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "module globals\n    use types\n    type(AdjList), allocatable :: g(:)\nend module\n\nThen, the max_matching function can access g via this module. But the function is recursive, so it has to be in a module.",
      "start_char": 12287,
      "end_char": 12488,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Or, alternatively, the function is contained within a module. So here's the plan:\n\n- Define a module 'types' that contains the AdjList type.",
      "start_char": 12490,
      "end_char": 12630,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "- Define a module 'globals' that contains the adjacency list g.\n\n- The max_matching function is part of a module, which uses 'globals' to access g.\n\nBut in Fortran, recursive functions must be declared with the 'recursive' keyword, and if they are in a module, they can be used.",
      "start_char": 12633,
      "end_char": 12911,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Alternatively, perhaps put the max_matching function in a module. So here's the code structure:\n\nmodule types\n    type AdjList\n        integer, allocatable :: nodes(:)\n    end type\nend module\n\nmodule globals\n    use types\n    type(AdjList), allocatable :: g(:)\nend module\n\nmodule max_matching_mod\n    use globals\ncontains\n    recursive integer function max_matching(v, p) result(res)\n        integer, intent(in) :: v, p\n        integer :: a, o, i, w, r\n        a = 0\n        o = 0\n        if (.not. allocated(g(v)%nodes)) then\n            ! No children except parent\n            res = 1\n            return\n        end if\n        do i = 1, size(g(v)%nodes)\n            w = g(v)%nodes(i)\n            if (w == p) cycle\n            r = max_matching(w, v)\n            a = a + r / 2\n            o = o + mod(r, 2)\n        end do\n        res = 2 * a + min(1, o) + 1\n    end function max_matching\nend module max_matching_mod\n\nprogram main\n    use utils\n    use types\n    use globals\n    use max_matching_mod\n    implicit none\n    integer :: n, i, a, b, m\n\n    read(*,*) n\n\n    allocate(g(0:n-1)) do i = 1, n-1\n        read(*,*) a, b\n        a = a - 1\n        b = b - 1\n        call append(g(a)%nodes, b)\n        call append(g(b)%nodes, a)\n    end do\n\n    m = max_matching(0, -1) / 2\n\n    if (2 * m == n) then\n        print *, \"Second\"\n    else\n        print *, \"First\"\n    end if\n\nend program main But then, the 'utils' module with the append subroutine must be available.",
      "start_char": 12913,
      "end_char": 14382,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Wait, the 'append' subroutine is needed in the main program when building the adjacency lists. So the 'utils' module should be used in the main program. But the 'append' subroutine needs to be part of a module that the main program can use.",
      "start_char": 14385,
      "end_char": 14625,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Putting the 'utils' module into the code:\n\nmodule utils\ncontains\n    subroutine append(arr, element)\n        integer, allocatable, intent(inout) :: arr(:)\n        integer, intent(in) :: element\n        integer, allocatable :: tmp(:)",
      "start_char": 14628,
      "end_char": 14860,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "if (.not. allocated(arr)) then\n            allocate(arr(1))\n            arr(1) = element\n        else\n            allocate(tmp(size(arr)+1))\n            tmp(1:size(arr)) = arr\n            tmp(size(arr)+1) = element\n            call move_alloc(tmp, arr)\n        end if\n    end subroutine append\nend module utils\n\nThen, in the main program, 'use utils' gives access to the 'append' subroutine.",
      "start_char": 14869,
      "end_char": 15260,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Now, compiling all these modules and program. But let's check for possible errors.",
      "start_char": 15262,
      "end_char": 15344,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "In the max_matching function, when looping through g(v)%nodes, if the array is not allocated, the size would be zero. So perhaps the loop doesn't execute.",
      "start_char": 15347,
      "end_char": 15501,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "For example, if a node has no children except parent, then the loop is skipped, a and o are zero. The result is 0 + 0 +1 =1. Which seems correct. But wait, in the case where the node is a leaf (parent is the only adjacent node), then the loop is skipped. So the code returns 2*0 + min(1, 0) +1 =0 +0+1=1. Which seems correct. But what if a node has children, but all are parent?",
      "start_char": 15502,
      "end_char": 15881,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Well, since the adjacency list for a node includes all neighbors except the parent. Wait, no.",
      "start_char": 15883,
      "end_char": 15976,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The adjacency list includes all neighbors. So when the code processes each neighbor, it skips the parent. So the code correctly loops over all children except the parent.",
      "start_char": 15977,
      "end_char": 16147,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "In Fortran, when the adjacency list is empty (size(g(v)%nodes) is zero), the loop doesn't run. But in practice, a tree node with parent -1 (the root) must have at least one child (if n>1), but in the case of n=1, the code would return 1, which when divided by 2 gives m=0.5, but since integer division truncates, m=0. So 2*m=0 ==n=1?",
      "start_char": 16150,
      "end_char": 16483,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "No, the code would output \"First\". But in the case where n=1, the Java code's output would be \"Second\" if 2m ==n. But 2m is 0, n=1, so output \"First\". But I'm not sure about the correctness of the algorithm. But the Fortran code should mirror the Java code.",
      "start_char": 16484,
      "end_char": 16742,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Now, possible issues:\n\n- In Fortran, when you do integer division, 3/2 is 1, same as Java. But in Java, for positive integers, division truncates towards zero. Same in Fortran. So the division in m = max_matching(0,-1)/2 should behave the same as in Java.",
      "start_char": 16745,
      "end_char": 17001,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Another possible issue is the handling of the adjacency lists.",
      "start_char": 17003,
      "end_char": 17065,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "For example, in the Java code, each node's adjacency list includes all adjacent nodes, including the parent. But during traversal, the code skips the parent. So in Fortran, the same applies.",
      "start_char": 17066,
      "end_char": 17256,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Thus, the code should be correct. Now, testing. Test case 1: n=2. One edge.",
      "start_char": 17258,
      "end_char": 17335,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "Then, the max_matching function would return: For node 0, parent -1. Its children are node 1. So call max_matching(1, 0).",
      "start_char": 17336,
      "end_char": 17457,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "In node 1's adjacency list, the parent is 0, so it skips it. So a=0, o=0. So returns 0 +0 +1=1. Then, back to node 0:\n\na += 1/2 \u2192 a=0.\n\no += 1%2 \u2192 o=1. Then res=2*0 +1 +1 =2. So m=2/2=1. Then 2*m=2, which equals n=2. So output \"Second\".",
      "start_char": 17461,
      "end_char": 17700,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Which is correct, as per the problem's sample input 1. So the code should handle that. Another test case: n=1. Then the code would compute max_matching(0,-1) \u2192 1. m=0. 2*0 =0 ! =1 \u2192 output \"First\". So the code seems to handle that.",
      "start_char": 17702,
      "end_char": 17934,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Now, compiling and checking for syntax errors. Possible syntax issues:\n\n-",
      "start_char": 17937,
      "end_char": 18010,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "In Fortran, when using modules, they must be compiled in order.",
      "start_char": 18012,
      "end_char": 18075,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "The main program uses the modules, which must be available.",
      "start_char": 18076,
      "end_char": 18135,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Another possible issue is the use of 0-based indices for the g array.",
      "start_char": 18137,
      "end_char": 18206,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "In Fortran, array indices can start at 0. So allocate(g(0:n-1)) is valid. But when using g(v) where v is 0, that's allowed.",
      "start_char": 18207,
      "end_char": 18330,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Another thing: the max_matching function is in a module, and is recursive. That should be allowed.",
      "start_char": 18333,
      "end_char": 18431,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Thus, the code should be correct.",
      "start_char": 18433,
      "end_char": 18466,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    }
  ],
  "original_reasoning": "Okay, I need to translate this Java code into Fortran. Let's start by understanding what the Java code does. \n\nThe main part is the maxMatching function, which seems to perform some kind of tree traversal to calculate a maximum matching. The program reads a tree structure and determines if the game result is \"First\" or \"Second\" based on whether twice the matching equals the number of nodes.\n\nFirst, I need to represent the tree structure in Fortran. In Java, they use an ArrayList of ArrayLists for adjacency. Fortran doesn't have dynamic arrays of arrays, but I can use an array of allocatable arrays or perhaps a fixed-size 2D array. But since each node can have a variable number of edges, maybe using an array of pointers to arrays would work. Alternatively, use a list structure. Hmm.\n\nWait, Fortran has derived types. Maybe I can create a type that holds a dynamic array for each node's children. But handling that in Fortran might be a bit tricky. Alternatively, since the nodes are numbered up to n, perhaps preallocate a 2D array where each row holds the children, with the first element indicating the count. For example, a 2D array g where g(1,i) is the number of children for node i, and g(2:,i) are the children indices. But that's a bit old-school. Alternatively, use a jagged array approach with allocatable arrays for each node.\n\nAlternatively, maybe using a linked list structure. But that's complicated. Let's think: in Fortran, perhaps we can have an array of allocatable arrays. So, each element of the array is an allocatable integer array. That's possible with Fortran 2003 and later. So, for example:\n\ntype IntArray\n    integer, allocatable :: elements(:)\nend type\n\ntype(IntArray), allocatable :: g(:)\n\nThen, for each node, we can have an allocatable array of connected nodes.\n\nBut how to handle that in practice. Let's see. The Java code initializes g as an array of ArrayLists. So in Fortran, I can allocate g as an array of allocatable arrays, each initially empty. Then, when adding edges, append to the respective arrays.\n\nBut Fortran doesn't have a built-in dynamic list like ArrayList. So every time we add an element, we need to reallocate and copy. Alternatively, preallocate a certain size and track the count. But for simplicity, maybe use a maximum possible size. But the problem is that the tree can have up to n-1 edges per node. But n can be up to, say, 1e5, but for the purposes of this code, maybe the input is manageable.\n\nAlternatively, when reading the edges, for each a and b, append to both g(a) and g(b). So for each node, collect all adjacent nodes.\n\nSo, first, in the main program, after reading n, we need to allocate g as an array of allocatable arrays. Then, for each of the n-1 edges, read a and b, convert them to 0-based (since the Java code subtracts 1), then append b to g(a) and a to g(b).\n\nBut in Fortran, indices typically start at 1. Wait, in the Java code, the nodes are 0-based. So when reading a and b, subtract 1. So in Fortran, perhaps use 1-based indices. Wait, no. Let's see. The Java code reads a and b, subtracts 1, and adds each to the other's adjacency list. So in Fortran, perhaps keep the nodes as 1-based. So when reading, subtract 1, then add 1 again? No, maybe not. Let me think. Let's stick with 0-based indices for Fortran, since the original code uses 0-based. Wait, but in Fortran, array indices start at 1 by default. Hmm, this could be a problem.\n\nAlternatively, switch to 1-based indices. So when reading a and b from input, subtract 1 to get 0-based, then add 1 to convert to 1-based in Fortran. Because in Fortran, the adjacency list would then be 1-based. For example, node 1 in Fortran corresponds to node 0 in Java. So when building the adjacency list, after reading a and b (0-based in Java), add 1 to both, then add each to the other's list.\n\nWait, the original code reads a and b as 1-based (since they are input as node numbers), subtracts 1 to make them 0-based. Then builds the adjacency list. So in Fortran, we can read a and b, subtract 1 to get 0-based, then add 1 to make them 1-based in Fortran. Because in Fortran, arrays are typically 1-based. So the code can use 1-based indexing. Let's proceed that way.\n\nSo the steps for the main program:\n\nRead n.\n\nInitialize g as an array of size n, each element is an allocatable array of integers. Initially empty.\n\nFor each of the n-1 edges:\n\n   read a and b (input is 1-based in Java code, then subtract 1 to get 0-based). But in Fortran, since we want 1-based indices, a and b would be read, subtract 1 (so they are 0-based in Java terms), then add 1 to get 1-based for Fortran.\n\nWait, no. Let's clarify. The input in the Java code is given as a series of edges where each node is 1-based. Then, the code subtracts 1 to make them 0-based. So in Fortran, when reading a and b, we read them as integers, subtract 1 (to get 0-based as per Java code), but then use them as 1-based in Fortran. Wait, no. Because in the Java code, the nodes are 0-based. So in Fortran, perhaps the nodes are 0-based, but in Fortran arrays, that's allowed. So in Fortran, the code can use 0-based indexing for the nodes, and the adjacency list would start from index 0.\n\nBut Fortran arrays can start from 0. So for example:\n\ninteger, allocatable :: g(:,:)\n\nBut no, it's an array of arrays. So each node's adjacency list is an array. So in Fortran, we can have:\n\ntype :: AdjList\n    integer, allocatable :: nodes(:)\nend type\n\ntype(AdjList), allocatable :: g(:)\n\nThen, allocate g(0:n-1) (since in Java, nodes are 0-based). Then, for each edge a and b (after subtracting 1), add each to the other's list.\n\nWait, but when the user inputs a and b, they are 1-based. So in Java, after subtracting 1, they are 0-based. So in Fortran, when reading, we do the same. So in Fortran:\n\nread a and b (from input as integers), then a = a-1, b = b-1.\n\nThen, for each, add to the adjacency list. So in Fortran, the adjacency list is 0-based. So the nodes are 0-based. So the g array is allocated from 0 to n-1.\n\nBut in Fortran, arrays can be declared with any lower bound. So:\n\nallocate(g(0:n-1))\n\nEach g(i) is a list of adjacent nodes (0-based) for node i.\n\nSo when reading the edges, for each a and b, subtract 1 (so they become 0-based), then add each to the other's adjacency list.\n\nNow, how to manage the adjacency list in Fortran. For each node, the adjacency list is an allocatable array. When adding a new node to the list, we need to append it. So, for example, in Java:\n\ng[a].add(b);\n\nIn Fortran, that would be:\n\ncall append(g(a)%nodes, b)\n\nBut how to implement the append function. Because in Fortran, when you want to append an element to an array, you have to reallocate and copy. So write a subroutine that takes an array and an element, and appends it.\n\nSo a possible approach:\n\nmodule utils\ncontains\n    subroutine append(arr, element)\n        integer, allocatable, intent(inout) :: arr(:)\n        integer, intent(in) :: element\n        integer, allocatable :: tmp(:)\n        if (.not. allocated(arr)) then\n            allocate(arr(1))\n            arr(1) = element\n        else\n            allocate(tmp(size(arr)+1))\n            tmp(1:size(arr)) = arr\n            tmp(size(arr)+1) = element\n            call move_alloc(tmp, arr)\n        end if\n    end subroutine append\nend module utils\n\nThen, when adding a node to the adjacency list, use this subroutine.\n\nNow, the main program structure.\n\nRead n from input.\n\nAllocate g(0:n-1), each g(i) is an allocatable array.\n\nRead n-1 edges. For each, read a and b (1-based input), subtract 1 to make 0-based. Then append b to g(a), and a to g(b).\n\nThen call the maxMatching function, starting at node 0, parent -1 (since Fortran uses 0-based, but parent can be -1 as in Java).\n\nWait, but in Fortran, integers can be negative. So parent is passed as -1, as in Java.\n\nThe maxMatching function in Java returns an integer. Let's translate that.\n\nIn Java:\n\nint maxMatching(int v, int p) {\n    int a = 0;\n    int o = 0;\n    for (int w : g[v]) {\n        if (w == p) continue;\n        int r = maxMatching(w, v);\n        a += r / 2;\n        o += r % 2;\n    }\n    return 2 * a + Math.min(1, o) + 1;\n}\n\nIn Fortran, this is a recursive function. But Fortran can handle recursion if the function is declared as recursive.\n\nSo, the function would look like:\n\nrecursive integer function max_matching(v, p) result(res)\n    integer, intent(in) :: v, p\n    integer :: a, o, r, w, i\n    a = 0\n    o = 0\n    do i = 1, size(g(v)%nodes)\n        w = g(v)%nodes(i)\n        if (w == p) cycle\n        r = max_matching(w, v)\n        a = a + r / 2\n        o = o + mod(r, 2)\n    end do\n    res = 2*a + min(1, o) + 1\nend function\n\nWait, but the adjacency list for v is stored in g(v)%nodes. So for each w in g(v)%nodes, we process them, skipping if w is p.\n\nThen, compute the sum a and o.\n\nThe return value is 2*a + min(1, o) + 1.\n\nIn Fortran, the min function can take multiple arguments, but to get the minimum of two values, use min(1, o).\n\nSo that's the function.\n\nNow, the main program calls max_matching(0, -1), then divides by 2. Then checks if 2*m == n. If so, output \"Second\", else \"First\".\n\nSo the main steps in Fortran:\n\nAfter building the adjacency list, call the function:\n\nm = max_matching(0, -1) / 2\n\nThen, if (2*m == n) then print \"Second\", else \"First\".\n\nNow, handling input. The Java code uses a custom scanner class. In Fortran, we can read from standard input using read statements.\n\nBut the problem is that in the Java code, the input is read line by line, using a tokenizer. So each input line can contain multiple integers. So in Fortran, we can read the entire line, split into tokens, and process them.\n\nBut for simplicity, perhaps assume that each input is given as one integer per line. But the original code's input may have multiple integers per line. For example, the edges are given as two integers per line.\n\nSo in Fortran, to read the input correctly, perhaps read the entire line and split into tokens. But how to do that in Fortran?\n\nAlternatively, use list-directed input. So for each line, read a and b with:\n\nread(*,*) a, b\n\nBut that may not handle cases where input has leading/trailing spaces, but generally, list-directed input handles that.\n\nSo in Fortran:\n\nread n from input.\n\nThen read n-1 lines, each with a and b. Then subtract 1 to make them 0-based, and append to the adjacency lists.\n\nSo the code for reading edges would be:\n\ndo i = 1, n-1\n    read(*, *) a, b\n    a = a -1\n    b = b -1\n    call append(g(a)%nodes, b)\n    call append(g(b)%nodes, a)\nend do\n\nBut need to handle 0-based indices here.\n\nNow, putting all together.\n\nFirst, the utils module with the append subroutine.\n\nThen, the main program.\n\nBut in Fortran, the order of modules and program matters. The main program should come after the modules.\n\nSo the code structure would be:\n\nmodule utils\ncontains\n    subroutine append(arr, element)\n        ! ... as before ...\n    end subroutine\nend module\n\nprogram main\n    use utils\n    implicit none\n    type(AdjList), allocatable :: g(:)\n    integer :: n, i, a, b, m\n    integer, external :: max_matching\n\n    ! Read n\n    read(*,*) n\n\n    ! Allocate g(0:n-1)\n    allocate(g(0:n-1))\n\n    ! Read edges\n    do i = 1, n-1\n        read(*,*) a, b\n        a = a - 1\n        b = b - 1\n        call append(g(a)%nodes, b)\n        call append(g(b)%nodes, a)\n    end do\n\n    ! Compute max matching\n    m = max_matching(0, -1) / 2\n\n    ! Determine and print result\n    if (2 * m == n) then\n        print *, \"Second\"\n    else\n        print *, \"First\"\n    end if\n\nend program\n\nBut wait, the type AdjList is not defined. So need to define it.\n\nAt the top:\n\nmodule types\n    type AdjList\n        integer, allocatable :: nodes(:)\n    end type\nend module\n\nThen, use the types module in the main program and the function.\n\nWait, but the max_matching function also needs access to the adjacency list g. How to pass it? Because in Java, the g is a static variable. In Fortran, the function would need to have access to the adjacency list. So perhaps pass it as an argument. But since the function is recursive, passing it each time would be cumbersome.\n\nAlternatively, make g a module variable. So the adjacency list is in a module.\n\nSo restructuring the code.\n\nWe can have a module that contains the adjacency list.\n\nmodule globals\n    use types\n    type(AdjList), allocatable :: g(:)\nend module\n\nThen, the max_matching function can access g via this module.\n\nBut the function is recursive, so it has to be in a module. Or, alternatively, the function is contained within a module.\n\nSo here's the plan:\n\n- Define a module 'types' that contains the AdjList type.\n\n- Define a module 'globals' that contains the adjacency list g.\n\n- The max_matching function is part of a module, which uses 'globals' to access g.\n\nBut in Fortran, recursive functions must be declared with the 'recursive' keyword, and if they are in a module, they can be used.\n\nAlternatively, perhaps put the max_matching function in a module.\n\nSo here's the code structure:\n\nmodule types\n    type AdjList\n        integer, allocatable :: nodes(:)\n    end type\nend module\n\nmodule globals\n    use types\n    type(AdjList), allocatable :: g(:)\nend module\n\nmodule max_matching_mod\n    use globals\ncontains\n    recursive integer function max_matching(v, p) result(res)\n        integer, intent(in) :: v, p\n        integer :: a, o, i, w, r\n        a = 0\n        o = 0\n        if (.not. allocated(g(v)%nodes)) then\n            ! No children except parent\n            res = 1\n            return\n        end if\n        do i = 1, size(g(v)%nodes)\n            w = g(v)%nodes(i)\n            if (w == p) cycle\n            r = max_matching(w, v)\n            a = a + r / 2\n            o = o + mod(r, 2)\n        end do\n        res = 2 * a + min(1, o) + 1\n    end function max_matching\nend module max_matching_mod\n\nprogram main\n    use utils\n    use types\n    use globals\n    use max_matching_mod\n    implicit none\n    integer :: n, i, a, b, m\n\n    read(*,*) n\n\n    allocate(g(0:n-1))\n\n    do i = 1, n-1\n        read(*,*) a, b\n        a = a - 1\n        b = b - 1\n        call append(g(a)%nodes, b)\n        call append(g(b)%nodes, a)\n    end do\n\n    m = max_matching(0, -1) / 2\n\n    if (2 * m == n) then\n        print *, \"Second\"\n    else\n        print *, \"First\"\n    end if\n\nend program main\n\nBut then, the 'utils' module with the append subroutine must be available.\n\nWait, the 'append' subroutine is needed in the main program when building the adjacency lists. So the 'utils' module should be used in the main program.\n\nBut the 'append' subroutine needs to be part of a module that the main program can use.\n\nPutting the 'utils' module into the code:\n\nmodule utils\ncontains\n    subroutine append(arr, element)\n        integer, allocatable, intent(inout) :: arr(:)\n        integer, intent(in) :: element\n        integer, allocatable :: tmp(:)\n        if (.not. allocated(arr)) then\n            allocate(arr(1))\n            arr(1) = element\n        else\n            allocate(tmp(size(arr)+1))\n            tmp(1:size(arr)) = arr\n            tmp(size(arr)+1) = element\n            call move_alloc(tmp, arr)\n        end if\n    end subroutine append\nend module utils\n\nThen, in the main program, 'use utils' gives access to the 'append' subroutine.\n\nNow, compiling all these modules and program.\n\nBut let's check for possible errors.\n\nIn the max_matching function, when looping through g(v)%nodes, if the array is not allocated, the size would be zero. So perhaps the loop doesn't execute. For example, if a node has no children except parent, then the loop is skipped, a and o are zero. The result is 0 + 0 +1 =1. Which seems correct.\n\nBut wait, in the case where the node is a leaf (parent is the only adjacent node), then the loop is skipped. So the code returns 2*0 + min(1, 0) +1 =0 +0+1=1. Which seems correct.\n\nBut what if a node has children, but all are parent? Well, since the adjacency list for a node includes all neighbors except the parent. Wait, no. The adjacency list includes all neighbors. So when the code processes each neighbor, it skips the parent.\n\nSo the code correctly loops over all children except the parent.\n\nIn Fortran, when the adjacency list is empty (size(g(v)%nodes) is zero), the loop doesn't run. But in practice, a tree node with parent -1 (the root) must have at least one child (if n>1), but in the case of n=1, the code would return 1, which when divided by 2 gives m=0.5, but since integer division truncates, m=0. So 2*m=0 ==n=1? No, the code would output \"First\".\n\nBut in the case where n=1, the Java code's output would be \"Second\" if 2m ==n. But 2m is 0, n=1, so output \"First\".\n\nBut I'm not sure about the correctness of the algorithm. But the Fortran code should mirror the Java code.\n\nNow, possible issues:\n\n- In Fortran, when you do integer division, 3/2 is 1, same as Java. But in Java, for positive integers, division truncates towards zero. Same in Fortran.\n\nSo the division in m = max_matching(0,-1)/2 should behave the same as in Java.\n\nAnother possible issue is the handling of the adjacency lists. For example, in the Java code, each node's adjacency list includes all adjacent nodes, including the parent. But during traversal, the code skips the parent. So in Fortran, the same applies.\n\nThus, the code should be correct.\n\nNow, testing.\n\nTest case 1: n=2. One edge. Then, the max_matching function would return:\n\nFor node 0, parent -1.\n\nIts children are node 1. So call max_matching(1, 0).\n\nIn node 1's adjacency list, the parent is 0, so it skips it. So a=0, o=0. So returns 0 +0 +1=1.\n\nThen, back to node 0:\n\na += 1/2 \u2192 a=0.\n\no += 1%2 \u2192 o=1.\n\nThen res=2*0 +1 +1 =2. So m=2/2=1.\n\nThen 2*m=2, which equals n=2. So output \"Second\".\n\nWhich is correct, as per the problem's sample input 1.\n\nSo the code should handle that.\n\nAnother test case: n=1. Then the code would compute max_matching(0,-1) \u2192 1. m=0. 2*0 =0 !=1 \u2192 output \"First\".\n\nSo the code seems to handle that.\n\nNow, compiling and checking for syntax errors.\n\nPossible syntax issues:\n\n- In Fortran, when using modules, they must be compiled in order. The main program uses the modules, which must be available.\n\nAnother possible issue is the use of 0-based indices for the g array. In Fortran, array indices can start at 0. So allocate(g(0:n-1)) is valid.\n\nBut when using g(v) where v is 0, that's allowed.\n\nAnother thing: the max_matching function is in a module, and is recursive. That should be allowed.\n\nThus, the code should be correct."
}