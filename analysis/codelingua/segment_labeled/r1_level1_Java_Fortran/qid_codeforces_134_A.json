{
  "segments": [
    {
      "text": "Okay, I need to translate this Java code into Fortran.",
      "start_char": 0,
      "end_char": 54,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Let's start by understanding what the Java code does.",
      "start_char": 55,
      "end_char": 108,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "First, it reads an integer n from the input. Then it reads n integers into an array arr.",
      "start_char": 111,
      "end_char": 199,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "It calculates the sum of all elements in arr. Then it checks for each element in the array if (sum - arr[i]) divided by (n-1) equals arr[i].",
      "start_char": 200,
      "end_char": 340,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "If so, it counts those elements and records their indices (plus 1 because Java is 0-indexed but the output is 1-based).",
      "start_char": 341,
      "end_char": 460,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Finally, it prints the count and the indices.",
      "start_char": 461,
      "end_char": 506,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "So, in Fortran, I need to replicate this logic.",
      "start_char": 508,
      "end_char": 555,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Let's break it down step by step.",
      "start_char": 556,
      "end_char": 589,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "1. Read the integer n. In Fortran, I'll use READ(*,*) n.\n\n2. Read the array of n integers.",
      "start_char": 591,
      "end_char": 681,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Since Fortran needs to know the size of the array at compile time, but here n is dynamic.",
      "start_char": 682,
      "end_char": 771,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Wait, in Fortran 90 and later, we can allocate arrays dynamically. So we can use ALLOCATABLE arrays.",
      "start_char": 772,
      "end_char": 872,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "So:\n\n   INTEGER, ALLOCATABLE :: arr(:)\n   READ(*,*) n\n   ALLOCATE(arr(n))\n   READ(*,*) arr\n\nBut wait, in Java, the code reads each element in a loop. But Fortran can read the entire array in one line if the input is provided as space-separated values. So if the user inputs n, then enters n numbers on the next line(s), the READ(*,*) arr should work. 3. Calculate the sum.",
      "start_char": 873,
      "end_char": 1245,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Fortran has the intrinsic SUM function. So sum = SUM(arr). 4. Then loop through each element.",
      "start_char": 1247,
      "end_char": 1340,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "For each i from 1 to n (since Fortran arrays are 1-based by default), check if (sum - arr(i)) is divisible by (n-1), and if the division result equals arr(i).",
      "start_char": 1342,
      "end_char": 1500,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Wait, in Java code, it's checking if (sum - arr[i]) % (n-1) == 0, and then (sum - arr[i])/(n-1) == arr[i]. So combining these two conditions. But if (sum - arr[i]) is divisible by (n-1), then the division will be exact. So in Fortran, we can compute (sum - arr(i)) / (n-1) and see if it equals arr(i).",
      "start_char": 1503,
      "end_char": 1804,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "However, division of integers in Fortran truncates towards zero. But in Java, if the result is not an integer, the modulo would have caught it. So if the modulo is zero, then the division is exact. So in Fortran, for each i:\n\nIF (MOD(sum - arr(i), n-1) == 0) THEN\n    temp = (sum - arr(i)) / (n-1) IF (temp == arr(i)) THEN\n        increment count and record the index\n    END",
      "start_char": 1805,
      "end_char": 2185,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "IF\nEND IF\n\nBut wait, since sum is the total sum, when we subtract arr(i), we get the sum of the other elements.",
      "start_char": 2186,
      "end_char": 2297,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "If the average of the other n-1 elements (which is (sum - arr(i))/(n-1)) equals arr(i), then the condition holds. So yes, that's the check. Now, handling the indices.",
      "start_char": 2298,
      "end_char": 2464,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "In Java, indices start at 0, and we add 1.",
      "start_char": 2466,
      "end_char": 2508,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "In Fortran, the loop would be from 1 to n, so the index i itself is already 1-based. So when appending to the string, we just use i.\n\nNow, for building the string of indices.",
      "start_char": 2509,
      "end_char": 2683,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "In Java, a StringBuilder is used.",
      "start_char": 2684,
      "end_char": 2717,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "In Fortran, perhaps we can build a character string by concatenating the indices as strings. But since the number of elements could be up to n, which could be large, perhaps using a list (array) to store the indices and then output them all at once.",
      "start_char": 2718,
      "end_char": 2967,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, we can collect the indices in an array, then loop through them to print. But the Java code first counts the number of valid indices (c), then prints c, followed by the space-separated indices. So in Fortran:\n\n- Allocate an integer array to hold the indices (size up to n)\n- Initialize a counter c = 0\n- Loop over each i from 1 to n\n   if the condition holds, increment c and store i in the array\n- Then print c, followed by the first c elements of the array.",
      "start_char": 2969,
      "end_char": 3443,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, since in Fortran dynamic strings are a bit tricky, perhaps collect the indices into a character variable as we go. Let's see. But for efficiency, maybe collect the indices into an array, then print them. So:\n\nInitialize an array indices with size n.\n\ncount = 0\n\ndo i = 1, n\n   if (condition) then\n      count = count + 1\n      indices(count) = i\n   end if\nend do\n\nThen, print count, and the first count elements of indices. But how to print them space-separated.",
      "start_char": 3445,
      "end_char": 3923,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Fortran can do formatted output. So something like:\n\nprint '(I0)', count\nif (count > 0) then\n   write(*, '(I0)') (indices(i), i=1, count)\nend if\n\nWait, but the format for the second line.",
      "start_char": 3925,
      "end_char": 4112,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "If we have multiple elements, how to have them space-separated.",
      "start_char": 4113,
      "end_char": 4176,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "The format (I0) for each element would print each on a new line, but Java's code uses a space. So perhaps use a format that includes the elements separated by spaces. So for the indices line, we can use:\n\nwrite(*, '(*(I0,:,\" \"))') (indices(i), i=1, count)",
      "start_char": 4177,
      "end_char": 4433,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The * in the format allows for variable numbers of items.",
      "start_char": 4435,
      "end_char": 4492,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The : in the format specifier suppresses the trailing space. So this format will output each integer followed by a space, except the last one.",
      "start_char": 4493,
      "end_char": 4635,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Alternatively, we can use a loop to build a string.",
      "start_char": 4636,
      "end_char": 4687,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, we can loop through the indices and build a string. For example:\n\ncharacter(len=1000) :: buffer  ! assuming 1000 is enough\ninteger :: pos\n\npos = 1\ndo i = 1, count\n   write(buffer(pos:), '(I0, \" \")') indices(i)\n   pos = pos + len_trim(buffer(pos:)) + 1  ! move position\nend do\nif (count > 0) then\n   buffer = trim(buffer)  !",
      "start_char": 4689,
      "end_char": 5027,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "remove trailing space\nend if\nprint *, buffer\n\nBut this might be a bit complicated, especially with fixed buffer size. So perhaps the best approach is to use an array for the indices and then write them all in one go with a format that adds spaces. So for example:\n\nprint *, count\nif (count > 0) then\n   write(*, '(*(I0,:,\" \"))') (indices(i), i=1, count)\nend if\n\nThis should work.",
      "start_char": 5028,
      "end_char": 5408,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The * allows any number of items, and the :\" \" adds a space between them but not at the end. Putting it all together.",
      "start_char": 5409,
      "end_char": 5526,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Now, handling division and modulo.",
      "start_char": 5529,
      "end_char": 5563,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "In Java, the code uses integers. So in Fortran, the variables should be integers. So sum is integer, n is integer, etc.",
      "start_char": 5564,
      "end_char": 5683,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Potential issues:\n\n- Division in Fortran with integers uses integer division. But the modulo function here is MOD. But since in Java, the % operator returns the remainder with the same sign as the dividend.",
      "start_char": 5685,
      "end_char": 5891,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Fortran's MOD function does the same. So MOD(a, b) in Fortran is equivalent to a % b in Java when a and b are positive. But if a is negative, then MOD(a, b) is also negative (if I recall correctly).",
      "start_char": 5892,
      "end_char": 6090,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "However, in this problem, since sum is the sum of positive numbers (assuming the input is correct?), but even if not, the code should handle negative numbers as per Java's logic. But the original code uses integers, so same in Fortran. So the code in Fortran would be:\n\nprogram codeforces_134_A\n    implicit none\n    integer :: n, i, sum_val, c, temp\n    integer, allocatable :: arr(:), indices(:)\n    character(len=1000) :: buffer\n    integer :: pos\n\n    ! Read input\n    read(*,*) n\n    allocate(arr(n))\n    read(*,*) arr\n\n    sum_val = sum(arr) c = 0\n    allocate(indices(n)) do i = 1, n\n        if ( (sum_val - arr(i)) == 0 ) then  !",
      "start_char": 6091,
      "end_char": 6738,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "avoid division by zero if n-1 is zero?\n            ! But n is the size of the array, which is read from input. So n >=1. But when n=1, n-1=0.\n            !",
      "start_char": 6739,
      "end_char": 6894,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Wait, in the original code, if n is 1, then (n-1) is 0, leading to division by zero. But in Java, when n=1, the code will compute (sum - arr[0]) / 0, which will cause an exception. So the original code probably expects that n is at least 2. Or perhaps the problem constraints ensure that n >=2. But the code doesn't handle that. So in Fortran, same as Java. If n=1, then (n-1) is 0, and the code would divide by zero. So perhaps the problem's input constraints ensure that n >=2.",
      "start_char": 6895,
      "end_char": 7374,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Otherwise, we need to handle that. But since the original code doesn't handle it, perhaps we can proceed under the same assumption. Assuming that n >=2. Otherwise, if n=1, then in the loop, (sum - arr[i]) is 0 (sum is arr[0], so 0). Then (sum - arr[i])/(n-1) is 0/0, which is undefined. So in Java, this would throw an exception. But perhaps the problem's input constraints ensure n >=2. So proceed. So in Fortran, for each i:\n\nif (mod(sum_val - arr(i), n-1) == 0) then\n    temp = (sum_val - arr(i)) / (n-1) if (temp == arr(i)) then\n        c = c + 1\n        indices(c) = i\n    end if\nend if\n\nYes. So putting this all together. But wait, in Java code, for n=1, (sum - arr[i]) is 0, and (n-1) is 0. So division by zero. But in Java, that code would throw an exception. So the problem probably requires that n >=2, and the test cases ensure that.",
      "start_char": 7375,
      "end_char": 8228,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Now, the code for Fortran:\n\nprogram codeforces_134_A\n    implicit none\n    integer :: n, i, sum_val, c, temp, ios\n    integer, allocatable :: arr(:), indices(:)\n\n    ! Read n\n    read(*,*, iostat=ios) n\n    if (ios /= 0) stop\n\n    !",
      "start_char": 8230,
      "end_char": 8462,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Allocate and read array\n    allocate(arr(n)) read(*,*, iostat=ios) arr\n    if (ios /= 0) stop\n\n    sum_val = sum(arr) c = 0\n    allocate(indices(n)) do i = 1, n\n        if (n - 1 == 0) cycle  ! avoid division by zero. But n >=1. If n=1, then n-1=0. So in this case, the loop would cycle, but c remains 0. Then output 0 and empty line. Which is same as Java's code when n=1, but in Java, the code would crash with division by zero. So perhaps in Fortran, if n=1, the code would output 0 and nothing. But the problem's input constraints may not allow n=1. So perhaps leave as is. But in code, perhaps handle n=1? But original code doesn't. So proceed. Assuming that n >=2. So in the loop:\n\ndo i = 1, n\n    if (mod(sum_val - arr(i), n-1) == 0) then\n        temp = (sum_val - arr(i)) / (n-1) if (temp == arr(i)) then\n            c = c + 1\n            indices(c) = i\n        end if\n    end if\nend do\n\nThen, output:\n\nprint *, c\nif (c > 0) then\n    write(*, '(*(I0,:,\" \"))') indices(1:c)\nend if\n\nWait, but when c=0, the second line (the indices) is printed as empty.",
      "start_char": 8463,
      "end_char": 9547,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "In Java, when c is 0, sb is empty, so System.out.println(sb.toString()) prints an empty line. In Fortran, when c=0, the second print is not executed, so the output is just the 0 followed by nothing.",
      "start_char": 9548,
      "end_char": 9747,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Which would differ from the Java code. Ah, right.",
      "start_char": 9748,
      "end_char": 9797,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "Because in Java, even if c is 0, it still prints the empty string, resulting in a blank line. So in Fortran, we need to print the blank line even if c is 0.",
      "start_char": 9799,
      "end_char": 9955,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Wait, looking at the Java code:\n\nif c is 0, sb is empty. Then System.out.println(sb.toString()) appends a new line, so the output is:\n\n0\n<empty line> Yes.",
      "start_char": 9957,
      "end_char": 10111,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Because the println method adds a new line. So in the Java code, two lines are printed: the first is the count (0), the second is the empty string with a new line.",
      "start_char": 10113,
      "end_char": 10276,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "In Fortran, the code should print the count, then the list of indices (which may be empty). But in Fortran, when using print *, the output adds a new line.",
      "start_char": 10278,
      "end_char": 10433,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "So, the code should:\n\nprint the count (with a new line), then print the indices (possibly empty), also with a new line. But how to do that.",
      "start_char": 10435,
      "end_char": 10574,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "In Java code, the first line is System.out.println(c), which prints c followed by a new line.",
      "start_char": 10577,
      "end_char": 10670,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The second line is System.out.println(sb.toString()), which prints the string followed by a new line.",
      "start_char": 10672,
      "end_char": 10773,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Even if the string is empty, this results in a new line. So in Fortran, the equivalent would be to print the count, then print the list of indices (even if empty) followed by a new line. But in Fortran, when you print an empty list, how does that work? For example, if c=0, then the indices array's first 0 elements are printed. How does that work?",
      "start_char": 10774,
      "end_char": 11125,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "In Fortran, if we do:\n\nif (c > 0) then\n    write(*, '(*(I0,:,\" \"))')",
      "start_char": 11127,
      "end_char": 11195,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "indices(1:c)\nelse\n    print *\nend if\n\nBut perhaps the second line (the indices) must always be printed, even if empty.",
      "start_char": 11196,
      "end_char": 11314,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "So, in the Java code, even if there are zero indices, it prints an empty line. So in Fortran, after printing the count, we need to print the list of indices (space-separated), followed by a new line.",
      "start_char": 11315,
      "end_char": 11514,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "If there are zero indices, it's just a new line. So perhaps:\n\nprint '(I0)', c\n\nif (c > 0) then\n    write(*, '(*(I0,:,\" \"))') (indices(i), i=1, c)\nelse\n    write(*, *)\nend if\n\nWait, but for the case when c=0, the second line would be written as an empty line.",
      "start_char": 11516,
      "end_char": 11775,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Let's see:\n\nIn Fortran, 'write(*,*)' prints a new line. But in the Java code, even when c=0, the second line is printed as a blank line. So the code can be structured as:\n\nprint '(I0)', c\n\nif (c == 0) then\n    print *\nelse\n    write(*, '(*(I0,:,\" \"))') (indices(i), i=1, c)\nend if\n\nBut perhaps there's a more efficient way. Because even when c=0, the write statement with indices(1:0) (if allowed) would output nothing. Wait, in Fortran, when you have an array section like (indices(i), i=1, c) and c=0, the implied-do loop would have zero iterations, and the format would produce no output. But the WRITE statement would still output a new line.",
      "start_char": 11776,
      "end_char": 12423,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Wait, let's test with a Fortran code snippet. Suppose:\n\nprogram test\n    implicit none\n    integer :: arr(0)\n    write(*, '(*(I0,:,\" \"))') (arr(i), i=1, 0)\nend program\n\nThis would have zero elements to write.",
      "start_char": 12425,
      "end_char": 12633,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "The format (*(I0,:,\" \")) would have zero elements. So the output would be nothing, but in Fortran, when a WRITE statement has no data, it outputs nothing except for the current record. So in this case, the output is a blank line? Or no line?",
      "start_char": 12634,
      "end_char": 12875,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "In Fortran, when using a WRITE statement with format and no data items, like WRITE(*, '(A)') '', it would print a blank line. But if there are no data items and the format has no literals, like WRITE(*, '()'), it would output a blank line. But in this case, the format is (*(I0,:,\" \")), and there are zero data items.",
      "start_char": 12877,
      "end_char": 13194,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The * in the format would process zero data items, so the entire format is processed. So the output would be nothing.",
      "start_char": 13195,
      "end_char": 13312,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Then, the WRITE statement completes the current record, which is a line with zero characters. So when you print it, it's a blank line. Wait, maybe not. Let me think.",
      "start_char": 13313,
      "end_char": 13478,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "In Fortran, each WRITE starts a new record.",
      "start_char": 13480,
      "end_char": 13523,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "The format specification is processed, even if there are no data items.",
      "start_char": 13524,
      "end_char": 13595,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "If the format has no items that produce output (like if the data list is empty and the format has no literals), then the output is an empty record, which may be a blank line or not, depending on the system. But when we have WRITE(*, '(*(I0,:,\" \"))'), with zero data items, the format would expand to zero I0 edits, each with optional space. So nothing is printed, but the WRITE statement will output a new line. So the output is a blank line. Wait, no.",
      "start_char": 13596,
      "end_char": 14048,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Because each WRITE statement outputs at least one record. Even if nothing is printed. So the WRITE statement would output a line with zero characters.",
      "start_char": 14050,
      "end_char": 14200,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Which, depending on the system, may appear as a blank line.",
      "start_char": 14201,
      "end_char": 14260,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "For example, in terminal, a line with zero characters is a blank line. So for the code:\n\nprint '(I0)', 0\nwrite(*, '(*(I0,:,\" \"))') But how to pass zero elements. In the code, when c=0, (indices(i), i=1, c) would generate an empty list. So:\n\nwrite(*, '(*(I0,:,\" \"))') (indices(i), i=1, c) where c=0.",
      "start_char": 14261,
      "end_char": 14562,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "This would output a line with nothing. So the Java code's second line is a blank line. So in Fortran, after printing the count, the second line is blank if c=0. Thus, in Fortran, the code can be written as:\n\nprint '(I0)', c\nwrite(*, '(*(I0,:,\" \"))') (indices(i), i=1, c)\n\nBut when c=0, this would output a line with nothing, which is the same as a blank line? Or not. But in Java, the code prints two lines even when c=0.",
      "start_char": 14564,
      "end_char": 14987,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "The first line is 0, the second is empty. So the Fortran code should print two lines as well.",
      "start_char": 14988,
      "end_char": 15081,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "So, the first print statement outputs c followed by a new line.",
      "start_char": 15083,
      "end_char": 15146,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "The second write statement outputs the indices, and if there are none, outputs a new line with nothing. So two lines in total, which matches Java's behavior. So the code:\n\nprint '(I0)', c\nwrite(*, '(*(I0,:,\" \"))') (indices(i), i=1, c) Yes. Because when c=0, the implied-do loop has zero elements, so the write statement outputs a new line with nothing. So this should replicate the Java code's behavior. Putting it all together.",
      "start_char": 15147,
      "end_char": 15577,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Potential code:\n\nprogram codeforces_134_A\n    implicit none\n    integer :: n, i, sum_val, c, temp\n    integer, allocatable :: arr(:), indices(:)\n\n    read(*,*) n\n    allocate(arr(n)) read(*,*) arr\n\n    sum_val = sum(arr) c = 0\n    allocate(indices(n)) do i = 1, n\n        if (mod(sum_val - arr(i), n - 1) == 0) then\n            temp = (sum_val - arr(i)) / (n - 1)\n            if (temp == arr(i)) then\n                c = c + 1\n                indices(c) = i\n            end if\n        end if\n    end do\n\n    print '(I0)', c\n    write(*, '(*(I0,:,\" \"))') (indices(i), i=1, c)\n\nend program codeforces_134_A\n\nWait, but the line where temp is calculated: temp = (sum_val - arr(i)) / (n-1) \u2014 in Fortran, parentheses must match.",
      "start_char": 15580,
      "end_char": 16315,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "Oh, there's an extra closing parenthesis after arr(i). Wait, no, in the code:\n\ntemp = (sum_val - arr(i)) / (n-1) But the code should be:\n\ntemp = (sum_val - arr(i)) / (n - 1) Yes. So that's correct. Now, checking for possible division by zero when n=1. But as discussed earlier, if n=1, then n-1=0, and the code will attempt to compute mod(sum_val - arr(i), 0), which is undefined (division by zero). But Fortran's MOD function will throw a runtime error if the second argument is zero. So the code will crash, just like Java. So the code assumes that n is at least 2.",
      "start_char": 16316,
      "end_char": 16886,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "Which is consistent with the original Java code. So this should be the correct Fortran translation. Testing with sample input. Sample input 1:\n\n5\n1 2 3 4 5\n\nsum_val = 15\n\nfor each element i:\n\nCheck (15 - arr(i)) /4 == arr(i)\n\nSo for i=1: (15-1)/4=14/4=3.5. Not integer. So no.\n\ni=2: (15-2)/4=13/4=3.25. No.\n\ni=3: 12/4=3. 3 ==3 \u2192 yes. So index 3.\n\ni=4: 11/4=2.75. No.\n\ni=5: 10/4=2.5. No. So c=1, indices is [3].",
      "start_char": 16887,
      "end_char": 17301,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Output:\n\n1\n\n3\n\nSample input 2:\n\n3\n0 0 0\n\nsum is 0. Each element is 0. For each i:\n\nsum - arr[i] =0 \u2192 0 /2=0. So 0 ==0 \u2192 yes. All three elements. So c=3, indices 1 2 3. Output:\n\n3\n\n1 2 3\n\nAnother sample input where n=2, elements 3 and 3. sum=6. For each element:\n\nsum -3 =3. divided by 1 \u21923. Which equals 3. So both elements are valid. Output c=2, indices 1 2. So code should output:\n\n2\n\n1 2\n\nThus, the Fortran code should handle these cases correctly. Edge case where n=1 (even though the original code would crash). If someone inputs n=1, then in the loop, n-1=0, leading to division by zero in the MOD function. So the code will crash as expected, just like the Java code.",
      "start_char": 17302,
      "end_char": 17981,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Thus, the code should be correct.",
      "start_char": 17983,
      "end_char": 18016,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    }
  ],
  "original_reasoning": "Okay, I need to translate this Java code into Fortran. Let's start by understanding what the Java code does. \n\nFirst, it reads an integer n from the input. Then it reads n integers into an array arr. It calculates the sum of all elements in arr. Then it checks for each element in the array if (sum - arr[i]) divided by (n-1) equals arr[i]. If so, it counts those elements and records their indices (plus 1 because Java is 0-indexed but the output is 1-based). Finally, it prints the count and the indices.\n\nSo, in Fortran, I need to replicate this logic. Let's break it down step by step.\n\n1. Read the integer n. In Fortran, I'll use READ(*,*) n.\n\n2. Read the array of n integers. Since Fortran needs to know the size of the array at compile time, but here n is dynamic. Wait, in Fortran 90 and later, we can allocate arrays dynamically. So we can use ALLOCATABLE arrays. So:\n\n   INTEGER, ALLOCATABLE :: arr(:)\n   READ(*,*) n\n   ALLOCATE(arr(n))\n   READ(*,*) arr\n\nBut wait, in Java, the code reads each element in a loop. But Fortran can read the entire array in one line if the input is provided as space-separated values. So if the user inputs n, then enters n numbers on the next line(s), the READ(*,*) arr should work.\n\n3. Calculate the sum. Fortran has the intrinsic SUM function. So sum = SUM(arr).\n\n4. Then loop through each element. For each i from 1 to n (since Fortran arrays are 1-based by default), check if (sum - arr(i)) is divisible by (n-1), and if the division result equals arr(i). \n\nWait, in Java code, it's checking if (sum - arr[i]) % (n-1) == 0, and then (sum - arr[i])/(n-1) == arr[i]. So combining these two conditions. But if (sum - arr[i]) is divisible by (n-1), then the division will be exact. So in Fortran, we can compute (sum - arr(i)) / (n-1) and see if it equals arr(i). However, division of integers in Fortran truncates towards zero. But in Java, if the result is not an integer, the modulo would have caught it. So if the modulo is zero, then the division is exact.\n\nSo in Fortran, for each i:\n\nIF (MOD(sum - arr(i), n-1) == 0) THEN\n    temp = (sum - arr(i)) / (n-1)\n    IF (temp == arr(i)) THEN\n        increment count and record the index\n    END IF\nEND IF\n\nBut wait, since sum is the total sum, when we subtract arr(i), we get the sum of the other elements. If the average of the other n-1 elements (which is (sum - arr(i))/(n-1)) equals arr(i), then the condition holds. So yes, that's the check.\n\nNow, handling the indices. In Java, indices start at 0, and we add 1. In Fortran, the loop would be from 1 to n, so the index i itself is already 1-based. So when appending to the string, we just use i.\n\nNow, for building the string of indices. In Java, a StringBuilder is used. In Fortran, perhaps we can build a character string by concatenating the indices as strings. But since the number of elements could be up to n, which could be large, perhaps using a list (array) to store the indices and then output them all at once.\n\nAlternatively, we can collect the indices in an array, then loop through them to print. But the Java code first counts the number of valid indices (c), then prints c, followed by the space-separated indices.\n\nSo in Fortran:\n\n- Allocate an integer array to hold the indices (size up to n)\n- Initialize a counter c = 0\n- Loop over each i from 1 to n\n   if the condition holds, increment c and store i in the array\n- Then print c, followed by the first c elements of the array.\n\nAlternatively, since in Fortran dynamic strings are a bit tricky, perhaps collect the indices into a character variable as we go. Let's see.\n\nBut for efficiency, maybe collect the indices into an array, then print them. So:\n\nInitialize an array indices with size n.\n\ncount = 0\n\ndo i = 1, n\n   if (condition) then\n      count = count + 1\n      indices(count) = i\n   end if\nend do\n\nThen, print count, and the first count elements of indices.\n\nBut how to print them space-separated. Fortran can do formatted output. So something like:\n\nprint '(I0)', count\nif (count > 0) then\n   write(*, '(I0)') (indices(i), i=1, count)\nend if\n\nWait, but the format for the second line. If we have multiple elements, how to have them space-separated. The format (I0) for each element would print each on a new line, but Java's code uses a space. So perhaps use a format that includes the elements separated by spaces.\n\nSo for the indices line, we can use:\n\nwrite(*, '(*(I0,:,\" \"))') (indices(i), i=1, count)\n\nThe * in the format allows for variable numbers of items. The : in the format specifier suppresses the trailing space. So this format will output each integer followed by a space, except the last one. Alternatively, we can use a loop to build a string.\n\nAlternatively, we can loop through the indices and build a string. For example:\n\ncharacter(len=1000) :: buffer  ! assuming 1000 is enough\ninteger :: pos\n\npos = 1\ndo i = 1, count\n   write(buffer(pos:), '(I0, \" \")') indices(i)\n   pos = pos + len_trim(buffer(pos:)) + 1  ! move position\nend do\nif (count > 0) then\n   buffer = trim(buffer)  ! remove trailing space\nend if\nprint *, buffer\n\nBut this might be a bit complicated, especially with fixed buffer size. So perhaps the best approach is to use an array for the indices and then write them all in one go with a format that adds spaces.\n\nSo for example:\n\nprint *, count\nif (count > 0) then\n   write(*, '(*(I0,:,\" \"))') (indices(i), i=1, count)\nend if\n\nThis should work. The * allows any number of items, and the :\" \" adds a space between them but not at the end.\n\nPutting it all together.\n\nNow, handling division and modulo. In Java, the code uses integers. So in Fortran, the variables should be integers. So sum is integer, n is integer, etc.\n\nPotential issues:\n\n- Division in Fortran with integers uses integer division. But the modulo function here is MOD. But since in Java, the % operator returns the remainder with the same sign as the dividend. Fortran's MOD function does the same. So MOD(a, b) in Fortran is equivalent to a % b in Java when a and b are positive. But if a is negative, then MOD(a, b) is also negative (if I recall correctly). However, in this problem, since sum is the sum of positive numbers (assuming the input is correct?), but even if not, the code should handle negative numbers as per Java's logic. But the original code uses integers, so same in Fortran.\n\nSo the code in Fortran would be:\n\nprogram codeforces_134_A\n    implicit none\n    integer :: n, i, sum_val, c, temp\n    integer, allocatable :: arr(:), indices(:)\n    character(len=1000) :: buffer\n    integer :: pos\n\n    ! Read input\n    read(*,*) n\n    allocate(arr(n))\n    read(*,*) arr\n\n    sum_val = sum(arr)\n    c = 0\n    allocate(indices(n))\n\n    do i = 1, n\n        if ( (sum_val - arr(i)) == 0 ) then  ! avoid division by zero if n-1 is zero?\n            ! But n is the size of the array, which is read from input. So n >=1. But when n=1, n-1=0.\n            ! Wait, in the original code, if n is 1, then (n-1) is 0, leading to division by zero. But in Java, when n=1, the code will compute (sum - arr[0]) / 0, which will cause an exception. So the original code probably expects that n is at least 2. Or perhaps the problem constraints ensure that n >=2. But the code doesn't handle that. So in Fortran, same as Java. If n=1, then (n-1) is 0, and the code would divide by zero. So perhaps the problem's input constraints ensure that n >=2. Otherwise, we need to handle that.\n\nBut since the original code doesn't handle it, perhaps we can proceed under the same assumption.\n\nAssuming that n >=2. Otherwise, if n=1, then in the loop, (sum - arr[i]) is 0 (sum is arr[0], so 0). Then (sum - arr[i])/(n-1) is 0/0, which is undefined. So in Java, this would throw an exception. But perhaps the problem's input constraints ensure n >=2. So proceed.\n\nSo in Fortran, for each i:\n\nif (mod(sum_val - arr(i), n-1) == 0) then\n    temp = (sum_val - arr(i)) / (n-1)\n    if (temp == arr(i)) then\n        c = c + 1\n        indices(c) = i\n    end if\nend if\n\nYes.\n\nSo putting this all together.\n\nBut wait, in Java code, for n=1, (sum - arr[i]) is 0, and (n-1) is 0. So division by zero. But in Java, that code would throw an exception. So the problem probably requires that n >=2, and the test cases ensure that.\n\nNow, the code for Fortran:\n\nprogram codeforces_134_A\n    implicit none\n    integer :: n, i, sum_val, c, temp, ios\n    integer, allocatable :: arr(:), indices(:)\n\n    ! Read n\n    read(*,*, iostat=ios) n\n    if (ios /= 0) stop\n\n    ! Allocate and read array\n    allocate(arr(n))\n    read(*,*, iostat=ios) arr\n    if (ios /= 0) stop\n\n    sum_val = sum(arr)\n    c = 0\n    allocate(indices(n))\n\n    do i = 1, n\n        if (n - 1 == 0) cycle  ! avoid division by zero. But n >=1. If n=1, then n-1=0. So in this case, the loop would cycle, but c remains 0. Then output 0 and empty line. Which is same as Java's code when n=1, but in Java, the code would crash with division by zero. So perhaps in Fortran, if n=1, the code would output 0 and nothing. But the problem's input constraints may not allow n=1. So perhaps leave as is.\n\nBut in code, perhaps handle n=1?\n\nBut original code doesn't. So proceed.\n\nAssuming that n >=2.\n\nSo in the loop:\n\ndo i = 1, n\n    if (mod(sum_val - arr(i), n-1) == 0) then\n        temp = (sum_val - arr(i)) / (n-1)\n        if (temp == arr(i)) then\n            c = c + 1\n            indices(c) = i\n        end if\n    end if\nend do\n\nThen, output:\n\nprint *, c\nif (c > 0) then\n    write(*, '(*(I0,:,\" \"))') indices(1:c)\nend if\n\nWait, but when c=0, the second line (the indices) is printed as empty. In Java, when c is 0, sb is empty, so System.out.println(sb.toString()) prints an empty line.\n\nIn Fortran, when c=0, the second print is not executed, so the output is just the 0 followed by nothing. Which would differ from the Java code.\n\nAh, right. Because in Java, even if c is 0, it still prints the empty string, resulting in a blank line. So in Fortran, we need to print the blank line even if c is 0.\n\nWait, looking at the Java code:\n\nif c is 0, sb is empty. Then System.out.println(sb.toString()) appends a new line, so the output is:\n\n0\n<empty line>\n\nYes. Because the println method adds a new line. So in the Java code, two lines are printed: the first is the count (0), the second is the empty string with a new line.\n\nIn Fortran, the code should print the count, then the list of indices (which may be empty). But in Fortran, when using print *, the output adds a new line.\n\nSo, the code should:\n\nprint the count (with a new line), then print the indices (possibly empty), also with a new line.\n\nBut how to do that.\n\nIn Java code, the first line is System.out.println(c), which prints c followed by a new line.\n\nThe second line is System.out.println(sb.toString()), which prints the string followed by a new line. Even if the string is empty, this results in a new line.\n\nSo in Fortran, the equivalent would be to print the count, then print the list of indices (even if empty) followed by a new line.\n\nBut in Fortran, when you print an empty list, how does that work?\n\nFor example, if c=0, then the indices array's first 0 elements are printed. How does that work?\n\nIn Fortran, if we do:\n\nif (c > 0) then\n    write(*, '(*(I0,:,\" \"))') indices(1:c)\nelse\n    print *\nend if\n\nBut perhaps the second line (the indices) must always be printed, even if empty. So, in the Java code, even if there are zero indices, it prints an empty line.\n\nSo in Fortran, after printing the count, we need to print the list of indices (space-separated), followed by a new line. If there are zero indices, it's just a new line.\n\nSo perhaps:\n\nprint '(I0)', c\n\nif (c > 0) then\n    write(*, '(*(I0,:,\" \"))') (indices(i), i=1, c)\nelse\n    write(*, *)\nend if\n\nWait, but for the case when c=0, the second line would be written as an empty line. Let's see:\n\nIn Fortran, 'write(*,*)' prints a new line. But in the Java code, even when c=0, the second line is printed as a blank line.\n\nSo the code can be structured as:\n\nprint '(I0)', c\n\nif (c == 0) then\n    print *\nelse\n    write(*, '(*(I0,:,\" \"))') (indices(i), i=1, c)\nend if\n\nBut perhaps there's a more efficient way. Because even when c=0, the write statement with indices(1:0) (if allowed) would output nothing. Wait, in Fortran, when you have an array section like (indices(i), i=1, c) and c=0, the implied-do loop would have zero iterations, and the format would produce no output. But the WRITE statement would still output a new line.\n\nWait, let's test with a Fortran code snippet. Suppose:\n\nprogram test\n    implicit none\n    integer :: arr(0)\n    write(*, '(*(I0,:,\" \"))') (arr(i), i=1, 0)\nend program\n\nThis would have zero elements to write. The format (*(I0,:,\" \")) would have zero elements. So the output would be nothing, but in Fortran, when a WRITE statement has no data, it outputs nothing except for the current record. So in this case, the output is a blank line? Or no line?\n\nIn Fortran, when using a WRITE statement with format and no data items, like WRITE(*, '(A)') '', it would print a blank line. But if there are no data items and the format has no literals, like WRITE(*, '()'), it would output a blank line. But in this case, the format is (*(I0,:,\" \")), and there are zero data items. The * in the format would process zero data items, so the entire format is processed. So the output would be nothing. Then, the WRITE statement completes the current record, which is a line with zero characters. So when you print it, it's a blank line.\n\nWait, maybe not. Let me think. In Fortran, each WRITE starts a new record. The format specification is processed, even if there are no data items. If the format has no items that produce output (like if the data list is empty and the format has no literals), then the output is an empty record, which may be a blank line or not, depending on the system.\n\nBut when we have WRITE(*, '(*(I0,:,\" \"))'), with zero data items, the format would expand to zero I0 edits, each with optional space. So nothing is printed, but the WRITE statement will output a new line. So the output is a blank line. Wait, no. Because each WRITE statement outputs at least one record. Even if nothing is printed. So the WRITE statement would output a line with zero characters. Which, depending on the system, may appear as a blank line. For example, in terminal, a line with zero characters is a blank line.\n\nSo for the code:\n\nprint '(I0)', 0\nwrite(*, '(*(I0,:,\" \"))') \n\nBut how to pass zero elements. In the code, when c=0, (indices(i), i=1, c) would generate an empty list. So:\n\nwrite(*, '(*(I0,:,\" \"))') (indices(i), i=1, c) where c=0.\n\nThis would output a line with nothing. So the Java code's second line is a blank line. So in Fortran, after printing the count, the second line is blank if c=0.\n\nThus, in Fortran, the code can be written as:\n\nprint '(I0)', c\nwrite(*, '(*(I0,:,\" \"))') (indices(i), i=1, c)\n\nBut when c=0, this would output a line with nothing, which is the same as a blank line? Or not.\n\nBut in Java, the code prints two lines even when c=0. The first line is 0, the second is empty. So the Fortran code should print two lines as well.\n\nSo, the first print statement outputs c followed by a new line. The second write statement outputs the indices, and if there are none, outputs a new line with nothing. So two lines in total, which matches Java's behavior.\n\nSo the code:\n\nprint '(I0)', c\nwrite(*, '(*(I0,:,\" \"))') (indices(i), i=1, c)\n\nYes. Because when c=0, the implied-do loop has zero elements, so the write statement outputs a new line with nothing. So this should replicate the Java code's behavior.\n\nPutting it all together.\n\nPotential code:\n\nprogram codeforces_134_A\n    implicit none\n    integer :: n, i, sum_val, c, temp\n    integer, allocatable :: arr(:), indices(:)\n\n    read(*,*) n\n    allocate(arr(n))\n    read(*,*) arr\n\n    sum_val = sum(arr)\n    c = 0\n    allocate(indices(n))\n\n    do i = 1, n\n        if (mod(sum_val - arr(i), n - 1) == 0) then\n            temp = (sum_val - arr(i)) / (n - 1)\n            if (temp == arr(i)) then\n                c = c + 1\n                indices(c) = i\n            end if\n        end if\n    end do\n\n    print '(I0)', c\n    write(*, '(*(I0,:,\" \"))') (indices(i), i=1, c)\n\nend program codeforces_134_A\n\nWait, but the line where temp is calculated: temp = (sum_val - arr(i)) / (n-1) \u2014 in Fortran, parentheses must match. Oh, there's an extra closing parenthesis after arr(i). Wait, no, in the code:\n\ntemp = (sum_val - arr(i)) / (n-1)\n\nBut the code should be:\n\ntemp = (sum_val - arr(i)) / (n - 1)\n\nYes. So that's correct.\n\nNow, checking for possible division by zero when n=1. But as discussed earlier, if n=1, then n-1=0, and the code will attempt to compute mod(sum_val - arr(i), 0), which is undefined (division by zero). But Fortran's MOD function will throw a runtime error if the second argument is zero. So the code will crash, just like Java. So the code assumes that n is at least 2. Which is consistent with the original Java code.\n\nSo this should be the correct Fortran translation.\n\nTesting with sample input.\n\nSample input 1:\n\n5\n1 2 3 4 5\n\nsum_val = 15\n\nfor each element i:\n\nCheck (15 - arr(i)) /4 == arr(i)\n\nSo for i=1: (15-1)/4=14/4=3.5. Not integer. So no.\n\ni=2: (15-2)/4=13/4=3.25. No.\n\ni=3: 12/4=3. 3 ==3 \u2192 yes. So index 3.\n\ni=4: 11/4=2.75. No.\n\ni=5: 10/4=2.5. No.\n\nSo c=1, indices is [3]. Output:\n\n1\n\n3\n\nSample input 2:\n\n3\n0 0 0\n\nsum is 0. Each element is 0.\n\nFor each i:\n\nsum - arr[i] =0 \u2192 0 /2=0. So 0 ==0 \u2192 yes. All three elements. So c=3, indices 1 2 3.\n\nOutput:\n\n3\n\n1 2 3\n\nAnother sample input where n=2, elements 3 and 3. sum=6.\n\nFor each element:\n\nsum -3 =3. divided by 1 \u21923. Which equals 3. So both elements are valid. Output c=2, indices 1 2.\n\nSo code should output:\n\n2\n\n1 2\n\nThus, the Fortran code should handle these cases correctly.\n\nEdge case where n=1 (even though the original code would crash). If someone inputs n=1, then in the loop, n-1=0, leading to division by zero in the MOD function. So the code will crash as expected, just like the Java code.\n\nThus, the code should be correct."
}