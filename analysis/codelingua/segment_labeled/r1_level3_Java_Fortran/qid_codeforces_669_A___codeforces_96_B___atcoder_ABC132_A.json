{
  "segments": [
    {
      "text": "We are going to chain three programs. Only the first reads the initial input, and only the last produces the final output. The intermediate results are passed as in-memory data. Steps:\n 1. The first Java program (codeforces_669_A) reads an integer `n` and computes:\n        result1 = (n / 3) * 2 + (if n mod 3 == 0 then 0 else 1)\n\n 2. The second Java program (codeforces_96_B) takes a number (which will be the output of the first program) and does:\n        It searches for the smallest number (>= the input) that is composed of an even number of digits, \n        with exactly half being '4' and half being '7'. The number is generated by iterating over binary masks. 3.",
      "start_char": 0,
      "end_char": 673,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "The third Java program (atcoder_ABC132_A) takes a string (which will be the string representation of the output of the second program) and checks:\n        - The string has exactly 2 distinct characters.\n        - Each distinct character appears exactly twice.",
      "start_char": 676,
      "end_char": 935,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "However, note: the output of the first program is an integer, which becomes the input to the second program (as a long).",
      "start_char": 938,
      "end_char": 1058,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "The output of the second program is a long, which we convert to a string to feed to the third program. Therefore, the chain is:\n   input (integer) -> first program -> integer result1 -> second program -> long result2 -> third program -> string result3 -> output\n\n Important: The second program expects a long, and the third program expects a string. But note: the first program's output is an integer, but the second program reads a long. We can convert the integer to a long.",
      "start_char": 1060,
      "end_char": 1540,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Plan for Fortran:\n\n  We will write a single program that:\n    - Reads the initial integer (like the first program).\n    - Computes the result of the first program (call it `res1`).\n    -",
      "start_char": 1543,
      "end_char": 1729,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Then, using `res1` as the starting point, we simulate the second program to find the next super lucky number (call it `res2`).\n    - Then, convert `res2` to a string and check the conditions of the third program. However, note the second program uses a while loop that starts with a mask and increments until the generated number is >= the input. Steps for the second part (simulating the second Java program): We note that the second program:\n        long number = ... (which is our `res1`)\n        long ans = -1, value = 0;\n        int mask = 2;\n        while (value < number) {\n            String s = Integer.toBinaryString(mask++).substring(1);\n            //",
      "start_char": 1730,
      "end_char": 2406,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "This binary string has no leading '1' (because of substring(1)) so it's of length (mask-1) in bits? \n            // Actually, the mask starts at 2: binary of 2 is \"10\" -> substring(1) becomes \"0\" -> then we replace: becomes \"4\" -> value=4 -> if 4 < number? \n            // But note: mask is incremented, so next is 3: binary \"11\" -> substring(1) is \"1\" -> becomes \"7\" -> value=7.\n            // Then mask=4: binary \"100\" -> substring(1) is \"00\" -> becomes \"44\", then mask=5: \"101\" -> \"01\" becomes \"47\", mask=6: \"110\" -> \"10\" becomes \"74\", mask=7: \"111\" -> \"11\" becomes \"77\", mask=8: \"1000\" -> \"000\" becomes \"444\", etc. The idea: the mask is used to generate a bit string of length (number of bits in mask-1). The substring(1) removes the leading '1'. Then we count zeros (which are the bits that are 0). We require that the number of zeros equals the number of ones? Actually, the condition is:\n                if (zeros != s.length() - zeros) continue;\n            which means we require that the number of zeros equals the number of ones. So the string must have even length and exactly half zeros and half ones. Then we replace '0' with '4' and '1' with '7' to form a number. We break when we get a number >= the input. So we need to generate these numbers in increasing order until we find one >= `res1`. How to do in Fortran? We can do a similar loop: start with mask=2, and then for each mask:\n            - Convert mask to a binary string without the leading '1' (so the length is the number of bits of mask minus one).\n            - Check if the length is even? Actually, the condition (zeros == length/2) requires even length. So we can skip if the length is odd? But the condition is checked by counting. However, note: the mask starts at 2 and increases. The generated string length is (bit_length(mask)-1). We require the same number of zeros and ones. We can simulate the same process. Steps for a given mask:\n            len_bin = bit_size of mask?",
      "start_char": 2407,
      "end_char": 4472,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Actually, we can get the binary representation and then remove the leading '1'. But note: in Java, Integer.toBinaryString(2) is \"10\", then substring(1) is \"0\". For 3: \"11\" -> \"1\". For 4: \"100\" -> \"00\", for 5: \"101\" -> \"01\", etc.\n\n        How to get the binary representation without the leading 1 in Fortran? We can compute the position of the leading 1 and then take the rest. Alternatively, we can note that the mask starts at 2 and then increases. The length of the string for mask is (floor(log2(mask))). Actually, the number of bits without the leading one is floor(log2(mask)). But we can generate the binary string by:\n\n          Let nbits = bit_size(mask) [but we don't know the size, so we can use bit_len = floor(log2(real(mask))) + 1, then the string without the first bit is the last (bit_len-1) bits?] However, Fortran doesn't have built-in for binary string. We can use bit manipulation.",
      "start_char": 4473,
      "end_char": 5411,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Alternatively, we can generate the binary representation of mask and then remove the first character? But we have to be careful: we want exactly the bits from the first set bit to the end? Actually, the Java method gives the minimal representation. We can compute the length of the binary representation of mask: \n          len = floor(log2(real(mask))) + 1\n          Then the binary string without the first character is the last (len-1) bits? Actually, the first character is always '1'. So we can generate the binary representation for (mask - 2**(len-1)) in (len-1) bits. But note: mask=2: len=2 -> then we take the last 1 bit: which is the low bit? Actually, the binary representation of 2 is '10', and without the first bit is '0'. How to generate the (len-1) bits? We can take the bits from position len-2 down to 0.",
      "start_char": 5421,
      "end_char": 6272,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Steps for a mask (integer, but note: mask in the Java program is an int and we are starting at 2, then increasing. The numbers are not huge at first, but note: the output of the first program might be large? The first program: input n, then res1 = (n/3)*2 + (if mod(n,3)==0?0:1). So if n is large, then res1 might be up to about 2e9? But the mask is an int, so it can go up to 2^31. But the generated numbers (as strings) have length (bit_length(mask)-1). The maximum length we can get is 30 (for mask up to 2^31, the binary string without the first bit is 31-1=30). Then the number of digits is 30, which is 15 fours and 15 sevens -> that number is 4.4.. * 10^30, which is beyond Fortran's integer kind?",
      "start_char": 6282,
      "end_char": 6986,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "However, the problem: we are storing the generated number as a long in Java? But in Fortran, we need to store a number that can be up to 30 digits. We can use character strings? But the condition is we need to compare with `res1` (which is integer, so at most 10 digits) and then we break when we get the first number that is >= res1. So we don't need to go to 30 digits? Because res1 is at most about 666e6? (if n is 1e9, then res1 = (1e9/3)*2 + 1 = about 666666667). So we only need numbers that are at most 9 or 10 digits? How many digits? The smallest number with 2 digits: 44, 47, 74, 77 -> 4 numbers. Then 4 digits: 4444, 4447, ... -> 6? Actually, the number of digits is even: 2,4,6,... up to 10? Then the maximum we need is 10 digits? 10-digit numbers: 10^10 is about 10 billion, which fits in an 8-byte integer? In Fortran, we can use integer(kind=8) for numbers up to 10^18. So we can do:\n\n          Let `start` = res1 (from the first program) as an integer(kind=8) Then we iterate mask from 2 upwards until we find a number >= start. For each mask, we:\n            - Compute the length of the binary representation of mask: len_bin = floor(log2(real(mask, kind=8))) + 1\n            - Then the number of bits we care about is len_str = len_bin - 1 [because we remove the leading one]\n\n            - If len_str is odd, we skip? Actually, the condition (zeros == ones) requires that the length is even? So we can skip if mod(len_str,2) /= 0? But note: the condition is checked by counting. We can skip if the length is odd because then zeros != ones. So to save time, we can skip odd lengths.",
      "start_char": 6997,
      "end_char": 8640,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "- Then we extract the bits for the mask without the leading one: that is the lower (len_bin-1) bits. - We can form a string of length = len_str: do j = len_str-1 downto 0\n                      if the j-th bit (counting from 0 as the least significant) is set? Then we put '1', else '0'\n\n            - Then we count the number of zeros. If the count of zeros is not len_str/2, skip. - Then we form the number: replace '0' with '4', '1' with '7', and then convert the string to an integer(kind=8) -> call this `value`\n\n            - If value >= start, then we break and set `res2 = value`\n\n          Then we pass `res2` to the third program as a string. 3.",
      "start_char": 8654,
      "end_char": 9353,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "The third program (atcoder_ABC132_A) takes a string and checks:\n        - It has exactly 2 distinct characters, and each appears exactly twice. But note: the string we are passing is the string representation of `res2` (which is a number). How long is the string? It can be 2,4,6,... up to 10 or 12? \n\n    Conditions:\n        - The string must have exactly two distinct characters? Actually, the program checks: \n            for each character in the string, count the frequency -> then check that each of the two distinct characters appears twice? But note: the program doesn't assume the string length is 4?",
      "start_char": 9356,
      "end_char": 9970,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "It counts the frequency of each character and then checks that every character that appears has frequency 2? And also that there are exactly 2 distinct characters.",
      "start_char": 9981,
      "end_char": 10144,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "However, the number we generated (res2) is composed only of '4' and '7'. So the distinct characters must be only two: '4' and '7'. But the program doesn't know that. Also note: the string might be of even length (say L) and we require that each character appears exactly L/2 times? Actually, the program only requires that each character that appears does so exactly twice? That is incorrect for the original problem?",
      "start_char": 10154,
      "end_char": 10581,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Let me check the original problem: atcoder_ABC132_A. The problem says: \n          \"Given a string S of length 4.",
      "start_char": 10592,
      "end_char": 10704,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Determine if S is made up of exactly two kinds of characters, each appearing exactly twice.\" So the string length is always 4? Then the condition is: two distinct characters and each appears twice. But in our chain, the string we are passing is the string representation of res2. What is the length of res2? It can be 1? Actually, no: because we generate numbers with even digits (2,4,6,...). So the length is even. However, the original problem (atcoder_ABC132_A) expects a string of length 4? But note: the problem statement in the code: \n            String s = in.next();\n            char [] targ = s.toCharArray();\n\n        and then the map counts the frequency.",
      "start_char": 10705,
      "end_char": 11398,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "It doesn't specify the length. But the problem says \"Given a string S of length 4\" in the contest. So we must assume that the string we get from res2 has length 4?",
      "start_char": 11399,
      "end_char": 11562,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "However, our res2 is generated by the second program: it can be 2,4,6,... digits. So the length might be 2,4,6, etc. The third program in the chain is written for a string of length 4?",
      "start_char": 11573,
      "end_char": 11767,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Actually, no: it counts the frequency and then checks that each character appears exactly twice and that there are two distinct characters.",
      "start_char": 11768,
      "end_char": 11907,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "This condition is independent of the length? But wait: the condition \"each character appears exactly twice\" implies that the total length must be 4? Because if we have two distinct characters, each appearing twice, then total length=4. So the third program expects a string of length 4? Then what if the string we get from res2 is not 4? Then the condition will fail. But note: the second program produces numbers that are composed of even digits, but the length can be 2,4,6,... How can we have a string of length 4? The second program produces the smallest super lucky number >= res1. If res1 is 1, then the first super lucky number is 4 (length=1? no, 4 is one digit -> but wait: the second program: \n            mask=2: binary \"10\" -> substring(1)=\"0\" -> becomes \"4\" -> value=4 -> then we break? Then the string \"4\" is passed to the third program? The third program: \n            It has one distinct character? Then it fails -> prints \"No\". But the chain: \n            Input: 1 -> first program: res1 = (1/3)*2 + 1 = 0*2+1 = 1 -> then second program: outputs 4 -> then third program: outputs \"No\". However, the original second program: \n            It starts at mask=2: produces 4 -> since 4>=1 -> output 4. So the chain does not require the third program to get a string of length 4?",
      "start_char": 11908,
      "end_char": 13277,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Therefore, we must note: the third program in the chain is being used with any string (the string representation of res2). The program checks:\n            - The string has exactly two distinct characters? \n            -",
      "start_char": 13297,
      "end_char": 13516,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "And each distinct character appears exactly twice? But if the string has length 2, then we would have two distinct characters? and each appearing once? -> fails. If the string has length 4, then two distinct characters each twice -> passes. Actually, the condition in the third program: \n            for (Entry<Character, Integer> c : map.entrySet()) {\n                if (c.getValue() ! = 2) {\n                    ok = false;\n                    break;\n                }\n            }\n            and then also we check map.size()==2? So it requires that every character appears exactly twice and that there are two distinct characters. This condition can only be satisfied if the string length is 4? (because 2 distinct * 2 = 4). Therefore, if the string has length 2: then we have two characters? but each must appear twice? -> impossible.",
      "start_char": 13517,
      "end_char": 14415,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Similarly, for length 6: we would require each of two characters to appear twice? that would be 4, not 6. So the condition is only satisfied for strings of length 4? But note: what if we have a string of length 4 with three distinct characters? e.g., \"4477\": two distinct, each twice -> yes. \"4444\": one distinct, fails. \"4455\": two distinct, but each twice? -> yes?",
      "start_char": 14425,
      "end_char": 14829,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "However, the second program only produces numbers with digits '4' and '7'. So the string will be composed of '4' and '7'.",
      "start_char": 14840,
      "end_char": 14961,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Therefore, the condition for the third program to output \"Yes\" is:\n            - The string has length 4, and it has exactly two distinct characters (which must be '4' and '7') and each appears twice? But note: the condition does not care about which characters, only the frequency.",
      "start_char": 14972,
      "end_char": 15254,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "However, the second program only produces '4' and '7'. So the distinct characters are '4' and '7'. So the third program will output \"Yes\" if and only if the string has length 4 and has two '4's and two '7's? But what if the string has length 4 and has three '4's and one '7'? Then the condition fails. So the chain: Input n -> first program -> res1 -> second program finds the super lucky number (which is a number with even length and half the digits are '4' and half are '7') -> then we check if this number (as a string) has length 4 and exactly two of each? But note: the super lucky number can be 44, 47, 74, 77 (length=2) -> then the third program: \n            distinct characters: {'4','7'} -> two distinct? yes. frequency: each appears once? -> fails. So the third program will output \"No\" for a 2-digit super lucky number. The original chain doesn't care about the internal conditions? It just chains the programs. Therefore, we must implement the third program as given: Convert the number `res2` to a string (call it `s`)\n            Build a frequency map for the characters in `s`\n            Check: \n                if the map has size 2 AND every key in the map has value 2 -> then print \"Yes\"\n                else print \"No\"\n\n        But note: the condition \"every key has value 2\" implies the string length is 4?",
      "start_char": 15265,
      "end_char": 16700,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Actually, if the string length is not 4, then the condition fails. So the third program is independent of the length? It will work for any string. Implementation:\n\n   Steps:\n\n     Step 1: Read the initial integer `n` (like the first program). Step 2: Compute `res1` = (n/3)*2 + (if mod(n,3)==0 then 0 else 1)\n\n     Step 3: Convert `res1` to integer(kind=8) (it's an integer, but we will use it as the starting point for the second program). Step 4: Find the next super lucky number (>= res1) as described. We'll use an integer(kind=8) for `value` and `start`. We start with mask=2 (as integer) and then increment mask until we find a value >= start. How to generate the binary string without the leading one for a given mask (integer)? Let's define:\n            len_bin = number of bits in the binary representation of mask (without leading zeros) -> this is floor(log2(real(mask, kind=8)))+1\n            len_str = len_bin - 1 [the number of bits we use]\n\n          We skip if len_str is 0? (mask=1: but mask starts at 2) -> no. Then we extract the lower len_str bits? Actually, the binary representation of mask is: \n                mask = 2^(len_bin-1) +",
      "start_char": 16701,
      "end_char": 17931,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "x, where x is in the range [0, 2^(len_bin-1)-1]\n          The bits we want are the representation of x in len_str bits. How to extract the bits? We can do:\n\n            bits: do i = len_str-1 downto 0\n                     bit = (mask - 2**(len_bin-1))   ... but wait, we can use bit-level operations. Alternatively, we can note: the entire mask has len_bin bits. We want the last len_str bits? Actually, the representation without the leading one is the trailing len_str bits. How to get the i-th bit (from the least significant, starting at 0) of (mask)? bit = mod(mask / 2**i, 2)   -> but we are only interested in the bits from position (len_bin-2) down to 0? Actually, the leading one is the highest bit (at position len_bin-1). We want the bits from position len_bin-2 down to 0. We can do:\n\n            temp = mask - 2**(len_bin-1)",
      "start_char": 17932,
      "end_char": 18842,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "[this gives the value without the leading one? but actually, it does]\n\n          Then we can convert `temp` to a binary string of length `len_str`? But we don't need the string for the entire mask, we can use bit manipulation. However, we need to count the zeros and ones.",
      "start_char": 18845,
      "end_char": 19128,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "We can traverse the bits from 0 to len_str-1? But note: the representation of `temp` in len_str bits: the bit at position j (0-indexed from the least significant) is the j-th bit from the right. How to get the j-th bit (from the most significant) in the string? In the string, the first character is the most significant? We can form the string by: do j = len_str-1 downto 0\n                bit_j = mod(temp / 2**j, 2)   -> but that gives the j-th bit from the least significant? Actually, we want the most significant bit of the substring to be the highest bit of temp? Alternatively, we can shift and mask: We traverse j from 0 to len_str-1: \n                bit = mod(temp, 2)   -> the least significant bit\n                then temp = temp / 2\n            but then we get the bits in reverse order. Or we can traverse from the highest bit:\n\n            do j = len_str-1, 0, -1\n                if (temp has the j-th bit set) -> then the bit is 1? But note: j here is the exponent?",
      "start_char": 19129,
      "end_char": 20221,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Actually, the bits in the number `temp` are stored in base2, and the j-th bit from the most significant is the (len_str-1 - j) bit?",
      "start_char": 20234,
      "end_char": 20365,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Instead, we can avoid building the string and count the bits:\n\n            We can count the number of ones in the lower `len_str` bits of `mask`? But note: we removed the leading one? Actually, the entire mask has len_bin bits. We are taking the lower len_str bits?",
      "start_char": 20378,
      "end_char": 20643,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Actually, the mask is represented in len_bin bits: the highest bit is set. Then the rest (len_str bits) are the bits we care about. So the number of ones in the entire mask is: 1 (the leading) plus the popcount of the lower len_str bits? But we don't care about the leading one?",
      "start_char": 20656,
      "end_char": 20934,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "We are only interested in the substring of bits (without the leading one). So we can count the number of ones in the lower len_str bits? How to get the lower len_str bits? bits = mask - 2**(len_bin-1)   ->",
      "start_char": 20958,
      "end_char": 21189,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "this gives a number that has at most len_str bits. Then the number of ones in the bits? But note: the condition is that the substring has exactly half ones? So we require that the popcount of bits equals len_str/2? However, the condition in the second program: zeros = len_str - ones, and we require zeros==ones -> so ones = len_str/2. Therefore, we require:\n            popcount(bits) = len_str/2 [and also we skip if len_str is odd? because then len_str/2 is not integer]\n\n          So we can do:\n\n            if (mod(len_str,2) /= 0) cycle   ! skip odd lengths\n\n            pop = popcnt(bits)   ! but note: the bits variable is an integer, and we are only interested in the len_str bits? However, the variable `bits` is exactly the value in the lower len_str bits? Then if popcount(bits) == len_str/2, then we form the number by:\n\n            We want to form a string: for each bit in the bits (from the most significant to the least) we output:\n                if the bit is set -> '7'\n                else -> '4'\n\n          How to get the bits in the string from the most significant to the least? We can do:\n\n              do j = len_str-1 downto 0\n                 if (btest(bits, j)) then ...   -> but note: the bits are stored as a number.",
      "start_char": 21190,
      "end_char": 22524,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "The j-th bit (starting from 0 as the least significant) is the j-th bit from the right. But we want the most significant bit (which corresponds to the highest power) to be the first character.",
      "start_char": 22525,
      "end_char": 22717,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "The highest bit in the substring (which was the bit at position len_bin-2 in the mask) is the (len_str-1)-th bit of the number `bits`? Actually, the number `bits` is in the range [0, 2^(len_str)-1].",
      "start_char": 22745,
      "end_char": 22957,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "The most significant bit is the bit at position (len_str-1) (counting from 0 at the least significant). So we can traverse j from len_str-1 down to 0:\n\n                if (bits has the bit set at position j) then the digit is '7'\n                else '4'\n\n            Then we form the string and convert to an integer(kind=8). However, we don't need to form the string? We can form the number directly? The number: each digit is 4 or 7. We can compute:\n\n            value = 0\n            do j = len_str-1 downto 0\n                if (btest(bits, j)) then\n                    digit = 7\n                else\n                    digit = 4\n                end if\n                value = value * 10 + digit\n\n          But note: the bits are stored in the variable `bits` as a base2 number. The j we are iterating is the bit position?",
      "start_char": 22958,
      "end_char": 23823,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "However, the bits in `bits` are stored as a base2 number, and the bit at position j (0-indexed from the least significant) is the j-th bit. But we want to traverse from the highest bit (which is position len_str-1) to the lowest (position 0). Example: mask=5 -> len_bin=3 -> len_str=2. Then bits = 5 - 2**(2) = 5-4=1. The binary representation of 1 in 2 bits: \"01\". We want to form the number: first digit: from the highest bit (bit1) -> 0 -> then digit=4; then bit0: 1 -> then digit=7 -> so the number is 47. How to get the highest bit? The highest bit in the 2-bit representation is bit1 (which is the 2^1 bit).",
      "start_char": 23836,
      "end_char": 24498,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "We can check the bit at position j for j from len_str-1 down to 0. But note: the number `bits` might not have the full len_str bits? Actually, we have exactly len_str bits? because we subtracted 2**(len_bin-1), and then we are representing it in len_str bits? So we can do:\n\n            do j = len_str-1, 0, -1\n                if (bits has the j-th bit set) then ... \n\n          How to check? We can use:\n\n            if (btest(bits, j)) then ...   -> but Fortran's btest tests the j-th bit from the least significant? meaning j=0 is the lowest. But we want the j-th bit from the most significant?",
      "start_char": 24511,
      "end_char": 25131,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Alternatively, we can note: the bit we want at the first character is the bit at position (len_str-1) in the entire `bits`?",
      "start_char": 25156,
      "end_char": 25279,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Actually, we are storing the bits in an integer, and the integer has the bits in little-endian? But btest is independent: it tests the bit at position j (0-indexed from the least significant). So the most significant bit in the substring is the bit at position (len_str-1) of the integer? Example: for bits=1 (binary \"01\" in 2 bits): \n            j=0 -> least significant -> 1\n            j=1 -> next -> 0\n\n          But we want to output the most significant first -> so we want to start at j=1 and then j=0.",
      "start_char": 25292,
      "end_char": 25825,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Therefore, we traverse j from len_str-1 down to 0, and for each j we check the bit at position j? \n\n          But wait: the bit at position j (with j being the exponent) is the same as the (len_str-1 - j) bit from the most significant?",
      "start_char": 25837,
      "end_char": 26072,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Actually, no: the bits are stored in base2: the j-th bit (0-indexed from the least significant) is the coefficient for 2^j. We want to output the most significant first: that is the bit for 2^(len_str-1) first. So we should traverse j from len_str-1 down to 0, and at each step we check the bit at position j? -> that would be the same as the exponent? But note: the bit at position j (0-indexed from the least) is the j-th bit. The highest bit is at position len_str-1? So we can do:\n\n            do j = len_str-1, 0, -1\n                if (btest(bits, j)) then   -> but j is the exponent? then the bit at exponent j is set. Then the first digit we output is for the highest exponent? That's correct. Example: bits=1 (which is 2^0) -> then for j=1: we check if bit1 is set -> no -> then we output 4; for j=0: set -> output 7 -> so the number is 47. That matches. Therefore, we can form the number without building a string? But note: the number might be too big? We are forming a decimal number from a string of up to 30 digits? But we break when we find a number >= res1 (which is at most about 666e6) so we only go up to 10 digits? 10 digits: 10^10 is 10 billion, which is within the range of integer(kind=8) (max ~9e18). So we can form the number by:\n\n          value = 0\n          do j = len_str-1, 0, -1\n             if (btest(bits, j)) then\n                 digit = 7\n             else\n                 digit = 4\n             end if\n             value = value * 10 + digit\n\n        But note: the variable `bits` is an integer. We are using j from len_str-1 down to 0? However, we must be cautious: the bit position j must be in the range [0, len_str-1]. And we have ensured that `bits` has at most len_str bits?",
      "start_char": 26085,
      "end_char": 27920,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Actually, `bits` is in the range [0, 2**len_str - 1]. But note: the mask might have more than len_str bits? No, because we subtracted the leading one, and the rest are exactly len_str bits. Therefore, we can do:\n\n          if (mod(len_str,2) == 0) then   ! only even lengths\n             pop = popcnt(bits)   ! intrinsic function? Fortran 2008 has popcnt, but we can also count by btest over j from 0 to len_str-1? if (pop == len_str/2) then   ! condition for same number of zeros and ones? but note: zeros = len_str - pop, and we require zeros==pop -> so pop==len_str/2.\n                 ! form the number\n                 temp_value = 0\n                 do j = len_str-1, 0, -1\n                    if (btest(bits, j)) then\n                        digit = 7\n                    else\n                        digit = 4\n                    end if\n                    temp_value = temp_value * 10_8 + digit\n                 end do\n                 if (temp_value >= start) then\n                    res2 = temp_value\n                    exit   !",
      "start_char": 27921,
      "end_char": 28995,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "break the mask loop\n                 end if\n             end if\n          end if\n\n        But note: the mask is an integer that can be large?",
      "start_char": 28996,
      "end_char": 29137,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "However, the value we are looking for is at most 10 digits? So len_str is at most 10? Then the mask: \n            The mask starts at 2, and the mask for a string of length L is at least 2^L? and then we subtract the leading one. For L=10: mask_min = 2^10 = 1024. We start at mask=2 and go up to at least 1024? We can break when we find a value >= start. But note: the mask is incremented until we find one. The mask for the 10-digit numbers: the mask starts at 2^10=1024?",
      "start_char": 29138,
      "end_char": 29642,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Actually, the mask for the first 10-digit super lucky number: \n            We want a binary string without the leading one of length 10? So the mask is 2^10 + x, where x is the value we use for the bits. So we iterate mask from 2 to ... until we get a value that is >= start and satisfies the condition. But note: the mask for a substring of length L is in the range [2^L, 2^(L+1)-1]. We can iterate by length? But the original program iterates mask without regard to length? However, the super lucky numbers are generated in increasing order? Not exactly: \n            mask=2 -> \"0\" -> 4\n            mask=3 -> \"1\" -> 7\n            mask=4 -> \"00\" -> 44\n            mask=5 -> \"01\" -> 47\n            mask=6 -> \"10\" -> 74\n            mask=7 -> \"11\" -> 77\n            mask=8 -> \"000\" -> skip (odd length)\n            mask=9 -> \"001\" -> skip (odd length) ... until mask=16: \"0000\" -> 4444\n\n        But 44 (mask=4) is 44, which is greater than 7? But we break as soon as we find a value >= start? So if start=1, we break at mask=2? So we are generating in increasing order?",
      "start_char": 29643,
      "end_char": 30749,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Actually, 4 < 7 < 44 < 47 < 74 < 77 < 4444 ... But 4444 is 4 digits and 4444 > 77? So the order is increasing by the numerical value? But the mask iteration: \n            mask=2: value=4\n            mask=3: value=7\n            mask=4: value=44 -> 44>7? so if start=5, then we break at mask=3 (value=7) because 7>=5? But then we skip 44? which is the next super lucky number? Actually, the condition in the while loop is: we break at the first super lucky number that is >= start. And we generate in increasing order? However, the mask iteration does not generate in increasing numerical order? mask=2: 4\n            mask=3: 7 -> which is greater than 4 -> okay. mask=4: 44 -> which is greater than 7? -> no, 44>7 -> so we break at 7? But wait: 44 is 44, which is greater than 7? So if we are looking for the first super lucky number >=5, we break at 7? Then what about 44? It is generated later?",
      "start_char": 30760,
      "end_char": 31760,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Actually, the condition: we break as soon as we find one? So we don't generate all super lucky numbers? But the original program: \n            It starts at mask=2 and increments mask until it finds the first super lucky number that is >= the input. How does it generate 44? When the input is 8: mask=2: 4 <8 -> skip\n                mask=3: 7 <8 -> skip\n                mask=4: 44>=8 -> break -> output 44. But 44 is the next super lucky number after 7?",
      "start_char": 31781,
      "end_char": 32282,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "However, note: the super lucky numbers: \n            4,7,44,47,74,77,4444,4447,... So 44 is the next after 7? And our mask=4 produces 44? Therefore, the mask iteration does generate in increasing order? Why? Because the mask increases, and the value produced by mask is:\n\n            value = f(mask) = number formed by replacing 0->4, 1->7 in the binary representation of mask without the leading one.",
      "start_char": 32302,
      "end_char": 32743,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "The binary representation of mask without the leading one: the length is increasing as mask increases. And for the same length, the value increases? Example for length=2: mask=4: \"00\" -> 44\n            mask=5: \"01\" -> 47\n            mask=6: \"10\" -> 74\n            mask=7: \"11\" -> 77\n\n        Then next mask=8: length=3 (skip because odd) -> mask=9: \"001\" -> skip (odd) ... mask=16: length=4 -> \"0000\" -> 4444. So the values: 44,47,74,77, then 4444? And 44<47<74<77<4444? So the mask iteration produces the super lucky numbers in increasing order? Therefore, we can iterate mask from 2 upward and break at the first value that is >= start. However, note: the mask might become very large? But we break when the value is >= start, and start is at most about 666e6? The first super lucky number with 10 digits is 4444444444 (which is 4e9) -> which is greater than 666e6? So we break at the first super lucky number that is >= start, which might be a 2,4,6,8, or 10-digit number. The maximum mask we need: for a super lucky number of 10 digits, the mask starts at 2^10 = 1024 and goes up to 2^11-1? But we break as soon as we form the first 10-digit number that is >= start? And the 10-digit numbers start at 4444444444 (4e9) and go up? But if start is 5000000000, then we break at the first 10-digit super lucky number that is >=5000000000? How many masks? For 10 digits, the mask ranges from 1024 to 2047? and we skip the masks that do not have exactly 5 ones? Then we form the number and compare?",
      "start_char": 32753,
      "end_char": 34358,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "This is acceptable because 2^11 is only 2048. So we can iterate mask from 2 to a sufficiently large number?",
      "start_char": 34369,
      "end_char": 34476,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "We can set an upper bound: for example, we know that the number of digits we need is at most 60? But we break when the value is found.",
      "start_char": 34486,
      "end_char": 34620,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, we can break when the length of the substring (len_str) becomes too large? But we don't know. We can set an upper bound for mask?",
      "start_char": 34630,
      "end_char": 34784,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "For example, we know that the value we are looking for is at least the start (which is at most 666e6) and the next super lucky number is at most 10 digits? 10 digits: the mask for the first 10-digit number is 1024? Actually, the mask for the first 10-digit number is 2^10 = 1024? Then we break at mask=1024? But wait: we might have to iterate over many masks for the same length? For 10 digits, we have to iterate masks from 1024 to 2047? and we skip masks that do not have exactly 5 ones? The number of masks for 10 digits: we require 5 ones in the 10 bits? C(10,5)=252. So we iterate 252 masks? Then we form the number and compare? So we can do:\n\n          start = res1   (as int64)\n\n          mask = 2\n          found = .false. do while (.not. found)\n             ! compute len_bin = floor(log2(real(mask, kind=8))) + 1   [number of bits in mask]\n             len_bin = 0\n             temp_mask = mask\n             do while (temp_mask > 0) len_bin = len_bin + 1\n                 temp_mask = rshift(temp_mask, 1)   ! or temp_mask = temp_mask/2\n             end do\n             ! Actually, we can use bit_size? But we want the minimal number of bits. \n             ! Alternatively, we can compute: \n             ! if (mask==0) then len_bin=0; else len_bin = floor(log(real(mask, kind=8))/log(2.0)) + 1\n\n             len_str = len_bin - 1   ! we remove the leading one. if (len_str <= 0) then   ! skip if no bits? but mask>=2 -> len_bin>=2 -> len_str>=1.\n                 ! skip?\n             end if\n\n             if (mod(len_str,2) == 0) then   ! even length\n                 ! Extract the bits: the value without the leading one is: bits = mask - 2**(len_bin-1)\n                 bits = mask - 2**(len_bin-1)   ! note: 2**(len_bin-1) is the value of the leading one.\n\n                 ! Count the number of ones in the lower len_str bits? But note: bits has exactly len_str bits? pop = 0\n                 do j = 0, len_str-1\n                    if (btest(bits, j)) pop = pop + 1\n                 end do\n\n                 if (pop == len_str/2) then   ! condition\n                    ! form the number from the bits: from the highest bit to the lowest? \n                    temp_value = 0\n                    do j = len_str-1, 0, -1   !",
      "start_char": 34785,
      "end_char": 37131,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "j from high to low: we want the highest bit to be the first digit\n                       if (btest(bits, j)) then\n                           digit = 7\n                       else\n                           digit = 4\n                       end if\n                       temp_value = temp_value * 10 + digit\n                    end do\n\n                    if (temp_value >= start) then\n                       res2 = temp_value\n                       found = .true.\n                    end if\n                 end if\n             end if\n             mask = mask + 1\n          end do\n\n        But note: the mask might be large?",
      "start_char": 37132,
      "end_char": 37755,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "For 10-digit numbers, the mask goes from 1024 to 2047? But what if we don't find a 10-digit number? Then we go to 12? But the next super lucky number after 10-digit is 12-digit?",
      "start_char": 37756,
      "end_char": 37933,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "and 12-digit numbers start at 444444444444 (4e11) which is > 666e6? so we break at the first 10-digit super lucky number? However, we break as soon as we find one >= start? But what if the start is 1e18? Then we might need a very long mask? But note: the output of the first program: if n is 3e9, then res1 = (3e9/3)*2 + 0 = 2e9. The next super lucky number might be 4444444444 (4e9) -> which is found at mask=1024? But if n is 5e18? Then we need a super lucky number with 20 digits? The mask for 20 digits: from 2^20 to 2^21-1 -> about 2e6 masks? and we require exactly 10 ones? The number of masks to iterate is C(20,10)=184756, which is acceptable? But worst-case: the next super lucky number might be with 60 digits? Then mask would be from 2^60 to 2^61-1, which is 2^60 masks? that is too many. We need a better approach? The original Java program iterates mask until the value is found.",
      "start_char": 37944,
      "end_char": 38905,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "It might not be efficient for very large numbers? But note: the input n for the first program: the problem context (codeforces_669_A) is for n up to 1000? Or what? Actually, the problem does not specify, but we assume the input is within the range of an integer. However, the chain: the first program reads an integer n (which in Java is up to 2e9). Then res1 is about (2e9/3)*2+1 -> about 1.3e9. Then the second program: the next super lucky number above 1.3e9 is 4444444444? which is 4e9. The mask for 10 digits: 1024 to 2047 -> about 1000 masks? So we assume the mask loop will not be too heavy. But to be safe, we can break the mask loop when the value we form (temp_value) becomes too large?",
      "start_char": 38906,
      "end_char": 39632,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Alternatively, we can iterate by the length L (even) from 2,4,6,... and for each L, we generate all masks that are L-bit numbers? How? The mask for a fixed length L is in the range [2^L, 2^(L+1)-1]. Then for each mask in that range, we compute the bits = mask - 2**L, and then check if the popcount of bits is L/2? Then form the number and then compare? And we break when we find the first number >= start? This is more efficient? We can do:\n\n          L = 2\n          found = .false. do while (.not. found)\n             if (L is even) then   ! always true\n                 min_mask = 2**L\n                 max_mask = 2**(L+1) - 1\n                 do mask = min_mask, max_mask\n                    bits = mask - min_mask   ! because min_mask = 2**L -> the leading one is removed, leaving L bits. pop = popcnt(bits)   ! but note: bits is an integer, and we are only interested in the L bits? if (pop == L/2) then\n                       ! form the number: \n                       temp_value = 0\n                       do j = L-1, 0, -1\n                          if (btest(bits, j)) then\n                             digit = 7\n                          else\n                             digit = 4\n                          end if\n                          temp_value = temp_value * 10 + digit\n                       end do\n                       if (temp_value >= start) then\n                          res2 = temp_value\n                          found = .true. exit   ! exit the inner mask loop\n                       end if\n                    end if\n                 end do\n             end if\n             L = L + 2   ? But note: we are going by even lengths? end do But this iterates by increasing L? and the numbers are generated in increasing order? The smallest number for L=2: 44,47,74,77 -> which are greater than the numbers for L=0? and less than the numbers for L=4? But note: the number 44 is 44, which is greater than 7 (which is L=1? but we skip odd) -> but 7 was generated at L=1? we skipped. How did we generate 4 and 7? They are for L=1? but we skip odd. But wait: the original mask iteration started at mask=2: \n            mask=2: L=1 -> skipped? \n            mask=3: L=1 -> skipped? mask=4: L=2 -> then we generate 44. So we missed 4 and 7? Why? Because the original mask=2 and mask=3: \n            For mask=2: len_bin=2 -> len_str=1 -> odd -> skip.\n            mask=3: len_bin=2 -> len_str=1 -> skip. So the original program does not generate 4 and 7? But wait: the first program: \n            mask=2: binary \"10\" -> substring(1) is \"0\" -> then becomes \"4\" -> value=4.\n            mask=3: \"11\" -> \"1\" -> becomes \"7\" -> value=7. How did we get the length? For mask=2: len_bin = number of bits: 2 -> len_str=1 -> which is odd -> skip. So we skip? But the condition in the second program: \n            if (zeros != s.length() - zeros) continue;\n            For mask=2: s=\"0\" -> length=1 -> zeros=1, ones=0 -> not equal -> skip. So the second program also skips mask=2 and mask=3? Then how does it produce 4 and 7? Let me run the second Java program for input=1:\n\n          mask=2: s = Integer.toBinaryString(2) -> \"10\", then substring(1) -> \"0\". zeros = 1 (because one char '0') -> s.length()=1 -> zeros==1, ones=0 -> not equal -> skip. mask=3: s = \"11\" -> substring(1)=\"1\" -> zeros=0, ones=1 -> not equal -> skip. mask=4: s = \"100\" -> substring(1)=\"00\" -> zeros=2, ones=0 -> not equal? 2 != 0 -> skip. mask=5: s = \"101\" -> substring(1)=\"01\" -> zeros=1, ones=1 -> equal -> then s becomes \"47\" -> value=47. So 47 is the first super lucky number? But 4 and 7 are not generated? This contradicts the example? Actually, the example says: mask=2: s = \"0\" -> becomes \"4\" -> value=4. But the condition: \n            zeros = 1, and the length is 1 -> then zeros ! = 1 - zeros? -> 1 != 0 -> skip. So the program does not output 4? Then what is the first super lucky number?",
      "start_char": 39662,
      "end_char": 43961,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "The definition: a super lucky number is a number that has an even number of digits and the digits are only 4 and 7 and the number of 4s equals the number of 7s. So 4 and 7 are not super lucky? because they have only one digit (odd) and also the condition of half and half fails. Therefore, the first super lucky number is 44? But wait: the second program: \n            mask=4: \"00\" -> becomes \"44\", then zeros=2, ones=0 -> 2 != 0? - > skip. mask=5: \"01\" -> becomes \"47\", zeros=1, ones=1 -> condition holds -> value=47. So the first super lucky number is 47? But 44 is also super lucky? Why is 44 skipped? For mask=4: the binary string is \"00\", then zeros=2, ones=0 -> 2 != 0 -> skip. The condition: if (zeros != s.length() - zeros) ... \n            zeros = 2, s.length()=2 -> then s.length()-zeros=0 -> 2 != 0 -> skip. So the condition requires that the number of zeros equals the number of ones?",
      "start_char": 43991,
      "end_char": 44977,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Therefore, the definition of super lucky number in the second program is: \n            the number of zeros (in the binary mask string) must equal the number of ones. But then 44 would be generated from a binary string with two zeros? then zeros=2, ones=0 -> not equal -> skip. So 44 is not generated? How do we generate 44? We need a binary string with two zeros and two ones? But wait: the length is 2, so if we have two zeros, then ones=0. The condition: zeros == ones -> 2==0? false. So the only super lucky number of length 2 is 47 and 74 and 77? But 47: \n            binary string: \"01\" -> zeros=1, ones=1 -> condition holds. Similarly, 74: \"10\" -> zeros=1, ones=1.\n        and 77: \"11\" -> zeros=0, ones=2 -> 0==2? false. So only 47 and 74? But the problem says: super lucky number is a number such that its decimal representation contains an even number of digits, and the digits are only 4 and 7, and the number of 4s equals the number of 7s. So 44 has two 4's and zero 7's -> fails because the number of 4's should equal the number of 7's? And 77 fails similarly.",
      "start_char": 44997,
      "end_char": 46172,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Therefore, the super lucky numbers are: 47,74,4477,444777, etc. But then what about 44447777? So the condition in the second program is correct: the binary string must have an even length and exactly half zeros and half ones? And then we replace zeros by 4 and ones by 7?",
      "start_char": 46192,
      "end_char": 46493,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Therefore, the number of 4's in the decimal representation will be the number of zeros in the binary string, and the number of 7's will be the number of ones? So the decimal representation will have exactly half 4's and half 7's? And the total number of digits is even? So it matches the definition. Therefore, the first super lucky number is 47? But then the example in the second program: \n            input=1: output=47. However, the example in the first program: \n            input=1: res1 = (1/3)*2+1 = 0+1 = 1. then second program: the first super lucky number >=1 is 47. So we are good.",
      "start_char": 46504,
      "end_char": 47167,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Therefore, we must change our approach: the condition is not on the number of ones in the entire `bits`? but on the count of zeros and ones in the binary string? which is exactly the same as the condition in the second program: zeros = count of '0' in the binary string (which is the same as the number of unset bits in the `bits` over the len_str bits? but note: the binary string is exactly the representation of `bits` in len_str bits? How to count the zeros? zeros = len_str - popcount(bits) And we require: zeros == popcount(bits)   -> popcount(bits) = len_str/2. So the condition is the same. But note: the binary string for mask=5 (which is 101) without the leading one is \"01\", which has len_str=2, and popcount(bits)=1, and len_str/2=1 -> condition holds. For mask=4 (100->\"00\"): popcount=0, then condition: 0 == 2/2 -> 0==1 -> false. So we skip. Therefore, we can use the popcount condition. And we must start at mask=2 and go up? and we break when we find the first value>=start. But we can also iterate by length L=2,4,6,... and within each length, iterate mask from 2^L to 2^(L+1)-1, and then within that, we extract bits = mask - 2^L, and then check popcount(bits)==L/2. And then form the number and break when we find one>=start. This generates in increasing order by L? and within L, by the value of the mask? But the value of the number: For L=2: we generate 47 and 74? mask=5: bits=5-4=1 -> binary \"01\" (in 2 bits) -> then the number: j=1: bit1? -> btest(1,1) is false? -> '4'; j=0: btest(1,0) is true -> '7' -> 47.\n                mask=6: bits=6-4=2 -> binary \"10\" -> then j=1: btest(2,1) -> true -> '7'; j=0: btest(2,0) -> false -> '4' -> 74. So 47<74. And we iterate mask from 5 to 6? Then for L=4: mask from 16 to 31? The smallest number for L=4: the smallest mask with popcount=2 is 16+3 (binary \"0011\") -> number = 4477? But mask=16: bits=0 -> popcount=0 -> skip. mask=17: bits=1 -> binary \"0001\" -> popcount=1 -> skip. mask=18: bits=2 -> popcount=1 -> skip. mask=19: bits=3 -> popcount=2 -> then the number: j=3: btest(3,3)? false -> '4'\n            j=2: false -> '4'\n            j=1: true -> '7'\n            j=0: true -> '7'\n            -> 4477. Then next is mask=20: bits=4 -> popcount=1 -> skip. So the numbers are generated in increasing order? But 74 (L=2) is 74, and 4477 is 4477, which is greater than 74? So to generate in increasing order, we must iterate L from 2,4,6,... and within L, iterate mask from 2^L to 2^(L+1)-1, and then the number we form is increasing? But note: 47 and 74 are both less than any 4-digit number. So we can do:\n\n          start = res1   (int64)\n\n          found = .false. L = 2\n          do while (.not. found)\n             min_mask = 2**L\n             max_mask = 2**(L+1) - 1 do mask = min_mask, max_mask\n                 bits = mask - min_mask\n                 ! Count the number of ones in the L bits of `bits`\n                 pop = 0\n                 do j = 0, L-1\n                    if (btest(bits, j)) pop = pop + 1\n                 end do\n                 if (pop == L/2) then\n                    ! form the number from the bits: from most significant (bit L-1) to least (bit0)\n                    temp_value = 0 do j = L-1, 0, -1 if (btest(bits, j)) then\n                           digit = 7\n                       else\n                           digit = 4\n                       end if\n                       temp_value = temp_value * 10_8 + digit\n                    end do\n                    if (temp_value >= start) then\n                       res2 = temp_value\n                       found = .true.\n                       exit   !",
      "start_char": 47186,
      "end_char": 51171,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "exit inner loop\n                    end if\n                 end if\n             end do\n             if (.not. found) L = L + 2\n          end do\n\n        This should work. But note: the mask might be large? For large L, the range is from 2^L to 2^(L+1)-1, which has size 2^L. For L=20, 2^20 is 1e6? and we iterate over 1e6 masks?",
      "start_char": 51172,
      "end_char": 51509,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "and we do this for increasing L until we find one? The worst-case L might be 60? then 2^60 is too many.",
      "start_char": 51510,
      "end_char": 51613,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "We need to break when L is such that the smallest number for that L (which is 4...4, with L/2 fours and then L/2 sevens? but actually the smallest is 4...47...7) is greater than start? But note: the smallest number for length L is 4...4 (all fours) -> which is 4 * (10^L-1)/9. We can compute this and break the outer loop if the smallest number for L is already >= start? But we are iterating L from 2 upward. We can compute the smallest number for L: \n            num_min = 0\n            do i = 1, L\n                num_min = num_min * 10 + 4\n            end do\n\n        Then if num_min >= start, then we will find a number in this L, so we do the inner loop and break after the first one? But note: the numbers in the inner loop are not sorted in increasing order? We iterate mask from min_mask to max_mask, and the number is formed by the binary representation? The smallest number for fixed L is 4...4 (when the binary representation is all zeros) -> but we skip that because popcount=0 != L/2? The smallest number might be 4..47..7?",
      "start_char": 51633,
      "end_char": 52730,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Actually, the smallest number is when the binary representation is sorted: zeros first then ones? so the number is 4...47...7. So we can compute:\n\n            num_min = 0\n            do i = 1, L/2\n                num_min = num_min * 10 + 4\n            end do\n            do i = 1, L/2\n                num_min = num_min * 10 + 7\n            end do But this might not be the smallest? The smallest might be 4..474..7? We cannot easily determine the minimum number without generating?",
      "start_char": 52741,
      "end_char": 53251,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Alternatively, we can break the outer loop when L is such that the smallest possible number (which is 4...4) is already greater than the current candidate? But wait, we haven't found any candidate in the previous L? We can store the best candidate found so far? Given the complexity, and since the first program's output is at most about 666e6, the smallest L for which the smallest super lucky number is greater than 666e6 is L=10: smallest super lucky number for L=10: 4444477777? -> 4444477777 > 666e6? And L=10: the inner loop iterates over 2^10=1024 masks? which is acceptable. So we can simply iterate L=2,4,6,... up to L_max (say 60) and break when we find one. Given that 2^60 is too many, but for L=2,4,..., up to L=60, the inner loop size is 2^L, and we only do L=2,4,6,..., so L=2,4,6,...,60: the total number of masks is sum_{k=1}^{30} 2^{2*k} = sum_{k=1}^{30} 4^k = (4^31-4)/3, which is about 4^31, which is 4e9, which is too many.",
      "start_char": 53262,
      "end_char": 54267,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Therefore, we must iterate by mask within a fixed L without iterating exponentially many times? But note: we only iterate over the masks that have exactly L/2 ones? The number of such masks is C(L, L/2), which for L=60 is C(60,30) ~ 1e17, which is too many. So we must use the original mask iteration (over all integers starting from 2) and break when we find the first super lucky number>=start. But then for start=1, we find at L=2: mask=5:47? How many masks do we iterate? We start at mask=2, then 3,4,...,5 -> 4 masks. For start=1e18, we need to go to L=40? The mask for L=40 is about 2^40, and we iterate from 2 to 2^40? that is 2^40 iterations ~ 1e12, which is too many. We need a better approach? Given the complexity, and since the first program's output is at most about 666e6, we know that the answer will be for L<=10 (because the smallest super lucky number for L=10 is 4444444444 which is 4e9, which is >666e6). So we can iterate mask from 2 to 2^11-1 (which is 2047) and that's it. Specifically, we can set an upper bound for mask: \n            mask_max = 2*10**4   ? but we know that for L=10, we only go up to 2047. So we can do:\n\n          start = res1   (int64)\n\n          res2 = a big number, say 10**18    ! as initial\n          found = .false.\n          mask = 2\n          do while (.not. found .and. mask <= 100000)   ! 100000 is arbitrary, but for L=10 we only need up to 2047.\n\n          ... the same as above ... But we might find it within mask<=2047.",
      "start_char": 54277,
      "end_char": 55870,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Alternatively, we can iterate L from 2 to 40 by step 2, and for each L, iterate only the masks that have exactly L/2 ones? How to iterate combinations? We can generate all binary strings of length L with exactly L/2 ones? But the number is C(L, L/2), and for L=40, C(40,20) is about 1.3e11, which is too many. Given the constraints on start (<= about 666e6) and the fact that the answer will be with L<=10 (since the first super lucky number for L=10 is 4e9>666e6), we can simply iterate L from 2 to 10 by step 2, and for each L iterate mask in [2^L, 2^(L+1)-1] (which is 2^L numbers per L) and the total is 2^2+2^4+2^6+2^8+2^10 = 4+16+64+256+1024 = 1364, which is acceptable. Therefore, we can do:\n\n          start = res1\n\n          res2 = -1\n          do L = 2, 10, 2   ! L=2,4,6,8,10\n             min_mask = 2**L\n             max_mask = 2**(L+1)-1\n             do mask = min_mask, max_mask\n                 bits = mask - min_mask   ! an integer in [0, 2^L-1]\n                 pop = popcnt(bits)       ! but note: Fortran's popcnt counts all bits? but we only care about the L bits? \n                 !",
      "start_char": 55880,
      "end_char": 57036,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "However, since bits < 2^L, it has at most L bits, and popcnt(bits) is the count in the entire integer? which is the same as the count in the L bits. if (pop == L/2) then\n                    ! form the number\n                    temp_value = 0 do j = L-1, 0, -1 if (btest(bits, j)) then\n                           digit = 7\n                       else\n                           digit = 4\n                       end if\n                       temp_value = temp_value * 10_8 + digit\n                    end do\n                    if (temp_value >= start) then\n                       ! We found a candidate\n                       if (res2 == -1 .or. temp_value < res2) then\n                           res2 = temp_value\n                       end if\n                    end if\n                 end if\n             end do\n          end do\n\n          ! After the loops, res2 is the smallest super lucky number >= start. But note: it is possible that there is no super lucky number in L<=10? then we need to go to L=12, etc. Given that start is at most 666e6, the super lucky number for L=10: the smallest is 4444444444 (4e9) which is >666e6. And we will find candidates in L=10, and we want the smallest candidate? But note: the super lucky numbers in L=2,4,6,8 are less than 10^8? and 10^8<666e6 (which is 6.66e8) -> so we might find candidates in L=8 and L=10? And we want the smallest candidate overall? We are iterating L from 2 to 10, and within L, we iterate mask from min_mask to max_mask. This does not generate in increasing numerical order? Example: \n            L=2: we get 47,74. L=4: we get 4477, 4447, ... the smallest in L=4 is 4477. And 47<4477, so we should compare across L.",
      "start_char": 57037,
      "end_char": 58872,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Therefore, we cannot break at the first candidate in the smallest L? because a larger L might yield a smaller candidate? But the numbers in a smaller L are always smaller than those in a larger L? The largest number in L=2: 77 < smallest in L=4: 4444? -> 77<4444? no, 77<4444? -> 77 is 77 and 4444 is 4444 -> 77<4444? But wait: 77 is 77 and 4444 is 4444 -> 77<4444? -> no, 77 < 4444? -> 77 is less than 4444? -> yes. So the smallest candidate might be in L=2, then in L=4 we get larger candidates. Therefore, we can break at the first L where we find a candidate? But wait: it is possible that in L=2 there is no candidate>=start, then we go to L=4, and then we find one. But within a fixed L, the candidates are not generated in increasing order? Example: L=4: \n          mask=16+3: bits=3: \"0011\" -> 4477\n          mask=16+5: bits=5: \"0101\" -> 4747 -> which is greater than 4477? ... So within a fixed L, we iterate mask in increasing order, but the numerical value of the formed number is not sorted by mask? Therefore, we must for each L iterate all masks and keep the smallest candidate>=start in that L, and then overall the smallest candidate over all L.\n\n        But note: the smallest candidate overall will be in the smallest L that has any candidate>=start? because any number in a smaller L is smaller than any number in a larger L? Why? The largest number in L is at most (77...7 with L digits) < (44...4 with L+2 digits) because 77...7 < 10^L, and 44...4 (L+2) >= 10^(L+1) > 10^L > 77...7. Therefore, we can do:\n\n          res2 = -1\n          do L = 2, 100, 2   ! L up to 100? but we know within L=10 we will find one for start<=666e6. min_mask = 2**L\n             max_mask = 2**(L+1)-1\n             ! In this L, we will find the smallest candidate>=start, if exists. candidate = -1\n             do mask = min_mask, max_mask\n                 bits = mask - min_mask\n                 if (popcnt(bits) /= L/2) cycle\n                 ! form the number\n                 temp_value = 0 do j = L-1, 0, -1\n                    if (btest(bits, j)) then\n                        digit = 7\n                    else\n                        digit = 4\n                    end if\n                    temp_value = temp_value * 10_8 + digit\n                 end do\n                 if (temp_value < start) cycle\n                 if (candidate == -1 .or. temp_value < candidate) then\n                     candidate = temp_value\n                 end if\n             end do\n             if (candidate /= -1) then\n                 res2 = candidate\n                 exit   ! break the L loop\n             end if\n          end do\n\n        This will work. But note: we might not find a candidate in L=2, then we go to L=4, and as soon as we find one candidate in any L, we break because any candidate in a larger L will be bigger. Therefore, we exit at the first L (starting from 2) for which there is at least one candidate>=start, and we take the smallest candidate in that L.\n\n        And the smallest candidate in that L is the first super lucky number>=start. Why?",
      "start_char": 58883,
      "end_char": 62148,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Because any super lucky number in a smaller L would have been found in a previous iteration and been smaller. Example: start=50. L=2: \n            47<50 -> skip.\n            74>=50 -> candidate=74. then we set res2=74 and break. But wait, is 74 the first>=50? What about 47? 47<50, so it's skipped. So it is the first in the chain: 47,74 -> then 74 is the first>=50. Therefore, this is correct. Steps for the entire program:\n\n          step1: read n (integer)\n          step2: compute res1 = (n/3)*2 \n                  if (mod(n,3)==0) then res1 = res1 + 0\n                  else res1 = res1 + 1\n          step3: convert res1 to int64: start = res1\n\n          step4: \n             res2 = -1 do L = 2, 100, 2   ! L from 2 to 100 by step 2\n                 min_mask = 2**L\n                 max_mask = 2**(L+1) - 1\n                 candidate = -1\n                 do mask = min_mask, max_mask\n                     bits = mask - min_mask\n                     ! Count the number of set bits in `bits` (which has exactly L bits)\n                     pop = 0\n                     do j = 0, 63   ! we care only up to L-1, but L<=100, but bits may be stored in 64 bits. if (j >= L) exit\n                         if (btest(bits, j)) pop = pop + 1\n                     end do\n                     if (pop /= L/2) cycle\n\n                     ! form the number from the binary representation of `bits` (L bits, from most significant to least)\n                     temp_value = 0\n                     ! We want to get the bits from the most significant (bit L-1) to the least (bit0) do j = L-1, 0, -1 if (j < 0) exit\n                         if (btest(bits, j)) then\n                             digit = 7\n                         else\n                             digit = 4\n                         end if\n                         temp_value = temp_value * 10_8 + digit\n                     end do\n\n                     if (temp_value < start) cycle\n\n                     if (candidate == -1) then\n                         candidate = temp_value\n                     else\n                         if (temp_value < candidate) candidate = temp_value\n                     end if\n                 end do   ! end mask for fixed L\n\n                 if (candidate /= -1) then\n                     res2 = candidate\n                     exit\n                 end if\n             end do   ! end L\n\n          step5: convert res2 to a string (call it s)\n\n          step6: \n             ! Now, simulate the third program: \n             ! Build a frequency map for the characters in the string s.\n             ! Check: \n             ! if there are exactly 2 distinct characters and each appears exactly twice -> then output \"Yes\"\n             ! else output \"No\"\n\n          How to build the frequency map in Fortran? We can use an array for ASCII? but we only have '4' and '7'? Or we can use a loop and compare. Steps for the third program:\n\n            character(len=:), allocatable :: s   ! string representation of res2\n            integer :: freq(0:255) = 0   ! frequency for ASCII, but we only need '4' and '7' do i = 1, len(s)\n                c = s(i:i) ich = iachar(c)\n                freq(ich) = freq(ich) + 1\n            end do\n\n            distinct = 0\n            allTwice = .true. do i = 0, 255\n                if (freq(i) > 0) then\n                    distinct = distinct + 1\n                    if (freq(i) /= 2) then\n                        allTwice = .false. end if\n                end if\n            end do\n\n            if (distinct == 2 .and. allTwice) then\n                print *, \"Yes\"\n            else\n                print *, \"No\"\n            end if\n\n          But note: the condition in the original program: \n                for (Entry<Character, Integer> c : map.entrySet()) {\n                    if (c.getValue() ! = 2) {\n                        ok = false;\n                        break;\n                    }\n                } if (ok && map.size()==2) ... So it requires that every character that appears appears exactly twice, and there are exactly two distinct characters.",
      "start_char": 62158,
      "end_char": 66512,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "In our case, the string might have more than two distinct characters? but it's composed of '4' and '7'. So distinct will be either 1 or 2. But what if the string has a digit other than '4' and '7'? It shouldn't.",
      "start_char": 66536,
      "end_char": 66747,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "However, the condition in the third program is general. But note: the string is the decimal representation of res2, which is composed only of '4' and '7'. So distinct will be 1 or 2. So we could simply:\n\n             count4 = 0\n             count7 = 0\n             do i = 1, len(s)\n                 if (s(i:i)=='4') count4 = count4+1\n                 if (s(i:i)=='7') count7 = count7+1\n             end do\n\n             if ( (count4==2 .and. count7==2) .and. (count4+count7==len(s)) ) then\n                 print *, \"Yes\"\n             else\n                 print *, \"No\"\n             end if\n\n          But wait: the condition in the third program is: \n              the string has exactly two distinct characters and each appears exactly twice. This is equivalent to: \n              total length = 4, and count4=2 and count7=2. But what if the string has length!=4? then count4+count7 = len(s), and we require count4==2 and count7==2 -> then len(s)=4. So we can do:\n\n             if (len(s)/=4) then\n                 print *, \"No\"\n             else\n                 if (count4==2 .and. count7==2) then\n                     print *, \"Yes\"\n                 else\n                     print *, \"No\"\n                 end if\n             end if\n\n          But the original program does not assume the string length is 4?",
      "start_char": 66770,
      "end_char": 68139,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "It counts the frequency of each character, and then checks that every character has frequency 2 and that there are exactly two distinct characters. Example: if the string is \"4444\", then distinct=1 and one character has frequency 4 -> fails.",
      "start_char": 68154,
      "end_char": 68406,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "In our case, the string is composed of '4' and '7'. So if the string has length 4, then we require two '4's and two '7's. But if the string has length 2, then it's either \"47\", \"74\", \"44\", \"77\". \"47\": distinct=2, but frequencies: '4':1, '7':1 -> not 2 -> fails. So we output \"No\" for any string that is not of length 4 and with two '4's and two '7's? But the original program would fail for a string of length 2: distinct=2, but frequencies are 1 and 1 -> not 2 -> fails. And for a string of length 6: distinct=2, but frequencies are 3 and 3 -> not 2 -> fails.",
      "start_char": 68418,
      "end_char": 69048,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Therefore, the condition is only satisfied for strings of length 4 with two distinct characters and each appears twice. So we can simply:\n\n             if (len(s) /= 4) then\n                 write(*,*) \"No\"\n             else\n                 count4 = 0 do i = 1, 4\n                     if (s(i:i)=='4') count4 = count4+1\n                 end do\n                 if (count4==2) then\n                     write(*,*) \"Yes\"\n                 else\n                     write(*,*) \"No\"\n                 end if\n             end if\n\n          But note: the string might contain a character that is not '4' or '7'? but it shouldn't.",
      "start_char": 69060,
      "end_char": 69710,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "However, the third program is general. But we know the string is from res2, which is composed of '4' and '7'. So we can assume only '4' and '7'. Then distinct is either 1 or 2. And the only way to have distinct=2 and each twice is to have two '4's and two '7's. But if we have a string of length 4 with two '4's and two '7's, then count4=2 and count7=2. And if the string has length 4 and count4=2, then count7=2. So we only need to check the length and count the '4's. Alternatively, we can do:\n\n             if (len(s)/=4) then\n                 write(*,*) \"No\"\n             else\n                 if (s(1:1)==s(2:2) .and. s(2:2)==s(3:3) .and. s(3:3)==s(4:4)) then\n                     ! all same -> distinct=1 -> fails\n                     write(*,*) \"No\"\n                 else\n                     ! We can check: \n                     if ( (s(1:1)==s(2:2) .and. s(3:3)==s(4:4)) .or. ... ) then  ? -> too complex. end if\n             end if\n\n          Better to count the '4's. So:\n\n             if (len(s) /= 4) then\n                 write(*,*) \"No\"\n             else\n                 count = 0\n                 do i = 1,4\n                    if (s(i:i)=='4') count = count+1\n                 end do\n                 if (count==2) then\n                     write(*,*) \"Yes\"\n                 else\n                     write(*,*) \"No\"\n                 end if\n             end if\n\n        But what if the string is \"7777\"? then count4=0 -> not 2 -> \"No\", which is correct. And \"4477\": count4=2 -> \"Yes\". This matches. However, note: the original program would also work for a string like \"abab\" (distinct 'a' and 'b', each twice) -> \"Yes\". But our string only has '4' and '7'.",
      "start_char": 69722,
      "end_char": 71510,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "And the condition is satisfied only if there are exactly two distinct characters and each appears twice? In our case, if the string is \"4747\", then distinct '4' and '7', and each appears twice -> \"Yes\". How many '4's in \"4747\"? 2. So the count4=2 works. Therefore, we can use this. But note: the string might have length 4 but contain a digit other than '4' and '7'? It shouldn't, because res2 is composed of '4' and '7'. So we are safe. Summary of the entire Fortran program:\n\n          program chain\n            implicit none\n            integer :: n, res1, remainder\n            integer(kind=8) :: start, res2, candidate, temp_value, min_mask, max_mask, mask, bits, digit_val\n            integer :: L, j, pop, i, count4, len_s\n            character(len=100) :: s  ! 100 digits should be enough\n\n            ! Step1: read n\n            read(*,*) n\n\n            ! Step2: compute res1\n            res1 = (n / 3) * 2\n            remainder = mod(n, 3) if (remainder /= 0) then\n                res1 = res1 + 1\n            end if\n            start = res1   ! convert to int64\n\n            ! Step3: find the next super lucky number >= start\n            res2 = -1\n            ! We iterate L=2,4,6,..., up to 60 (or until found) do L = 2, 100, 2\n                min_mask = 2**L\n                max_mask = 2**(L+1) - 1\n                candidate = -1\n                do mask = min_mask, max_mask\n                    bits = mask - min_mask\n\n                    ! Count the number of ones in the L bits\n                    pop = 0\n                    do j = 0, L-1\n                        if (btest(bits, j)) pop = pop + 1\n                    end do\n                    if (pop /= L/2) cycle\n\n                    ! Form the number from the binary representation of `bits` (L bits)\n                    temp_value = 0 do j = L-1, 0, -1\n                        if (btest(bits, j)) then\n                            digit_val = 7\n                        else\n                            digit_val = 4\n                        end if\n                        temp_value = temp_value * 10_8 + digit_val\n                    end do\n\n                    if (temp_value < start) cycle\n\n                    ! We have a candidate, and we want the smallest candidate in this L\n                    if (candidate == -1) then\n                        candidate = temp_value\n                    else\n                        if (temp_value < candidate) candidate = temp_value\n                    end if\n                end do\n\n                if (candidate /= -1) then\n                    res2 = candidate\n                    exit\n                end if\n            end do\n\n            ! If we didn't find any, then we use a fallback? if (res2 == -1) then\n                ! In case we didn't find, we set to a default? But the chain should always find one. res2 = 0\n            end if\n\n            ! Convert res2 to a string\n            write(s, '(I0)') res2   ! This writes the integer to a string without leading spaces. len_s = len_trim(s)      ! But I0 may give the exact length.\n\n            ! Step4: check the string for the third program\n            if (len_s /= 4) then\n                write(*,*) \"No\"\n            else\n                count4 = 0\n                do i = 1, 4\n                    if (s(i:i) == '4') count4 = count4 + 1\n                end do\n                if (count4 == 2) then\n                    write(*,*)",
      "start_char": 71530,
      "end_char": 75080,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "\"Yes\"\n                else\n                    write(*,*) \"No\"\n                end if\n            end if\n\n          end program\n\n        But note: the conversion of res2 to string: if res2 is 47, then the string is \"47\", which has length 2. Then we output \"No\". This matches the condition. However, we must ensure that the string is exactly the decimal representation. We use the format '(I0)' which gives the minimal representation. This should work. Let's test with n=1:\n\n          step2: res1 = (1/3)*2 = 0, then remainder=1 -> res1=0+1=1.\n          start=1. Then we iterate L=2,4,6,...\n          L=2: \n             min_mask=4, max_mask=7. mask=4: bits=0, pop=0 -> 0==1? no -> skip. mask=5: bits=1, pop=1 -> 1==1 -> form number: \n                 j=1: btest(1,1) -> false -> digit=4; j=0: true -> digit=7 -> number=47. 47>=1 -> candidate=47.\n             mask=6: bits=2, pop=1 -> form: j=1: true (because 2 in binary is 10: bit1 is set) -> digit=7; j=0: false->digit=4 -> 74. candidate = min(47,74)=47.\n             mask=7: bits=3, pop=2 -> skip. then candidate=47, res2=47. Convert to string: \"47\" -> len=2 -> output \"No\"\n\n        The expected output for the chain for n=1: \n            first program: 1\n            second program: 47\n            third program: \"No\"\n\n        So it matches. Another test: n=47\n          first program: \n             n=47, \n                47/3 = 15 (integer division) -> 15*2=30, then mod(47,3)=2 -> so 30+1=31.\n          start=31. Then find the next super lucky number>=31: \n             L=2: mask=5:47>=31 -> candidate=47.\n\n          string=\"47\", then third program: \n             len=2 -> \"No\"\n\n        But what if n=4444? \n          first program: \n             n=4444, res1 = (4444/3)*2 + (4444%3 ? 4444/3=1481*3=4443, remainder=1 -> so 1481*2+1 = 2962+1=2963. Then find the next super lucky number >=2963: \n             L=2: 47,74 -> skip. L=4: the first candidate>=2963 is 4477? mask=16: bits=0 -> pop=0 -> skip. mask=17: bits=1 -> pop=1 -> form: 0001 -> 4447? number: from high to low: \n                       j=3: bit3? 0->4\n                       j=2:0->4\n                       j=1:0->4\n                       j=0:1->7 -> 4447. 4447>=2963 -> candidate=4447. Then string=\"4447\" -> \n                 len=4, count4: 3 -> then output \"No\"\n\n        But the next super lucky number after 2963 should be 4477? \n           4477: mask= for L=4: we need a bit string with two ones? \n                 mask=16+3: bits=3: binary 0011 -> then the number: \n                    j=3:0->4\n                    j=2:0->4\n                    j=1:1->7\n                    j=0:1->7 -> 4477.\n\n                 mask=16+3 = 19. then 4477>=2963 -> candidate = min(4447,4477) -> 4447? But 4447 is not a super lucky number? because it has 3 fours and 1 seven -> not equal counts. Why did we generate 4447? We require pop = L/2 = 2? For mask=17: bits=1, pop=1 -> but we skip because 1!=2. I see: in the inner loop, we have:\n\n            if (pop /= L/2) cycle\n\n        So for L=4, we only consider pop=2. Therefore, 4447 should not be generated. Let me recompute for mask=17: \n            L=4, bits=1, pop= number of ones in the binary representation of 1 (in 4 bits? we are considering the lower 4 bits? but 1 in 4 bits is 0001) -> pop=1 -> skip. Then we continue: \n            mask=18: bits=2: 0010 -> pop=1 -> skip.\n            mask=19: bits=3: 0011 -> pop=2 -> form: 0011 -> 4477. then 4477>=2963 -> candidate=4477. Then string=\"4477\": \n            len=4, count4=2 -> output \"Yes\" So for n=4444, the chain outputs \"Yes\". Therefore, the program is fixed. Note: when forming the number, we are using exactly L bits? we do j from L-1 downto 0, and for each j we check the j-th bit? This is correct. We'll write the program accordingly.",
      "start_char": 75081,
      "end_char": 79256,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "However, note: the exponentiation 2**L: for L up to 100, we need to compute 2^100, which is about 1e30, which is beyond the range of 32-bit integer. We should use integer(kind=8) for min_mask, max_mask, mask, and bits. Let me use:\n\n            integer(kind=8) :: L_val   ! we'll use L as integer(kind=8) for exponentiation? but L is at most 100, so 2^100 is about 1e30, which requires about 100 bits -> so we need at least 128-bit integers? Alternatively, we can avoid computing 2**L for large L? We know that for L> floor(log2(start))+2, the value 2**L is huge, and we are iterating L from 2 upward, and we break when L is such that the smallest candidate (which is at least 4 * (10^L-1)/9) is >= start? But we are only doing L up to 100, and we break as soon as we find a candidate in one L. But 2**100 is too big for integer(kind=8) (which is 64 bits, max 1e19). So we cannot use integer(kind=8) for L>=64. Therefore, we must avoid exponentiation for large L? Alternatively, we can break the outer loop when L is such that 2**L would overflow? Since we know that for start<=666e6, the answer will be found in L<=10, we can break when L>60 (say) and then use a fallback. Or we can use a different approach for large L? but we won't need it. We can compute min_mask = shift_left(1, L)   ! 1 shifted left by L bits. But Fortran has shift functions? We can use: min_mask = ishft(1_8, L)   ! but L is integer, and if L>63, then it becomes 0. So we can do:\n\n            if (L > 63) then\n                exit   ! or use a fallback: res2 = a huge number, but we break the L loop. end if\n            min_mask = ishft(1_8, L)   ! 2**L\n            max_mask = ishft(1_8, L+1) - 1\n\n        But note: for L=100, ishft(1_8,100) = 0? And then the inner loop: mask from 0 to -1? which is not done. So we can skip L if L>63. But since we break at L=10 for our start, it's safe. Alternatively, we can use:\n\n            min_mask = 2_8**L   ! but this might be computed as real? and then converted to int64? But 2**L for L=100 is 2^100, which is 1.26e30, which is not representable as int64. So we avoid by breaking the outer loop when L>63. We'll change the L loop: do L = 2, 100, 2\n                if (L > 63) exit\n                min_mask = ishft(1_8, L)\n                max_mask = ior(min_mask, ishft(1_8, L)-1)   ! actually, max_mask = min_mask*2 - 1 = 2^(L+1)-1\n                ! But note: ishft(1_8, L+1) - 1\n                max_mask = ishft(1_8, L+1) - 1\n\n                ... \n\n            end do\n\n        How to compute 2^(L+1)-1? We can do: \n                max_mask = ishft(1_8, L+1) - 1 But if L+1>63, then ishft(1_8, L+1) is 0, then max_mask = -1? So we skip L>63. We'll do:\n\n            if (L>63) cycle   ! but we are in a loop L=2,4,..., so we can break the loop? or just skip this L. But we break when we find a candidate, and L is small for our start. We'll do:\n\n            if (L>63) exit\n\n        Now, the program. Note: the shift functions: \n            min_mask = ishft(1_8, L)   ! 1<<L But in Fortran, ishft(i, shift) where shift can be negative or positive. For positive, it's left shift. But we want: 2^L = shift left by L bits of 1.\n\n        Example: L=2 -> 1<<2 = 4. So it is correct. We'll use:\n\n            integer(kind=8) :: min_mask, max_mask, mask, bits, temp\n            min_mask = ishft(1_8, L)\n            max_mask = ishft(1_8, L+1) - 1\n\n        This works for L<=62? because for L=63: \n            min_mask = 2^63, which is representable in int64? max_mask = 2^64-1 -> which is not representable in int64? because int64 max is 2^63-1. So for L>=64, we skip. We can change the loop to L=2,4,..., up to 62. Then in the L loop:\n\n            do L = 2, 62, 2\n                min_mask = ishft(1_8, L)\n                max_mask = ishft(1_8, L+1) - 1\n\n        But for L=62: \n            min_mask = 2^62\n            max_mask = 2^63 - 1   -> which is the maximum int64. Then for L=64: we don't do. This is acceptable. Final program:",
      "start_char": 79266,
      "end_char": 83591,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    }
  ],
  "original_reasoning": "We are going to chain three programs. Only the first reads the initial input, and only the last produces the final output.\n The intermediate results are passed as in-memory data.\n\n Steps:\n 1. The first Java program (codeforces_669_A) reads an integer `n` and computes:\n        result1 = (n / 3) * 2 + (if n mod 3 == 0 then 0 else 1)\n\n 2. The second Java program (codeforces_96_B) takes a number (which will be the output of the first program) and does:\n        It searches for the smallest number (>= the input) that is composed of an even number of digits, \n        with exactly half being '4' and half being '7'. The number is generated by iterating over binary masks.\n\n 3. The third Java program (atcoder_ABC132_A) takes a string (which will be the string representation of the output of the second program) and checks:\n        - The string has exactly 2 distinct characters.\n        - Each distinct character appears exactly twice.\n\n However, note: the output of the first program is an integer, which becomes the input to the second program (as a long).\n The output of the second program is a long, which we convert to a string to feed to the third program.\n\n Therefore, the chain is:\n   input (integer) -> first program -> integer result1 -> second program -> long result2 -> third program -> string result3 -> output\n\n Important: The second program expects a long, and the third program expects a string.\n\n But note: the first program's output is an integer, but the second program reads a long. We can convert the integer to a long.\n\n Plan for Fortran:\n\n  We will write a single program that:\n    - Reads the initial integer (like the first program).\n    - Computes the result of the first program (call it `res1`).\n    - Then, using `res1` as the starting point, we simulate the second program to find the next super lucky number (call it `res2`).\n    - Then, convert `res2` to a string and check the conditions of the third program.\n\n  However, note the second program uses a while loop that starts with a mask and increments until the generated number is >= the input.\n\n  Steps for the second part (simulating the second Java program):\n\n      We note that the second program:\n        long number = ... (which is our `res1`)\n        long ans = -1, value = 0;\n        int mask = 2;\n        while (value < number) {\n            String s = Integer.toBinaryString(mask++).substring(1);\n            // This binary string has no leading '1' (because of substring(1)) so it's of length (mask-1) in bits? \n            // Actually, the mask starts at 2: binary of 2 is \"10\" -> substring(1) becomes \"0\" -> then we replace: becomes \"4\" -> value=4 -> if 4 < number? \n            // But note: mask is incremented, so next is 3: binary \"11\" -> substring(1) is \"1\" -> becomes \"7\" -> value=7.\n            // Then mask=4: binary \"100\" -> substring(1) is \"00\" -> becomes \"44\", then mask=5: \"101\" -> \"01\" becomes \"47\", mask=6: \"110\" -> \"10\" becomes \"74\", mask=7: \"111\" -> \"11\" becomes \"77\", mask=8: \"1000\" -> \"000\" becomes \"444\", etc.\n\n            The idea: the mask is used to generate a bit string of length (number of bits in mask-1). The substring(1) removes the leading '1'. \n            Then we count zeros (which are the bits that are 0). We require that the number of zeros equals the number of ones? Actually, the condition is:\n                if (zeros != s.length() - zeros) continue;\n            which means we require that the number of zeros equals the number of ones. So the string must have even length and exactly half zeros and half ones.\n\n            Then we replace '0' with '4' and '1' with '7' to form a number.\n\n            We break when we get a number >= the input.\n\n        So we need to generate these numbers in increasing order until we find one >= `res1`.\n\n      How to do in Fortran?\n        We can do a similar loop: start with mask=2, and then for each mask:\n            - Convert mask to a binary string without the leading '1' (so the length is the number of bits of mask minus one).\n            - Check if the length is even? Actually, the condition (zeros == length/2) requires even length. So we can skip if the length is odd? But the condition is checked by counting.\n\n        However, note: the mask starts at 2 and increases. The generated string length is (bit_length(mask)-1). We require the same number of zeros and ones.\n\n        We can simulate the same process.\n\n        Steps for a given mask:\n            len_bin = bit_size of mask? Actually, we can get the binary representation and then remove the leading '1'.\n\n        But note: in Java, Integer.toBinaryString(2) is \"10\", then substring(1) is \"0\". For 3: \"11\" -> \"1\". For 4: \"100\" -> \"00\", for 5: \"101\" -> \"01\", etc.\n\n        How to get the binary representation without the leading 1 in Fortran? We can compute the position of the leading 1 and then take the rest.\n\n        Alternatively, we can note that the mask starts at 2 and then increases. The length of the string for mask is (floor(log2(mask))). Actually, the number of bits without the leading one is floor(log2(mask)).\n\n        But we can generate the binary string by:\n\n          Let nbits = bit_size(mask)  [but we don't know the size, so we can use bit_len = floor(log2(real(mask))) + 1, then the string without the first bit is the last (bit_len-1) bits?]\n\n        However, Fortran doesn't have built-in for binary string. We can use bit manipulation.\n\n        Alternatively, we can generate the binary representation of mask and then remove the first character? But we have to be careful: we want exactly the bits from the first set bit to the end? Actually, the Java method gives the minimal representation.\n\n        We can compute the length of the binary representation of mask: \n          len = floor(log2(real(mask))) + 1\n          Then the binary string without the first character is the last (len-1) bits? Actually, the first character is always '1'. So we can generate the binary representation for (mask - 2**(len-1)) in (len-1) bits.\n\n        But note: mask=2: len=2 -> then we take the last 1 bit: which is the low bit? Actually, the binary representation of 2 is '10', and without the first bit is '0'. \n\n        How to generate the (len-1) bits? We can take the bits from position len-2 down to 0.\n\n        Steps for a mask (integer, but note: mask in the Java program is an int and we are starting at 2, then increasing. The numbers are not huge at first, but note: the output of the first program might be large? The first program: input n, then res1 = (n/3)*2 + (if mod(n,3)==0?0:1). So if n is large, then res1 might be up to about 2e9? But the mask is an int, so it can go up to 2^31. But the generated numbers (as strings) have length (bit_length(mask)-1). The maximum length we can get is 30 (for mask up to 2^31, the binary string without the first bit is 31-1=30). Then the number of digits is 30, which is 15 fours and 15 sevens -> that number is 4.4.. * 10^30, which is beyond Fortran's integer kind? \n\n        However, the problem: we are storing the generated number as a long in Java? But in Fortran, we need to store a number that can be up to 30 digits. We can use character strings? But the condition is we need to compare with `res1` (which is integer, so at most 10 digits) and then we break when we get the first number that is >= res1. So we don't need to go to 30 digits? Because res1 is at most about 666e6? (if n is 1e9, then res1 = (1e9/3)*2 + 1 = about 666666667). So we only need numbers that are at most 9 or 10 digits? \n\n        How many digits? The smallest number with 2 digits: 44, 47, 74, 77 -> 4 numbers. Then 4 digits: 4444, 4447, ... -> 6? Actually, the number of digits is even: 2,4,6,... up to 10? Then the maximum we need is 10 digits? 10-digit numbers: 10^10 is about 10 billion, which fits in an 8-byte integer? In Fortran, we can use integer(kind=8) for numbers up to 10^18.\n\n        So we can do:\n\n          Let `start` = res1 (from the first program) as an integer(kind=8)\n\n          Then we iterate mask from 2 upwards until we find a number >= start.\n\n          For each mask, we:\n            - Compute the length of the binary representation of mask: len_bin = floor(log2(real(mask, kind=8))) + 1\n            - Then the number of bits we care about is len_str = len_bin - 1   [because we remove the leading one]\n\n            - If len_str is odd, we skip? Actually, the condition (zeros == ones) requires that the length is even? So we can skip if mod(len_str,2) /= 0? But note: the condition is checked by counting. We can skip if the length is odd because then zeros != ones. So to save time, we can skip odd lengths.\n\n            - Then we extract the bits for the mask without the leading one: that is the lower (len_bin-1) bits.\n\n            - We can form a string of length = len_str: \n                  do j = len_str-1 downto 0\n                      if the j-th bit (counting from 0 as the least significant) is set? Then we put '1', else '0'\n\n            - Then we count the number of zeros. If the count of zeros is not len_str/2, skip.\n\n            - Then we form the number: replace '0' with '4', '1' with '7', and then convert the string to an integer(kind=8) -> call this `value`\n\n            - If value >= start, then we break and set `res2 = value`\n\n          Then we pass `res2` to the third program as a string.\n\n 3. The third program (atcoder_ABC132_A) takes a string and checks:\n        - It has exactly 2 distinct characters, and each appears exactly twice.\n\n    But note: the string we are passing is the string representation of `res2` (which is a number). How long is the string? It can be 2,4,6,... up to 10 or 12? \n\n    Conditions:\n        - The string must have exactly two distinct characters? Actually, the program checks: \n            for each character in the string, count the frequency -> then check that each of the two distinct characters appears twice? \n\n        But note: the program doesn't assume the string length is 4? It counts the frequency of each character and then checks that every character that appears has frequency 2? And also that there are exactly 2 distinct characters.\n\n        However, the number we generated (res2) is composed only of '4' and '7'. So the distinct characters must be only two: '4' and '7'. But the program doesn't know that. \n\n        Also note: the string might be of even length (say L) and we require that each character appears exactly L/2 times? Actually, the program only requires that each character that appears does so exactly twice? That is incorrect for the original problem? \n\n        Let me check the original problem: atcoder_ABC132_A. The problem says: \n          \"Given a string S of length 4. Determine if S is made up of exactly two kinds of characters, each appearing exactly twice.\"\n\n        So the string length is always 4? Then the condition is: two distinct characters and each appears twice.\n\n        But in our chain, the string we are passing is the string representation of res2. What is the length of res2? It can be 1? Actually, no: because we generate numbers with even digits (2,4,6,...). So the length is even. However, the original problem (atcoder_ABC132_A) expects a string of length 4? \n\n        But note: the problem statement in the code: \n            String s = in.next();\n            char[] targ = s.toCharArray();\n\n        and then the map counts the frequency. It doesn't specify the length. But the problem says \"Given a string S of length 4\" in the contest. So we must assume that the string we get from res2 has length 4? \n\n        However, our res2 is generated by the second program: it can be 2,4,6,... digits. So the length might be 2,4,6, etc. \n\n        The third program in the chain is written for a string of length 4? Actually, no: it counts the frequency and then checks that each character appears exactly twice and that there are two distinct characters. This condition is independent of the length? \n\n        But wait: the condition \"each character appears exactly twice\" implies that the total length must be 4? Because if we have two distinct characters, each appearing twice, then total length=4. \n\n        So the third program expects a string of length 4? Then what if the string we get from res2 is not 4? Then the condition will fail. \n\n        But note: the second program produces numbers that are composed of even digits, but the length can be 2,4,6,... \n\n        How can we have a string of length 4? The second program produces the smallest super lucky number >= res1. If res1 is 1, then the first super lucky number is 4 (length=1? no, 4 is one digit -> but wait: the second program: \n            mask=2: binary \"10\" -> substring(1)=\"0\" -> becomes \"4\" -> value=4 -> then we break? \n            Then the string \"4\" is passed to the third program? \n\n        The third program: \n            It has one distinct character? Then it fails -> prints \"No\".\n\n        But the chain: \n            Input: 1 -> first program: res1 = (1/3)*2 + 1 = 0*2+1 = 1 -> then second program: outputs 4 -> then third program: outputs \"No\".\n\n        However, the original second program: \n            It starts at mask=2: produces 4 -> since 4>=1 -> output 4.\n\n        So the chain does not require the third program to get a string of length 4? \n\n        Therefore, we must note: the third program in the chain is being used with any string (the string representation of res2). The program checks:\n            - The string has exactly two distinct characters? \n            - And each distinct character appears exactly twice? \n\n        But if the string has length 2, then we would have two distinct characters? and each appearing once? -> fails. \n        If the string has length 4, then two distinct characters each twice -> passes.\n\n        Actually, the condition in the third program: \n            for (Entry<Character, Integer> c : map.entrySet()) {\n                if (c.getValue() != 2) {\n                    ok = false;\n                    break;\n                }\n            }\n            and then also we check map.size()==2? \n\n        So it requires that every character appears exactly twice and that there are two distinct characters.\n\n        This condition can only be satisfied if the string length is 4? (because 2 distinct * 2 = 4). \n\n        Therefore, if the string has length 2: then we have two characters? but each must appear twice? -> impossible. \n        Similarly, for length 6: we would require each of two characters to appear twice? that would be 4, not 6. \n\n        So the condition is only satisfied for strings of length 4? \n\n        But note: what if we have a string of length 4 with three distinct characters? e.g., \"4477\": two distinct, each twice -> yes. \n        \"4444\": one distinct, fails. \n        \"4455\": two distinct, but each twice? -> yes? \n\n        However, the second program only produces numbers with digits '4' and '7'. So the string will be composed of '4' and '7'. \n\n        Therefore, the condition for the third program to output \"Yes\" is:\n            - The string has length 4, and it has exactly two distinct characters (which must be '4' and '7') and each appears twice? \n\n        But note: the condition does not care about which characters, only the frequency. However, the second program only produces '4' and '7'. So the distinct characters are '4' and '7'. \n\n        So the third program will output \"Yes\" if and only if the string has length 4 and has two '4's and two '7's? \n\n        But what if the string has length 4 and has three '4's and one '7'? Then the condition fails. \n\n        So the chain: \n          Input n -> first program -> res1 -> second program finds the super lucky number (which is a number with even length and half the digits are '4' and half are '7') -> then we check if this number (as a string) has length 4 and exactly two of each? \n\n        But note: the super lucky number can be 44, 47, 74, 77 (length=2) -> then the third program: \n            distinct characters: {'4','7'} -> two distinct? yes. \n            frequency: each appears once? -> fails. \n\n        So the third program will output \"No\" for a 2-digit super lucky number.\n\n        The original chain doesn't care about the internal conditions? It just chains the programs. \n\n        Therefore, we must implement the third program as given: \n            Convert the number `res2` to a string (call it `s`)\n            Build a frequency map for the characters in `s`\n            Check: \n                if the map has size 2 AND every key in the map has value 2 -> then print \"Yes\"\n                else print \"No\"\n\n        But note: the condition \"every key has value 2\" implies the string length is 4? Actually, if the string length is not 4, then the condition fails. \n\n        So the third program is independent of the length? It will work for any string.\n\n Implementation:\n\n   Steps:\n\n     Step 1: Read the initial integer `n` (like the first program).\n\n     Step 2: Compute `res1` = (n/3)*2 + (if mod(n,3)==0 then 0 else 1)\n\n     Step 3: Convert `res1` to integer(kind=8) (it's an integer, but we will use it as the starting point for the second program).\n\n     Step 4: Find the next super lucky number (>= res1) as described.\n\n        We'll use an integer(kind=8) for `value` and `start`.\n        We start with mask=2 (as integer) and then increment mask until we find a value >= start.\n\n        How to generate the binary string without the leading one for a given mask (integer)?\n\n          Let's define:\n            len_bin = number of bits in the binary representation of mask (without leading zeros) -> this is floor(log2(real(mask, kind=8)))+1\n            len_str = len_bin - 1   [the number of bits we use]\n\n          We skip if len_str is 0? (mask=1: but mask starts at 2) -> no.\n\n          Then we extract the lower len_str bits? Actually, the binary representation of mask is: \n                mask = 2^(len_bin-1) + x, where x is in the range [0, 2^(len_bin-1)-1]\n          The bits we want are the representation of x in len_str bits.\n\n          How to extract the bits? We can do:\n\n            bits: do i = len_str-1 downto 0\n                     bit = (mask - 2**(len_bin-1))   ... but wait, we can use bit-level operations.\n\n          Alternatively, we can note: the entire mask has len_bin bits. We want the last len_str bits? Actually, the representation without the leading one is the trailing len_str bits.\n\n          How to get the i-th bit (from the least significant, starting at 0) of (mask)? \n                bit = mod(mask / 2**i, 2)   -> but we are only interested in the bits from position (len_bin-2) down to 0? \n\n          Actually, the leading one is the highest bit (at position len_bin-1). We want the bits from position len_bin-2 down to 0.\n\n          We can do:\n\n            temp = mask - 2**(len_bin-1)   [this gives the value without the leading one? but actually, it does]\n\n          Then we can convert `temp` to a binary string of length `len_str`? But we don't need the string for the entire mask, we can use bit manipulation.\n\n          However, we need to count the zeros and ones. We can traverse the bits from 0 to len_str-1? \n\n          But note: the representation of `temp` in len_str bits: the bit at position j (0-indexed from the least significant) is the j-th bit from the right.\n\n          How to get the j-th bit (from the most significant) in the string? \n            In the string, the first character is the most significant? \n\n          We can form the string by:\n\n            do j = len_str-1 downto 0\n                bit_j = mod(temp / 2**j, 2)   -> but that gives the j-th bit from the least significant? \n\n          Actually, we want the most significant bit of the substring to be the highest bit of temp? \n\n          Alternatively, we can shift and mask:\n\n            We traverse j from 0 to len_str-1: \n                bit = mod(temp, 2)   -> the least significant bit\n                then temp = temp / 2\n            but then we get the bits in reverse order.\n\n          Or we can traverse from the highest bit:\n\n            do j = len_str-1, 0, -1\n                if (temp has the j-th bit set) -> then the bit is 1? But note: j here is the exponent? \n\n          Actually, the bits in the number `temp` are stored in base2, and the j-th bit from the most significant is the (len_str-1 - j) bit? \n\n          Instead, we can avoid building the string and count the bits:\n\n            We can count the number of ones in the lower `len_str` bits of `mask`? But note: we removed the leading one? Actually, the entire mask has len_bin bits. We are taking the lower len_str bits? \n\n          Actually, the mask is represented in len_bin bits: the highest bit is set. Then the rest (len_str bits) are the bits we care about.\n\n          So the number of ones in the entire mask is: 1 (the leading) plus the popcount of the lower len_str bits? But we don't care about the leading one? \n\n          We are only interested in the substring of bits (without the leading one). So we can count the number of ones in the lower len_str bits? \n\n          How to get the lower len_str bits? \n\n            bits = mask - 2**(len_bin-1)   -> this gives a number that has at most len_str bits.\n\n          Then the number of ones in the bits? \n\n          But note: the condition is that the substring has exactly half ones? So we require that the popcount of bits equals len_str/2? \n\n          However, the condition in the second program: zeros = len_str - ones, and we require zeros==ones -> so ones = len_str/2.\n\n          Therefore, we require:\n            popcount(bits) = len_str/2   [and also we skip if len_str is odd? because then len_str/2 is not integer]\n\n          So we can do:\n\n            if (mod(len_str,2) /= 0) cycle   ! skip odd lengths\n\n            pop = popcnt(bits)   ! but note: the bits variable is an integer, and we are only interested in the len_str bits? \n\n          However, the variable `bits` is exactly the value in the lower len_str bits? \n\n          Then if popcount(bits) == len_str/2, then we form the number by:\n\n            We want to form a string: for each bit in the bits (from the most significant to the least) we output:\n                if the bit is set -> '7'\n                else -> '4'\n\n          How to get the bits in the string from the most significant to the least? \n\n            We can do:\n\n              do j = len_str-1 downto 0\n                 if (btest(bits, j)) then ...   -> but note: the bits are stored as a number. The j-th bit (starting from 0 as the least significant) is the j-th bit from the right.\n\n            But we want the most significant bit (which corresponds to the highest power) to be the first character. \n\n            The highest bit in the substring (which was the bit at position len_bin-2 in the mask) is the (len_str-1)-th bit of the number `bits`? \n\n            Actually, the number `bits` is in the range [0, 2^(len_str)-1]. The most significant bit is the bit at position (len_str-1) (counting from 0 at the least significant). \n\n            So we can traverse j from len_str-1 down to 0:\n\n                if (bits has the bit set at position j) then the digit is '7'\n                else '4'\n\n            Then we form the string and convert to an integer(kind=8).\n\n          However, we don't need to form the string? We can form the number directly? \n\n          The number: each digit is 4 or 7. We can compute:\n\n            value = 0\n            do j = len_str-1 downto 0\n                if (btest(bits, j)) then\n                    digit = 7\n                else\n                    digit = 4\n                end if\n                value = value * 10 + digit\n\n          But note: the bits are stored in the variable `bits` as a base2 number. The j we are iterating is the bit position? \n\n          However, the bits in `bits` are stored as a base2 number, and the bit at position j (0-indexed from the least significant) is the j-th bit. But we want to traverse from the highest bit (which is position len_str-1) to the lowest (position 0). \n\n          Example: mask=5 -> len_bin=3 -> len_str=2. Then bits = 5 - 2**(2) = 5-4=1. \n            The binary representation of 1 in 2 bits: \"01\". \n            We want to form the number: first digit: from the highest bit (bit1) -> 0 -> then digit=4; then bit0: 1 -> then digit=7 -> so the number is 47.\n\n          How to get the highest bit? The highest bit in the 2-bit representation is bit1 (which is the 2^1 bit). \n\n          We can check the bit at position j for j from len_str-1 down to 0.\n\n          But note: the number `bits` might not have the full len_str bits? Actually, we have exactly len_str bits? because we subtracted 2**(len_bin-1), and then we are representing it in len_str bits? \n\n          So we can do:\n\n            do j = len_str-1, 0, -1\n                if (bits has the j-th bit set) then ... \n\n          How to check? We can use:\n\n            if (btest(bits, j)) then ...   -> but Fortran's btest tests the j-th bit from the least significant? meaning j=0 is the lowest. \n\n          But we want the j-th bit from the most significant? \n\n          Alternatively, we can note: the bit we want at the first character is the bit at position (len_str-1) in the entire `bits`? \n\n          Actually, we are storing the bits in an integer, and the integer has the bits in little-endian? But btest is independent: it tests the bit at position j (0-indexed from the least significant). \n\n          So the most significant bit in the substring is the bit at position (len_str-1) of the integer? \n\n          Example: for bits=1 (binary \"01\" in 2 bits): \n            j=0 -> least significant -> 1\n            j=1 -> next -> 0\n\n          But we want to output the most significant first -> so we want to start at j=1 and then j=0.\n\n          Therefore, we traverse j from len_str-1 down to 0, and for each j we check the bit at position j? \n\n          But wait: the bit at position j (with j being the exponent) is the same as the (len_str-1 - j) bit from the most significant? \n\n          Actually, no: the bits are stored in base2: the j-th bit (0-indexed from the least significant) is the coefficient for 2^j.\n\n          We want to output the most significant first: that is the bit for 2^(len_str-1) first.\n\n          So we should traverse j from len_str-1 down to 0, and at each step we check the bit at position j? -> that would be the same as the exponent? \n\n          But note: the bit at position j (0-indexed from the least) is the j-th bit. The highest bit is at position len_str-1? \n\n          So we can do:\n\n            do j = len_str-1, 0, -1\n                if (btest(bits, j)) then   -> but j is the exponent? then the bit at exponent j is set.\n\n          Then the first digit we output is for the highest exponent? That's correct.\n\n          Example: bits=1 (which is 2^0) -> then for j=1: we check if bit1 is set -> no -> then we output 4; for j=0: set -> output 7 -> so the number is 47.\n\n          That matches.\n\n        Therefore, we can form the number without building a string? \n\n        But note: the number might be too big? We are forming a decimal number from a string of up to 30 digits? But we break when we find a number >= res1 (which is at most about 666e6) so we only go up to 10 digits? 10 digits: 10^10 is 10 billion, which is within the range of integer(kind=8) (max ~9e18).\n\n        So we can form the number by:\n\n          value = 0\n          do j = len_str-1, 0, -1\n             if (btest(bits, j)) then\n                 digit = 7\n             else\n                 digit = 4\n             end if\n             value = value * 10 + digit\n\n        But note: the variable `bits` is an integer. We are using j from len_str-1 down to 0? \n\n        However, we must be cautious: the bit position j must be in the range [0, len_str-1]. And we have ensured that `bits` has at most len_str bits? Actually, `bits` is in the range [0, 2**len_str - 1]. \n\n        But note: the mask might have more than len_str bits? No, because we subtracted the leading one, and the rest are exactly len_str bits.\n\n        Therefore, we can do:\n\n          if (mod(len_str,2) == 0) then   ! only even lengths\n             pop = popcnt(bits)   ! intrinsic function? Fortran 2008 has popcnt, but we can also count by btest over j from 0 to len_str-1? \n             if (pop == len_str/2) then   ! condition for same number of zeros and ones? but note: zeros = len_str - pop, and we require zeros==pop -> so pop==len_str/2.\n                 ! form the number\n                 temp_value = 0\n                 do j = len_str-1, 0, -1\n                    if (btest(bits, j)) then\n                        digit = 7\n                    else\n                        digit = 4\n                    end if\n                    temp_value = temp_value * 10_8 + digit\n                 end do\n                 if (temp_value >= start) then\n                    res2 = temp_value\n                    exit   ! break the mask loop\n                 end if\n             end if\n          end if\n\n        But note: the mask is an integer that can be large? However, the value we are looking for is at most 10 digits? So len_str is at most 10? Then the mask: \n            The mask starts at 2, and the mask for a string of length L is at least 2^L? and then we subtract the leading one. \n\n            For L=10: mask_min = 2^10 = 1024. We start at mask=2 and go up to at least 1024? \n\n        We can break when we find a value >= start.\n\n        But note: the mask is incremented until we find one. The mask for the 10-digit numbers: the mask starts at 2^10=1024? Actually, the mask for the first 10-digit super lucky number: \n            We want a binary string without the leading one of length 10? So the mask is 2^10 + x, where x is the value we use for the bits. \n\n        So we iterate mask from 2 to ... until we get a value that is >= start and satisfies the condition.\n\n        But note: the mask for a substring of length L is in the range [2^L, 2^(L+1)-1]. \n\n        We can iterate by length? But the original program iterates mask without regard to length? \n\n        However, the super lucky numbers are generated in increasing order? Not exactly: \n            mask=2 -> \"0\" -> 4\n            mask=3 -> \"1\" -> 7\n            mask=4 -> \"00\" -> 44\n            mask=5 -> \"01\" -> 47\n            mask=6 -> \"10\" -> 74\n            mask=7 -> \"11\" -> 77\n            mask=8 -> \"000\" -> skip (odd length)\n            mask=9 -> \"001\" -> skip (odd length) ... until mask=16: \"0000\" -> 4444\n\n        But 44 (mask=4) is 44, which is greater than 7? But we break as soon as we find a value >= start? So if start=1, we break at mask=2? \n\n        So we are generating in increasing order? Actually, 4 < 7 < 44 < 47 < 74 < 77 < 4444 ... \n\n        But 4444 is 4 digits and 4444 > 77? \n\n        So the order is increasing by the numerical value? \n\n        But the mask iteration: \n            mask=2: value=4\n            mask=3: value=7\n            mask=4: value=44 -> 44>7? so if start=5, then we break at mask=3 (value=7) because 7>=5? \n\n        But then we skip 44? which is the next super lucky number? \n\n        Actually, the condition in the while loop is: we break at the first super lucky number that is >= start. \n\n        And we generate in increasing order? \n\n        However, the mask iteration does not generate in increasing numerical order? \n            mask=2: 4\n            mask=3: 7 -> which is greater than 4 -> okay.\n            mask=4: 44 -> which is greater than 7? -> no, 44>7 -> so we break at 7? \n\n        But wait: 44 is 44, which is greater than 7? So if we are looking for the first super lucky number >=5, we break at 7? \n\n        Then what about 44? It is generated later? \n\n        Actually, the condition: we break as soon as we find one? So we don't generate all super lucky numbers? \n\n        But the original program: \n            It starts at mask=2 and increments mask until it finds the first super lucky number that is >= the input.\n\n        How does it generate 44? \n            When the input is 8: \n                mask=2: 4 <8 -> skip\n                mask=3: 7 <8 -> skip\n                mask=4: 44>=8 -> break -> output 44.\n\n        But 44 is the next super lucky number after 7? \n\n        However, note: the super lucky numbers: \n            4,7,44,47,74,77,4444,4447,... \n\n        So 44 is the next after 7? \n\n        And our mask=4 produces 44? \n\n        Therefore, the mask iteration does generate in increasing order? \n\n        Why? Because the mask increases, and the value produced by mask is:\n\n            value = f(mask) = number formed by replacing 0->4, 1->7 in the binary representation of mask without the leading one.\n\n        The binary representation of mask without the leading one: the length is increasing as mask increases. And for the same length, the value increases? \n\n        Example for length=2: \n            mask=4: \"00\" -> 44\n            mask=5: \"01\" -> 47\n            mask=6: \"10\" -> 74\n            mask=7: \"11\" -> 77\n\n        Then next mask=8: length=3 (skip because odd) -> mask=9: \"001\" -> skip (odd) ... mask=16: length=4 -> \"0000\" -> 4444.\n\n        So the values: 44,47,74,77, then 4444? \n\n        And 44<47<74<77<4444? \n\n        So the mask iteration produces the super lucky numbers in increasing order? \n\n        Therefore, we can iterate mask from 2 upward and break at the first value that is >= start.\n\n        However, note: the mask might become very large? But we break when the value is >= start, and start is at most about 666e6? The first super lucky number with 10 digits is 4444444444 (which is 4e9) -> which is greater than 666e6? So we break at the first super lucky number that is >= start, which might be a 2,4,6,8, or 10-digit number.\n\n        The maximum mask we need: for a super lucky number of 10 digits, the mask starts at 2^10 = 1024 and goes up to 2^11-1? But we break as soon as we form the first 10-digit number that is >= start? \n\n        And the 10-digit numbers start at 4444444444 (4e9) and go up? \n\n        But if start is 5000000000, then we break at the first 10-digit super lucky number that is >=5000000000? \n\n        How many masks? For 10 digits, the mask ranges from 1024 to 2047? and we skip the masks that do not have exactly 5 ones? Then we form the number and compare? \n\n        This is acceptable because 2^11 is only 2048.\n\n        So we can iterate mask from 2 to a sufficiently large number? We can set an upper bound: for example, we know that the number of digits we need is at most 60? But we break when the value is found.\n\n        Alternatively, we can break when the length of the substring (len_str) becomes too large? But we don't know. \n\n        We can set an upper bound for mask? For example, we know that the value we are looking for is at least the start (which is at most 666e6) and the next super lucky number is at most 10 digits? 10 digits: the mask for the first 10-digit number is 1024? \n\n        Actually, the mask for the first 10-digit number is 2^10 = 1024? Then we break at mask=1024? \n\n        But wait: we might have to iterate over many masks for the same length? For 10 digits, we have to iterate masks from 1024 to 2047? and we skip masks that do not have exactly 5 ones? \n\n        The number of masks for 10 digits: we require 5 ones in the 10 bits? C(10,5)=252. So we iterate 252 masks? \n\n        Then we form the number and compare? \n\n        So we can do:\n\n          start = res1   (as int64)\n\n          mask = 2\n          found = .false.\n          do while (.not. found)\n             ! compute len_bin = floor(log2(real(mask, kind=8))) + 1   [number of bits in mask]\n             len_bin = 0\n             temp_mask = mask\n             do while (temp_mask > 0)\n                 len_bin = len_bin + 1\n                 temp_mask = rshift(temp_mask, 1)   ! or temp_mask = temp_mask/2\n             end do\n             ! Actually, we can use bit_size? But we want the minimal number of bits. \n             ! Alternatively, we can compute: \n             !   if (mask==0) then len_bin=0; else len_bin = floor(log(real(mask, kind=8))/log(2.0)) + 1\n\n             len_str = len_bin - 1   ! we remove the leading one.\n\n             if (len_str <= 0) then   ! skip if no bits? but mask>=2 -> len_bin>=2 -> len_str>=1.\n                 ! skip?\n             end if\n\n             if (mod(len_str,2) == 0) then   ! even length\n                 ! Extract the bits: the value without the leading one is: bits = mask - 2**(len_bin-1)\n                 bits = mask - 2**(len_bin-1)   ! note: 2**(len_bin-1) is the value of the leading one.\n\n                 ! Count the number of ones in the lower len_str bits? But note: bits has exactly len_str bits? \n                 pop = 0\n                 do j = 0, len_str-1\n                    if (btest(bits, j)) pop = pop + 1\n                 end do\n\n                 if (pop == len_str/2) then   ! condition\n                    ! form the number from the bits: from the highest bit to the lowest? \n                    temp_value = 0\n                    do j = len_str-1, 0, -1   ! j from high to low: we want the highest bit to be the first digit\n                       if (btest(bits, j)) then\n                           digit = 7\n                       else\n                           digit = 4\n                       end if\n                       temp_value = temp_value * 10 + digit\n                    end do\n\n                    if (temp_value >= start) then\n                       res2 = temp_value\n                       found = .true.\n                    end if\n                 end if\n             end if\n             mask = mask + 1\n          end do\n\n        But note: the mask might be large? For 10-digit numbers, the mask goes from 1024 to 2047? But what if we don't find a 10-digit number? Then we go to 12? \n\n        But the next super lucky number after 10-digit is 12-digit? and 12-digit numbers start at 444444444444 (4e11) which is > 666e6? so we break at the first 10-digit super lucky number? \n\n        However, we break as soon as we find one >= start? \n\n        But what if the start is 1e18? Then we might need a very long mask? \n\n        But note: the output of the first program: if n is 3e9, then res1 = (3e9/3)*2 + 0 = 2e9. The next super lucky number might be 4444444444 (4e9) -> which is found at mask=1024? \n\n        But if n is 5e18? Then we need a super lucky number with 20 digits? The mask for 20 digits: from 2^20 to 2^21-1 -> about 2e6 masks? and we require exactly 10 ones? The number of masks to iterate is C(20,10)=184756, which is acceptable? \n\n        But worst-case: the next super lucky number might be with 60 digits? Then mask would be from 2^60 to 2^61-1, which is 2^60 masks? that is too many.\n\n        We need a better approach? \n\n        The original Java program iterates mask until the value is found. It might not be efficient for very large numbers? \n\n        But note: the input n for the first program: the problem context (codeforces_669_A) is for n up to 1000? Or what? \n\n        Actually, the problem does not specify, but we assume the input is within the range of an integer. \n\n        However, the chain: the first program reads an integer n (which in Java is up to 2e9). Then res1 is about (2e9/3)*2+1 -> about 1.3e9. Then the second program: the next super lucky number above 1.3e9 is 4444444444? which is 4e9. The mask for 10 digits: 1024 to 2047 -> about 1000 masks? \n\n        So we assume the mask loop will not be too heavy.\n\n        But to be safe, we can break the mask loop when the value we form (temp_value) becomes too large? \n\n        Alternatively, we can iterate by the length L (even) from 2,4,6,... and for each L, we generate all masks that are L-bit numbers? \n\n        How? The mask for a fixed length L is in the range [2^L, 2^(L+1)-1]. \n\n        Then for each mask in that range, we compute the bits = mask - 2**L, and then check if the popcount of bits is L/2? \n\n        Then form the number and then compare? \n\n        And we break when we find the first number >= start? \n\n        This is more efficient? \n\n        We can do:\n\n          L = 2\n          found = .false.\n          do while (.not. found)\n             if (L is even) then   ! always true\n                 min_mask = 2**L\n                 max_mask = 2**(L+1) - 1\n                 do mask = min_mask, max_mask\n                    bits = mask - min_mask   ! because min_mask = 2**L -> the leading one is removed, leaving L bits.\n\n                    pop = popcnt(bits)   ! but note: bits is an integer, and we are only interested in the L bits? \n                    if (pop == L/2) then\n                       ! form the number: \n                       temp_value = 0\n                       do j = L-1, 0, -1\n                          if (btest(bits, j)) then\n                             digit = 7\n                          else\n                             digit = 4\n                          end if\n                          temp_value = temp_value * 10 + digit\n                       end do\n                       if (temp_value >= start) then\n                          res2 = temp_value\n                          found = .true.\n                          exit   ! exit the inner mask loop\n                       end if\n                    end if\n                 end do\n             end if\n             L = L + 2   ? But note: we are going by even lengths? \n          end do\n\n        But this iterates by increasing L? and the numbers are generated in increasing order? \n\n        The smallest number for L=2: 44,47,74,77 -> which are greater than the numbers for L=0? and less than the numbers for L=4? \n\n        But note: the number 44 is 44, which is greater than 7 (which is L=1? but we skip odd) -> but 7 was generated at L=1? we skipped. \n\n        How did we generate 4 and 7? They are for L=1? but we skip odd. \n\n        But wait: the original mask iteration started at mask=2: \n            mask=2: L=1 -> skipped? \n            mask=3: L=1 -> skipped? \n            mask=4: L=2 -> then we generate 44.\n\n        So we missed 4 and 7? \n\n        Why? Because the original mask=2 and mask=3: \n            For mask=2: len_bin=2 -> len_str=1 -> odd -> skip.\n            mask=3: len_bin=2 -> len_str=1 -> skip.\n\n        So the original program does not generate 4 and 7? \n\n        But wait: the first program: \n            mask=2: binary \"10\" -> substring(1) is \"0\" -> then becomes \"4\" -> value=4.\n            mask=3: \"11\" -> \"1\" -> becomes \"7\" -> value=7.\n\n        How did we get the length? \n            For mask=2: len_bin = number of bits: 2 -> len_str=1 -> which is odd -> skip.\n\n        So we skip? \n\n        But the condition in the second program: \n            if (zeros != s.length() - zeros) continue;\n            For mask=2: s=\"0\" -> length=1 -> zeros=1, ones=0 -> not equal -> skip.\n\n        So the second program also skips mask=2 and mask=3? \n\n        Then how does it produce 4 and 7? \n\n        Let me run the second Java program for input=1:\n\n          mask=2: s = Integer.toBinaryString(2) -> \"10\", then substring(1) -> \"0\". \n          zeros = 1 (because one char '0') -> s.length()=1 -> zeros==1, ones=0 -> not equal -> skip.\n          mask=3: s = \"11\" -> substring(1)=\"1\" -> zeros=0, ones=1 -> not equal -> skip.\n          mask=4: s = \"100\" -> substring(1)=\"00\" -> zeros=2, ones=0 -> not equal? 2 != 0 -> skip.\n          mask=5: s = \"101\" -> substring(1)=\"01\" -> zeros=1, ones=1 -> equal -> then s becomes \"47\" -> value=47.\n\n        So 47 is the first super lucky number? \n\n        But 4 and 7 are not generated? \n\n        This contradicts the example? \n\n        Actually, the example says: \n            mask=2: s = \"0\" -> becomes \"4\" -> value=4.\n\n        But the condition: \n            zeros = 1, and the length is 1 -> then zeros != 1 - zeros? -> 1 != 0 -> skip.\n\n        So the program does not output 4? \n\n        Then what is the first super lucky number? \n\n        The definition: a super lucky number is a number that has an even number of digits and the digits are only 4 and 7 and the number of 4s equals the number of 7s.\n\n        So 4 and 7 are not super lucky? because they have only one digit (odd) and also the condition of half and half fails.\n\n        Therefore, the first super lucky number is 44? \n\n        But wait: the second program: \n            mask=4: \"00\" -> becomes \"44\", then zeros=2, ones=0 -> 2 != 0? -> skip.\n            mask=5: \"01\" -> becomes \"47\", zeros=1, ones=1 -> condition holds -> value=47.\n\n        So the first super lucky number is 47? \n\n        But 44 is also super lucky? \n\n        Why is 44 skipped? \n            For mask=4: the binary string is \"00\", then zeros=2, ones=0 -> 2 != 0 -> skip.\n\n        The condition: if (zeros != s.length() - zeros) ... \n            zeros = 2, s.length()=2 -> then s.length()-zeros=0 -> 2 != 0 -> skip.\n\n        So the condition requires that the number of zeros equals the number of ones? \n\n        Therefore, the definition of super lucky number in the second program is: \n            the number of zeros (in the binary mask string) must equal the number of ones.\n\n        But then 44 would be generated from a binary string with two zeros? then zeros=2, ones=0 -> not equal -> skip.\n\n        So 44 is not generated? \n\n        How do we generate 44? \n\n        We need a binary string with two zeros and two ones? But wait: the length is 2, so if we have two zeros, then ones=0. \n\n        The condition: zeros == ones -> 2==0? false.\n\n        So the only super lucky number of length 2 is 47 and 74 and 77? \n\n        But 47: \n            binary string: \"01\" -> zeros=1, ones=1 -> condition holds.\n\n        Similarly, 74: \"10\" -> zeros=1, ones=1.\n        and 77: \"11\" -> zeros=0, ones=2 -> 0==2? false.\n\n        So only 47 and 74? \n\n        But the problem says: super lucky number is a number such that its decimal representation contains an even number of digits, and the digits are only 4 and 7, and the number of 4s equals the number of 7s.\n\n        So 44 has two 4's and zero 7's -> fails because the number of 4's should equal the number of 7's? \n\n        And 77 fails similarly.\n\n        Therefore, the super lucky numbers are: 47,74,4477,444777, etc. \n\n        But then what about 44447777? \n\n        So the condition in the second program is correct: the binary string must have an even length and exactly half zeros and half ones? \n\n        And then we replace zeros by 4 and ones by 7? \n\n        Therefore, the number of 4's in the decimal representation will be the number of zeros in the binary string, and the number of 7's will be the number of ones? \n\n        So the decimal representation will have exactly half 4's and half 7's? \n\n        And the total number of digits is even? \n\n        So it matches the definition.\n\n        Therefore, the first super lucky number is 47? \n\n        But then the example in the second program: \n            input=1: output=47.\n\n        However, the example in the first program: \n            input=1: res1 = (1/3)*2+1 = 0+1 = 1.\n            then second program: the first super lucky number >=1 is 47.\n\n        So we are good.\n\n        Therefore, we must change our approach: the condition is not on the number of ones in the entire `bits`? but on the count of zeros and ones in the binary string? which is exactly the same as the condition in the second program: \n            zeros = count of '0' in the binary string (which is the same as the number of unset bits in the `bits` over the len_str bits? but note: the binary string is exactly the representation of `bits` in len_str bits? \n\n        How to count the zeros? \n            zeros = len_str - popcount(bits)\n\n        And we require: zeros == popcount(bits)   -> popcount(bits) = len_str/2.\n\n        So the condition is the same.\n\n        But note: the binary string for mask=5 (which is 101) without the leading one is \"01\", which has len_str=2, and popcount(bits)=1, and len_str/2=1 -> condition holds.\n\n        For mask=4 (100->\"00\"): popcount=0, then condition: 0 == 2/2 -> 0==1 -> false.\n\n        So we skip.\n\n        Therefore, we can use the popcount condition.\n\n        And we must start at mask=2 and go up? and we break when we find the first value>=start.\n\n        But we can also iterate by length L=2,4,6,... and within each length, iterate mask from 2^L to 2^(L+1)-1, and then within that, we extract bits = mask - 2^L, and then check popcount(bits)==L/2.\n\n        And then form the number and break when we find one>=start.\n\n        This generates in increasing order by L? and within L, by the value of the mask? \n\n        But the value of the number: \n            For L=2: we generate 47 and 74? \n                mask=5: bits=5-4=1 -> binary \"01\" (in 2 bits) -> then the number: j=1: bit1? -> btest(1,1) is false? -> '4'; j=0: btest(1,0) is true -> '7' -> 47.\n                mask=6: bits=6-4=2 -> binary \"10\" -> then j=1: btest(2,1) -> true -> '7'; j=0: btest(2,0) -> false -> '4' -> 74.\n\n            So 47<74.\n\n        And we iterate mask from 5 to 6? \n\n        Then for L=4: mask from 16 to 31? \n\n        The smallest number for L=4: the smallest mask with popcount=2 is 16+3 (binary \"0011\") -> number = 4477? \n        But mask=16: bits=0 -> popcount=0 -> skip.\n        mask=17: bits=1 -> binary \"0001\" -> popcount=1 -> skip.\n        mask=18: bits=2 -> popcount=1 -> skip.\n        mask=19: bits=3 -> popcount=2 -> then the number: \n            j=3: btest(3,3)? false -> '4'\n            j=2: false -> '4'\n            j=1: true -> '7'\n            j=0: true -> '7'\n            -> 4477.\n\n        Then next is mask=20: bits=4 -> popcount=1 -> skip.\n\n        So the numbers are generated in increasing order? \n\n        But 74 (L=2) is 74, and 4477 is 4477, which is greater than 74? \n\n        So to generate in increasing order, we must iterate L from 2,4,6,... and within L, iterate mask from 2^L to 2^(L+1)-1, and then the number we form is increasing? \n\n        But note: 47 and 74 are both less than any 4-digit number.\n\n        So we can do:\n\n          start = res1   (int64)\n\n          found = .false.\n          L = 2\n          do while (.not. found)\n             min_mask = 2**L\n             max_mask = 2**(L+1) - 1\n             do mask = min_mask, max_mask\n                 bits = mask - min_mask\n                 ! Count the number of ones in the L bits of `bits`\n                 pop = 0\n                 do j = 0, L-1\n                    if (btest(bits, j)) pop = pop + 1\n                 end do\n                 if (pop == L/2) then\n                    ! form the number from the bits: from most significant (bit L-1) to least (bit0)\n                    temp_value = 0\n                    do j = L-1, 0, -1\n                       if (btest(bits, j)) then\n                           digit = 7\n                       else\n                           digit = 4\n                       end if\n                       temp_value = temp_value * 10_8 + digit\n                    end do\n                    if (temp_value >= start) then\n                       res2 = temp_value\n                       found = .true.\n                       exit   ! exit inner loop\n                    end if\n                 end if\n             end do\n             if (.not. found) L = L + 2\n          end do\n\n        This should work.\n\n        But note: the mask might be large? For large L, the range is from 2^L to 2^(L+1)-1, which has size 2^L. For L=20, 2^20 is 1e6? and we iterate over 1e6 masks? and we do this for increasing L until we find one? \n\n        The worst-case L might be 60? then 2^60 is too many.\n\n        We need to break when L is such that the smallest number for that L (which is 4...4, with L/2 fours and then L/2 sevens? but actually the smallest is 4...47...7) is greater than start? \n\n        But note: the smallest number for length L is 4...4 (all fours) -> which is 4 * (10^L-1)/9. \n\n        We can compute this and break the outer loop if the smallest number for L is already >= start? \n\n        But we are iterating L from 2 upward. We can compute the smallest number for L: \n            num_min = 0\n            do i = 1, L\n                num_min = num_min * 10 + 4\n            end do\n\n        Then if num_min >= start, then we will find a number in this L, so we do the inner loop and break after the first one? \n\n        But note: the numbers in the inner loop are not sorted in increasing order? We iterate mask from min_mask to max_mask, and the number is formed by the binary representation? \n\n        The smallest number for fixed L is 4...4 (when the binary representation is all zeros) -> but we skip that because popcount=0 != L/2? \n\n        The smallest number might be 4..47..7? \n\n        Actually, the smallest number is when the binary representation is sorted: zeros first then ones? so the number is 4...47...7. \n\n        So we can compute:\n\n            num_min = 0\n            do i = 1, L/2\n                num_min = num_min * 10 + 4\n            end do\n            do i = 1, L/2\n                num_min = num_min * 10 + 7\n            end do\n\n        But this might not be the smallest? The smallest might be 4..474..7? \n\n        We cannot easily determine the minimum number without generating? \n\n        Alternatively, we can break the outer loop when L is such that the smallest possible number (which is 4...4) is already greater than the current candidate? But wait, we haven't found any candidate in the previous L? \n\n        We can store the best candidate found so far? \n\n        Given the complexity, and since the first program's output is at most about 666e6, the smallest L for which the smallest super lucky number is greater than 666e6 is L=10: \n            smallest super lucky number for L=10: 4444477777? -> 4444477777 > 666e6? \n\n        And L=10: the inner loop iterates over 2^10=1024 masks? which is acceptable.\n\n        So we can simply iterate L=2,4,6,... up to L_max (say 60) and break when we find one.\n\n        Given that 2^60 is too many, but for L=2,4,..., up to L=60, the inner loop size is 2^L, and we only do L=2,4,6,..., so L=2,4,6,...,60: the total number of masks is sum_{k=1}^{30} 2^{2*k} = sum_{k=1}^{30} 4^k = (4^31-4)/3, which is about 4^31, which is 4e9, which is too many.\n\n        Therefore, we must iterate by mask within a fixed L without iterating exponentially many times? \n\n        But note: we only iterate over the masks that have exactly L/2 ones? The number of such masks is C(L, L/2), which for L=60 is C(60,30) ~ 1e17, which is too many.\n\n        So we must use the original mask iteration (over all integers starting from 2) and break when we find the first super lucky number>=start.\n\n        But then for start=1, we find at L=2: mask=5:47? \n\n        How many masks do we iterate? \n            We start at mask=2, then 3,4,...,5 -> 4 masks.\n\n        For start=1e18, we need to go to L=40? The mask for L=40 is about 2^40, and we iterate from 2 to 2^40? that is 2^40 iterations ~ 1e12, which is too many.\n\n        We need a better approach? \n\n        Given the complexity, and since the first program's output is at most about 666e6, we know that the answer will be for L<=10 (because the smallest super lucky number for L=10 is 4444444444 which is 4e9, which is >666e6). \n\n        So we can iterate mask from 2 to 2^11-1 (which is 2047) and that's it.\n\n        Specifically, we can set an upper bound for mask: \n            mask_max = 2*10**4   ? but we know that for L=10, we only go up to 2047.\n\n        So we can do:\n\n          start = res1   (int64)\n\n          res2 = a big number, say 10**18    ! as initial\n          found = .false.\n          mask = 2\n          do while (.not. found .and. mask <= 100000)   ! 100000 is arbitrary, but for L=10 we only need up to 2047.\n\n          ... the same as above ...\n\n        But we might find it within mask<=2047.\n\n        Alternatively, we can iterate L from 2 to 40 by step 2, and for each L, iterate only the masks that have exactly L/2 ones? \n\n        How to iterate combinations? \n\n          We can generate all binary strings of length L with exactly L/2 ones? \n\n          But the number is C(L, L/2), and for L=40, C(40,20) is about 1.3e11, which is too many.\n\n        Given the constraints on start (<= about 666e6) and the fact that the answer will be with L<=10 (since the first super lucky number for L=10 is 4e9>666e6), we can simply iterate L from 2 to 10 by step 2, and for each L iterate mask in [2^L, 2^(L+1)-1] (which is 2^L numbers per L) and the total is 2^2+2^4+2^6+2^8+2^10 = 4+16+64+256+1024 = 1364, which is acceptable.\n\n        Therefore, we can do:\n\n          start = res1\n\n          res2 = -1\n          do L = 2, 10, 2   ! L=2,4,6,8,10\n             min_mask = 2**L\n             max_mask = 2**(L+1)-1\n             do mask = min_mask, max_mask\n                 bits = mask - min_mask   ! an integer in [0, 2^L-1]\n                 pop = popcnt(bits)       ! but note: Fortran's popcnt counts all bits? but we only care about the L bits? \n                 ! However, since bits < 2^L, it has at most L bits, and popcnt(bits) is the count in the entire integer? which is the same as the count in the L bits.\n                 if (pop == L/2) then\n                    ! form the number\n                    temp_value = 0\n                    do j = L-1, 0, -1\n                       if (btest(bits, j)) then\n                           digit = 7\n                       else\n                           digit = 4\n                       end if\n                       temp_value = temp_value * 10_8 + digit\n                    end do\n                    if (temp_value >= start) then\n                       ! We found a candidate\n                       if (res2 == -1 .or. temp_value < res2) then\n                           res2 = temp_value\n                       end if\n                    end if\n                 end if\n             end do\n          end do\n\n          ! After the loops, res2 is the smallest super lucky number >= start.\n\n        But note: it is possible that there is no super lucky number in L<=10? then we need to go to L=12, etc. \n\n        Given that start is at most 666e6, the super lucky number for L=10: the smallest is 4444444444 (4e9) which is >666e6. \n\n        And we will find candidates in L=10, and we want the smallest candidate? \n\n        But note: the super lucky numbers in L=2,4,6,8 are less than 10^8? and 10^8<666e6 (which is 6.66e8) -> so we might find candidates in L=8 and L=10? \n\n        And we want the smallest candidate overall? \n\n        We are iterating L from 2 to 10, and within L, we iterate mask from min_mask to max_mask. This does not generate in increasing numerical order? \n\n        Example: \n            L=2: we get 47,74.\n            L=4: we get 4477, 4447, ... the smallest in L=4 is 4477.\n\n        And 47<4477, so we should compare across L. \n\n        Therefore, we cannot break at the first candidate in the smallest L? because a larger L might yield a smaller candidate? \n\n        But the numbers in a smaller L are always smaller than those in a larger L? \n            The largest number in L=2: 77 < smallest in L=4: 4444? -> 77<4444? no, 77<4444? -> 77 is 77 and 4444 is 4444 -> 77<4444? \n            But wait: 77 is 77 and 4444 is 4444 -> 77<4444? -> no, 77 < 4444? -> 77 is less than 4444? -> yes.\n\n        So the smallest candidate might be in L=2, then in L=4 we get larger candidates. \n\n        Therefore, we can break at the first L where we find a candidate? \n\n        But wait: it is possible that in L=2 there is no candidate>=start, then we go to L=4, and then we find one. \n\n        But within a fixed L, the candidates are not generated in increasing order? \n\n        Example: L=4: \n          mask=16+3: bits=3: \"0011\" -> 4477\n          mask=16+5: bits=5: \"0101\" -> 4747 -> which is greater than 4477? \n          ...\n\n        So within a fixed L, we iterate mask in increasing order, but the numerical value of the formed number is not sorted by mask? \n\n        Therefore, we must for each L iterate all masks and keep the smallest candidate>=start in that L, and then overall the smallest candidate over all L.\n\n        But note: the smallest candidate overall will be in the smallest L that has any candidate>=start? because any number in a smaller L is smaller than any number in a larger L? \n\n        Why? \n            The largest number in L is at most (77...7 with L digits) < (44...4 with L+2 digits) because 77...7 < 10^L, and 44...4 (L+2) >= 10^(L+1) > 10^L > 77...7.\n\n        Therefore, we can do:\n\n          res2 = -1\n          do L = 2, 100, 2   ! L up to 100? but we know within L=10 we will find one for start<=666e6.\n             min_mask = 2**L\n             max_mask = 2**(L+1)-1\n             ! In this L, we will find the smallest candidate>=start, if exists.\n             candidate = -1\n             do mask = min_mask, max_mask\n                 bits = mask - min_mask\n                 if (popcnt(bits) /= L/2) cycle\n                 ! form the number\n                 temp_value = 0\n                 do j = L-1, 0, -1\n                    if (btest(bits, j)) then\n                        digit = 7\n                    else\n                        digit = 4\n                    end if\n                    temp_value = temp_value * 10_8 + digit\n                 end do\n                 if (temp_value < start) cycle\n                 if (candidate == -1 .or. temp_value < candidate) then\n                     candidate = temp_value\n                 end if\n             end do\n             if (candidate /= -1) then\n                 res2 = candidate\n                 exit   ! break the L loop\n             end if\n          end do\n\n        This will work.\n\n        But note: we might not find a candidate in L=2, then we go to L=4, and as soon as we find one candidate in any L, we break because any candidate in a larger L will be bigger.\n\n        Therefore, we exit at the first L (starting from 2) for which there is at least one candidate>=start, and we take the smallest candidate in that L.\n\n        And the smallest candidate in that L is the first super lucky number>=start.\n\n        Why? Because any super lucky number in a smaller L would have been found in a previous iteration and been smaller.\n\n        Example: start=50.\n          L=2: \n            47<50 -> skip.\n            74>=50 -> candidate=74.\n          then we set res2=74 and break.\n\n        But wait, is 74 the first>=50? What about 47? 47<50, so it's skipped. \n\n        So it is the first in the chain: 47,74 -> then 74 is the first>=50.\n\n        Therefore, this is correct.\n\n        Steps for the entire program:\n\n          step1: read n (integer)\n          step2: compute res1 = (n/3)*2 \n                  if (mod(n,3)==0) then res1 = res1 + 0\n                  else res1 = res1 + 1\n          step3: convert res1 to int64: start = res1\n\n          step4: \n             res2 = -1\n             do L = 2, 100, 2   ! L from 2 to 100 by step 2\n                 min_mask = 2**L\n                 max_mask = 2**(L+1) - 1\n                 candidate = -1\n                 do mask = min_mask, max_mask\n                     bits = mask - min_mask\n                     ! Count the number of set bits in `bits` (which has exactly L bits)\n                     pop = 0\n                     do j = 0, 63   ! we care only up to L-1, but L<=100, but bits may be stored in 64 bits.\n                         if (j >= L) exit\n                         if (btest(bits, j)) pop = pop + 1\n                     end do\n                     if (pop /= L/2) cycle\n\n                     ! form the number from the binary representation of `bits` (L bits, from most significant to least)\n                     temp_value = 0\n                     ! We want to get the bits from the most significant (bit L-1) to the least (bit0)\n                     do j = L-1, 0, -1\n                         if (j < 0) exit\n                         if (btest(bits, j)) then\n                             digit = 7\n                         else\n                             digit = 4\n                         end if\n                         temp_value = temp_value * 10_8 + digit\n                     end do\n\n                     if (temp_value < start) cycle\n\n                     if (candidate == -1) then\n                         candidate = temp_value\n                     else\n                         if (temp_value < candidate) candidate = temp_value\n                     end if\n                 end do   ! end mask for fixed L\n\n                 if (candidate /= -1) then\n                     res2 = candidate\n                     exit\n                 end if\n             end do   ! end L\n\n          step5: convert res2 to a string (call it s)\n\n          step6: \n             ! Now, simulate the third program: \n             !   Build a frequency map for the characters in the string s.\n             !   Check: \n             !      if there are exactly 2 distinct characters and each appears exactly twice -> then output \"Yes\"\n             !      else output \"No\"\n\n          How to build the frequency map in Fortran? \n             We can use an array for ASCII? but we only have '4' and '7'? \n             Or we can use a loop and compare.\n\n          Steps for the third program:\n\n            character(len=:), allocatable :: s   ! string representation of res2\n            integer :: freq(0:255) = 0   ! frequency for ASCII, but we only need '4' and '7'\n\n            do i = 1, len(s)\n                c = s(i:i)\n                ich = iachar(c)\n                freq(ich) = freq(ich) + 1\n            end do\n\n            distinct = 0\n            allTwice = .true.\n            do i = 0, 255\n                if (freq(i) > 0) then\n                    distinct = distinct + 1\n                    if (freq(i) /= 2) then\n                        allTwice = .false.\n                    end if\n                end if\n            end do\n\n            if (distinct == 2 .and. allTwice) then\n                print *, \"Yes\"\n            else\n                print *, \"No\"\n            end if\n\n          But note: the condition in the original program: \n                for (Entry<Character, Integer> c : map.entrySet()) {\n                    if (c.getValue() != 2) {\n                        ok = false;\n                        break;\n                    }\n                }\n                if (ok && map.size()==2) ... \n\n          So it requires that every character that appears appears exactly twice, and there are exactly two distinct characters.\n\n          In our case, the string might have more than two distinct characters? but it's composed of '4' and '7'. So distinct will be either 1 or 2.\n\n          But what if the string has a digit other than '4' and '7'? It shouldn't.\n\n          However, the condition in the third program is general.\n\n          But note: the string is the decimal representation of res2, which is composed only of '4' and '7'. So distinct will be 1 or 2.\n\n          So we could simply:\n\n             count4 = 0\n             count7 = 0\n             do i = 1, len(s)\n                 if (s(i:i)=='4') count4 = count4+1\n                 if (s(i:i)=='7') count7 = count7+1\n             end do\n\n             if ( (count4==2 .and. count7==2) .and. (count4+count7==len(s)) ) then\n                 print *, \"Yes\"\n             else\n                 print *, \"No\"\n             end if\n\n          But wait: the condition in the third program is: \n              the string has exactly two distinct characters and each appears exactly twice.\n\n          This is equivalent to: \n              total length = 4, and count4=2 and count7=2.\n\n          But what if the string has length!=4? then count4+count7 = len(s), and we require count4==2 and count7==2 -> then len(s)=4.\n\n          So we can do:\n\n             if (len(s)/=4) then\n                 print *, \"No\"\n             else\n                 if (count4==2 .and. count7==2) then\n                     print *, \"Yes\"\n                 else\n                     print *, \"No\"\n                 end if\n             end if\n\n          But the original program does not assume the string length is 4? \n             It counts the frequency of each character, and then checks that every character has frequency 2 and that there are exactly two distinct characters.\n\n          Example: if the string is \"4444\", then distinct=1 and one character has frequency 4 -> fails.\n\n          In our case, the string is composed of '4' and '7'. \n\n          So if the string has length 4, then we require two '4's and two '7's.\n\n          But if the string has length 2, then it's either \"47\", \"74\", \"44\", \"77\". \n             \"47\": distinct=2, but frequencies: '4':1, '7':1 -> not 2 -> fails.\n          So we output \"No\" for any string that is not of length 4 and with two '4's and two '7's? \n\n          But the original program would fail for a string of length 2: distinct=2, but frequencies are 1 and 1 -> not 2 -> fails.\n\n          And for a string of length 6: distinct=2, but frequencies are 3 and 3 -> not 2 -> fails.\n\n          Therefore, the condition is only satisfied for strings of length 4 with two distinct characters and each appears twice.\n\n          So we can simply:\n\n             if (len(s) /= 4) then\n                 write(*,*) \"No\"\n             else\n                 count4 = 0\n                 do i = 1, 4\n                     if (s(i:i)=='4') count4 = count4+1\n                 end do\n                 if (count4==2) then\n                     write(*,*) \"Yes\"\n                 else\n                     write(*,*) \"No\"\n                 end if\n             end if\n\n          But note: the string might contain a character that is not '4' or '7'? but it shouldn't.\n\n          However, the third program is general. But we know the string is from res2, which is composed of '4' and '7'. \n\n          So we can assume only '4' and '7'. Then distinct is either 1 or 2. And the only way to have distinct=2 and each twice is to have two '4's and two '7's.\n\n          But if we have a string of length 4 with two '4's and two '7's, then count4=2 and count7=2.\n\n          And if the string has length 4 and count4=2, then count7=2.\n\n          So we only need to check the length and count the '4's.\n\n          Alternatively, we can do:\n\n             if (len(s)/=4) then\n                 write(*,*) \"No\"\n             else\n                 if (s(1:1)==s(2:2) .and. s(2:2)==s(3:3) .and. s(3:3)==s(4:4)) then\n                     ! all same -> distinct=1 -> fails\n                     write(*,*) \"No\"\n                 else\n                     ! We can check: \n                     if ( (s(1:1)==s(2:2) .and. s(3:3)==s(4:4)) .or. ... ) then  ? -> too complex.\n\n                 end if\n             end if\n\n          Better to count the '4's.\n\n          So:\n\n             if (len(s) /= 4) then\n                 write(*,*) \"No\"\n             else\n                 count = 0\n                 do i = 1,4\n                    if (s(i:i)=='4') count = count+1\n                 end do\n                 if (count==2) then\n                     write(*,*) \"Yes\"\n                 else\n                     write(*,*) \"No\"\n                 end if\n             end if\n\n        But what if the string is \"7777\"? then count4=0 -> not 2 -> \"No\", which is correct.\n\n        And \"4477\": count4=2 -> \"Yes\".\n\n        This matches.\n\n        However, note: the original program would also work for a string like \"abab\" (distinct 'a' and 'b', each twice) -> \"Yes\". \n        But our string only has '4' and '7'. \n\n        And the condition is satisfied only if there are exactly two distinct characters and each appears twice? \n\n        In our case, if the string is \"4747\", then distinct '4' and '7', and each appears twice -> \"Yes\". \n\n        How many '4's in \"4747\"? 2.\n\n        So the count4=2 works.\n\n        Therefore, we can use this.\n\n        But note: the string might have length 4 but contain a digit other than '4' and '7'? It shouldn't, because res2 is composed of '4' and '7'. \n\n        So we are safe.\n\n        Summary of the entire Fortran program:\n\n          program chain\n            implicit none\n            integer :: n, res1, remainder\n            integer(kind=8) :: start, res2, candidate, temp_value, min_mask, max_mask, mask, bits, digit_val\n            integer :: L, j, pop, i, count4, len_s\n            character(len=100) :: s  ! 100 digits should be enough\n\n            ! Step1: read n\n            read(*,*) n\n\n            ! Step2: compute res1\n            res1 = (n / 3) * 2\n            remainder = mod(n, 3)\n            if (remainder /= 0) then\n                res1 = res1 + 1\n            end if\n            start = res1   ! convert to int64\n\n            ! Step3: find the next super lucky number >= start\n            res2 = -1\n            ! We iterate L=2,4,6,..., up to 60 (or until found)\n            do L = 2, 100, 2\n                min_mask = 2**L\n                max_mask = 2**(L+1) - 1\n                candidate = -1\n                do mask = min_mask, max_mask\n                    bits = mask - min_mask\n\n                    ! Count the number of ones in the L bits\n                    pop = 0\n                    do j = 0, L-1\n                        if (btest(bits, j)) pop = pop + 1\n                    end do\n                    if (pop /= L/2) cycle\n\n                    ! Form the number from the binary representation of `bits` (L bits)\n                    temp_value = 0\n                    do j = L-1, 0, -1\n                        if (btest(bits, j)) then\n                            digit_val = 7\n                        else\n                            digit_val = 4\n                        end if\n                        temp_value = temp_value * 10_8 + digit_val\n                    end do\n\n                    if (temp_value < start) cycle\n\n                    ! We have a candidate, and we want the smallest candidate in this L\n                    if (candidate == -1) then\n                        candidate = temp_value\n                    else\n                        if (temp_value < candidate) candidate = temp_value\n                    end if\n                end do\n\n                if (candidate /= -1) then\n                    res2 = candidate\n                    exit\n                end if\n            end do\n\n            ! If we didn't find any, then we use a fallback? \n            if (res2 == -1) then\n                ! In case we didn't find, we set to a default? But the chain should always find one.\n                res2 = 0\n            end if\n\n            ! Convert res2 to a string\n            write(s, '(I0)') res2   ! This writes the integer to a string without leading spaces.\n            len_s = len_trim(s)      ! But I0 may give the exact length.\n\n            ! Step4: check the string for the third program\n            if (len_s /= 4) then\n                write(*,*) \"No\"\n            else\n                count4 = 0\n                do i = 1, 4\n                    if (s(i:i) == '4') count4 = count4 + 1\n                end do\n                if (count4 == 2) then\n                    write(*,*) \"Yes\"\n                else\n                    write(*,*) \"No\"\n                end if\n            end if\n\n          end program\n\n        But note: the conversion of res2 to string: if res2 is 47, then the string is \"47\", which has length 2. Then we output \"No\". \n\n        This matches the condition.\n\n        However, we must ensure that the string is exactly the decimal representation.\n\n        We use the format '(I0)' which gives the minimal representation.\n\n        This should work.\n\n        Let's test with n=1:\n\n          step2: res1 = (1/3)*2 = 0, then remainder=1 -> res1=0+1=1.\n          start=1.\n\n          Then we iterate L=2,4,6,...\n          L=2: \n             min_mask=4, max_mask=7.\n             mask=4: bits=0, pop=0 -> 0==1? no -> skip.\n             mask=5: bits=1, pop=1 -> 1==1 -> form number: \n                 j=1: btest(1,1) -> false -> digit=4; j=0: true -> digit=7 -> number=47.\n                 47>=1 -> candidate=47.\n             mask=6: bits=2, pop=1 -> form: j=1: true (because 2 in binary is 10: bit1 is set) -> digit=7; j=0: false->digit=4 -> 74. candidate = min(47,74)=47.\n             mask=7: bits=3, pop=2 -> skip.\n\n             then candidate=47, res2=47.\n\n          Convert to string: \"47\" -> len=2 -> output \"No\"\n\n        The expected output for the chain for n=1: \n            first program: 1\n            second program: 47\n            third program: \"No\"\n\n        So it matches.\n\n        Another test: n=47\n          first program: \n             n=47, \n                47/3 = 15 (integer division) -> 15*2=30, then mod(47,3)=2 -> so 30+1=31.\n          start=31.\n\n          Then find the next super lucky number>=31: \n             L=2: mask=5:47>=31 -> candidate=47.\n\n          string=\"47\", then third program: \n             len=2 -> \"No\"\n\n        But what if n=4444? \n          first program: \n             n=4444, res1 = (4444/3)*2 + (4444%3 ? 4444/3=1481*3=4443, remainder=1 -> so 1481*2+1 = 2962+1=2963.\n          Then find the next super lucky number >=2963: \n             L=2: 47,74 -> skip.\n             L=4: the first candidate>=2963 is 4477? \n                 mask=16: bits=0 -> pop=0 -> skip.\n                 mask=17: bits=1 -> pop=1 -> form: 0001 -> 4447? \n                    number: from high to low: \n                       j=3: bit3? 0->4\n                       j=2:0->4\n                       j=1:0->4\n                       j=0:1->7 -> 4447.\n                   4447>=2963 -> candidate=4447.\n\n             Then string=\"4447\" -> \n                 len=4, count4: 3 -> then output \"No\"\n\n        But the next super lucky number after 2963 should be 4477? \n           4477: mask= for L=4: we need a bit string with two ones? \n                 mask=16+3: bits=3: binary 0011 -> then the number: \n                    j=3:0->4\n                    j=2:0->4\n                    j=1:1->7\n                    j=0:1->7 -> 4477.\n\n                 mask=16+3 = 19.\n\n                 then 4477>=2963 -> candidate = min(4447,4477) -> 4447? \n\n        But 4447 is not a super lucky number? because it has 3 fours and 1 seven -> not equal counts.\n\n        Why did we generate 4447? \n            We require pop = L/2 = 2? \n            For mask=17: bits=1, pop=1 -> but we skip because 1!=2.\n\n        I see: in the inner loop, we have:\n\n            if (pop /= L/2) cycle\n\n        So for L=4, we only consider pop=2.\n\n        Therefore, 4447 should not be generated.\n\n        Let me recompute for mask=17: \n            L=4, bits=1, pop= number of ones in the binary representation of 1 (in 4 bits? we are considering the lower 4 bits? but 1 in 4 bits is 0001) -> pop=1 -> skip.\n\n        Then we continue: \n            mask=18: bits=2: 0010 -> pop=1 -> skip.\n            mask=19: bits=3: 0011 -> pop=2 -> form: 0011 -> 4477.\n            then 4477>=2963 -> candidate=4477.\n\n        Then string=\"4477\": \n            len=4, count4=2 -> output \"Yes\"\n\n        So for n=4444, the chain outputs \"Yes\".\n\n        Therefore, the program is fixed.\n\n        Note: when forming the number, we are using exactly L bits? we do j from L-1 downto 0, and for each j we check the j-th bit? \n\n        This is correct.\n\n        We'll write the program accordingly.\n\n        However, note: the exponentiation 2**L: for L up to 100, we need to compute 2^100, which is about 1e30, which is beyond the range of 32-bit integer. We should use integer(kind=8) for min_mask, max_mask, mask, and bits.\n\n        Let me use:\n\n            integer(kind=8) :: L_val   ! we'll use L as integer(kind=8) for exponentiation?\n            but L is at most 100, so 2^100 is about 1e30, which requires about 100 bits -> so we need at least 128-bit integers? \n\n        Alternatively, we can avoid computing 2**L for large L? \n\n        We know that for L> floor(log2(start))+2, the value 2**L is huge, and we are iterating L from 2 upward, and we break when L is such that the smallest candidate (which is at least 4 * (10^L-1)/9) is >= start? \n\n        But we are only doing L up to 100, and we break as soon as we find a candidate in one L.\n\n        But 2**100 is too big for integer(kind=8) (which is 64 bits, max 1e19).\n\n        So we cannot use integer(kind=8) for L>=64.\n\n        Therefore, we must avoid exponentiation for large L? \n\n        Alternatively, we can break the outer loop when L is such that 2**L would overflow? \n\n        Since we know that for start<=666e6, the answer will be found in L<=10, we can break when L>60 (say) and then use a fallback.\n\n        Or we can use a different approach for large L? but we won't need it.\n\n        We can compute min_mask = shift_left(1, L)   ! 1 shifted left by L bits.\n\n        But Fortran has shift functions? \n\n        We can use: min_mask = ishft(1_8, L)   ! but L is integer, and if L>63, then it becomes 0.\n\n        So we can do:\n\n            if (L > 63) then\n                exit   ! or use a fallback: res2 = a huge number, but we break the L loop.\n            end if\n            min_mask = ishft(1_8, L)   ! 2**L\n            max_mask = ishft(1_8, L+1) - 1\n\n        But note: for L=100, ishft(1_8,100) = 0? \n\n        And then the inner loop: mask from 0 to -1? which is not done.\n\n        So we can skip L if L>63.\n\n        But since we break at L=10 for our start, it's safe.\n\n        Alternatively, we can use:\n\n            min_mask = 2_8**L   ! but this might be computed as real? and then converted to int64? \n\n        But 2**L for L=100 is 2^100, which is 1.26e30, which is not representable as int64.\n\n        So we avoid by breaking the outer loop when L>63.\n\n        We'll change the L loop:\n\n            do L = 2, 100, 2\n                if (L > 63) exit\n                min_mask = ishft(1_8, L)\n                max_mask = ior(min_mask, ishft(1_8, L)-1)   ! actually, max_mask = min_mask*2 - 1 = 2^(L+1)-1\n                ! But note: ishft(1_8, L+1) - 1\n                max_mask = ishft(1_8, L+1) - 1\n\n                ... \n\n            end do\n\n        How to compute 2^(L+1)-1? \n            We can do: \n                max_mask = ishft(1_8, L+1) - 1\n\n        But if L+1>63, then ishft(1_8, L+1) is 0, then max_mask = -1? \n\n        So we skip L>63.\n\n        We'll do:\n\n            if (L>63) cycle   ! but we are in a loop L=2,4,..., so we can break the loop? or just skip this L.\n\n        But we break when we find a candidate, and L is small for our start.\n\n        We'll do:\n\n            if (L>63) exit\n\n        Now, the program.\n\n        Note: the shift functions: \n            min_mask = ishft(1_8, L)   ! 1<<L\n\n        But in Fortran, ishft(i, shift) where shift can be negative or positive. For positive, it's left shift.\n\n        But we want: 2^L = shift left by L bits of 1.\n\n        Example: L=2 -> 1<<2 = 4.\n\n        So it is correct.\n\n        We'll use:\n\n            integer(kind=8) :: min_mask, max_mask, mask, bits, temp\n            min_mask = ishft(1_8, L)\n            max_mask = ishft(1_8, L+1) - 1\n\n        This works for L<=62? because for L=63: \n            min_mask = 2^63, which is representable in int64? \n            max_mask = 2^64-1 -> which is not representable in int64? because int64 max is 2^63-1.\n\n        So for L>=64, we skip.\n\n        We can change the loop to L=2,4,..., up to 62.\n\n        Then in the L loop:\n\n            do L = 2, 62, 2\n                min_mask = ishft(1_8, L)\n                max_mask = ishft(1_8, L+1) - 1\n\n        But for L=62: \n            min_mask = 2^62\n            max_mask = 2^63 - 1   -> which is the maximum int64.\n\n        Then for L=64: we don't do.\n\n        This is acceptable.\n\n        Final program:"
}