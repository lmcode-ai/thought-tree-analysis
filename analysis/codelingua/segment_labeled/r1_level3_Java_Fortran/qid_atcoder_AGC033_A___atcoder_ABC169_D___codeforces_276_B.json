{
  "segments": [
    {
      "text": "We are going to combine three Java programs into one Fortran program. Steps:\n 1. The first program (atcoder_AGC033_A) reads H and W and a grid of characters. It then does a BFS from all '#' and computes the maximum depth (steps) to cover all '.'. 2.",
      "start_char": 0,
      "end_char": 250,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "The second program (atcoder_ABC169_D) reads a long integer and decomposes it into prime factors, then calculates the answer by counting the exponents in a specific way. 3.",
      "start_char": 252,
      "end_char": 423,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "The third program (codeforces_276_B) reads a string and counts the frequency of each character. Then it checks the number of characters with odd frequency. It prints \"First\" if the number of odd frequencies is 0 or 1 or odd, otherwise \"Second\".",
      "start_char": 425,
      "end_char": 669,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "However, note that the output of the first program is an integer (ans) which becomes the input to the second program (as n). Then the output of the second program (an integer) becomes the input to the third program? But wait, the third program reads a string. But the instructions say: the output of each program is used as the input to the next. How the chain works? Input to the first program: H, W and a grid of characters. Output of first program: an integer (ans) -> which is the input to the second program (as n). Output of second program: an integer (answer) -> which is the input to the third program? But the third program expects a string.",
      "start_char": 672,
      "end_char": 1335,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "This is a problem because the second program outputs an integer and the third program expects a string.",
      "start_char": 1338,
      "end_char": 1441,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "However, looking at the original Java programs, they are independent and each reads from stdin and writes to stdout.",
      "start_char": 1444,
      "end_char": 1560,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The chain would be:\n\n   $ java atcoder_AGC033_A < input.txt > temp1.txt\n   $ java atcoder_ABC169_D < temp1.txt > temp2.txt\n   $ java codeforces_276_B < temp2.txt\n\n But the third program expects a string, but temp2.txt contains an integer? That would cause an error. But wait, the problem states: \"the output of each program is used as the input to the next\".",
      "start_char": 1561,
      "end_char": 1919,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "However, the third program expects a string of letters (like \"aba\") but the second program outputs a number. This seems to be a disconnect.",
      "start_char": 1924,
      "end_char": 2065,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Let me reexamine the problem: \"Translate the entire sequence into a single Fortran program that reproduces the same behavior. \"\n\n We must reproduce the behavior of the entire chain.",
      "start_char": 2066,
      "end_char": 2246,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "The chain:\n\n   Input to the first program: H, W and grid. First program outputs an integer (ans1). Second program takes that integer as input and outputs another integer (ans2). Third program takes that integer as input? But the third program expects a string. However, in the third program, we have:\n\n        String str = bufferedReader.readLine(); So if the second program outputs the integer 5, then the third program would read the string \"5\". Then it counts the frequency of each character in \"5\". In this string, we have one character '5'. So the frequency of '5' is 1. Then oddCount = 1 (because 1 is odd). Then:\n\n        if (oddCount <= 1 || oddCount % 2 != 0) -> true -> prints \"First\". But that is not the intended behavior of the original chain? Because the original third program was designed for a game with letters. However, the problem says: \"reproduces the same behavior\". So we must chain exactly as given.",
      "start_char": 2247,
      "end_char": 3188,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Therefore, the Fortran program will:\n\n   Step 1: Read H and W and a grid (like the first program). Then compute ans1 (the BFS result). Step 2: Use ans1 as input to the second program. So we set n = ans1 and then compute ans2 (the prime factor decomposition count). Step 3: Convert ans2 to a string (because the third program reads a string).",
      "start_char": 3191,
      "end_char": 3538,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Then, for that string, count the frequency of each character and then check the number of characters that have odd frequency. Then output the final result (either \"First\" or \"Second\").",
      "start_char": 3539,
      "end_char": 3723,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "How to do in Fortran:\n\n   - We read the initial grid (with H and W) from standard input (only the first block reads). - Then we do the BFS (as in the first Java program) to get ans1.",
      "start_char": 3730,
      "end_char": 3915,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "- Then we take ans1 as the input to the second program: factorize the number ans1 and compute the answer (ans2) by the method of prime exponents.",
      "start_char": 3919,
      "end_char": 4064,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "- Then we convert ans2 to a string and then count the frequency of each character in that string. Then determine the number of characters with odd frequency (oddCount). If oddCount <= 1 or oddCount is odd, then output \"First\"\n        Else output \"Second\"\n\n Implementation details:\n\n   Step 1: BFS for grid (multi-source BFS from all '#').",
      "start_char": 4068,
      "end_char": 4414,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "We'll have:\n        integer :: H, W\n        character, allocatable :: grid(:,:)\n        integer :: ans1, ans2\n\n        We also need a queue.",
      "start_char": 4419,
      "end_char": 4559,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "We can use two arrays for the queue (for positions and depth) or use a linked list? But Fortran doesn't have built-in queue. We can simulate with arrays and two pointers (head and tail). Step 2: Factorize ans1 (which is an integer). Note: ans1 might be 0? Let's see: in the BFS, if there are no '.' then ans1 remains 0. But what if the grid has no '#'? Then we start with an empty queue -> so we break immediately and output 0. The second program: \n          n = ans1\n          if n==0 or 1? The original Java program for the second one starts from i=2 to sqrt(n). So for n=0,1: the loop doesn't run, then if n>1 -> then we add one more. However, note: the second program is for atcoder_ABC169_D which expects a positive long. Our ans1 from the first program is nonnegative (could be 0). But in the BFS, the grid might be all '#' -> then no '.' so we output 0. In the second program: \n          for n=0: \n            the loop from 2 to sqrt(0) -> sqrt(0)=0, so the loop doesn't run. Then check: n>1? 0>1 is false -> so answer=0. for n=1: similarly answer=0, then n>1? no -> so 0. But note: the second program does:\n            long n = scanner.nextLong();\n\n        Then it factors n. But n must be at least 1? Actually, the problem for atcoder_ABC169_D says: \"n is an integer satisfying 1<=n<=10^12\". But in our chain, the input to the second program is the output of the first, which is a nonnegative integer (could be 0).",
      "start_char": 4560,
      "end_char": 6033,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "However, the original second program might not handle 0. But in the chain, we must use the same logic. The factorization loop for n=0: \n            while (0==(n % i)) -> n%i is 0? for i>=2 -> but n=0 mod i is 0? so we get stuck in an infinite loop? Actually, if n==0, then the condition (0==(n % i)) is true for any i? because 0 mod i is 0. Then we do n /= i -> n remains 0. Then again the same condition holds -> infinite loop. So we must be cautious. The original second program is designed for n>=1. But our chain might produce 0. How did the original Java program run for n=0? It would get stuck. Therefore, we must adjust: the chain might break for n=0. However, looking at the first program: the BFS result is 0 only when there are no '.' in the grid. But note: the grid may be entirely '#' -> then we start with all '#' and no '.' -> then we never enqueue any '.' -> so the while loop runs only for the '#' nodes, but then we check neighbors: if the neighbor is '.' and unvisited -> but there are none. So the while loop exits without updating ans beyond 0. But then we pass 0 to the second program -> which will cause an infinite loop. We must fix the second program to handle n=0? Actually, the original second program is for a problem that states n>=1. So we have to consider: in the chain, the first program might output 0, which is not handled by the second.",
      "start_char": 6043,
      "end_char": 7477,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "However, the problem says: \"reproduces the same behavior\". So if the original chain (running the Java programs sequentially) would break (infinite loop) for an input that leads to 0, then our Fortran program should too? But that is not acceptable. Alternatively, we note that the second program is not designed for n=0. But in the context of the first program, when there are no '.' then the BFS result is 0. Then the second program would get stuck. This is a flaw in the chain. However, the problem does not specify the range of inputs. We must assume the input to the first program is valid (as per the original problem). The original problem for the first program: AGC033_A - \"Darkness and Light\". The constraints: H, W at least 1, and grid of characters. The grid has at least one '#'? Actually, the problem statement of AGC033_A: \n          \"There is a grid of H rows and W columns. Each cell is either black or white. ... Initially, at least one black cell exists. \"\n\n        So we are guaranteed at least one '#' -> but note: the BFS result (ans) is the maximum number of steps to cover all '.' from the initial '#'s. It is possible that there are no '.'? Then the grid is entirely '#' -> then we output 0. But the second program is not designed for 0. How did the original problem of the second program (ABC169_D) handle n=0? It wasn't designed for that. Since the problem says \"reproduces the same behavior\", we must mimic the Java chain.",
      "start_char": 7487,
      "end_char": 8979,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "If the original Java chain would break (infinite loop) for an input that makes the first program output 0, then we break too? But we are writing a single Fortran program and we cannot have an infinite loop. We must then note: the second program in the chain might not be called with n=0? But the problem says the entire sequence. So we have to handle the chain as is. Alternatively, we can note: the second program is designed for n>=1. So we must avoid n=0. But the first program outputs 0 only when there are no '.' -> then the grid is all '#' -> then the second program would be called with 0 -> which is invalid. How did the original Java program atcoder_ABC169_D handle n=0? It does not. It would run an infinite loop.",
      "start_char": 8980,
      "end_char": 9730,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Therefore, to be safe, we must check: if the first program outputs 0, then we skip the second program? But that is not the chain. Or we can fix the second program to handle 0? But the problem says: \"reproduces the same behavior\".",
      "start_char": 9740,
      "end_char": 9969,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Since the problem does not specify the input domain, we assume that the input to the chain is valid for all three programs.",
      "start_char": 9979,
      "end_char": 10102,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "However, the first program might output 0 which is invalid for the second. But note: the first program's problem states: \"Initially, at least one black cell exists.\" but does not say anything about white cells. So it is possible that there are no white cells. Then the output is 0. And the second program's problem states: \"n is an integer satisfying 1<=n<=10^12\". So 0 is not allowed. Therefore, we must assume that the input grid has at least one white cell? Or that the chain is only run on inputs that are valid for all?",
      "start_char": 10103,
      "end_char": 10654,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "The problem says: \"when run on the same input\". So if we are given an input that makes the first program output 0, then the chain (the three Java programs) would break (infinite loop). Then our Fortran program should break too? But we cannot have an infinite loop. We must avoid that. We decide: we will write the second program part to handle n>=1. For n=0, we set ans2=0? But that is what the second program would do if it didn't break? Actually, it breaks. Alternatively, we can break out of the factorization loop if n becomes 0? But the condition in the Java program is `while (0 == (n % i))`. For n=0, this condition is true for any i. So we break when n becomes 0? We can add a condition: if n==0, break the inner loop and the outer loop? But that is not in the original. Since we are forced to write a program that does not break, and the problem says \"behaves identically\", we must note that the original chain breaks for n=0. So we can do: In the second program part: \n            if (ans1 == 0) then\n                ans2 = 0   ! and skip the factorization? But the original program doesn't skip, it gets stuck.\n            else\n                ... do the factorization ... But that is not the same. The original gets stuck. However, we cannot have an infinite loop.",
      "start_char": 10664,
      "end_char": 11996,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Therefore, we must decide: the problem states \"reproduces the same behavior\", meaning same output for the same input. But for n=0, the original chain does not terminate? Then our program should not terminate? That is not acceptable.",
      "start_char": 11997,
      "end_char": 12229,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Alternatively, we note that the problem says: \"Ensure that the final Fortran program behaves identically to the original chain when run on the same input. \"\n\n        If the original chain runs without infinite loops for valid inputs, then we do the same. The problem for the first program states: H, W at least 1 and at least one '#'.",
      "start_char": 12239,
      "end_char": 12572,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "The grid may have no white cells? Then we output 0. Then the second program gets 0 and goes into an infinite loop.",
      "start_char": 12573,
      "end_char": 12687,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "We are forced to assume that the input to the chain is such that the first program produces a positive integer? But the problem does not state that. Given the ambiguity, we design:\n\n          Step 1: Read H, W and grid. Then do BFS. Let ans1 = ... (could be 0). Step 2: \n             n = ans1\n             If n==0, then set ans2=0 and skip the factorization (because the original would break, but we must avoid infinite loop. However, the problem expects the same behavior -> but we cannot have an infinite loop. So we break the chain?). But note: the second program for n=0 would break. Our Fortran program must break? Or we can set ans2=0 and proceed? How about we do the factorization only for n>=1? For n==0, we set ans2=0 and then the third program will get the string \"0\", which has one character '0' -> oddCount=1 -> output \"First\".",
      "start_char": 12698,
      "end_char": 13578,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "However, the original chain would not produce that because it breaks. So we are not reproducing the same behavior. This is a problem.",
      "start_char": 13589,
      "end_char": 13722,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "We must either:\n\n          a) Assume that the input grid has at least one '.' so that ans1>0? But the problem does not say that. b) Note that the original chain breaks for n=0, so we can break too? But in Fortran, we can break by stopping the program? But the problem says \"behaves identically\", meaning same output? The original chain doesn't output anything for the third program in that case. Alternatively, we can simulate the infinite loop? That would be bad. After reexamination: the first program outputs 0 only when there are no '.' -> then the grid is entirely '#'.",
      "start_char": 13732,
      "end_char": 14335,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "In that case, the BFS never visits any '.' and the answer is 0. Then the second program (if we run it) would get 0 and go into an infinite loop. Therefore, we decide: we will run the second program only for n>=1. For n==0, we set ans2=0. But that is not what the original second program does. However, the problem does not specify the behavior for n=0 in the second program. We must follow the code. The Java code for the second program for n=0:\n\n            long n = scanner.nextLong();   // n=0\n            int sqrt = (int) Math.sqrt(n); // sqrt(0)=0 -> so sqrt=0\n            for (int i=2; i<=sqrt; i++) { ... } // the loop runs for i from 2 to 0 -> so it doesn't run. then if (n>1) -> 0>1 is false -> so ans2=0. But wait, that's not what we thought. The loop condition is: i<=sqrt. Since sqrt=0, then i starts at 2 and 2<=0 is false -> so the loop does not run. Then it checks if n>1? false. Then outputs 0. So actually, the second program does not break for n=0. It outputs 0. Why did we think it breaks?",
      "start_char": 14336,
      "end_char": 15394,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Because of the inner while loop? But the inner while loop is inside the for loop that does not run. So it's safe. Therefore, we can write the second program part without worrying about n=0: the for loop from i=2 to sqrt (which is 0) doesn't run. Then we check if n>1 -> false, so we output 0. So the chain for n=0: \n            first program outputs 0 -> second program outputs 0 -> third program gets the string \"0\" -> which has one character '0' -> oddCount=1 -> outputs \"First\". Therefore, we can proceed.",
      "start_char": 15404,
      "end_char": 15930,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Step 3: Convert the integer ans2 to a string. Then count the frequency of each character in that string. Note: the string representation of ans2 might have multiple digits? For example, if ans2=123, then the string is \"123\". Then we count frequency for '1','2','3'.",
      "start_char": 15944,
      "end_char": 16218,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Steps for the third program:\n            Read the string (which is the string representation of ans2). Build a frequency map for each character in the string. Count the number of characters that have odd frequency (oddCount). If oddCount<=1 or oddCount is odd, then output \"First\", else \"Second\". Implementation:\n\n   We will do:\n\n        Step 1: BFS for grid -> ans1. Step 2: Factorize ans1 (which is a nonnegative integer) to compute ans2. We note that the original second program uses a loop from i=2 to sqrt(n). We must do the same.",
      "start_char": 16228,
      "end_char": 16810,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Step 3: Convert ans2 to a string. Then traverse the string and count frequencies. Then compute oddCount (the number of characters that appear an odd number of times). Then output accordingly. Note: The third program also handles the case when the string is empty? But ans2 is at least 0 -> the string \"0\" is non-empty. How to convert integer to string in Fortran? We can use internal write. Example:\n\n        character(len=20) :: str\n        write(str, *) ans2   !",
      "start_char": 16820,
      "end_char": 17296,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "This will write with a leading space for positive numbers? We need to trim. But note: the original third program reads one line.",
      "start_char": 17297,
      "end_char": 17425,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "We write the integer without any extra text? So we write the integer and then we remove leading spaces. Alternatively, we can format without spaces. We can do: write(str, '(I0)') ans2   -> this writes without leading/trailing spaces. Then we build the frequency array for characters. The string will contain only digits? Because ans2 is an integer. The digits are from '0' to '9'. So we can have an array of size 0:9? But we don't know the base. Actually, the string is in base 10. We can use an array of 0 to 255? Or we can use an array indexed by the ASCII value? But Fortran doesn't have a map. We can do:\n\n            integer, dimension(0:255) :: freq\n            freq = 0\n\n            do i = 1, len_trim(str) ich = iachar(str(i:i))\n                freq(ich) = freq(ich) + 1\n            end do\n\n        Then we traverse the characters that appeared?",
      "start_char": 17435,
      "end_char": 18335,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Actually, we only care about the digits that appear. Then we count how many of these frequencies are odd. oddCount = 0\n        do i = 0, 255\n            if (freq(i) > 0 .and. mod(freq(i),2)==1) then\n                oddCount = oddCount + 1\n            end if\n        end do\n\n        Then: \n            if (oddCount <= 1 .or. mod(oddCount,2)==1) then\n                write(*,*) \"First\"\n            else\n                write(*,*) \"Second\"\n            end if\n\n   But note: the third program in the original Java does:\n\n        if (oddCount <= 1 || oddCount % 2 != 0) {\n            writer.println(\"First\");\n        } else {\n            writer.println(\"Second\");\n        } So we do the same. However, note: the condition \"oddCount % 2 != 0\" is the same as mod(oddCount,2)==1?",
      "start_char": 18336,
      "end_char": 19123,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Yes, because oddCount is nonnegative. But note: in Fortran, mod(oddCount,2) can be 0 or 1. So we can write: if (oddCount <= 1 .or. mod(oddCount,2) == 1) then\n\n   But note: the condition in the Java code: oddCount<=1 OR oddCount is odd. So we are good. Now, we write the Fortran program. Steps:\n\n    1. Read H and W.\n    2. Read grid (H lines of W characters each). 3. Do multi-source BFS (like the first Java program) to compute ans1. 4. Set n = ans1, then compute ans2 by factorizing n (like the second Java program). Note: n is nonnegative. Steps for factorization:\n\n            ans2 = 0\n            if (n>=2) then   ! because for n=0 or 1, we skip the loop and then check at the end: if n>1 then add one? But the original does:\n\n                sqrt_n = int(sqrt(real(n)))   ! But n might be large?",
      "start_char": 19124,
      "end_char": 19968,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "We use integer arithmetic for sqrt? Or use nint(sqrt(real(n))) but for large n, real might not be exact. Instead, we can do:\n\n                i = 2\n                do while (i * i <= n)   ! this avoids floating point\n\n            How the original works:\n\n                for (int i=2; i<=sqrt; i++) {\n                    count = 0\n                    while (n mod i == 0) {\n                        n = n / i\n                        count++\n                    }\n                    for (j=1; count>=j; j++) {\n                        count -= j\n                        ans2 = ans2 + 1\n                    }\n                }\n                if (n>1) then\n                    ans2 = ans2 + 1\n\n            We do similarly. Note: we must consider that n might be 0 or 1. For n=0: we skip the while loop (because i*i<=0 is false for i>=2). Then we check n>1? false -> ans2 remains 0. For n=1: same. For n=2: \n                i=2: 2*2=4>2 -> so the while condition fails? Then we break the loop and then check n>1 -> true -> ans2=1. But the original: \n                sqrt = (int)Math.sqrt(2) -> 1 -> then the loop condition: i<=sqrt -> 2<=1 -> false. Then n>1 -> true -> ans2=1. So we can do:\n\n                i = 2\n                do while (i <= sqrt_n)   ... but how to compute sqrt_n without real? We can do:\n\n                    integer :: i, j, count, sqrt_n\n                    sqrt_n = int(sqrt(real(n, kind=8)))   ! for large n, we use real(8) for n.\n\n            But n can be up to 10^12?",
      "start_char": 19969,
      "end_char": 21551,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "The first program: the grid has H and W up to 1000, so the BFS depth is at most 1000? So n is at most 1000?",
      "start_char": 21552,
      "end_char": 21659,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Actually, the BFS depth is the maximum distance, which is at most (H+W) which is 2000. So n is at most 2000? Then we can use:\n\n                    sqrt_n = int(sqrt(real(n))) But we can also avoid real by:\n\n                    i = 2\n                    do while (i*i <= n)\n\n            This is safe because n is at most 2000? Then i will go up to about 44. Steps:\n\n                ans2 = 0\n                temp = n   ! we will work on temp? But the original modifies n. We can use n directly? But we need the final n for the check at the end. Actually, we are going to factorize the same n? We can use a temporary variable?",
      "start_char": 21660,
      "end_char": 22326,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Or we can use the variable n and then after the factorization we have the leftover? But we need the leftover for the check. We do:\n\n                    temp = n\n                    i = 2\n                    do while (i*i <= temp) count = 0\n                        do while (mod(temp, i) == 0)\n                            temp = temp / i\n                            count = count + 1\n                        end do\n                        j = 1\n                        do while (count >= j)\n                            count = count - j\n                            j = j + 1\n                            ans2 = ans2 + 1\n                        end do\n                        i = i + 1\n                    end do\n                    if (temp > 1) then\n                        ans2 = ans2 + 1\n                    end if\n\n            But note: the original uses a for loop from i=2 to sqrt_n. We are doing i from 2 to sqrt(temp) (by i*i<=temp). This is equivalent.",
      "start_char": 22327,
      "end_char": 23327,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "However, the original breaks the inner while when the factor is exhausted. Then the j loop runs for the count. But note: the j loop in the original:\n\n                    for (int j=1; count - j >= 0; j++) { count -= j;\n                        answer++;\n                    }\n\n            We can write the j loop as:\n\n                    j = 1\n                    do while (count >= j) count = count - j\n                        ans2 = ans2 + 1\n                        j = j + 1\n                    end do\n\n            This is the same. 5. Convert ans2 to a string.\n\n        character(32) :: str   ! enough for an integer up to 2000? 2000 -> 4 digits. write(str, '(I0)') ans2   ! I0 means integer without leading spaces. Then we remove trailing spaces? Actually, we want the whole string without leading spaces. Then we can use:\n\n            str = adjustl(str)   ! but I0 already doesn't have leading spaces?",
      "start_char": 23341,
      "end_char": 24331,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Actually, the write with I0 writes without leading spaces. But we want the entire string without trailing spaces? We can use:\n\n            len_str = len_trim(str) Then we traverse from 1 to len_str. 6. Build frequency array for the characters in str(1:len_str). We assume the string contains only digits? Then we can use an array for the digits? Or we can use an array for the entire ASCII. We'll do:\n\n            integer :: freq(0:255) = 0   ! frequency of each ASCII character\n\n            do i = 1, len_str\n                c = str(i:i)\n                ic = iachar(c)\n                freq(ic) = freq(ic) + 1\n            end do\n\n        Then count the number of characters that have odd frequency: oddCount = 0\n            do i = 0, 255\n                if (freq(i) > 0) then\n                    if (mod(freq(i),2) == 1) then\n                        oddCount = oddCount + 1\n                    end if\n                end if\n            end do\n\n    7. Then:\n\n            if (oddCount<=1 .or. mod(oddCount,2)==1) then\n                write(*,*) \"First\"\n            else\n                write(*,*) \"Second\"\n            end if\n\n   But note: the original Java program writes without a newline? Actually, it uses println -> which adds a newline. In Fortran, write(*,*) adds a newline and also adds spaces? We want exactly the string. We can do:\n\n            write(*,'(A)') \"First\"\n\n        or\n\n            write(*,'(A)')",
      "start_char": 24332,
      "end_char": 25800,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "\"Second\"\n\n   However, note: the problem says \"Only the last block should handle producing output\". So we output only at the end. Now, we code the entire Fortran program. Important: we must not do any I/O in the middle. We assume the input is from standard input and the output to standard output. We note: the first program reads from stdin. We read H and W and then H lines. We must be cautious: the grid is read row by row. Let's code. Note: The BFS uses a queue.",
      "start_char": 25801,
      "end_char": 26286,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "We can simulate a queue with two arrays: one for the row indices, one for the column indices, and one for the depth? Or we can use a 2D array for visited and then use a queue structure. We'll use:\n\n        integer, dimension(:), allocatable :: q_i, q_j, q_d   ! for the queue: we store row, column, depth.\n        integer :: q_head, q_tail\n\n        We start by enqueueing all the '#' positions with depth=0. Then we traverse the grid and mark the '#' as visited? In the Java program, they have a flag array and they set the starting points? Actually, they set flag for the starting points? No, they don't set flag for the starting points. They start the queue from the '#' and then when processing a node, they check the neighbors. They set flag for a neighbor when they add it. We need a visited array? In Java, they use flag (initially zeros). Then when they see a '.' and flag==0, they set flag to 1 and add to the queue. We do the same. Steps for BFS:\n\n            allocate(flag(0:H-1,0:W-1))   ! but Fortran usually 1-indexed? We can do 1:H, 1:W.\n\n            Actually, the grid is stored from (1,1) to (H,W). We read:\n\n                do i = 1, H\n                    read(*,*) line   ! but the line is a string of W characters. We can read as:\n\n                character(len=W) :: line\n                read(*,*) line\n\n                then do j=1, W\n                    grid(i,j) = line(j:j) Then we start:\n\n                q_head = 1\n                q_tail = 1\n\n                We'll preallocate the queue.",
      "start_char": 26295,
      "end_char": 27860,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "The maximum size is H*W.\n\n                allocate(q_i(H*W), q_j(H*W), q_d(H*W)) Then for each cell (i,j) in the grid that is '#', we set:\n\n                    q_i(q_tail) = i\n                    q_j(q_tail) = j\n                    q_d(q_tail) = 0\n                    q_tail = q_tail + 1\n                    flag(i,j) = 1   ! but note: the Java program does not set flag for the starting points?",
      "start_char": 27861,
      "end_char": 28273,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Actually, it doesn't set until the neighbor is visited. But wait: in the Java program, they do not set flag for the starting points.",
      "start_char": 28274,
      "end_char": 28406,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "They only set for the neighbors. So the starting points are not marked as visited? Then they might be revisited? However, the starting points are '#' and when we check neighbors of a starting point, we see that the starting point is '#' -> so we don't add the starting point again? But the condition: A[y+dy][x+dx]=='.' -> so we skip. So we don't need to mark the starting points as visited?",
      "start_char": 28424,
      "end_char": 28833,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Actually, we do: because we might have two '#' adjacent? Then from one '#' we might try to visit the other? But the other is '#' -> condition fails. But we never mark the '#' as visited? Then when we start, we enqueue all '#' and then when processing a '#' we check its neighbors: if the neighbor is '.' and unvisited, we mark and enqueue. The '#' themselves are never visited? That is okay. However, we might enqueue the same '#' multiple times? Because we enqueue at the beginning all '#' and then when we process a '#' we don't enqueue any other '#' (because condition: if the neighbor is '#' then we skip because A[i][j]=='#' -> but the condition is: if the neighbor is '.' and unvisited). So we don't enqueue '#' again. So we do not need to mark the starting points as visited? But note: the Java program does not set flag for the starting points. So we do the same. We only set flag for the '.' that we visit. Then:\n\n                ans1 = 0   ! this will be updated to the maximum depth we see. do while (q_head < q_tail)\n                    i0 = q_i(q_head)\n                    j0 = q_j(q_head)\n                    d0 = q_d(q_head)\n                    q_head = q_head + 1\n\n                    ! then for each of the four directions\n                    do k = 1, 4 ni = i0 + dy(k) nj = j0 + dx(k) if (ni>=1 .and. ni<=H .and. nj>=1 .and. nj<=W) then\n                            if (flag(ni,nj)==0 .and. grid(ni,nj)=='.') then\n                                flag(ni,nj) = 1\n                                q_i(q_tail) = ni\n                                q_j(q_tail) = nj\n                                q_d(q_tail) = d0+1\n                                q_tail = q_tail+1\n                                ans1 = d0+1\n                            end if\n                        end if\n                    end do\n                end do Then we have ans1. Note: the Java program uses:\n\n                int[] dx = {1, -1, 0, 0};\n                int [] dy = {0, 0, 1, -1};\n\n            So we define:\n\n                dx = [0,0,1,-1]   ? Wait, no: in Java, for a given direction i, the neighbor is (y+dy[i], x+dx[i]) They have:\n                    dy: [1, -1, 0, 0] -> meaning: down, up, then right (dx[2]=1, dy[2]=0) and left (dx[3]=-1, dy[3]=0) ? Actually, the indices:\n\n                    i=0: dx[0]=1 -> x+1, dy[0]=0 -> same row -> right? \n                    i=1: dx[1]=-1 -> left, dy[1]=0 -> same row -> left.\n                    i=2: dx[2]=0, dy[2]=1 -> down? i=3: dx[3]=0, dy[3]=-1 -> up. So the directions: right, left, down, up? But the grid: in Java, the first index is row (vertical) and the second is column (horizontal). So:\n\n                    (y, x) -> then moving down: y+1, same x. So we define:\n\n                    dx = [1, -1, 0, 0]   ! for columns: right, left, no change, no change\n                    dy = [0, 0, 1, -1]   ! for rows: no change, no change, down, up\n\n                But wait: the Java code: if (0 <= y+dy[i] && y+dy[i] <= H-1 ... ) In our Fortran, we use indices 1..H, so:\n\n                    if (ni>=1 .and. ni<=H .and. ...) then\n\n                We define:\n\n                    integer :: dx(4), dy(4)\n                    dx = [1, -1, 0, 0]\n                    dy = [0, 0, 1, -1]\n\n                Then for a point (i0, j0) (row i0, column j0):\n\n                    right: (i0, j0+1)\n                    left: (i0, j0-1)\n                    down: (i0+1, j0)\n                    up: (i0-1, j0)\n\n            That matches. Now, we code. Note: the grid might be all '#' -> then the while loop never runs (because the queue is non-empty at the beginning, but then we process each '#' and we never enqueue any '.' -> then the while loop runs for each '#' and then exits. Then ans1 remains 0. So we are safe. Let's code the entire Fortran program. We'll write in free form.",
      "start_char": 28851,
      "end_char": 33035,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "We note: the entire program must be in one file. Steps:\n\n    1. Read H and W.\n    2. Read grid. 3. BFS to compute ans1. 4. Factorize ans1 to compute ans2. 5. Convert ans2 to string and compute oddCount for the string. 6. Output \"First\" or \"Second\". We'll use:\n\n        implicit none\n\n        integer :: H, W, i, j, k, ans1, ans2, temp, count, jj, ni, nj, d0, i0, j0, q_head, q_tail, q_size, len_str, ic, oddCount\n        character, allocatable :: grid(:,:)\n        integer, allocatable :: flag(:,:)\n        integer, allocatable :: q_i(:), q_j(:), q_d(:)\n        character(len=1000) :: line   ! for reading the grid lines\n        integer :: dx(4), dy(4)\n        integer :: n, sqrt_n, factor, i_factor\n        character(len=32) :: str_ans2\n        integer :: freq(0:255)\n        character :: c\n\n        ! Step 1: Read H and W\n        read(*,*) H, W\n\n        ! Allocate grid and flag\n        allocate(grid(1:H,1:W)) allocate(flag(1:H,1:W))\n        flag = 0\n\n        ! Read the grid do i = 1, H\n            read(*,*) line\n            do j = 1, W\n                grid(i,j) = line(j:j)\n            end do\n        end do\n\n        ! Initialize the queue: we don't know the size, so we use H*W\n        q_size = H*W\n        allocate(q_i(q_size), q_j(q_size), q_d(q_size))\n        q_head = 1\n        q_tail = 1\n\n        ! Directions\n        dx = [1, -1, 0, 0]\n        dy = [0, 0, 1, -1]\n\n        ! Enqueue all '#' with depth 0\n        do i = 1, H\n            do j = 1, W\n                if (grid(i,j) == '#') then\n                    q_i(q_tail) = i\n                    q_j(q_tail) = j\n                    q_d(q_tail) = 0\n                    q_tail = q_tail + 1\n                end if\n            end do\n        end do\n\n        ans1 = 0\n\n        ! BFS\n        do while (q_head < q_tail)\n            i0 = q_i(q_head)\n            j0 = q_j(q_head)\n            d0 = q_d(q_head)\n            q_head = q_head + 1\n\n            do k = 1, 4\n                ni = i0 + dy(k)\n                nj = j0 + dx(k) if (ni>=1 .and. ni<=H .and. nj>=1 .and. nj<=W) then\n                    if (flag(ni,nj)==0 .and. grid(ni,nj)=='.') then\n                        flag(ni,nj) = 1\n                        q_i(q_tail) = ni\n                        q_j(q_tail) = nj\n                        q_d(q_tail) = d0+1\n                        q_tail = q_tail + 1\n                        ans1 = d0+1   ! the last depth we set is the maximum? Actually, the BFS tree: the depth increases. We update ans1 every time we add a node? Then the last node added will have the maximum depth? Yes, because we are doing BFS and the depth is increasing. end if\n                end if\n            end do\n        end do\n\n        ! Now, ans1 is the result of the first program.\n\n        ! Step 4: Factorize ans1 to get ans2 (second program)\n\n        n = ans1   ! n is nonnegative integer. ans2 = 0\n        temp = n   ! we'll work on temp\n\n        if (temp < 2) then\n            ! do nothing, then we skip the factorization loop and then check at the end if temp>1 -> false.\n        else\n            factor = 2\n            do while (factor * factor <= temp) count = 0\n                do while (mod(temp, factor) == 0)\n                    temp = temp / factor\n                    count = count + 1\n                end do\n\n                jj = 1\n                do while (count >= jj) count = count - jj\n                    jj = jj + 1\n                    ans2 = ans2 + 1\n                end do\n\n                factor = factor + 1\n            end do\n        end if\n\n        if (temp > 1) then\n            ans2 = ans2 + 1\n        end if\n\n        ! Now ans2 is the result of the second program.\n\n        ! Step 5: Convert ans2 to string\n        write(str_ans2, '(I0)') ans2\n        len_str = len_trim(str_ans2)\n\n        ! Step 6: Count frequency of characters in the string (only the non-blank part: str_ans2(1:len_str))\n        freq = 0\n        do i = 1, len_str\n            c = str_ans2(i:i) ic = iachar(c)\n            freq(ic) = freq(ic) + 1\n        end do\n\n        oddCount = 0\n        do i = 0, 255\n            if (freq(i) > 0) then\n                if (mod(freq(i),2) == 1) then\n                    oddCount = oddCount + 1\n                end if\n            end if\n        end do\n\n        if (oddCount <= 1 .or. mod(oddCount,2) == 1) then\n            write(*, '(A)') \"First\"\n        else\n            write(*, '(A)') \"Second\"\n        end if\n\n   End.",
      "start_char": 33044,
      "end_char": 37559,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Let me test with a small grid:\n\n        Input for the first program: \n            3 3\n            . #.\n            .. #\n            ... The grid:\n\n            row1: . # . row2: . . #\n            row3: . . . The '#' are at (1,2), (2,3). The BFS:\n\n            Start with (1,2,0) and (2,3,0). Process (1,2): \n                neighbors: (1,3): '.' -> mark and enqueue (1,3,1) -> ans1=1. (1,1): '.' -> mark and enqueue (1,1,1) -> ans1=1. (0,2): invalid. (2,2): '.' -> mark and enqueue (2,2,1) -> ans1=1. Process (2,3): \n                neighbors: (2,4) invalid. (2,2): already visited? -> skip. (3,3): '.' -> enqueue (3,3,1) -> ans1=1. (1,3): already visited? -> skip. Then we process the queue: (1,3,1): \n                neighbors: (1,4) invalid. (1,2) visited (it's '#' and not visited by flag? Actually, we didn't mark '#' as visited, but the neighbor (1,2) is '#' -> condition grid(ni,nj)=='.' fails -> skip. (0,3) invalid. (2,3) visited (it's '#' -> condition fails) -> skip. Similarly, (1,1,1): \n                neighbors: (1,0) invalid. (1,2) '#' -> skip. (0,1) invalid. (2,1) '.' -> enqueue (2,1,2) -> ans1=2. Then (2,2,1): \n                neighbors: (2,3) '#' -> skip.\n                         (2,1) '.' -> but we haven't visited? Actually, we haven't visited (2,1) yet? So we enqueue? But wait: we haven't visited (2,1) -> then we enqueue (2,1,2) -> but we already enqueued from (1,1,1)? So we mark (2,1) as visited when we first enqueue? So when we get (2,2,1) and check (2,1) we see flag is set?",
      "start_char": 37564,
      "end_char": 39470,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Actually, we set flag when we enqueue (2,1) from (1,1,1). So we skip. Then (3,3,1): \n                neighbors: (3,4) invalid. (3,2) '.' -> enqueue (3,2,2) -> ans1=2. (4,3) invalid. (2,3) '#' -> skip. Then (2,1,2): \n                neighbors: (2,0) invalid. (2,2) visited -> skip. (1,1) visited -> skip. (3,1) '.' -> enqueue (3,1,3) -> ans1=3. Then (3,2,2): \n                neighbors: (3,3) visited -> skip. (3,1) '.' -> enqueue (3,1,3) -> but then we set flag for (3,1) and then when we get (3,2,2) we see (3,1) is already visited? So skip. Then (3,1,3): \n                neighbors: (3,0) invalid. (3,2) visited -> skip.\n                         (2,1) visited -> skip. (4,1) invalid. Then the queue is empty. ans1 = 3.\n\n        Step 4: Factorize 3:\n\n            n=3\n            factor=2: 2*2=4>3 -> break the outer while. then check: n=3>1 -> so ans2=1. Step 5: Convert 1 to string -> \"1\"\n            Frequency: '1':1 -> oddCount=1. Then condition: oddCount<=1 -> true -> output \"First\". So the program outputs \"First\". This matches. But note: the original first program output 3, then the second program output 1, then the third program output \"First\". We are good. Now, note: the queue for BFS: we used a fixed size array of H*W. This is acceptable. We write the Fortran code accordingly. Note: we assume that the integer kind is the default (which is usually 4 bytes). But the numbers are small (<=2000) so it's safe. We'll write the code.",
      "start_char": 39471,
      "end_char": 41281,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Important: we must free the memory? But the program ends. It's optional. We'll write the entire code.",
      "start_char": 41290,
      "end_char": 41391,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    }
  ],
  "original_reasoning": "We are going to combine three Java programs into one Fortran program.\n Steps:\n 1. The first program (atcoder_AGC033_A) reads H and W and a grid of characters. It then does a BFS from all '#' and computes the maximum depth (steps) to cover all '.'.\n 2. The second program (atcoder_ABC169_D) reads a long integer and decomposes it into prime factors, then calculates the answer by counting the exponents in a specific way.\n 3. The third program (codeforces_276_B) reads a string and counts the frequency of each character. Then it checks the number of characters with odd frequency. It prints \"First\" if the number of odd frequencies is 0 or 1 or odd, otherwise \"Second\".\n\n However, note that the output of the first program is an integer (ans) which becomes the input to the second program (as n). Then the output of the second program (an integer) becomes the input to the third program? But wait, the third program reads a string.\n\n But the instructions say: the output of each program is used as the input to the next.\n\n How the chain works?\n   Input to the first program: H, W and a grid of characters.\n   Output of first program: an integer (ans) -> which is the input to the second program (as n).\n   Output of second program: an integer (answer) -> which is the input to the third program? But the third program expects a string.\n\n This is a problem because the second program outputs an integer and the third program expects a string.\n\n However, looking at the original Java programs, they are independent and each reads from stdin and writes to stdout. The chain would be:\n\n   $ java atcoder_AGC033_A < input.txt > temp1.txt\n   $ java atcoder_ABC169_D < temp1.txt > temp2.txt\n   $ java codeforces_276_B < temp2.txt\n\n But the third program expects a string, but temp2.txt contains an integer? That would cause an error.\n\n But wait, the problem states: \"the output of each program is used as the input to the next\".\n\n However, the third program expects a string of letters (like \"aba\") but the second program outputs a number.\n\n This seems to be a disconnect. Let me reexamine the problem: \"Translate the entire sequence into a single Fortran program that reproduces the same behavior.\"\n\n We must reproduce the behavior of the entire chain. The chain:\n\n   Input to the first program: H, W and grid.\n   First program outputs an integer (ans1).\n   Second program takes that integer as input and outputs another integer (ans2).\n   Third program takes that integer as input? But the third program expects a string. \n\n However, in the third program, we have:\n\n        String str = bufferedReader.readLine();\n\n So if the second program outputs the integer 5, then the third program would read the string \"5\". Then it counts the frequency of each character in \"5\". In this string, we have one character '5'. So the frequency of '5' is 1. Then oddCount = 1 (because 1 is odd). Then:\n\n        if (oddCount <= 1 || oddCount % 2 != 0) -> true -> prints \"First\".\n\n But that is not the intended behavior of the original chain? Because the original third program was designed for a game with letters.\n\n However, the problem says: \"reproduces the same behavior\". So we must chain exactly as given.\n\n Therefore, the Fortran program will:\n\n   Step 1: Read H and W and a grid (like the first program). Then compute ans1 (the BFS result).\n   Step 2: Use ans1 as input to the second program. So we set n = ans1 and then compute ans2 (the prime factor decomposition count).\n   Step 3: Convert ans2 to a string (because the third program reads a string). Then, for that string, count the frequency of each character and then check the number of characters that have odd frequency.\n\n   Then output the final result (either \"First\" or \"Second\").\n\n How to do in Fortran:\n\n   - We read the initial grid (with H and W) from standard input (only the first block reads).\n   - Then we do the BFS (as in the first Java program) to get ans1.\n   - Then we take ans1 as the input to the second program: factorize the number ans1 and compute the answer (ans2) by the method of prime exponents.\n   - Then we convert ans2 to a string and then count the frequency of each character in that string. Then determine the number of characters with odd frequency (oddCount).\n        If oddCount <= 1 or oddCount is odd, then output \"First\"\n        Else output \"Second\"\n\n Implementation details:\n\n   Step 1: BFS for grid (multi-source BFS from all '#').\n\n   We'll have:\n        integer :: H, W\n        character, allocatable :: grid(:,:)\n        integer :: ans1, ans2\n\n        We also need a queue. We can use two arrays for the queue (for positions and depth) or use a linked list? But Fortran doesn't have built-in queue. We can simulate with arrays and two pointers (head and tail).\n\n   Step 2: Factorize ans1 (which is an integer). Note: ans1 might be 0? Let's see: in the BFS, if there are no '.' then ans1 remains 0. But what if the grid has no '#'? Then we start with an empty queue -> so we break immediately and output 0.\n\n        The second program: \n          n = ans1\n          if n==0 or 1? The original Java program for the second one starts from i=2 to sqrt(n). So for n=0,1: the loop doesn't run, then if n>1 -> then we add one more.\n\n        However, note: the second program is for atcoder_ABC169_D which expects a positive long. Our ans1 from the first program is nonnegative (could be 0). But in the BFS, the grid might be all '#' -> then no '.' so we output 0.\n\n        In the second program: \n          for n=0: \n            the loop from 2 to sqrt(0) -> sqrt(0)=0, so the loop doesn't run. Then check: n>1? 0>1 is false -> so answer=0.\n          for n=1: similarly answer=0, then n>1? no -> so 0.\n\n        But note: the second program does:\n            long n = scanner.nextLong();\n\n        Then it factors n. But n must be at least 1? Actually, the problem for atcoder_ABC169_D says: \"n is an integer satisfying 1<=n<=10^12\". But in our chain, the input to the second program is the output of the first, which is a nonnegative integer (could be 0).\n\n        However, the original second program might not handle 0. But in the chain, we must use the same logic.\n\n        The factorization loop for n=0: \n            while (0==(n % i)) -> n%i is 0? for i>=2 -> but n=0 mod i is 0? so we get stuck in an infinite loop? \n\n        Actually, if n==0, then the condition (0==(n % i)) is true for any i? because 0 mod i is 0. Then we do n /= i -> n remains 0. Then again the same condition holds -> infinite loop.\n\n        So we must be cautious. The original second program is designed for n>=1. But our chain might produce 0.\n\n        How did the original Java program run for n=0? It would get stuck.\n\n        Therefore, we must adjust: the chain might break for n=0. However, looking at the first program: the BFS result is 0 only when there are no '.' in the grid. But note: the grid may be entirely '#' -> then we start with all '#' and no '.' -> then we never enqueue any '.' -> so the while loop runs only for the '#' nodes, but then we check neighbors: if the neighbor is '.' and unvisited -> but there are none. So the while loop exits without updating ans beyond 0.\n\n        But then we pass 0 to the second program -> which will cause an infinite loop.\n\n        We must fix the second program to handle n=0? Actually, the original second program is for a problem that states n>=1. So we have to consider: in the chain, the first program might output 0, which is not handled by the second.\n\n        However, the problem says: \"reproduces the same behavior\". So if the original chain (running the Java programs sequentially) would break (infinite loop) for an input that leads to 0, then our Fortran program should too? But that is not acceptable.\n\n        Alternatively, we note that the second program is not designed for n=0. But in the context of the first program, when there are no '.' then the BFS result is 0. Then the second program would get stuck. This is a flaw in the chain.\n\n        However, the problem does not specify the range of inputs. We must assume the input to the first program is valid (as per the original problem). The original problem for the first program: AGC033_A - \"Darkness and Light\". The constraints: H, W at least 1, and grid of characters. The grid has at least one '#'? \n\n        Actually, the problem statement of AGC033_A: \n          \"There is a grid of H rows and W columns. Each cell is either black or white. ... Initially, at least one black cell exists.\"\n\n        So we are guaranteed at least one '#' -> but note: the BFS result (ans) is the maximum number of steps to cover all '.' from the initial '#'s. It is possible that there are no '.'? Then the grid is entirely '#' -> then we output 0.\n\n        But the second program is not designed for 0. How did the original problem of the second program (ABC169_D) handle n=0? It wasn't designed for that.\n\n        Since the problem says \"reproduces the same behavior\", we must mimic the Java chain. If the original Java chain would break (infinite loop) for an input that makes the first program output 0, then we break too? But we are writing a single Fortran program and we cannot have an infinite loop.\n\n        We must then note: the second program in the chain might not be called with n=0? But the problem says the entire sequence. So we have to handle the chain as is.\n\n        Alternatively, we can note: the second program is designed for n>=1. So we must avoid n=0. But the first program outputs 0 only when there are no '.' -> then the grid is all '#' -> then the second program would be called with 0 -> which is invalid.\n\n        How did the original Java program atcoder_ABC169_D handle n=0? It does not. It would run an infinite loop.\n\n        Therefore, to be safe, we must check: if the first program outputs 0, then we skip the second program? But that is not the chain. Or we can fix the second program to handle 0? But the problem says: \"reproduces the same behavior\".\n\n        Since the problem does not specify the input domain, we assume that the input to the chain is valid for all three programs. However, the first program might output 0 which is invalid for the second.\n\n        But note: the first program's problem states: \"Initially, at least one black cell exists.\" but does not say anything about white cells. So it is possible that there are no white cells. Then the output is 0.\n\n        And the second program's problem states: \"n is an integer satisfying 1<=n<=10^12\". So 0 is not allowed.\n\n        Therefore, we must assume that the input grid has at least one white cell? Or that the chain is only run on inputs that are valid for all?\n\n        The problem says: \"when run on the same input\". So if we are given an input that makes the first program output 0, then the chain (the three Java programs) would break (infinite loop). Then our Fortran program should break too? But we cannot have an infinite loop. We must avoid that.\n\n        We decide: we will write the second program part to handle n>=1. For n=0, we set ans2=0? But that is what the second program would do if it didn't break? Actually, it breaks.\n\n        Alternatively, we can break out of the factorization loop if n becomes 0? But the condition in the Java program is `while (0 == (n % i))`. For n=0, this condition is true for any i. So we break when n becomes 0? We can add a condition: if n==0, break the inner loop and the outer loop? But that is not in the original.\n\n        Since we are forced to write a program that does not break, and the problem says \"behaves identically\", we must note that the original chain breaks for n=0. So we can do:\n\n          In the second program part: \n            if (ans1 == 0) then\n                ans2 = 0   ! and skip the factorization? But the original program doesn't skip, it gets stuck.\n            else\n                ... do the factorization ...\n\n        But that is not the same. The original gets stuck.\n\n        However, we cannot have an infinite loop. Therefore, we must decide: the problem states \"reproduces the same behavior\", meaning same output for the same input. But for n=0, the original chain does not terminate? Then our program should not terminate? That is not acceptable.\n\n        Alternatively, we note that the problem says: \"Ensure that the final Fortran program behaves identically to the original chain when run on the same input.\"\n\n        If the original chain runs without infinite loops for valid inputs, then we do the same. The problem for the first program states: H, W at least 1 and at least one '#'. The grid may have no white cells? Then we output 0. Then the second program gets 0 and goes into an infinite loop. \n\n        We are forced to assume that the input to the chain is such that the first program produces a positive integer? But the problem does not state that.\n\n        Given the ambiguity, we design:\n\n          Step 1: Read H, W and grid. Then do BFS. Let ans1 = ... (could be 0).\n\n          Step 2: \n             n = ans1\n             If n==0, then set ans2=0 and skip the factorization (because the original would break, but we must avoid infinite loop. However, the problem expects the same behavior -> but we cannot have an infinite loop. So we break the chain?).\n\n          But note: the second program for n=0 would break. Our Fortran program must break? Or we can set ans2=0 and proceed? \n\n        How about we do the factorization only for n>=1? For n==0, we set ans2=0 and then the third program will get the string \"0\", which has one character '0' -> oddCount=1 -> output \"First\". \n\n        However, the original chain would not produce that because it breaks. So we are not reproducing the same behavior.\n\n        This is a problem. We must either:\n\n          a) Assume that the input grid has at least one '.' so that ans1>0? But the problem does not say that.\n\n          b) Note that the original chain breaks for n=0, so we can break too? But in Fortran, we can break by stopping the program? But the problem says \"behaves identically\", meaning same output? The original chain doesn't output anything for the third program in that case.\n\n        Alternatively, we can simulate the infinite loop? That would be bad.\n\n        After reexamination: the first program outputs 0 only when there are no '.' -> then the grid is entirely '#'. In that case, the BFS never visits any '.' and the answer is 0. Then the second program (if we run it) would get 0 and go into an infinite loop. \n\n        Therefore, we decide: we will run the second program only for n>=1. For n==0, we set ans2=0. But that is not what the original second program does. \n\n        However, the problem does not specify the behavior for n=0 in the second program. We must follow the code. The Java code for the second program for n=0:\n\n            long n = scanner.nextLong();   // n=0\n            int sqrt = (int) Math.sqrt(n); // sqrt(0)=0 -> so sqrt=0\n            for (int i=2; i<=sqrt; i++) { ... } // the loop runs for i from 2 to 0 -> so it doesn't run.\n            then if (n>1) -> 0>1 is false -> so ans2=0.\n\n        But wait, that's not what we thought. The loop condition is: i<=sqrt. Since sqrt=0, then i starts at 2 and 2<=0 is false -> so the loop does not run. Then it checks if n>1? false. Then outputs 0.\n\n        So actually, the second program does not break for n=0. It outputs 0.\n\n        Why did we think it breaks? Because of the inner while loop? But the inner while loop is inside the for loop that does not run. So it's safe.\n\n        Therefore, we can write the second program part without worrying about n=0: the for loop from i=2 to sqrt (which is 0) doesn't run. Then we check if n>1 -> false, so we output 0.\n\n        So the chain for n=0: \n            first program outputs 0 -> second program outputs 0 -> third program gets the string \"0\" -> which has one character '0' -> oddCount=1 -> outputs \"First\".\n\n        Therefore, we can proceed.\n\n   Step 3: Convert the integer ans2 to a string. Then count the frequency of each character in that string.\n\n        Note: the string representation of ans2 might have multiple digits? For example, if ans2=123, then the string is \"123\". Then we count frequency for '1','2','3'.\n\n        Steps for the third program:\n            Read the string (which is the string representation of ans2).\n            Build a frequency map for each character in the string.\n            Count the number of characters that have odd frequency (oddCount).\n            If oddCount<=1 or oddCount is odd, then output \"First\", else \"Second\".\n\n Implementation:\n\n   We will do:\n\n        Step 1: BFS for grid -> ans1.\n\n        Step 2: Factorize ans1 (which is a nonnegative integer) to compute ans2. We note that the original second program uses a loop from i=2 to sqrt(n). We must do the same.\n\n        Step 3: Convert ans2 to a string. Then traverse the string and count frequencies. Then compute oddCount (the number of characters that appear an odd number of times). Then output accordingly.\n\n   Note: The third program also handles the case when the string is empty? But ans2 is at least 0 -> the string \"0\" is non-empty.\n\n   How to convert integer to string in Fortran? We can use internal write.\n\n   Example:\n\n        character(len=20) :: str\n        write(str, *) ans2   ! This will write with a leading space for positive numbers? We need to trim.\n\n        But note: the original third program reads one line. We write the integer without any extra text? So we write the integer and then we remove leading spaces.\n\n        Alternatively, we can format without spaces.\n\n        We can do: write(str, '(I0)') ans2   -> this writes without leading/trailing spaces.\n\n   Then we build the frequency array for characters. The string will contain only digits? Because ans2 is an integer. The digits are from '0' to '9'. So we can have an array of size 0:9? But we don't know the base. Actually, the string is in base 10.\n\n        We can use an array of 0 to 255? Or we can use an array indexed by the ASCII value? But Fortran doesn't have a map. We can do:\n\n            integer, dimension(0:255) :: freq\n            freq = 0\n\n            do i = 1, len_trim(str)\n                ich = iachar(str(i:i))\n                freq(ich) = freq(ich) + 1\n            end do\n\n        Then we traverse the characters that appeared? Actually, we only care about the digits that appear. Then we count how many of these frequencies are odd.\n\n        oddCount = 0\n        do i = 0, 255\n            if (freq(i) > 0 .and. mod(freq(i),2)==1) then\n                oddCount = oddCount + 1\n            end if\n        end do\n\n        Then: \n            if (oddCount <= 1 .or. mod(oddCount,2)==1) then\n                write(*,*) \"First\"\n            else\n                write(*,*) \"Second\"\n            end if\n\n   But note: the third program in the original Java does:\n\n        if (oddCount <= 1 || oddCount % 2 != 0) {\n            writer.println(\"First\");\n        } else {\n            writer.println(\"Second\");\n        }\n\n   So we do the same.\n\n   However, note: the condition \"oddCount % 2 != 0\" is the same as mod(oddCount,2)==1? Yes, because oddCount is nonnegative.\n\n   But note: in Fortran, mod(oddCount,2) can be 0 or 1. So we can write:\n\n        if (oddCount <= 1 .or. mod(oddCount,2) == 1) then\n\n   But note: the condition in the Java code: oddCount<=1 OR oddCount is odd.\n\n   So we are good.\n\n   Now, we write the Fortran program.\n\n   Steps:\n\n    1. Read H and W.\n    2. Read grid (H lines of W characters each).\n    3. Do multi-source BFS (like the first Java program) to compute ans1.\n\n    4. Set n = ans1, then compute ans2 by factorizing n (like the second Java program). Note: n is nonnegative.\n\n        Steps for factorization:\n\n            ans2 = 0\n            if (n>=2) then   ! because for n=0 or 1, we skip the loop and then check at the end: if n>1 then add one? But the original does:\n\n                sqrt_n = int(sqrt(real(n)))   ! But n might be large? We use integer arithmetic for sqrt? Or use nint(sqrt(real(n))) but for large n, real might not be exact.\n\n            Instead, we can do:\n\n                i = 2\n                do while (i * i <= n)   ! this avoids floating point\n\n            How the original works:\n\n                for (int i=2; i<=sqrt; i++) {\n                    count = 0\n                    while (n mod i == 0) {\n                        n = n / i\n                        count++\n                    }\n                    for (j=1; count>=j; j++) {\n                        count -= j\n                        ans2 = ans2 + 1\n                    }\n                }\n                if (n>1) then\n                    ans2 = ans2 + 1\n\n            We do similarly.\n\n            Note: we must consider that n might be 0 or 1.\n\n            For n=0: we skip the while loop (because i*i<=0 is false for i>=2). Then we check n>1? false -> ans2 remains 0.\n            For n=1: same.\n\n            For n=2: \n                i=2: 2*2=4>2 -> so the while condition fails? Then we break the loop and then check n>1 -> true -> ans2=1.\n\n            But the original: \n                sqrt = (int)Math.sqrt(2) -> 1 -> then the loop condition: i<=sqrt -> 2<=1 -> false. Then n>1 -> true -> ans2=1.\n\n            So we can do:\n\n                i = 2\n                do while (i <= sqrt_n)   ... but how to compute sqrt_n without real? We can do:\n\n                    integer :: i, j, count, sqrt_n\n                    sqrt_n = int(sqrt(real(n, kind=8)))   ! for large n, we use real(8) for n.\n\n            But n can be up to 10^12? The first program: the grid has H and W up to 1000, so the BFS depth is at most 1000? So n is at most 1000? Actually, the BFS depth is the maximum distance, which is at most (H+W) which is 2000. So n is at most 2000? Then we can use:\n\n                    sqrt_n = int(sqrt(real(n)))\n\n            But we can also avoid real by:\n\n                    i = 2\n                    do while (i*i <= n)\n\n            This is safe because n is at most 2000? Then i will go up to about 44.\n\n            Steps:\n\n                ans2 = 0\n                temp = n   ! we will work on temp? But the original modifies n. We can use n directly? But we need the final n for the check at the end.\n\n                Actually, we are going to factorize the same n? We can use a temporary variable? Or we can use the variable n and then after the factorization we have the leftover? But we need the leftover for the check.\n\n                We do:\n\n                    temp = n\n                    i = 2\n                    do while (i*i <= temp)\n                        count = 0\n                        do while (mod(temp, i) == 0)\n                            temp = temp / i\n                            count = count + 1\n                        end do\n                        j = 1\n                        do while (count >= j)\n                            count = count - j\n                            j = j + 1\n                            ans2 = ans2 + 1\n                        end do\n                        i = i + 1\n                    end do\n                    if (temp > 1) then\n                        ans2 = ans2 + 1\n                    end if\n\n            But note: the original uses a for loop from i=2 to sqrt_n. We are doing i from 2 to sqrt(temp) (by i*i<=temp). This is equivalent.\n\n            However, the original breaks the inner while when the factor is exhausted. Then the j loop runs for the count.\n\n            But note: the j loop in the original:\n\n                    for (int j=1; count - j >= 0; j++) {\n                        count -= j;\n                        answer++;\n                    }\n\n            We can write the j loop as:\n\n                    j = 1\n                    do while (count >= j)\n                        count = count - j\n                        ans2 = ans2 + 1\n                        j = j + 1\n                    end do\n\n            This is the same.\n\n    5. Convert ans2 to a string.\n\n        character(32) :: str   ! enough for an integer up to 2000? 2000 -> 4 digits.\n\n        write(str, '(I0)') ans2   ! I0 means integer without leading spaces.\n\n        Then we remove trailing spaces? Actually, we want the whole string without leading spaces. Then we can use:\n\n            str = adjustl(str)   ! but I0 already doesn't have leading spaces? Actually, the write with I0 writes without leading spaces.\n\n        But we want the entire string without trailing spaces? We can use:\n\n            len_str = len_trim(str)\n\n        Then we traverse from 1 to len_str.\n\n    6. Build frequency array for the characters in str(1:len_str). We assume the string contains only digits? Then we can use an array for the digits? Or we can use an array for the entire ASCII.\n\n        We'll do:\n\n            integer :: freq(0:255) = 0   ! frequency of each ASCII character\n\n            do i = 1, len_str\n                c = str(i:i)\n                ic = iachar(c)\n                freq(ic) = freq(ic) + 1\n            end do\n\n        Then count the number of characters that have odd frequency:\n\n            oddCount = 0\n            do i = 0, 255\n                if (freq(i) > 0) then\n                    if (mod(freq(i),2) == 1) then\n                        oddCount = oddCount + 1\n                    end if\n                end if\n            end do\n\n    7. Then:\n\n            if (oddCount<=1 .or. mod(oddCount,2)==1) then\n                write(*,*) \"First\"\n            else\n                write(*,*) \"Second\"\n            end if\n\n   But note: the original Java program writes without a newline? Actually, it uses println -> which adds a newline. In Fortran, write(*,*) adds a newline and also adds spaces? We want exactly the string.\n\n        We can do:\n\n            write(*,'(A)') \"First\"\n\n        or\n\n            write(*,'(A)') \"Second\"\n\n   However, note: the problem says \"Only the last block should handle producing output\". So we output only at the end.\n\n   Now, we code the entire Fortran program.\n\n   Important: we must not do any I/O in the middle.\n\n   We assume the input is from standard input and the output to standard output.\n\n   We note: the first program reads from stdin. We read H and W and then H lines.\n\n   We must be cautious: the grid is read row by row.\n\n   Let's code.\n\n   Note: The BFS uses a queue. We can simulate a queue with two arrays: one for the row indices, one for the column indices, and one for the depth? Or we can use a 2D array for visited and then use a queue structure.\n\n   We'll use:\n\n        integer, dimension(:), allocatable :: q_i, q_j, q_d   ! for the queue: we store row, column, depth.\n        integer :: q_head, q_tail\n\n        We start by enqueueing all the '#' positions with depth=0.\n\n        Then we traverse the grid and mark the '#' as visited? In the Java program, they have a flag array and they set the starting points? Actually, they set flag for the starting points? No, they don't set flag for the starting points. They start the queue from the '#' and then when processing a node, they check the neighbors. They set flag for a neighbor when they add it.\n\n        We need a visited array? In Java, they use flag (initially zeros). Then when they see a '.' and flag==0, they set flag to 1 and add to the queue.\n\n        We do the same.\n\n        Steps for BFS:\n\n            allocate(flag(0:H-1,0:W-1))   ! but Fortran usually 1-indexed? We can do 1:H, 1:W.\n\n            Actually, the grid is stored from (1,1) to (H,W). We read:\n\n                do i = 1, H\n                    read(*,*) line   ! but the line is a string of W characters. We can read as:\n\n                character(len=W) :: line\n                read(*,*) line\n\n                then do j=1, W\n                    grid(i,j) = line(j:j)\n\n            Then we start:\n\n                q_head = 1\n                q_tail = 1\n\n                We'll preallocate the queue. The maximum size is H*W.\n\n                allocate(q_i(H*W), q_j(H*W), q_d(H*W))\n\n                Then for each cell (i,j) in the grid that is '#', we set:\n\n                    q_i(q_tail) = i\n                    q_j(q_tail) = j\n                    q_d(q_tail) = 0\n                    q_tail = q_tail + 1\n                    flag(i,j) = 1   ! but note: the Java program does not set flag for the starting points? Actually, it doesn't set until the neighbor is visited.\n\n                But wait: in the Java program, they do not set flag for the starting points. They only set for the neighbors. So the starting points are not marked as visited? Then they might be revisited? \n\n                However, the starting points are '#' and when we check neighbors of a starting point, we see that the starting point is '#' -> so we don't add the starting point again? But the condition: A[y+dy][x+dx]=='.' -> so we skip.\n\n                So we don't need to mark the starting points as visited? Actually, we do: because we might have two '#' adjacent? Then from one '#' we might try to visit the other? But the other is '#' -> condition fails.\n\n                But we never mark the '#' as visited? Then when we start, we enqueue all '#' and then when processing a '#' we check its neighbors: if the neighbor is '.' and unvisited, we mark and enqueue. The '#' themselves are never visited? That is okay.\n\n                However, we might enqueue the same '#' multiple times? Because we enqueue at the beginning all '#' and then when we process a '#' we don't enqueue any other '#' (because condition: if the neighbor is '#' then we skip because A[i][j]=='#' -> but the condition is: if the neighbor is '.' and unvisited). So we don't enqueue '#' again.\n\n                So we do not need to mark the starting points as visited? \n\n                But note: the Java program does not set flag for the starting points. So we do the same.\n\n                We only set flag for the '.' that we visit.\n\n            Then:\n\n                ans1 = 0   ! this will be updated to the maximum depth we see.\n\n                do while (q_head < q_tail)\n                    i0 = q_i(q_head)\n                    j0 = q_j(q_head)\n                    d0 = q_d(q_head)\n                    q_head = q_head + 1\n\n                    ! then for each of the four directions\n                    do k = 1, 4\n                        ni = i0 + dy(k)\n                        nj = j0 + dx(k)\n                        if (ni>=1 .and. ni<=H .and. nj>=1 .and. nj<=W) then\n                            if (flag(ni,nj)==0 .and. grid(ni,nj)=='.') then\n                                flag(ni,nj) = 1\n                                q_i(q_tail) = ni\n                                q_j(q_tail) = nj\n                                q_d(q_tail) = d0+1\n                                q_tail = q_tail+1\n                                ans1 = d0+1\n                            end if\n                        end if\n                    end do\n                end do\n\n            Then we have ans1.\n\n            Note: the Java program uses:\n\n                int[] dx = {1, -1, 0, 0};\n                int[] dy = {0, 0, 1, -1};\n\n            So we define:\n\n                dx = [0,0,1,-1]   ? Wait, no: in Java, for a given direction i, the neighbor is (y+dy[i], x+dx[i])\n\n                They have:\n                    dy: [1, -1, 0, 0] -> meaning: down, up, then right (dx[2]=1, dy[2]=0) and left (dx[3]=-1, dy[3]=0) ? \n\n                Actually, the indices:\n\n                    i=0: dx[0]=1 -> x+1, dy[0]=0 -> same row -> right? \n                    i=1: dx[1]=-1 -> left, dy[1]=0 -> same row -> left.\n                    i=2: dx[2]=0, dy[2]=1 -> down? \n                    i=3: dx[3]=0, dy[3]=-1 -> up.\n\n                So the directions: right, left, down, up? \n\n                But the grid: in Java, the first index is row (vertical) and the second is column (horizontal). So:\n\n                    (y, x) -> then moving down: y+1, same x.\n\n                So we define:\n\n                    dx = [1, -1, 0, 0]   ! for columns: right, left, no change, no change\n                    dy = [0, 0, 1, -1]   ! for rows: no change, no change, down, up\n\n                But wait: the Java code:\n\n                    if (0 <= y+dy[i] && y+dy[i] <= H-1 ... )\n\n                In our Fortran, we use indices 1..H, so:\n\n                    if (ni>=1 .and. ni<=H .and. ...) then\n\n                We define:\n\n                    integer :: dx(4), dy(4)\n                    dx = [1, -1, 0, 0]\n                    dy = [0, 0, 1, -1]\n\n                Then for a point (i0, j0) (row i0, column j0):\n\n                    right: (i0, j0+1)\n                    left: (i0, j0-1)\n                    down: (i0+1, j0)\n                    up: (i0-1, j0)\n\n            That matches.\n\n   Now, we code.\n\n   Note: the grid might be all '#' -> then the while loop never runs (because the queue is non-empty at the beginning, but then we process each '#' and we never enqueue any '.' -> then the while loop runs for each '#' and then exits. Then ans1 remains 0.\n\n   So we are safe.\n\n   Let's code the entire Fortran program.\n\n   We'll write in free form.\n\n   We note: the entire program must be in one file.\n\n   Steps:\n\n    1. Read H and W.\n    2. Read grid.\n    3. BFS to compute ans1.\n    4. Factorize ans1 to compute ans2.\n    5. Convert ans2 to string and compute oddCount for the string.\n    6. Output \"First\" or \"Second\".\n\n   We'll use:\n\n        implicit none\n\n        integer :: H, W, i, j, k, ans1, ans2, temp, count, jj, ni, nj, d0, i0, j0, q_head, q_tail, q_size, len_str, ic, oddCount\n        character, allocatable :: grid(:,:)\n        integer, allocatable :: flag(:,:)\n        integer, allocatable :: q_i(:), q_j(:), q_d(:)\n        character(len=1000) :: line   ! for reading the grid lines\n        integer :: dx(4), dy(4)\n        integer :: n, sqrt_n, factor, i_factor\n        character(len=32) :: str_ans2\n        integer :: freq(0:255)\n        character :: c\n\n        ! Step 1: Read H and W\n        read(*,*) H, W\n\n        ! Allocate grid and flag\n        allocate(grid(1:H,1:W))\n        allocate(flag(1:H,1:W))\n        flag = 0\n\n        ! Read the grid\n        do i = 1, H\n            read(*,*) line\n            do j = 1, W\n                grid(i,j) = line(j:j)\n            end do\n        end do\n\n        ! Initialize the queue: we don't know the size, so we use H*W\n        q_size = H*W\n        allocate(q_i(q_size), q_j(q_size), q_d(q_size))\n        q_head = 1\n        q_tail = 1\n\n        ! Directions\n        dx = [1, -1, 0, 0]\n        dy = [0, 0, 1, -1]\n\n        ! Enqueue all '#' with depth 0\n        do i = 1, H\n            do j = 1, W\n                if (grid(i,j) == '#') then\n                    q_i(q_tail) = i\n                    q_j(q_tail) = j\n                    q_d(q_tail) = 0\n                    q_tail = q_tail + 1\n                end if\n            end do\n        end do\n\n        ans1 = 0\n\n        ! BFS\n        do while (q_head < q_tail)\n            i0 = q_i(q_head)\n            j0 = q_j(q_head)\n            d0 = q_d(q_head)\n            q_head = q_head + 1\n\n            do k = 1, 4\n                ni = i0 + dy(k)\n                nj = j0 + dx(k)\n                if (ni>=1 .and. ni<=H .and. nj>=1 .and. nj<=W) then\n                    if (flag(ni,nj)==0 .and. grid(ni,nj)=='.') then\n                        flag(ni,nj) = 1\n                        q_i(q_tail) = ni\n                        q_j(q_tail) = nj\n                        q_d(q_tail) = d0+1\n                        q_tail = q_tail + 1\n                        ans1 = d0+1   ! the last depth we set is the maximum? Actually, the BFS tree: the depth increases. We update ans1 every time we add a node? Then the last node added will have the maximum depth? Yes, because we are doing BFS and the depth is increasing.\n                    end if\n                end if\n            end do\n        end do\n\n        ! Now, ans1 is the result of the first program.\n\n        ! Step 4: Factorize ans1 to get ans2 (second program)\n\n        n = ans1   ! n is nonnegative integer.\n\n        ans2 = 0\n        temp = n   ! we'll work on temp\n\n        if (temp < 2) then\n            ! do nothing, then we skip the factorization loop and then check at the end if temp>1 -> false.\n        else\n            factor = 2\n            do while (factor * factor <= temp)\n                count = 0\n                do while (mod(temp, factor) == 0)\n                    temp = temp / factor\n                    count = count + 1\n                end do\n\n                jj = 1\n                do while (count >= jj)\n                    count = count - jj\n                    jj = jj + 1\n                    ans2 = ans2 + 1\n                end do\n\n                factor = factor + 1\n            end do\n        end if\n\n        if (temp > 1) then\n            ans2 = ans2 + 1\n        end if\n\n        ! Now ans2 is the result of the second program.\n\n        ! Step 5: Convert ans2 to string\n        write(str_ans2, '(I0)') ans2\n        len_str = len_trim(str_ans2)\n\n        ! Step 6: Count frequency of characters in the string (only the non-blank part: str_ans2(1:len_str))\n        freq = 0\n        do i = 1, len_str\n            c = str_ans2(i:i)\n            ic = iachar(c)\n            freq(ic) = freq(ic) + 1\n        end do\n\n        oddCount = 0\n        do i = 0, 255\n            if (freq(i) > 0) then\n                if (mod(freq(i),2) == 1) then\n                    oddCount = oddCount + 1\n                end if\n            end if\n        end do\n\n        if (oddCount <= 1 .or. mod(oddCount,2) == 1) then\n            write(*, '(A)') \"First\"\n        else\n            write(*, '(A)') \"Second\"\n        end if\n\n   End.\n\n   Let me test with a small grid:\n\n        Input for the first program: \n            3 3\n            .#.\n            ..#\n            ...\n\n        The grid:\n\n            row1: . # .\n            row2: . . #\n            row3: . . .\n\n        The '#' are at (1,2), (2,3). \n\n        The BFS:\n\n            Start with (1,2,0) and (2,3,0).\n\n            Process (1,2): \n                neighbors: (1,3): '.' -> mark and enqueue (1,3,1) -> ans1=1.\n                         (1,1): '.' -> mark and enqueue (1,1,1) -> ans1=1.\n                         (0,2): invalid.\n                         (2,2): '.' -> mark and enqueue (2,2,1) -> ans1=1.\n\n            Process (2,3): \n                neighbors: (2,4) invalid.\n                         (2,2): already visited? -> skip.\n                         (3,3): '.' -> enqueue (3,3,1) -> ans1=1.\n                         (1,3): already visited? -> skip.\n\n            Then we process the queue: (1,3,1): \n                neighbors: (1,4) invalid.\n                         (1,2) visited (it's '#' and not visited by flag? Actually, we didn't mark '#' as visited, but the neighbor (1,2) is '#' -> condition grid(ni,nj)=='.' fails -> skip.\n                         (0,3) invalid.\n                         (2,3) visited (it's '#' -> condition fails) -> skip.\n\n            Similarly, (1,1,1): \n                neighbors: (1,0) invalid.\n                         (1,2) '#' -> skip.\n                         (0,1) invalid.\n                         (2,1) '.' -> enqueue (2,1,2) -> ans1=2.\n\n            Then (2,2,1): \n                neighbors: (2,3) '#' -> skip.\n                         (2,1) '.' -> but we haven't visited? Actually, we haven't visited (2,1) yet? So we enqueue? But wait: we haven't visited (2,1) -> then we enqueue (2,1,2) -> but we already enqueued from (1,1,1)? So we mark (2,1) as visited when we first enqueue? So when we get (2,2,1) and check (2,1) we see flag is set? Actually, we set flag when we enqueue (2,1) from (1,1,1). So we skip.\n\n            Then (3,3,1): \n                neighbors: (3,4) invalid.\n                         (3,2) '.' -> enqueue (3,2,2) -> ans1=2.\n                         (4,3) invalid.\n                         (2,3) '#' -> skip.\n\n            Then (2,1,2): \n                neighbors: (2,0) invalid.\n                         (2,2) visited -> skip.\n                         (1,1) visited -> skip.\n                         (3,1) '.' -> enqueue (3,1,3) -> ans1=3.\n\n            Then (3,2,2): \n                neighbors: (3,3) visited -> skip.\n                         (3,1) '.' -> enqueue (3,1,3) -> but then we set flag for (3,1) and then when we get (3,2,2) we see (3,1) is already visited? So skip.\n\n            Then (3,1,3): \n                neighbors: (3,0) invalid.\n                         (3,2) visited -> skip.\n                         (2,1) visited -> skip.\n                         (4,1) invalid.\n\n            Then the queue is empty.\n\n            ans1 = 3.\n\n        Step 4: Factorize 3:\n\n            n=3\n            factor=2: 2*2=4>3 -> break the outer while.\n            then check: n=3>1 -> so ans2=1.\n\n        Step 5: Convert 1 to string -> \"1\"\n            Frequency: '1':1 -> oddCount=1.\n\n        Then condition: oddCount<=1 -> true -> output \"First\".\n\n        So the program outputs \"First\".\n\n   This matches.\n\n   But note: the original first program output 3, then the second program output 1, then the third program output \"First\".\n\n   We are good.\n\n   Now, note: the queue for BFS: we used a fixed size array of H*W. This is acceptable.\n\n   We write the Fortran code accordingly.\n\n   Note: we assume that the integer kind is the default (which is usually 4 bytes). But the numbers are small (<=2000) so it's safe.\n\n   We'll write the code.\n\n   Important: we must free the memory? But the program ends. It's optional.\n\n   We'll write the entire code."
}