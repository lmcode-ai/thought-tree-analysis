{
  "segments": [
    {
      "text": "Okay, let's see.",
      "start_char": 0,
      "end_char": 16,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "I need to translate this Python code into C. Hmm, the code takes an integer y as input, but then it's not used anywhere else? Wait, no, looking closer\u2014the first line is y = int(input()), but then the code uses arr, which is the next input split into integers. Wait, maybe the Python code is supposed to process the array elements?",
      "start_char": 17,
      "end_char": 347,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The actual code's main logic seems to involve checking if any element at index k is the sum of elements at i and j, where k isn't either i or j. Oh right, but the body has three nested loops: i, j, and k. Wait the code is a bit confusing. Let me parse it again.",
      "start_char": 348,
      "end_char": 609,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Wait, the Python code first reads a number y (maybe the size of the array?), but in the array, it splits the next input into a list of integers.",
      "start_char": 611,
      "end_char": 755,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Wait, perhaps the first input is actually the number of elements, so arr is of length y? But the code is written such that it's taking the elements from the next input line, split into integers. Wait in the Python code, maybe the first line is getting the length of the array, but then the next line reads the elements.",
      "start_char": 756,
      "end_char": 1075,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Because otherwise, if you take the first input as a simple integer, which maybe isn't used, but perhaps in this problem's context, the array length is provided as the first input?\n\nWait the problem here is to translate the code as given, not to understand why it works. So the code first reads y as an integer from input, then reads the array. But in the code, the 'y' isn't used further. Hmm, that's odd. Let me check the code again. Wait the code's loops: there are three loops over the array's length. So for each triplet of i, j, and k indices. The innermost loop is for k?\n\nWait in the code:\n\nfor k in range(len(arr)): if ... condition ... then print and exit. Wait is that right? Wait let me structure it again: The code does:\n\nfor each i in 0 to len(arr)-1:\n\n   for each j in 0 to len(arr)-1:\n\n       if i == j, skip\n\n       for k in 0 to len(arr)-1:\n\n           if arr[k] ! = arr[j], and arr[k] ! = arr[i], and arr[k] is sum of i and j's elements, then print and exit. Wait, so the loops are i, then j, then k? Wait, the loops are in order: i is first, then j, then k.",
      "start_char": 1076,
      "end_char": 2159,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The condition checks whether arr[k] equals the sum of a[i] and a[j], but also that arr[k] isn't equal to either a[i] or a[j].",
      "start_char": 2160,
      "end_char": 2285,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Wait, but those conditions would exclude cases where a[k] is equal to either? Wait the condition is:\n\narr[k] ! = arr[j] (so, the element at k isn't same as j's value),\n\narr[k] ! = arr[i] (same for i),\n\nand arr[k] == a[i] + a[j]\n\nWait, but why are those first two conditions needed? Maybe to ensure that the other two elements aren't contributing to the sum via being equal?",
      "start_char": 2286,
      "end_char": 2658,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Or perhaps it's to avoid certain trivial cases where, say, a[i] is zero, so a[j] plus a[i] is a[j], but then arr[k] would be a[j], which is not considered here. Not sure, but the code needs to be translated accurately.",
      "start_char": 2659,
      "end_char": 2877,
      "label": " ",
      "label_info": {
        "type": " "
      }
    },
    {
      "text": "The code is printing the indices (k+1, j+1, i+1) as (since in Python they do +1 because C uses 0-based maybe) but the output is with 1-based because of +1. So when a match is found, it outputs those three indices in order, and exits. Otherwise, the loop continues.",
      "start_char": 2879,
      "end_char": 3143,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "The loop structure is going through all possible triplets of indices where k can be any position, but with i and j different from each other (but k can be equal to i or j?) Wait, no: the condition i == j is skipped, so when i != j, the code proceeds; but for k, there's no check of that, so if k equals i or j, that's okay? But the condition says that arr[k] cannot be equal to either arr[i] or arr[j]. So even if k is equal to one of them, but its value is different, that could still be okay. Hmm. For example, if k is i, but arr[i] has value that's different from itself? No, arr[i] is the number, so arr[k] can't be less than arr[i] if k is i. Wait, arr[k] is arr[i], so if k == j,then arr[k] is arr[j], so then, the condition arr[k] ! = arr[i] and arr[k] ! = arr[j] would be false. So for example, if i and j are such that i ! =",
      "start_char": 3145,
      "end_char": 3976,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "j, and if k takes one of i or j, then the first condition would be violated. But in the loops, it's k in the indices, so the code allows k to be any index including i or j, but the condition would check whether that k is not having arr[k] equal to one of the components (i or j's element). So this code may be checking for a third element which is the sum of two distinct elements (i and j indices) but whose value is the sum of those two. Not entirely sure, but code must be translated correctly regardless. Now translating to C: First, in C, how to read the array?",
      "start_char": 3977,
      "end_char": 4547,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "We need to first take the first input as an integer y (though not sure why, but the code does it), then the second line reads the array. But in C, we can't use list comprehensions. Wait in Python's code: arr = [int(i) for i in input().split()] So the second input line is read, split into space-separated tokens, converted to integers. Therefore in C, we need to first read a number (the first y) but the code doesn't use it beyond that? Wait in the code, the Python line uses the second input to create the array. The first input y might be the length of the array.",
      "start_char": 4549,
      "end_char": 5117,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Because in the code, the array is built from the split, which may have a variable number of elements, but perhaps the problem's input requires that the first input is the length. So perhaps the user is supposed to first read the length (y) and then the array elements, but the array length here is to be determined from the split? Wait in the Python code above, the first line takes an integer (y), then arr is whatever comes next. However, for the problem's scenario, perhaps the next line's elements have exactly y elements? The code in the Python may not check that.",
      "start_char": 5118,
      "end_char": 5688,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Because for instance, in C, when reading the array, we need to know its size, but since y is given here, perhaps that's the required size. Wait the code is supposed to be translated, but the original code may have bugs, but translation should be precise. For instance, the first input in Python code is read into y (int).",
      "start_char": 5689,
      "end_char": 6011,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "The subsequent array is exactly the items in the next line, split by whitespace, converted to integers. So arr has the same length as the number of items in that next line, which can be more than y. But in many programming contest problems, the first integer is the array length. Possibly in this problem, the first integer y is the array's length. Because in the code, the array is split from the next input, but its length is variable.",
      "start_char": 6012,
      "end_char": 6450,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "For the sake of the code structure, in the C version, we need to read the first y, then read the next line as space-separated integers.",
      "start_char": 6451,
      "end_char": 6586,
      "label": " ",
      "label_info": {
        "type": " "
      }
    },
    {
      "text": "In C, to read n elements, first we need to know n. So in C, the code structure would be:\n\nRead the first value of y.\n\nThen read n elements into an array. But to read the array, we have to have n as the first input.",
      "start_char": 6588,
      "end_char": 6802,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The code above in Python does NOT validate that the next line's element count matches the value of y. So the code may be expecting that it does, so in our C code, we have to read the array until n elements, but feed from the next input line.",
      "start_char": 6804,
      "end_char": 7045,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Now, structuring the C code:\n\nWe can do:\n\n- Read first integer, which is n (the length of the array). Or perhaps y is stored here. Wait the variables: in Python, y is read first, but the array is taken from the next line. But the code does not use y anywhere else. Oh wait, looking again:\n\nWait in the Python code, the first line is y = int(input()), but then the code does not use y for anything.",
      "start_char": 7047,
      "end_char": 7445,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Like, the array's length is determined by the next input's split. So the variable y is there butunused. That must be a mistake? Or part of the problem. Wait maybe the problem had a different requirement where the sum is supposed to be equal to y, but",
      "start_char": 7446,
      "end_char": 7696,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "perhaps the code has a typo?\n\nWait in the problem's context, the Python code might have an error where the first line reads y (the target) but then instead of checking the sum equals y, it's checking for an element which is the sum of two others.",
      "start_char": 7698,
      "end_char": 7944,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "Not sure, but per the user's request, we have to translate the code as given, so even if the first input is unused, in C we need to read it and store it, then proceed. So in C, we'll need variables: int y;\n\nscanf(\"%d\", &y);\n\nThen read the array.",
      "start_char": 7945,
      "end_char": 8192,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "For the array, since n (the next input) is split from a subsequent line, the number of array elements is the count of integers provided on that line. But in C, since we can't read until the end, and cannot know the array size in advance (without reading the first line again?), but perhaps the array size is exactly y. \n\nWait, this is critical. If the array length is exactly y, then in Python's code the code would have:\n\n    arr = [ ... ] which is exactly y elements.",
      "start_char": 8193,
      "end_char": 8662,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Otherwise, the problem may be that in the Python code's conditions, but given that the provided Python code includes y but then does not use it, the code may have a logic error. But as a translator, our job is to convert the code as presented, not fix it. So in our C code, we have to read the first integer (y) but not use it except to read the next elements. Wait but to read an array in C, you need to know the length to allocate an array. So perhaps the problem expects that the second input's elements have exactly y elements. Assuming that the second input line has y numbers, then the array size is y. Hence in code:\n\nWe can read y, then set the array size as y, and read that many numbers. But to read the array in C:\n\nstatic int arr[100000]; // assuming maximum possible size. Wait but in C, the code can first read y, then dynamically allocate (but perhaps it's easier with a sufficiently big static array.",
      "start_char": 8665,
      "end_char": 9584,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "Let's say that the problem constraints have the array size up to, say, 1e5 elements, but without that, perhaps the program may not read correctly.",
      "start_char": 9586,
      "end_char": 9732,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "Alternatively, perhaps in the code, the first integer is not used, but in the problem, the second line should have exactly y elements, so we can proceed as follows. So in code: Read y (the first integer, not used except possibly as the array size). int y;\n\n    scanf(\"%d\", &y);\n\n    int n = y; // assuming the array has n elements. Then read the array:\n\n    // Assuming n is a constant, static array:\n\n    arr = (int *)malloc(n * sizeof(int));\n\n    // Then, read the n numbers in.\n\n    for (int i=0; i < n; i++) {\n\n        int num = 0;\n\n        scanf(\"%d\", &num);\n\n        arr[i] = num;\n\n    }\n\nWait but the code as given in Python uses \"input().split()\", which allows multiple space-separated integers in one line. So after the first y, the second line will contain perhaps many numbers, so in C, the second line is read via a scanf with %d, but the%n numbers may need to be stored. Another approach may be to read all the numbers from the second input line. For that, perhaps better to read each number until EOL.",
      "start_char": 9735,
      "end_char": 10759,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Alternatively:\n\nSuppose that the first number is read via scanf, then the second line is read via another input function. But for easier handling, maybe the code uses:\n\nint y;\n\nscanf(\"%d\", &y); // do we care? Not in code. Then read the array elements from stdin.",
      "start_char": 10761,
      "end_char": 11023,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Since the split is all remaining numbers in the next line, perhaps the array is supposed to be that. So we can read everything until EOF there? No, perhaps using:\n\nchar line[BUFSZ];\n\nfgets(line, BUFSZ, stdin); Then parse tokens? But that's complicated.",
      "start_char": 11025,
      "end_char": 11277,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Alternatively, using scanf in a loop until enough elements are read, but then, perhaps the C code would have to read until EOF.\n\nAlternatively, proceed with a loop to read numbers until you get the required count (if using the array size y).",
      "start_char": 11281,
      "end_char": 11522,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "Since in Python, the array length is not fixed to y. Hmm. Wait in Python's code, the array length can be any, because \"input().split()\" can have any number of elements, and then a for loop is run over that. So for example, even if the first y is 3, the array might have 5 elements. In C, we need to read as many as possible. Ah, but to handle dynamic arrays in C is a bit more challenging.",
      "start_char": 11523,
      "end_char": 11916,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Maybe the code would need to read all the numbers in a fixed array. But given that, perhaps the problem's first number is indeed the array's length. Let me think. Let's proceed under the assumption that the first number (y) is the array length.",
      "start_char": 11917,
      "end_char": 12161,
      "label": " ",
      "label_info": {
        "type": " "
      }
    },
    {
      "text": "Thus, in C code:\n\n- Read y, use it to define the array size. Wait but in Python code, the array is built from all numbers in the next input line.",
      "start_char": 12163,
      "end_char": 12308,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "The first line input is y (the code reads a y), then the second line is split into array. So in Python, the array length may not be y. But perhaps in the problem, the second line has exactly y numbers.",
      "start_char": 12310,
      "end_char": 12511,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Because otherwise the code could have an empty array and segfault C.\n\nProbably the problem here is to assume that the array length is exactly equal to y (the first input), so even though the code is presented in Python with that, but the code can be:\n\nRead the first integer into y (but unused, perhaps a typo), then the second line has exactly y elements. Thus in the C code, the code can first read the first integer, then read exactly that number of elements into the array. So, let's structure that:\n\n#include <stdio.h>\n\nint main() {\n\n    int y; \n\n    // read first number, unused here. scanf(\"%d\", &y);\n\n    // Then read the next line's elements as array. int n = y;\n\n    int arr[n]; // using variable length array, which allowed in C99 but not older versions.\n\n    // Now read exactly 'n' elements. for(int i = 0; i < n; ++i) {\n\n        scanf(\"%d\", &arr[i]);\n\n    }\n\n    // Proceed with the loops.\n\n    // The rest of the logic here.\n\n    for (int i =0; i < n; i++) {\n\n        for (int j=0; j < n; j++) {\n\n            if (i ==j ) continue;\n\n            for (int k=0; k <n ;k++ ) {\n\n                if ( arr[k] != arr[j] && arr[k] != arr[i] && (arr[k] == (arr[i]+arr[j])) ) {\n\n                    printf(\"%d %d %d\\n\", k+1, j+1, i+1) ; // Note the order must be k,j,i?\n\n                    return 0; \n\n                }\n\n            }\n\n        }\n\n    }\n\n    printf(\"-1\\n\");\n\n    return 0;\n\n} Wait, in the Python code, the order of printing is (k+1, j+1, i+1). Because in the code's order: print(k+1, j+1, i+1). The order is the k's index, then j, then i. Yes. So the C code must follow that output order. Now, need to see the data types. The arrays elements can be of standard int sizes.",
      "start_char": 12512,
      "end_char": 14222,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The loops will run from 0 to n-1 (since C arrays are zero-based). So the indices in the code are correct as written here. But there's a potential problem: the loops are three nested loops, with i and j, and then k inside. Wait in Python, the k for loop is nested under the j loop. So in the order:\n\nfor each i in all indices:\n\n   for each j in all indices:\n\n      if i ==j, skip.\n\n      for k in all indices:\n\n          check the condition. If any satisfy, print and exit.",
      "start_char": 14223,
      "end_char": 14697,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Thus, in C code, the loops need to be structured exactly so. So in C, the structure must have the i loop, then j loop, then k loop. Wait in C code as written above:\n\nYes. The condition in Python's code is:\n\nif arr[k] ! = arr[j] and arr[k] ! = arr[i] and arr[k] == arr[i] + arr[j]:\n\nSo in C code, the condition is:\n\n( arr[k] ! = arr[j] ) && (arr[k] ! = arr[i]) && (arr[k] == (arr[i] + arr[j]) )\n\nWait the operator precedence in C is such that '&&' has higher precedence than ==, so it's okay. Now, the code must print and exit upon the first occurrence.",
      "start_char": 14699,
      "end_char": 15250,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "In C, after the condition is true, the code prints and returns from main, effectively exiting. So the code:\n\n            if ( arr[k] ! = arr[j] && arr[k] ! = arr[i] && (arr[k] == (arr[i]+arr[j])) ) {\n\n                printf(\"%d % d %d\\n\", k+1, j+1, i+1); \n\n                return 0; // terminates the program.\n\n                // C doesn't have exit() unless include stdlib.h and call exit(0), but using normal return 0 is okay.\n\n            } The remaining code is the else case, so everything else. Wait but when the code proceeds, looping until all possibilities considered, then after the loops, print -1.",
      "start_char": 15252,
      "end_char": 15859,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Now, note that in Python, the loops are run such that for any triplet (i,j,k), even if they are the same indices except i ! =j, and k can be any, this is checked. Wait something that might be a problem: \n\nSuppose the array has elements, say, 0. Then i and j are different indices, but the sum arr[i] + arr[j] is zero. Suppose that there exists a k where arr[k] is 0, but i ! =j and k can be same as i or j? Wait but the first condition requires arr[k] not to be equal to arr[i] or arr[j], so if, say, arr[i]=2, arr[j]=-2, then their sum is 0.",
      "start_char": 15863,
      "end_char": 16406,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "If arr[k] is 0, but one of them (i or j's elements) was 0, then the condition would be violated. But if neither of the elements is zero, but their sum is, and arr[k] is zero, then if 0 is not present in arr[i] or arr[j], then it would pass. So the conditions ensure that the value at k is equal to the sum of i and j's elements, and that it's not equal to either of those two elements' values. So the code is as given; translating that is the key.",
      "start_char": 16407,
      "end_char": 16856,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Another thing to note: the loops in C are written such that the i and j loops are run in the order of O(n^3), which could be extremely slow for large n. However, this is the code's logic, so that must be respected.",
      "start_char": 16858,
      "end_char": 17072,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Potential issues in C:\n\nThe VLA (variable length array) arr[n] is allowed only in C99 or later but not in C89. If that's a problem, perhaps using dynamic allocation is better. But assuming C99 is acceptable.",
      "start_char": 17074,
      "end_char": 17281,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "Another option: use a fixed maximum size array, but that would require choosing a maximum possible array size, which may not be possible via problem constraints. Let's think if that's necessary. Alternatively, perhaps the problem allows the code to be written with VLA. Hence, the code can proceed as above.",
      "start_char": 17283,
      "end_char": 17591,
      "label": " ",
      "label_info": {
        "type": " "
      }
    },
    {
      "text": "Another point: in C, when using scanf for the array, after the first scanf, to read the first line's value, there may be leftover newlines. So for example, after scanf(\"%d\", &y), the next input may still be on the next line, which would be read by the subsequent loop.",
      "start_char": 17593,
      "end_char": 17861,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "For example, the first number is provided, then the next numbers are on the same line, or perhaps in another line. Since in Python code, the first input is gotten as input(), which reads a whole line.",
      "start_char": 17863,
      "end_char": 18063,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "The subsequent arr is from another input().split(). So in the C code, to replicate that behavior, perhaps after the first scanf, other data is read from the subsequent lines. Wait in Python:\n\nSuppose the first input is entered as '5' followed by a new line. Then the second input().split() will read another line which contains the array elements split.",
      "start_char": 18064,
      "end_char": 18417,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "In C, the first scanf will take the first number (from standard input line) but leaves the rest (if present) on the line, so the rest can be read. Wait but if the first input is given as a separate line (ie, after entering 5, then pressing enter) then the second array elements must be in another line.",
      "start_char": 18421,
      "end_char": 18723,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Therefore, in code:\n\nThe first int is read, then scanf then reaches the next input space, so in the loop for the array, the subsequent %d reads will take the next inputs. Thus, as written in the C code:\n\nint y;  // first number. scanf(\"%d\", &y);\n\nThen read n = y elements in a loop. Because that's exactly the numbers on the subsequent line(s).",
      "start_char": 18726,
      "end_char": 19072,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Wait, but this may be an issue if in the test case, the first number is given with the other numbers in the same line.",
      "start_char": 19074,
      "end_char": 19192,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "For example:\n\nSample input (numbers written from left to right):\n\n3 1 3 2 \n\nThen first line (with \\n) is \"3 1 3 2 \\n\". Then when scanf first reads 3 into y, the next elements 1,3,2 are still in the input stream. Thus reading n=3 elements would read those 1, 3, 2. Thus arr would be [1, 3, 2]\n\nBut in Python's code, the first input() would read \"3\", then the next input() reads \"1 3 2\", and split into [1, 3,2]\n\nSo the code is okay. The problem arises only if the numbers are provided in separate lines. Which is standard in coding contests to have each input as per lines, but the code can handle that.",
      "start_char": 19193,
      "end_char": 19796,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Since the logic reads the first number, then reads until the 'n' elements. Thus the code structure is okay.",
      "start_char": 19797,
      "end_char": 19904,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Having said that, the code is now acceptable except for some possible edge cases. Wait but the loops are in this order:\n\nfor i in range(len(arr)):\n\n    for j in ... same. etc. So in C, for a given triplet of indices (i,j,k), the code loops through all i, then j loops over all indices except i, then loops all k indices, checking the conditions. Wait the order of loops may affect which triplet is found first, but the code exits as soon as the first qualifying triplet is found. However, in C, the code as written will behave the same way. So the code logic is correct. So the final C code should look like:\n\n#include <stdio.h>\n\nint main() {\n\n    int y;\n\n    scanf(\"%d\", &y);\n\n    int n = y;\n\n    int arr[n];\n\n    for(int i=0; i <n ;i++) {\n\n        scanf(\"%d\", &arr[i]);\n\n    }\n\n    for(int i=0; i <n; i++) {\n\n        for(int j=0; j <n; j++) {\n\n            if(i == j) continue;\n\n            for(int k=0; k <n ;k++) {\n\n                if( (arr[k] != arr[i]) && (arr[k] != arr[j]) && (arr[k] == arr[i]+arr[j] )) {\n\n                    printf(\"%d % d %d\\n\", k+1, j+1, i+1) ;\n\n                    return 0;\n\n                }\n\n            }\n\n        }\n\n    }\n\n    printf(\"%d\\n\", -1);\n\n    return 0;\n\n}\n\nWait a thought: in the Python code, for k, j, and i:\n\nThe indices are from 0-based, so we add +1 to each for output. Yes, the code must output 1-based indices. So that part is correct. Testing possible edge cases: for instance, if there are 3 elements, and arr[0]=1, arr[1] =2, arr[2]=3. Then if i =0 and j=1. So their sum is 3, which is arr[2]. Then the k would be 2. The conditions:\n\narr[k] (3) must not equal arr[j] (2), which is true. arr[k] must not equal arr[i] (1), yes.\n\nand 3 == (1+2): yes. So the triplet (k=2, j=1, i=0) would meet the conditions. Thus, it would print 3 (2+1), 2 (1+1), 1 (0+1). So 3 2 1. Yes. But in the code, when i is the first element (index 0), j is 1 (since i != j), then k loops up to 2, and in that iteration would hit k=2, and the condition would hold, so code works. Hence code is correct. Another testing point: what if it's a triple where k is the same as i? Suppose i=0, j=1, k=0. Then arr[0] could equals 3. The sum of a[i] (3) and a[j] (0). Then:\n\narr[k] (3) equals a's sum (3+0=3). But then check the conditions: \n\narr[k] (3) should not equal a[j] (0?), yes. And not equal to a[i] (3). But arr[k] is equal to a[i] (3), so condition fails. Hence, no output, which is correct. Thus, code correctly skips. Another case: arr[i] = 0, a[j]=0. Then sum is 0. But i ! =j (they have different indices). Now pick a k where arr[k] is 0. So condition: arr[k] can't be same as arr[i] (0) \u2192 which is false. Thus, the condition would reject it. Hence even if their sum equals, the condition is skipped. Because the element is same as either of the addends. Thus, correct. Therefore, the code should work. Now, another point: the loops are going in the order of i, j, then k. The order matters for the first hit.",
      "start_char": 19907,
      "end_char": 22868,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "For example, if multiple valid triplets exist, the first one found (according to the loop order) will be printed.",
      "start_char": 22869,
      "end_char": 22982,
      "label": " ",
      "label_info": {
        "type": " "
      }
    },
    {
      "text": "The Python code and C code now follow the same path, so the selection is same. Thus the C translation is as above.",
      "start_char": 22983,
      "end_char": 23097,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    }
  ],
  "original_reasoning": "Okay, let's see. I need to translate this Python code into C. Hmm, the code takes an integer y as input, but then it's not used anywhere else? Wait, no, looking closer\u2014the first line is y = int(input()), but then the code uses arr, which is the next input split into integers. Wait, maybe the Python code is supposed to process the array elements? The actual code's main logic seems to involve checking if any element at index k is the sum of elements at i and j, where k isn't either i or j. Oh right, but the body has three nested loops: i, j, and k. Wait the code is a bit confusing. Let me parse it again.\n\nWait, the Python code first reads a number y (maybe the size of the array?), but in the array, it splits the next input into a list of integers. Wait, perhaps the first input is actually the number of elements, so arr is of length y? But the code is written such that it's taking the elements from the next input line, split into integers. Wait in the Python code, maybe the first line is getting the length of the array, but then the next line reads the elements. Because otherwise, if you take the first input as a simple integer, which maybe isn't used, but perhaps in this problem's context, the array length is provided as the first input?\n\nWait the problem here is to translate the code as given, not to understand why it works. So the code first reads y as an integer from input, then reads the array. But in the code, the 'y' isn't used further. Hmm, that's odd. Let me check the code again.\n\nWait the code's loops: there are three loops over the array's length. So for each triplet of i, j, and k indices. The innermost loop is for k?\n\nWait in the code:\n\nfor k in range(len(arr)):\n    if ... condition ... then print and exit.\n\nWait is that right?\n\nWait let me structure it again:\n\nThe code does:\n\nfor each i in 0 to len(arr)-1:\n\n   for each j in 0 to len(arr)-1:\n\n       if i == j, skip\n\n       for k in 0 to len(arr)-1:\n\n           if arr[k] != arr[j], and arr[k] != arr[i], and arr[k] is sum of i and j's elements, then print and exit.\n\nWait, so the loops are i, then j, then k? Wait, the loops are in order: i is first, then j, then k. The condition checks whether arr[k] equals the sum of a[i] and a[j], but also that arr[k] isn't equal to either a[i] or a[j]. Wait, but those conditions would exclude cases where a[k] is equal to either?\n\nWait the condition is:\n\narr[k] != arr[j] (so, the element at k isn't same as j's value),\n\narr[k] != arr[i] (same for i),\n\nand arr[k] == a[i] + a[j]\n\nWait, but why are those first two conditions needed? Maybe to ensure that the other two elements aren't contributing to the sum via being equal? Or perhaps it's to avoid certain trivial cases where, say, a[i] is zero, so a[j] plus a[i] is a[j], but then arr[k] would be a[j], which is not considered here. Not sure, but the code needs to be translated accurately.\n\nThe code is printing the indices (k+1, j+1, i+1) as (since in Python they do +1 because C uses 0-based maybe) but the output is with 1-based because of +1. So when a match is found, it outputs those three indices in order, and exits. Otherwise, the loop continues.\n\nThe loop structure is going through all possible triplets of indices where k can be any position, but with i and j different from each other (but k can be equal to i or j?)\n\nWait, no: the condition i == j is skipped, so when i != j, the code proceeds; but for k, there's no check of that, so if k equals i or j, that's okay? But the condition says that arr[k] cannot be equal to either arr[i] or arr[j]. So even if k is equal to one of them, but its value is different, that could still be okay. Hmm. For example, if k is i, but arr[i] has value that's different from itself? No, arr[i] is the number, so arr[k] can't be less than arr[i] if k is i. Wait, arr[k] is arr[i], so if k == j,then arr[k] is arr[j], so then, the condition arr[k] != arr[i] and arr[k] != arr[j] would be false. So for example, if i and j are such that i != j, and if k takes one of i or j, then the first condition would be violated. \n\nBut in the loops, it's k in the indices, so the code allows k to be any index including i or j, but the condition would check whether that k is not having arr[k] equal to one of the components (i or j's element). So this code may be checking for a third element which is the sum of two distinct elements (i and j indices) but whose value is the sum of those two. Not entirely sure, but code must be translated correctly regardless.\n\nNow translating to C:\n\nFirst, in C, how to read the array?\n\nWe need to first take the first input as an integer y (though not sure why, but the code does it), then the second line reads the array. But in C, we can't use list comprehensions.\n\nWait in Python's code: arr = [int(i) for i in input().split()]\n\nSo the second input line is read, split into space-separated tokens, converted to integers. Therefore in C, we need to first read a number (the first y) but the code doesn't use it beyond that? Wait in the code, the Python line uses the second input to create the array. The first input y might be the length of the array. Because in the code, the array is built from the split, which may have a variable number of elements, but perhaps the problem's input requires that the first input is the length. So perhaps the user is supposed to first read the length (y) and then the array elements, but the array length here is to be determined from the split?\n\nWait in the Python code above, the first line takes an integer (y), then arr is whatever comes next. However, for the problem's scenario, perhaps the next line's elements have exactly y elements? The code in the Python may not check that. Because for instance, in C, when reading the array, we need to know its size, but since y is given here, perhaps that's the required size.\n\nWait the code is supposed to be translated, but the original code may have bugs, but translation should be precise. For instance, the first input in Python code is read into y (int). The subsequent array is exactly the items in the next line, split by whitespace, converted to integers. So arr has the same length as the number of items in that next line, which can be more than y. But in many programming contest problems, the first integer is the array length.\n\nPossibly in this problem, the first integer y is the array's length. Because in the code, the array is split from the next input, but its length is variable. For the sake of the code structure, in the C version, we need to read the first y, then read the next line as space-separated integers.\n\nIn C, to read n elements, first we need to know n. So in C, the code structure would be:\n\nRead the first value of y.\n\nThen read n elements into an array. But to read the array, we have to have n as the first input.\n\nThe code above in Python does NOT validate that the next line's element count matches the value of y. So the code may be expecting that it does, so in our C code, we have to read the array until n elements, but feed from the next input line.\n\nNow, structuring the C code:\n\nWe can do:\n\n- Read first integer, which is n (the length of the array). Or perhaps y is stored here.\n\nWait the variables: in Python, y is read first, but the array is taken from the next line. But the code does not use y anywhere else. Oh wait, looking again:\n\nWait in the Python code, the first line is y = int(input()), but then the code does not use y for anything. Like, the array's length is determined by the next input's split. So the variable y is there butunused. That must be a mistake? Or part of the problem.\n\nWait maybe the problem had a different requirement where the sum is supposed to be equal to y, but perhaps the code has a typo?\n\nWait in the problem's context, the Python code might have an error where the first line reads y (the target) but then instead of checking the sum equals y, it's checking for an element which is the sum of two others. Not sure, but per the user's request, we have to translate the code as given, so even if the first input is unused, in C we need to read it and store it, then proceed.\n\nSo in C, we'll need variables:\n\nint y;\n\nscanf(\"%d\", &y);\n\nThen read the array. For the array, since n (the next input) is split from a subsequent line, the number of array elements is the count of integers provided on that line. But in C, since we can't read until the end, and cannot know the array size in advance (without reading the first line again?), but perhaps the array size is exactly y. \n\nWait, this is critical. If the array length is exactly y, then in Python's code the code would have:\n\n    arr = [ ... ] which is exactly y elements. \n\nOtherwise, the problem may be that in the Python code's conditions, but given that the provided Python code includes y but then does not use it, the code may have a logic error. But as a translator, our job is to convert the code as presented, not fix it. So in our C code, we have to read the first integer (y) but not use it except to read the next elements. Wait but to read an array in C, you need to know the length to allocate an array. So perhaps the problem expects that the second input's elements have exactly y elements. \n\nAssuming that the second input line has y numbers, then the array size is y. Hence in code:\n\nWe can read y, then set the array size as y, and read that many numbers.\n\nBut to read the array in C:\n\nstatic int arr[100000]; // assuming maximum possible size.\n\nWait but in C, the code can first read y, then dynamically allocate (but perhaps it's easier with a sufficiently big static array. Let's say that the problem constraints have the array size up to, say, 1e5 elements, but without that, perhaps the program may not read correctly. \n\nAlternatively, perhaps in the code, the first integer is not used, but in the problem, the second line should have exactly y elements, so we can proceed as follows.\n\nSo in code:\n\nRead y (the first integer, not used except possibly as the array size).\n\n    int y;\n\n    scanf(\"%d\", &y);\n\n    int n = y; // assuming the array has n elements.\n\nThen read the array:\n\n    // Assuming n is a constant, static array:\n\n    arr = (int *)malloc(n * sizeof(int));\n\n    // Then, read the n numbers in.\n\n    for (int i=0; i < n; i++) {\n\n        int num = 0;\n\n        scanf(\"%d\", &num);\n\n        arr[i] = num;\n\n    }\n\nWait but the code as given in Python uses \"input().split()\", which allows multiple space-separated integers in one line. So after the first y, the second line will contain perhaps many numbers, so in C, the second line is read via a scanf with %d, but the%n numbers may need to be stored.\n\nAnother approach may be to read all the numbers from the second input line. For that, perhaps better to read each number until EOL.\n\nAlternatively:\n\nSuppose that the first number is read via scanf, then the second line is read via another input function. But for easier handling, maybe the code uses:\n\nint y;\n\nscanf(\"%d\", &y); // do we care? Not in code.\n\nThen read the array elements from stdin. Since the split is all remaining numbers in the next line, perhaps the array is supposed to be that. So we can read everything until EOF there? No, perhaps using:\n\nchar line[BUFSZ];\n\nfgets(line, BUFSZ, stdin);\n\nThen parse tokens?\n\nBut that's complicated.\n\nAlternatively, using scanf in a loop until enough elements are read, but then, perhaps the C code would have to read until EOF.\n\nAlternatively, proceed with a loop to read numbers until you get the required count (if using the array size y). Since in Python, the array length is not fixed to y. Hmm. Wait in Python's code, the array length can be any, because \"input().split()\" can have any number of elements, and then a for loop is run over that.\n\nSo for example, even if the first y is 3, the array might have 5 elements.\n\nIn C, we need to read as many as possible. \n\nAh, but to handle dynamic arrays in C is a bit more challenging. Maybe the code would need to read all the numbers in a fixed array. But given that, perhaps the problem's first number is indeed the array's length. Let me think. Let's proceed under the assumption that the first number (y) is the array length.\n\nThus, in C code:\n\n- Read y, use it to define the array size.\n\nWait but in Python code, the array is built from all numbers in the next input line. The first line input is y (the code reads a y), then the second line is split into array. So in Python, the array length may not be y. But perhaps in the problem, the second line has exactly y numbers. Because otherwise the code could have an empty array and segfault C.\n\nProbably the problem here is to assume that the array length is exactly equal to y (the first input), so even though the code is presented in Python with that, but the code can be:\n\nRead the first integer into y (but unused, perhaps a typo), then the second line has exactly y elements.\n\nThus in the C code, the code can first read the first integer, then read exactly that number of elements into the array. So, let's structure that:\n\n#include <stdio.h>\n\nint main() {\n\n    int y; \n\n    // read first number, unused here.\n\n    scanf(\"%d\", &y);\n\n    // Then read the next line's elements as array.\n\n    int n = y;\n\n    int arr[n]; // using variable length array, which allowed in C99 but not older versions.\n\n    // Now read exactly 'n' elements.\n\n    for(int i = 0; i < n; ++i) {\n\n        scanf(\"%d\", &arr[i]);\n\n    }\n\n    // Proceed with the loops.\n\n    // The rest of the logic here.\n\n    for (int i =0; i < n; i++) {\n\n        for (int j=0; j < n; j++) {\n\n            if (i ==j ) continue;\n\n            for (int k=0; k <n ;k++ ) {\n\n                if ( arr[k] != arr[j] && arr[k] != arr[i] && (arr[k] == (arr[i]+arr[j])) ) {\n\n                    printf(\"%d %d %d\\n\", k+1, j+1, i+1); // Note the order must be k,j,i?\n\n                    return 0; \n\n                }\n\n            }\n\n        }\n\n    }\n\n    printf(\"-1\\n\");\n\n    return 0;\n\n}\n\nWait, in the Python code, the order of printing is (k+1, j+1, i+1). Because in the code's order: print(k+1, j+1, i+1). The order is the k's index, then j, then i.\n\nYes. So the C code must follow that output order. \n\nNow, need to see the data types. The arrays elements can be of standard int sizes. The loops will run from 0 to n-1 (since C arrays are zero-based). So the indices in the code are correct as written here.\n\nBut there's a potential problem: the loops are three nested loops, with i and j, and then k inside. Wait in Python, the k for loop is nested under the j loop. So in the order:\n\nfor each i in all indices:\n\n   for each j in all indices:\n\n      if i ==j, skip.\n\n      for k in all indices:\n\n          check the condition.\n\nIf any satisfy, print and exit.\n\nThus, in C code, the loops need to be structured exactly so. So in C, the structure must have the i loop, then j loop, then k loop.\n\nWait in C code as written above:\n\nYes.\n\nThe condition in Python's code is:\n\nif arr[k] != arr[j] and arr[k] != arr[i] and arr[k] == arr[i] + arr[j]:\n\nSo in C code, the condition is:\n\n( arr[k] != arr[j] ) && (arr[k] != arr[i]) && (arr[k] == (arr[i] + arr[j]) )\n\nWait the operator precedence in C is such that '&&' has higher precedence than ==, so it's okay.\n\nNow, the code must print and exit upon the first occurrence.\n\nIn C, after the condition is true, the code prints and returns from main, effectively exiting.\n\nSo the code:\n\n            if ( arr[k] != arr[j] && arr[k] != arr[i] && (arr[k] == (arr[i]+arr[j])) ) {\n\n                printf(\"%d %d %d\\n\", k+1, j+1, i+1); \n\n                return 0; // terminates the program.\n\n                // C doesn't have exit() unless include stdlib.h and call exit(0), but using normal return 0 is okay.\n\n            }\n\nThe remaining code is the else case, so everything else.\n\nWait but when the code proceeds, looping until all possibilities considered, then after the loops, print -1.\n\nNow, note that in Python, the loops are run such that for any triplet (i,j,k), even if they are the same indices except i !=j, and k can be any, this is checked. \n\nWait something that might be a problem: \n\nSuppose the array has elements, say, 0. Then i and j are different indices, but the sum arr[i] + arr[j] is zero. Suppose that there exists a k where arr[k] is 0, but i !=j and k can be same as i or j?\n\nWait but the first condition requires arr[k] not to be equal to arr[i] or arr[j], so if, say, arr[i]=2, arr[j]=-2, then their sum is 0. If arr[k] is 0, but one of them (i or j's elements) was 0, then the condition would be violated. But if neither of the elements is zero, but their sum is, and arr[k] is zero, then if 0 is not present in arr[i] or arr[j], then it would pass.\n\nSo the conditions ensure that the value at k is equal to the sum of i and j's elements, and that it's not equal to either of those two elements' values.\n\nSo the code is as given; translating that is the key.\n\nAnother thing to note: the loops in C are written such that the i and j loops are run in the order of O(n^3), which could be extremely slow for large n. However, this is the code's logic, so that must be respected.\n\nPotential issues in C:\n\nThe VLA (variable length array) arr[n] is allowed only in C99 or later but not in C89. If that's a problem, perhaps using dynamic allocation is better. But assuming C99 is acceptable.\n\nAnother option: use a fixed maximum size array, but that would require choosing a maximum possible array size, which may not be possible via problem constraints. Let's think if that's necessary.\n\nAlternatively, perhaps the problem allows the code to be written with VLA. Hence, the code can proceed as above.\n\nAnother point: in C, when using scanf for the array, after the first scanf, to read the first line's value, there may be leftover newlines. So for example, after scanf(\"%d\", &y), the next input may still be on the next line, which would be read by the subsequent loop.\n\nFor example, the first number is provided, then the next numbers are on the same line, or perhaps in another line. Since in Python code, the first input is gotten as input(), which reads a whole line. The subsequent arr is from another input().split(). So in the C code, to replicate that behavior, perhaps after the first scanf, other data is read from the subsequent lines.\n\nWait in Python:\n\nSuppose the first input is entered as '5' followed by a new line.\n\nThen the second input().split() will read another line which contains the array elements split.\n\nIn C, the first scanf will take the first number (from standard input line) but leaves the rest (if present) on the line, so the rest can be read.\n\nWait but if the first input is given as a separate line (ie, after entering 5, then pressing enter) then the second array elements must be in another line.\n\nTherefore, in code:\n\nThe first int is read, then scanf then reaches the next input space, so in the loop for the array, the subsequent %d reads will take the next inputs.\n\nThus, as written in the C code:\n\nint y;  // first number.\n\nscanf(\"%d\", &y);\n\nThen read n = y elements in a loop. Because that's exactly the numbers on the subsequent line(s).\n\nWait, but this may be an issue if in the test case, the first number is given with the other numbers in the same line. For example:\n\nSample input (numbers written from left to right):\n\n3 1 3 2 \n\nThen first line (with \\n) is \"3 1 3 2 \\n\".\n\nThen when scanf first reads 3 into y, the next elements 1,3,2 are still in the input stream. Thus reading n=3 elements would read those 1, 3, 2. Thus arr would be [1, 3, 2]\n\nBut in Python's code, the first input() would read \"3\", then the next input() reads \"1 3 2\", and split into [1, 3,2]\n\nSo the code is okay. The problem arises only if the numbers are provided in separate lines. Which is standard in coding contests to have each input as per lines, but the code can handle that. Since the logic reads the first number, then reads until the 'n' elements.\n\nThus the code structure is okay.\n\nHaving said that, the code is now acceptable except for some possible edge cases.\n\nWait but the loops are in this order:\n\nfor i in range(len(arr)):\n\n    for j in ... same.\n\n    etc.\n\nSo in C, for a given triplet of indices (i,j,k), the code loops through all i, then j loops over all indices except i, then loops all k indices, checking the conditions.\n\nWait the order of loops may affect which triplet is found first, but the code exits as soon as the first qualifying triplet is found. However, in C, the code as written will behave the same way. So the code logic is correct.\n\nSo the final C code should look like:\n\n#include <stdio.h>\n\nint main() {\n\n    int y;\n\n    scanf(\"%d\", &y);\n\n    int n = y;\n\n    int arr[n];\n\n    for(int i=0; i <n ;i++) {\n\n        scanf(\"%d\", &arr[i]);\n\n    }\n\n    for(int i=0; i <n; i++) {\n\n        for(int j=0; j <n; j++) {\n\n            if(i == j) continue;\n\n            for(int k=0; k <n ;k++) {\n\n                if( (arr[k] != arr[i]) && (arr[k] != arr[j]) && (arr[k] == arr[i]+arr[j] )) {\n\n                    printf(\"%d %d %d\\n\", k+1, j+1, i+1);\n\n                    return 0;\n\n                }\n\n            }\n\n        }\n\n    }\n\n    printf(\"%d\\n\", -1);\n\n    return 0;\n\n}\n\nWait a thought: in the Python code, for k, j, and i:\n\nThe indices are from 0-based, so we add +1 to each for output.\n\nYes, the code must output 1-based indices. So that part is correct.\n\nTesting possible edge cases: for instance, if there are 3 elements, and arr[0]=1, arr[1] =2, arr[2]=3. Then if i =0 and j=1. So their sum is 3, which is arr[2]. Then the k would be 2. The conditions:\n\narr[k] (3) must not equal arr[j] (2), which is true.\n\narr[k] must not equal arr[i] (1), yes.\n\nand 3 == (1+2): yes.\n\nSo the triplet (k=2, j=1, i=0) would meet the conditions. \n\nThus, it would print 3 (2+1), 2 (1+1), 1 (0+1). So 3 2 1.\n\nYes.\n\nBut in the code, when i is the first element (index 0), j is 1 (since i != j), then k loops up to 2, and in that iteration would hit k=2, and the condition would hold, so code works.\n\nHence code is correct.\n\nAnother testing point: what if it's a triple where k is the same as i?\n\nSuppose i=0, j=1, k=0. Then arr[0] could equals 3. The sum of a[i] (3) and a[j] (0). Then:\n\narr[k] (3) equals a's sum (3+0=3). But then check the conditions: \n\narr[k] (3) should not equal a[j] (0?), yes. And not equal to a[i] (3). But arr[k] is equal to a[i] (3), so condition fails. Hence, no output, which is correct.\n\nThus, code correctly skips.\n\nAnother case: arr[i] = 0, a[j]=0. Then sum is 0. But i !=j (they have different indices). Now pick a k where arr[k] is 0. So condition: arr[k] can't be same as arr[i] (0) \u2192 which is false. Thus, the condition would reject it. Hence even if their sum equals, the condition is skipped. Because the element is same as either of the addends.\n\nThus, correct.\n\nTherefore, the code should work.\n\nNow, another point: the loops are going in the order of i, j, then k. The order matters for the first hit. For example, if multiple valid triplets exist, the first one found (according to the loop order) will be printed. The Python code and C code now follow the same path, so the selection is same.\n\nThus the C translation is as above."
}