{
  "qid": "atcoder_ABC126_E___codeforces_276_B",
  "tree": {
    "id": "root",
    "children": [
      {
        "id": "thought_0",
        "text": "We are given two Java programs to be executed in sequence. The first program (atcoder_ABC126_E) reads integers n and m, then m triplets (x, y, z). It uses a Union-Find data structure to count connected components and prints the count.",
        "label": "code_analysis",
        "relation": "elaboration",
        "children": [],
        "parent_id": "root"
      },
      {
        "id": "thought_1",
        "text": "The second program (codeforces_276_B) reads a string and determines if the first player can win in a game where players remove one character at a time.",
        "label": "mental_execution",
        "relation": "Continuation",
        "children": [
          {
            "id": "thought_2",
            "text": "The condition is: if the number of characters with odd frequency is 0 or 1 or odd, then \"First\", otherwise \"Second\". However, note that the first program outputs a single integer (the count of connected components). The second program reads a string.",
            "label": "mental_execution",
            "relation": "Continuation",
            "children": [
              {
                "id": "thought_3",
                "text": "This implies that the output of the first program becomes the input to the second? But that doesn't match because the first outputs an integer and the second expects a string. But the problem says: \"the output of each program is used as the input to the next\". So the output of the first program (an integer) would be the input to the second program. However, the second program reads a string. This is a problem because the integer would be read as a string.",
                "label": "mental_execution",
                "relation": "Continuation",
                "children": [
                  {
                    "id": "thought_4",
                    "text": "For example, if the first outputs \"3\", the second program would read the string \"3\". But looking at the second program: it counts the frequency of each character in the string. For a string that is a single integer (like \"3\"), the frequency of '3' is 1 (odd) -> oddCount=1 -> then it prints \"First\". But the original problem chain: \n  Input to first program: integers n, m and m triplets. Output of first program: an integer (say, k). Then the second program is run with input string = k (as a string) and then it outputs either \"First\" or \"Second\". But note: the problem says \"behaves identically\". So we have to simulate the chain.",
                    "label": "mental_execution",
                    "relation": "Continuation",
                    "children": [
                      {
                        "id": "thought_5",
                        "text": "However, the problem says: \"Translate the entire sequence into a single Fortran program that reproduces the same behavior. \"\n\nSo the Fortran program should:\n  1. Read the input for the first program (n, m and m triplets).",
                        "label": "high_level_plan",
                        "relation": "Continuation",
                        "children": [
                          {
                            "id": "thought_6",
                            "text": "2. Process the first program (without printing the intermediate result) to get the integer k (the number of connected components). 3. Then use k to form a string (because the second program expects a string input) and then run the second program's logic on that string. But note: the second program in the chain would have taken the output of the first as a string. So we must convert the integer k to a string and then process that string.",
                            "label": "high_level_plan",
                            "relation": "Continuation",
                            "children": [
                              {
                                "id": "thought_7",
                                "text": "Alternatively, we can avoid the conversion if we note that the second program only cares about the frequency of each digit in the string. However, the integer k can have multiple digits. For example, if k=12, then the string is \"12\", which has two characters: '1' and '2'. Each appears once -> so two odd frequencies -> then oddCount=2 -> then condition: if oddCount<=1 or oddCount is odd? Here: 2 is even and greater than 1 -> so it would output \"Second\". But we must simulate the chain exactly. Steps in the Fortran program:\n  1. Read the integers n and m.\n  2. Read m triplets (each triplet: x, y, z; and note that the first program subtracts 1 from x and y). 3. Use union-find to count the connected components -> let that count be `cnt`. 4. Convert `cnt` to a string (this string is the input to the second program). 5. For this string, count the frequency of each character. 6. Count the number of characters that have an odd frequency (say, `oddCount`). 7. If `oddCount <= 1` OR `oddCount` is odd, then output \"First\", else output \"Second\". Important: The original first program does not output anything in the middle.",
                                "label": "mental_execution",
                                "relation": "Continuation",
                                "children": [
                                  {
                                    "id": "thought_8",
                                    "text": "The second program reads the entire string. So we must not output the intermediate `cnt` to the screen and then read it back? The problem says: no I/O in the middle. Therefore, we will:\n  - Read the input for the first program (n, m and the triplets). - Process the union-find to get the count of connected components (cnt).",
                                    "label": "high_level_plan",
                                    "relation": "Continuation",
                                    "children": [
                                      {
                                        "id": "thought_9",
                                        "text": "- Convert cnt to a string (without any extra spaces or newlines) and then use that string as the input for the second program's logic.",
                                        "label": "high_level_plan",
                                        "relation": "Continuation",
                                        "children": [
                                          {
                                            "id": "thought_10",
                                            "text": "Implementation details:\n  - We'll write the entire program in Fortran.\n  - We need a union-find data structure (with path compression and union by rank) in Fortran. - We need to convert the integer `cnt` to a string. We can write an integer to a character variable using internal write. Structure of the Fortran program:\n\n  program main\n    implicit none\n\n    !",
                                            "label": "high_level_plan",
                                            "relation": "Continuation",
                                            "children": [
                                              {
                                                "id": "thought_11",
                                                "text": "Variables for the first program\n    integer :: n, m, i, x, y, z, cnt\n    integer, allocatable :: par(:), rank(:)\n\n    ! Variables for the second program\n    character(len=:), allocatable :: str\n    integer :: j, total_odd, len_str, freq(0:127)  ! Using ASCII range, but we can do for digits only? Actually the string is digits only.\n    integer :: digit, num, remainder, k, temp\n    character(len=20) :: buffer  ! To convert integer to string\n\n    ! Step 1: Read n and m\n    read(*,*) n, m\n\n    ! Allocate union-find arrays\n    allocate(par(0:n-1), rank(0:n-1))\n\n    ! Initialize union-find\n    do i = 0, n-1\n      par(i) = i\n      rank(i) = 0\n    end do\n\n    ! Process the m triplets\n    do i = 1, m\n      read(*,*) x, y, z\n      x = x - 1  ! convert to 0-indexed\n      y = y - 1\n      call unite(x, y, par, rank, n)\n    end do\n\n    ! Count the roots (where par[i] == i)\n    cnt = 0\n    do i = 0, n-1\n      if (par(i) == i) then\n        cnt = cnt + 1\n      end if\n    end do\n\n    ! Now, convert cnt to a string without any spaces or newlines.\n    write(buffer, '(I0)') cnt   ! I0 writes the integer without leading spaces\n    ! We want to trim the buffer and then assign to a variable that we can use for the second part.\n    ! Let's get the actual length of the string\n    len_str = len_trim(buffer)\n    allocate(character(len=len_str) :: str)\n    str = trim(buffer)\n\n    ! Now, for the second program: we have the string 'str'\n    ! We need to compute frequency of each character in the string.\n\n    ! Initialize frequency array (for ASCII 0 to 127, but we can also do for '0' to '9' only)\n    freq = 0\n\n    ! Traverse the string\n    do j = 1, len_str\n      ! For each character, convert to its ASCII index? Actually we can use the character as index.\n      ! But Fortran doesn't allow character as index? We can use IACHAR to get the integer value. k = iachar(str(j:j)) if (k < 0 .or. k > 127) then\n        ! Skip? But the string is digits, so safe. cycle\n      end if\n      freq(k) = freq(k) + 1\n    end do\n\n    ! Count the odd frequencies\n    total_odd = 0\n    do j = 48, 57   ! ASCII for '0' to '9'\n      if (mod(freq(j), 2) /= 0) then\n        total_odd = total_odd + 1\n      end if\n    end do\n\n    ! Also, if there are other characters? We don't expect any. But the string is only digits.\n\n    ! Now, condition:\n    if (total_odd <= 1 .or. mod(total_odd,2) /= 0) then\n      write(*,*)",
                                                "label": "code_analysis",
                                                "relation": "Continuation",
                                                "children": [
                                                  {
                                                    "id": "thought_12",
                                                    "text": "\"First\"\n    else\n      write(*,*) \"Second\"\n    end if\n\n    deallocate(par, rank, str)\n\n  contains\n\n    ! We'll write the union-find functions as internal subroutines. recursive integer function find(x, par) result(root)\n      integer, intent(in) :: x\n      integer, intent(inout) :: par(0:)\n      integer :: parent\n\n      parent = par(x) if (parent == x) then\n        root = x\n      else\n        root = find(parent, par)\n        par(x) = root   ! path compression\n      end if\n    end function find\n\n    subroutine unite(x, y, par, rank, n)\n      integer, intent(in) :: x, y, n\n      integer, intent(inout) :: par(0:n-1), rank(0:n-1)\n      integer :: rx, ry\n\n      rx = find(x, par)\n      ry = find(y, par)\n\n      if (rx == ry) return\n\n      if (rank(rx) < rank(ry)) then\n        par(rx) = ry\n      else if (rank(rx) > rank(ry)) then\n        par(ry) = rx\n      else\n        par(ry) = rx\n        rank(rx) = rank(rx) + 1\n      end if\n    end subroutine unite\n\n  end program main\n\nNote: We have to be cautious about the array indices. The original Java uses 0-indexed arrays. In Fortran, we can also use 0-indexed arrays by declaring (0:n-1).",
                                                    "label": "code_analysis",
                                                    "relation": "Continuation",
                                                    "children": [
                                                      {
                                                        "id": "thought_13",
                                                        "text": "However, note that in the union-find, we are using the same indices as the original. But in the main program, we are reading x and then subtracting 1 to make it 0-indexed. Similarly for y.\n\nAlso, the subroutine `unite` has the array arguments with bounds (0:n-1).",
                                                        "label": "code_analysis",
                                                        "relation": "Continuation",
                                                        "children": [
                                                          {
                                                            "id": "thought_14",
                                                            "text": "We pass the entire array and the size n.\n\nBut note: in the `find` function, the array `par` is passed with assumed shape. We must ensure that the bounds in the caller and the callee are consistent. Alternatively, we can use explicit bounds by passing the lower and upper bounds? However, in the main program we allocated par(0:n-1).",
                                                            "label": "code_analysis",
                                                            "relation": "Continuation",
                                                            "children": [
                                                              {
                                                                "id": "thought_15",
                                                                "text": "In the subroutine, we can have:\n\n    integer, intent(inout) :: par(0:) But then in `find`, we also have:",
                                                                "label": "code_analysis",
                                                                "relation": "Continuation",
                                                                "children": [
                                                                  {
                                                                    "id": "thought_16",
                                                                    "text": "integer, intent(inout) :: par(0:)\n\nThis means that in `find`, the array `par` is assumed to start at 0. This matches. But note: the `unite` subroutine also has the array `rank` with the same bounds. However, the `find` function only uses the `par` array.",
                                                                    "label": "code_analysis",
                                                                    "relation": "Continuation",
                                                                    "children": [],
                                                                    "parent_id": "thought_15"
                                                                  }
                                                                ],
                                                                "parent_id": "thought_14"
                                                              }
                                                            ],
                                                            "parent_id": "thought_13"
                                                          }
                                                        ],
                                                        "parent_id": "thought_12"
                                                      },
                                                      {
                                                        "id": "thought_17",
                                                        "text": "Another note: the `find` function is recursive. We must mark it as recursive. But Fortran allows recursion? Yes, but we have to declare the function as recursive.",
                                                        "label": "bug_fixing",
                                                        "relation": "Continuation",
                                                        "children": [
                                                          {
                                                            "id": "thought_18",
                                                            "text": "Alternatively, we can avoid recursion by using iterative path compression? But the original used recursion. We'll use recursion. But note: the problem says \"entire sequence\", so we are combining two programs. The first one uses union-find with recursion. We'll do the same.",
                                                            "label": "high_level_plan",
                                                            "relation": "Continuation",
                                                            "children": [],
                                                            "parent_id": "thought_17"
                                                          },
                                                          {
                                                            "id": "thought_19",
                                                            "text": "However, the recursion depth might be large for n up to 100000? But the problem doesn't specify constraints.",
                                                            "label": "mental_execution",
                                                            "relation": "Continuation",
                                                            "children": [
                                                              {
                                                                "id": "thought_20",
                                                                "text": "We assume the recursion depth is manageable (the union-find tree is not very deep due to path compression).",
                                                                "label": "high_level_plan",
                                                                "relation": "Continuation",
                                                                "children": [],
                                                                "parent_id": "thought_19"
                                                              }
                                                            ],
                                                            "parent_id": "thought_17"
                                                          },
                                                          {
                                                            "id": "thought_21",
                                                            "text": "Alternatively, we can write an iterative version to avoid stack overflow. But the problem doesn't specify n and m. We'll follow the original. Alternatively, we can write an iterative `find`:\n\n    function find(x, par) result(root)\n      integer, intent(in) :: x\n      integer, intent(inout) :: par(0:)\n      integer :: root, node, parent\n\n      node = x\n      do while (par(node) /= node)\n        node = par(node)\n      end do\n      root = node\n\n      ! Path compression: traverse again? node = x\n      do while (node /= root)\n        parent = par(node)\n        par(node) = root\n        node = parent\n      end do\n    end function\n\nThis iterative version avoids recursion. We'll use this to avoid stack overflow. Let's change the `find` to iterative.",
                                                            "label": "bug_fixing",
                                                            "relation": "Contrast",
                                                            "children": [
                                                              {
                                                                "id": "thought_22",
                                                                "text": "Revised `find`:\n\n    integer function find(x, par) result(root)\n      integer, intent(in) :: x\n      integer, intent(inout) :: par(0:)\n      integer :: node, temp, parent\n\n      ! Find the root\n      node = x\n      do while (par(node) /= node)\n        node = par(node)\n      end do\n      root = node\n\n      ! Path compression: set every node along the path to point to root. node = x\n      do while (node /= root)\n        parent = par(node)\n        par(node) = root\n        node = parent\n      end do\n    end function\n\nBut note: the original Java program used recursion and path compression. This iterative version does the same. We'll use the iterative version to avoid recursion limits. Now, let's code accordingly. Final Fortran program:\n\n  - Read n, m and the triplets.\n  - Initialize union-find.\n  - Process each triplet by uniting x and y (ignore z).\n  - Count the roots (where par[i]==i) -> cnt.\n  - Convert cnt to a string (without spaces).\n  - For the string, compute the frequency of each character (only digits are present). - Count the number of digits that appear an odd number of times (total_odd).\n  - If total_odd <= 1 or total_odd is odd, output \"First\", else \"Second\". But note: the condition in the second program was:\n\n    if (oddCount < = 1 || oddCount % 2 != 0) {\n        writer.println(\"First\");\n    } else {\n        writer.println(\"Second\");\n    } So in Fortran: if (total_odd <= 1 .or. mod(total_odd,2) /= 0) then\n\nBut note: mod(total_odd,2) /= 0  means total_odd is odd. We'll code accordingly. Let's write the code.",
                                                                "label": "bug_fixing",
                                                                "relation": "Continuation",
                                                                "children": [],
                                                                "parent_id": "thought_21"
                                                              }
                                                            ],
                                                            "parent_id": "thought_17"
                                                          }
                                                        ],
                                                        "parent_id": "thought_12"
                                                      }
                                                    ],
                                                    "parent_id": "thought_11"
                                                  }
                                                ],
                                                "parent_id": "thought_10"
                                              }
                                            ],
                                            "parent_id": "thought_9"
                                          }
                                        ],
                                        "parent_id": "thought_8"
                                      }
                                    ],
                                    "parent_id": "thought_7"
                                  }
                                ],
                                "parent_id": "thought_6"
                              }
                            ],
                            "parent_id": "thought_5"
                          }
                        ],
                        "parent_id": "thought_4"
                      }
                    ],
                    "parent_id": "thought_3"
                  }
                ],
                "parent_id": "thought_2"
              }
            ],
            "parent_id": "thought_1"
          }
        ],
        "parent_id": "root"
      }
    ],
    "metadata": {},
    "original_reasoning": "We are given two Java programs to be executed in sequence. The first program (atcoder_ABC126_E) reads integers n and m, then m triplets (x, y, z). It uses a Union-Find data structure to count connected components and prints the count.\n\nThe second program (codeforces_276_B) reads a string and determines if the first player can win in a game where players remove one character at a time. The condition is: if the number of characters with odd frequency is 0 or 1 or odd, then \"First\", otherwise \"Second\".\n\nHowever, note that the first program outputs a single integer (the count of connected components). The second program reads a string. This implies that the output of the first program becomes the input to the second? But that doesn't match because the first outputs an integer and the second expects a string.\n\nBut the problem says: \"the output of each program is used as the input to the next\". So the output of the first program (an integer) would be the input to the second program. However, the second program reads a string. This is a problem because the integer would be read as a string. For example, if the first outputs \"3\", the second program would read the string \"3\".\n\nBut looking at the second program: it counts the frequency of each character in the string. For a string that is a single integer (like \"3\"), the frequency of '3' is 1 (odd) -> oddCount=1 -> then it prints \"First\".\n\nBut the original problem chain: \n  Input to first program: integers n, m and m triplets.\n  Output of first program: an integer (say, k).\n  Then the second program is run with input string = k (as a string) and then it outputs either \"First\" or \"Second\".\n\nBut note: the problem says \"behaves identically\". So we have to simulate the chain.\n\nHowever, the problem says: \"Translate the entire sequence into a single Fortran program that reproduces the same behavior.\"\n\nSo the Fortran program should:\n  1. Read the input for the first program (n, m and m triplets).\n  2. Process the first program (without printing the intermediate result) to get the integer k (the number of connected components).\n  3. Then use k to form a string (because the second program expects a string input) and then run the second program's logic on that string.\n\nBut note: the second program in the chain would have taken the output of the first as a string. So we must convert the integer k to a string and then process that string.\n\nAlternatively, we can avoid the conversion if we note that the second program only cares about the frequency of each digit in the string. However, the integer k can have multiple digits. For example, if k=12, then the string is \"12\", which has two characters: '1' and '2'. Each appears once -> so two odd frequencies -> then oddCount=2 -> then condition: if oddCount<=1 or oddCount is odd? \n   Here: 2 is even and greater than 1 -> so it would output \"Second\".\n\nBut we must simulate the chain exactly.\n\nSteps in the Fortran program:\n  1. Read the integers n and m.\n  2. Read m triplets (each triplet: x, y, z; and note that the first program subtracts 1 from x and y).\n  3. Use union-find to count the connected components -> let that count be `cnt`.\n  4. Convert `cnt` to a string (this string is the input to the second program).\n  5. For this string, count the frequency of each character.\n  6. Count the number of characters that have an odd frequency (say, `oddCount`).\n  7. If `oddCount <= 1` OR `oddCount` is odd, then output \"First\", else output \"Second\".\n\nImportant: The original first program does not output anything in the middle. The second program reads the entire string. So we must not output the intermediate `cnt` to the screen and then read it back? The problem says: no I/O in the middle.\n\nTherefore, we will:\n  - Read the input for the first program (n, m and the triplets).\n  - Process the union-find to get the count of connected components (cnt).\n  - Convert cnt to a string (without any extra spaces or newlines) and then use that string as the input for the second program's logic.\n\nImplementation details:\n  - We'll write the entire program in Fortran.\n  - We need a union-find data structure (with path compression and union by rank) in Fortran.\n  - We need to convert the integer `cnt` to a string. We can write an integer to a character variable using internal write.\n\nStructure of the Fortran program:\n\n  program main\n    implicit none\n\n    ! Variables for the first program\n    integer :: n, m, i, x, y, z, cnt\n    integer, allocatable :: par(:), rank(:)\n\n    ! Variables for the second program\n    character(len=:), allocatable :: str\n    integer :: j, total_odd, len_str, freq(0:127)  ! Using ASCII range, but we can do for digits only? Actually the string is digits only.\n    integer :: digit, num, remainder, k, temp\n    character(len=20) :: buffer  ! To convert integer to string\n\n    ! Step 1: Read n and m\n    read(*,*) n, m\n\n    ! Allocate union-find arrays\n    allocate(par(0:n-1), rank(0:n-1))\n\n    ! Initialize union-find\n    do i = 0, n-1\n      par(i) = i\n      rank(i) = 0\n    end do\n\n    ! Process the m triplets\n    do i = 1, m\n      read(*,*) x, y, z\n      x = x - 1  ! convert to 0-indexed\n      y = y - 1\n      call unite(x, y, par, rank, n)\n    end do\n\n    ! Count the roots (where par[i] == i)\n    cnt = 0\n    do i = 0, n-1\n      if (par(i) == i) then\n        cnt = cnt + 1\n      end if\n    end do\n\n    ! Now, convert cnt to a string without any spaces or newlines.\n    write(buffer, '(I0)') cnt   ! I0 writes the integer without leading spaces\n    ! We want to trim the buffer and then assign to a variable that we can use for the second part.\n    ! Let's get the actual length of the string\n    len_str = len_trim(buffer)\n    allocate(character(len=len_str) :: str)\n    str = trim(buffer)\n\n    ! Now, for the second program: we have the string 'str'\n    ! We need to compute frequency of each character in the string.\n\n    ! Initialize frequency array (for ASCII 0 to 127, but we can also do for '0' to '9' only)\n    freq = 0\n\n    ! Traverse the string\n    do j = 1, len_str\n      ! For each character, convert to its ASCII index? Actually we can use the character as index.\n      ! But Fortran doesn't allow character as index? We can use IACHAR to get the integer value.\n      k = iachar(str(j:j))\n      if (k < 0 .or. k > 127) then\n        ! Skip? But the string is digits, so safe.\n        cycle\n      end if\n      freq(k) = freq(k) + 1\n    end do\n\n    ! Count the odd frequencies\n    total_odd = 0\n    do j = 48, 57   ! ASCII for '0' to '9'\n      if (mod(freq(j), 2) /= 0) then\n        total_odd = total_odd + 1\n      end if\n    end do\n\n    ! Also, if there are other characters? We don't expect any. But the string is only digits.\n\n    ! Now, condition:\n    if (total_odd <= 1 .or. mod(total_odd,2) /= 0) then\n      write(*,*) \"First\"\n    else\n      write(*,*) \"Second\"\n    end if\n\n    deallocate(par, rank, str)\n\n  contains\n\n    ! We'll write the union-find functions as internal subroutines.\n\n    recursive integer function find(x, par) result(root)\n      integer, intent(in) :: x\n      integer, intent(inout) :: par(0:)\n      integer :: parent\n\n      parent = par(x)\n      if (parent == x) then\n        root = x\n      else\n        root = find(parent, par)\n        par(x) = root   ! path compression\n      end if\n    end function find\n\n    subroutine unite(x, y, par, rank, n)\n      integer, intent(in) :: x, y, n\n      integer, intent(inout) :: par(0:n-1), rank(0:n-1)\n      integer :: rx, ry\n\n      rx = find(x, par)\n      ry = find(y, par)\n\n      if (rx == ry) return\n\n      if (rank(rx) < rank(ry)) then\n        par(rx) = ry\n      else if (rank(rx) > rank(ry)) then\n        par(ry) = rx\n      else\n        par(ry) = rx\n        rank(rx) = rank(rx) + 1\n      end if\n    end subroutine unite\n\n  end program main\n\nNote: We have to be cautious about the array indices. The original Java uses 0-indexed arrays. In Fortran, we can also use 0-indexed arrays by declaring (0:n-1).\n\nHowever, note that in the union-find, we are using the same indices as the original.\n\nBut in the main program, we are reading x and then subtracting 1 to make it 0-indexed. Similarly for y.\n\nAlso, the subroutine `unite` has the array arguments with bounds (0:n-1). We pass the entire array and the size n.\n\nBut note: in the `find` function, the array `par` is passed with assumed shape. We must ensure that the bounds in the caller and the callee are consistent. Alternatively, we can use explicit bounds by passing the lower and upper bounds? However, in the main program we allocated par(0:n-1). In the subroutine, we can have:\n\n    integer, intent(inout) :: par(0:)\n\nBut then in `find`, we also have:\n\n    integer, intent(inout) :: par(0:)\n\nThis means that in `find`, the array `par` is assumed to start at 0. This matches.\n\nBut note: the `unite` subroutine also has the array `rank` with the same bounds.\n\nHowever, the `find` function only uses the `par` array.\n\nAnother note: the `find` function is recursive. We must mark it as recursive.\n\nBut Fortran allows recursion? Yes, but we have to declare the function as recursive.\n\nAlternatively, we can avoid recursion by using iterative path compression? But the original used recursion. We'll use recursion.\n\nBut note: the problem says \"entire sequence\", so we are combining two programs. The first one uses union-find with recursion. We'll do the same.\n\nHowever, the recursion depth might be large for n up to 100000? But the problem doesn't specify constraints. We assume the recursion depth is manageable (the union-find tree is not very deep due to path compression). Alternatively, we can write an iterative version to avoid stack overflow.\n\nBut the problem doesn't specify n and m. We'll follow the original.\n\nAlternatively, we can write an iterative `find`:\n\n    function find(x, par) result(root)\n      integer, intent(in) :: x\n      integer, intent(inout) :: par(0:)\n      integer :: root, node, parent\n\n      node = x\n      do while (par(node) /= node)\n        node = par(node)\n      end do\n      root = node\n\n      ! Path compression: traverse again?\n      node = x\n      do while (node /= root)\n        parent = par(node)\n        par(node) = root\n        node = parent\n      end do\n    end function\n\nThis iterative version avoids recursion. We'll use this to avoid stack overflow.\n\nLet's change the `find` to iterative.\n\nRevised `find`:\n\n    integer function find(x, par) result(root)\n      integer, intent(in) :: x\n      integer, intent(inout) :: par(0:)\n      integer :: node, temp, parent\n\n      ! Find the root\n      node = x\n      do while (par(node) /= node)\n        node = par(node)\n      end do\n      root = node\n\n      ! Path compression: set every node along the path to point to root.\n      node = x\n      do while (node /= root)\n        parent = par(node)\n        par(node) = root\n        node = parent\n      end do\n    end function\n\nBut note: the original Java program used recursion and path compression. This iterative version does the same.\n\nWe'll use the iterative version to avoid recursion limits.\n\nNow, let's code accordingly.\n\nFinal Fortran program:\n\n  - Read n, m and the triplets.\n  - Initialize union-find.\n  - Process each triplet by uniting x and y (ignore z).\n  - Count the roots (where par[i]==i) -> cnt.\n  - Convert cnt to a string (without spaces).\n  - For the string, compute the frequency of each character (only digits are present).\n  - Count the number of digits that appear an odd number of times (total_odd).\n  - If total_odd <= 1 or total_odd is odd, output \"First\", else \"Second\".\n\nBut note: the condition in the second program was:\n\n    if (oddCount <= 1 || oddCount % 2 != 0) {\n        writer.println(\"First\");\n    } else {\n        writer.println(\"Second\");\n    }\n\nSo in Fortran: \n    if (total_odd <= 1 .or. mod(total_odd,2) /= 0) then\n\nBut note: mod(total_odd,2) /= 0  means total_odd is odd.\n\nWe'll code accordingly.\n\nLet's write the code."
  }
}