{
  "qid": "codeforces_296_A",
  "tree": {
    "id": "root",
    "children": [
      {
        "id": "thought_0",
        "text": "Okay, I need to translate this Java code into C. Let me start by understanding what the Java code is doing. The Java program reads an integer n, then reads n integers.",
        "label": "code_analysis",
        "relation": "elaboration",
        "children": [
          {
            "id": "thought_1",
            "text": "It counts the frequency of each integer using an array of size 1001. Then it finds the maximum count. Finally, it checks if the maximum count is within certain limits based on whether n is even or odd. If so, it prints \"YES\", else \"NO\". Now, translating this to C. Let's think about each part step by step. First, the InputReader class in Java is handling input. In C, we can read from stdin using scanf or fgets.",
            "label": "mental_execution",
            "relation": "Continuation",
            "children": [
              {
                "id": "thought_2",
                "text": "Since the code uses nextInt(), which reads integers one by one, maybe scanf is suitable here. But since the input could be multiple numbers in a line, we might need to read line by line and parse the integers.",
                "label": "language_mapping",
                "relation": "Continuation",
                "children": [
                  {
                    "id": "thought_3",
                    "text": "Alternatively, using scanf with space-separated inputs should work as it automatically skips whitespace. The main function in Java sets up the input and output streams. In C, the equivalent would be to use stdin and stdout directly. The Task class's solve method: the logic here is straightforward.",
                    "label": " ",
                    "relation": "Continuation",
                    "children": [
                      {
                        "id": "thought_4",
                        "text": "Read n, create an array of size 1001 (indexes 0 to 1000?), since in Java the array is [1001], so indexes 0-1000. Then for each of the n numbers, increment the count at that index. Then compute the maximum count. Now, the conditions for output: if even, the max count must be <= n/2. If odd, max must be <= n/2 +1. Because integer division in C is different for negative numbers, but n here is a positive integer. So for n even, check if max <= n/2, else for odd, n/2 +1. So I need to port this logic into C.\n\nFirst, variables: In C, we can have int array[1001]; initialized to all zeros. But in C, we have to initialize them to zero first.",
                        "label": "code_analysis",
                        "relation": "Continuation",
                        "children": [
                          {
                            "id": "thought_5",
                            "text": "Wait, in the Java code, the array starts at index 0. So in C, the array[0] to array[1000] would correspond to the counts for indices 0 to 1000. But in the problem, are the input numbers allowed up to 1000?",
                            "label": "mental_execution",
                            "relation": "Continuation",
                            "children": [
                              {
                                "id": "thought_6",
                                "text": "Let me see: the array size in Java is set to 1001, so probably the input numbers are 1-based or 0-based?",
                                "label": "mental_execution",
                                "relation": "Continuation",
                                "children": [
                                  {
                                    "id": "thought_7",
                                    "text": "Well, the code's for loop reads n numbers into 'index' and increments array[index]. So the indexes can be up to 1000, since the array has 1001 elements. So in C, the array can be 1001 elements. So in the code:\n\nint array[1001] = {0}; // initializes all elements to zero. Wait, in C, if you use int array[1001] = {0}; that initializes all elements to 0. That's good. So steps:\n\n1. Read n from input. 2. Initialize array to all zeros. 3. Read n integers, for each, do array[num]++. 4. Find the maximum in the array. The loop in Java starts from i=1, but why? Because 0 could be included?",
                                    "label": "code_analysis",
                                    "relation": "Continuation",
                                    "children": [
                                      {
                                        "id": "thought_8",
                                        "text": "Well, the Java code loops from 1 to array.length (which is 1001), but the indexes go up to 1000, so in code, the loop is from 1 < 1001 (since arrays are 0-based in Java, length is 1001 elements, so indices 0 to 1000. The code's for loop is for (int i = 1; i < array.length; i++), so starting at 1, up to 1000. Hmm, that's interesting. So in Java, they are skipping index 0 when checking for the max. Wait, why?",
                                        "label": "mental_execution",
                                        "relation": "Continuation",
                                        "children": [
                                          {
                                            "id": "thought_9",
                                            "text": "Let's look:\n\nIn the Java code, when they count array[index], index is the input number. So the input numbers could be 0. If the user enters 0 as an index, then array[0] will be incremented. But in the loop where counting max, the code starts at i =1 (skipping 0). So the max is not considering the 0 index's count? Wait that's a mistake. Let me check the code again. Original Java code's loop:\n\nfor (int i = 1; i < array.length; i++) {\n    if (countMax < array[i]) countMax = array[i];\n}\n\nWait array's indices go from 0 to 1000. The loop starts at i=1. So the first element (i=0) is not checked. That would be a bug, right?",
                                            "label": "code_analysis",
                                            "relation": "Continuation",
                                            "children": [
                                              {
                                                "id": "thought_10",
                                                "text": "Because if the input index is 0, its count is in array[0], but it won't be considered in the maximum. So perhaps the problem requires that the input numbers are from 1 to 1000?",
                                                "label": "mental_execution",
                                                "relation": "Continuation",
                                                "children": [
                                                  {
                                                    "id": "thought_11",
                                                    "text": "Looking at the problem, perhaps the code is correct according to the problem's constraints. Let me see. Maybe the problem specifies the input numbers are between 1 and 1000? Let me think. Since it's codeforces problem 296A, maybe I should look up the problem statement in mind.",
                                                    "label": " ",
                                                    "relation": "Continuation",
                                                    "children": [
                                                      {
                                                        "id": "thought_12",
                                                        "text": "Assuming problem's input constraints: each number is between 1 and 1000. Then array[0] won't be used, so starting from 1 makes sense. Otherwise, if the problem allows 0, then this code has a bug. But since the code uses the indices as the input numbers and increments array[index], if input numbers can be 0, then the max should start from i=0. But in the code here, that's not the case. So maybe the problem constraints ensure that the indices are at least 1.",
                                                        "label": "mental_execution",
                                                        "relation": "Continuation",
                                                        "children": [
                                                          {
                                                            "id": "thought_13",
                                                            "text": "Let's proceed with the translation as given, perhaps the original problem has the input numbers starting from 1. So in C code: Initialize max to -1. Then loop from i=1 to 1000 (since array is size 1001, indices 0-1000). Wait, since in Java the array is [1001], so in C, array's size is 1001, and the maximum is 1000. So in the for loop:\n\nIn C, for (i=1; i < 1001; i++). But in Java, the loop is i < array.length where array.length is 1001, so that's the same. So for the maximum, we need to consider all elements starting at 1? Wait in C, array indexes 0 to 1000. So code:\n\nint countMax = -1;\n\nfor (int i = 1; i < 1001; i++) {\n    if (array[i] > countMax) {\n        countMax = array[i];\n    }\n}\n\nThen proceed with the conditions. Now the conditions:\n\nif (n % 2 ==0) {\n\n   if (countMax <= n /2 ) then yes else no\n\nelse:\n\n   if countMax <= (n/2 +1) then yes else no. But since in C, integer division is truncating, for n odd, n/2 gives the floor, so n/2 +1 is the ceiling. Wait suppose n is 5. Then n/2 is 2 (5 /2 is 2 in integer division), adding 1: 3. So that would be correct. For example, maximum allowed is (5+1)/2 =3. So the code seems correct. Now putting the code together. First, the reading of n, then the counts. First step: in main:\n\nRead n first with scanf(\"%d\", &n); then read n times, each time reading an integer, say x, and do array[x]++. Wait, but how? In C, after reading n, then loop for i from 0 to n-1. Each time read an integer. Since the next numbers are n in total, but perhaps all in one line. So perhaps:\n\n#include <stdio.h>\n\nint main() {\n\n    int n;\n    scanf(\"%d\", &n);\n\n    int array[1001] = {0};\n\n    for (int i = 0; i < n; i++) {\n        int x;\n        scanf(\"%d\", &x);\n        array[x]++;\n    }\n\n    // find max count\n    int countMax = -1;\n    for (int i =1; i < 1001; i++) {\n        if (array[i] > countMax) countMax = array[i];\n    }\n\n    // determine the result\n    int allowed =0;\n    if( n %2 ==0 ) {\n        if (countMax <= (n /2 )) {\n            allowed =1;\n        }\n    } else {\n        if (countMax <= (n /2 +1) ) {\n            allowed =1;\n        }\n    }\n\n    printf(allowed ? \"YES\":\"NO\");\n\n    return 0;\n}\n\nWait wait: that's the proposed code. But there are some things to consider. Let me check for possible errors. Wait, the array is initialized to zero. So all are zeros. For each input x, we increment array[x]. But the input x can be 0?",
                                                            "label": "code_analysis",
                                                            "relation": "Continuation",
                                                            "children": [
                                                              {
                                                                "id": "thought_14",
                                                                "text": "Well, in the original Java code, the problem might allow that, but the initial code's maximum skip. But if the problem's x can be zero and count that, the code would be wrong. But as per the given Java code, they start their loop at i=1, so in C we do similarly, which follows the same approach as the original code, even if potentially wrong for zero. Since we are translating, we need to preserve the original logic exactly.",
                                                                "label": "code_analysis",
                                                                "relation": "Continuation",
                                                                "children": [],
                                                                "parent_id": "thought_13"
                                                              },
                                                              {
                                                                "id": "thought_15",
                                                                "text": "Next: in the loop of reading x: the problem says that after n is given, the next n integers are the array. So scanf can read them as per the input. But what if the input numbers are multiple in a line, or after newlines?",
                                                                "label": "mental_execution",
                                                                "relation": "Continuation",
                                                                "children": [
                                                                  {
                                                                    "id": "thought_16",
                                                                    "text": "Well, scanf reads until it finds a number, so as long as the input is space/newline separated numbers, it should be okay. Wait but in the Java code, the InputReader class's next() method reads tokens, so effectively splitting on whitespace.",
                                                                    "label": "mental_execution",
                                                                    "relation": "Continuation",
                                                                    "children": [
                                                                      {
                                                                        "id": "thought_17",
                                                                        "text": "Thus, the input is expected to be space-separated. So the C code should do the same. But sometimes, in programming competition problems, after the first number n, the other numbers can be in the next line. But the code with scanner is okay. Testing possible edge cases. Testing for n =1? Suppose input is 1 followed by 5. Then array[5] is 1. countMax is 1. Then since n is odd, the allowed is (1/2 +1)=0.5 +1=1.5? Wait integer division: n is 1, n/2 is 0, so 0 +1 =1. So 1 <=1: yes, so \"YES\". Another test case. Let's say n=2, inputs [1,1].",
                                                                        "label": "test_generation",
                                                                        "relation": "Continuation",
                                                                        "children": [
                                                                          {
                                                                            "id": "thought_18",
                                                                            "text": "countMax is 2, which is equal to n/2 (1). So the code will print \"YES\". Wait but wait, when n is even, allowed up to n/2. For n=2, n/2 is 1. So if max is 2, which is greater than 1, so \"NO\", but in that example, the max is 2 which is more than 1, so code outputs \"NO\". Let me see:\n\nIf the code's condition for n even is if countMax <= n/2 then yes. So 2 is more than 1 would print \"NO\" correctly. Wait the sample test case where input is 2 1 1:\n\nn is even (2), countMax is 2. So 2 <=1? No, so print NO, which is correct. Another case: n=3, input [1,1,1]. countMax is 3. For n=3, n/2 is 1, +1 becomes 2. 3>2, so output NO. But if input is [1,2,2], counts are 1 and 2, so max is 2. 3/2+1 =2, so OK, so output YES. So the code seems to work. Wait now the main thing: in the code above, I wrote:\n\nfor (int i =1; i <1001; i++), but in C, arrays are 0-based, so the indexes go from 0 to 1000. So that's correct. But the initial code in Java starts the loop from 1 to array.length. So that is from 1 up to 1000 (since array.length is 1001, the last index is 1000). So that's correct in C's code as well. Now is there any problem with the array size? Since in C, the size is 1001. So all indices from 0 to 1000. So if the input x can be 1000, that's okay.",
                                                                            "label": "mental_execution",
                                                                            "relation": "Continuation",
                                                                            "children": [
                                                                              {
                                                                                "id": "thought_19",
                                                                                "text": "If the input has a value higher than 1000, then array[x] is out of bound. But given that in the problem's original constraints (assuming from the given code), the numbers are up to 1000 (since array has size 1001), then that's okay. So to prevent array overflows, we can assume the problem's inputs are in the allowed range. Now, the code in C can be written as above.",
                                                                                "label": "mental_execution",
                                                                                "relation": "Continuation",
                                                                                "children": [
                                                                                  {
                                                                                    "id": "thought_20",
                                                                                    "text": "Wait, but in C the for loops: in the code written earlier, the for loops can use 'int i' inside. But in C89, variables have to be declared at the top. But assuming we can use C99 or higher. Alternatively, the main code would be:\n\n#include <stdio.h>\n\nint main() {\n    int n; if (scanf(\"%d\", &n) ! = 1) return 1;\n\n    int array[1001] = {0};\n    int x;\n\n    for (int i = 0; i < n; i++) {\n        if(scanf(\"%d\", &x) ! =1 ) return 1;\n        array[x]++;\n    }\n\n    int countMax = -1;\n    for (int i = 1; i < 1001; i++) {\n        if (array[i] > countMax) {\n            countMax = array[i];\n        }\n    }\n\n    int allowed =0; if (n %2 ==0) {\n        if (countMax <= (n/2)) allowed =1;\n    } else {\n        if (countMax <= (n/2 +1)) allowed =1;\n    }\n\n    printf(allowed ? \"YES\":\"NO\");\n\n    return 0;\n}\n\nWait but wait: in the first part, the scanf for n must be checked. Well, the original Java code just reads, assuming it's correct.",
                                                                                    "label": "bug_fixing",
                                                                                    "relation": "Continuation",
                                                                                    "children": [
                                                                                      {
                                                                                        "id": "thought_21",
                                                                                        "text": "In programming competition code, sometimes people don't check, but maybe to match exactly, but since it's code translation, perhaps proceed as per original. Wait also, the line array[X] increments when x could be up to 1000. So that's okay. Wait also, what about leading or trailing spaces? scanf would consume any whitespace.",
                                                                                        "label": "mental_execution",
                                                                                        "relation": "Continuation",
                                                                                        "children": [],
                                                                                        "parent_id": "thought_20"
                                                                                      }
                                                                                    ],
                                                                                    "parent_id": "thought_19"
                                                                                  }
                                                                                ],
                                                                                "parent_id": "thought_18"
                                                                              }
                                                                            ],
                                                                            "parent_id": "thought_17"
                                                                          }
                                                                        ],
                                                                        "parent_id": "thought_16"
                                                                      }
                                                                    ],
                                                                    "parent_id": "thought_15"
                                                                  }
                                                                ],
                                                                "parent_id": "thought_13"
                                                              }
                                                            ],
                                                            "parent_id": "thought_12"
                                                          }
                                                        ],
                                                        "parent_id": "thought_11"
                                                      },
                                                      {
                                                        "id": "thought_22",
                                                        "text": "Another thing: the original Java code is from codeforces problem 296A, which is: \n\nProblem 296A: \"Copying Homework\". The problem requires that you have an array a of n elements.",
                                                        "label": "code_analysis",
                                                        "relation": "Continuation",
                                                        "children": [
                                                          {
                                                            "id": "thought_23",
                                                            "text": "You can do some operations where you can take two of the elements and set them equal to their median.",
                                                            "label": " ",
                                                            "relation": "Contrast",
                                                            "children": [],
                                                            "parent_id": "thought_22"
                                                          },
                                                          {
                                                            "id": "thought_24",
                                                            "text": "The minimum possible number of operations needed to make all elements equal is... but in the problem statement, the actual question might require that the number of occurrences of any number does not exceed ceil(n/2), which is the condition checked here.",
                                                            "label": " ",
                                                            "relation": "Continuation",
                                                            "children": [
                                                              {
                                                                "id": "thought_25",
                                                                "text": "Therefore, the code is correct in its logic, and the array is initialized properly. So this code in C should work.",
                                                                "label": " ",
                                                                "relation": "Continuation",
                                                                "children": [],
                                                                "parent_id": "thought_24"
                                                              }
                                                            ],
                                                            "parent_id": "thought_22"
                                                          }
                                                        ],
                                                        "parent_id": "thought_11"
                                                      }
                                                    ],
                                                    "parent_id": "thought_10"
                                                  }
                                                ],
                                                "parent_id": "thought_9"
                                              }
                                            ],
                                            "parent_id": "thought_8"
                                          }
                                        ],
                                        "parent_id": "thought_7"
                                      }
                                    ],
                                    "parent_id": "thought_6"
                                  }
                                ],
                                "parent_id": "thought_5"
                              }
                            ],
                            "parent_id": "thought_4"
                          }
                        ],
                        "parent_id": "thought_3"
                      }
                    ],
                    "parent_id": "thought_2"
                  }
                ],
                "parent_id": "thought_1"
              }
            ],
            "parent_id": "thought_0"
          }
        ],
        "parent_id": "root"
      }
    ],
    "metadata": {},
    "original_reasoning": "Okay, I need to translate this Java code into C. Let me start by understanding what the Java code is doing. \n\nThe Java program reads an integer n, then reads n integers. It counts the frequency of each integer using an array of size 1001. Then it finds the maximum count. Finally, it checks if the maximum count is within certain limits based on whether n is even or odd. If so, it prints \"YES\", else \"NO\".\n\nNow, translating this to C. Let's think about each part step by step.\n\nFirst, the InputReader class in Java is handling input. In C, we can read from stdin using scanf or fgets. Since the code uses nextInt(), which reads integers one by one, maybe scanf is suitable here. But since the input could be multiple numbers in a line, we might need to read line by line and parse the integers. Alternatively, using scanf with space-separated inputs should work as it automatically skips whitespace.\n\nThe main function in Java sets up the input and output streams. In C, the equivalent would be to use stdin and stdout directly.\n\nThe Task class's solve method: the logic here is straightforward. Read n, create an array of size 1001 (indexes 0 to 1000?), since in Java the array is [1001], so indexes 0-1000. Then for each of the n numbers, increment the count at that index. Then compute the maximum count. \n\nNow, the conditions for output: if even, the max count must be <= n/2. If odd, max must be <= n/2 +1. Because integer division in C is different for negative numbers, but n here is a positive integer. So for n even, check if max <= n/2, else for odd, n/2 +1.\n\nSo I need to port this logic into C.\n\nFirst, variables:\n\nIn C, we can have int array[1001]; initialized to all zeros. But in C, we have to initialize them to zero first.\n\nWait, in the Java code, the array starts at index 0. So in C, the array[0] to array[1000] would correspond to the counts for indices 0 to 1000. But in the problem, are the input numbers allowed up to 1000? Let me see: the array size in Java is set to 1001, so probably the input numbers are 1-based or 0-based? Well, the code's for loop reads n numbers into 'index' and increments array[index]. So the indexes can be up to 1000, since the array has 1001 elements. So in C, the array can be 1001 elements.\n\nSo in the code:\n\nint array[1001] = {0}; // initializes all elements to zero.\n\nWait, in C, if you use int array[1001] = {0}; that initializes all elements to 0. That's good.\n\nSo steps:\n\n1. Read n from input.\n\n2. Initialize array to all zeros.\n\n3. Read n integers, for each, do array[num]++.\n\n4. Find the maximum in the array. The loop in Java starts from i=1, but why? Because 0 could be included? Well, the Java code loops from 1 to array.length (which is 1001), but the indexes go up to 1000, so in code, the loop is from 1 < 1001 (since arrays are 0-based in Java, length is 1001 elements, so indices 0 to 1000. The code's for loop is for (int i = 1; i < array.length; i++), so starting at 1, up to 1000. Hmm, that's interesting. So in Java, they are skipping index 0 when checking for the max. \n\nWait, why? Let's look:\n\nIn the Java code, when they count array[index], index is the input number. So the input numbers could be 0. If the user enters 0 as an index, then array[0] will be incremented. But in the loop where counting max, the code starts at i =1 (skipping 0). So the max is not considering the 0 index's count?\n\nWait that's a mistake. Let me check the code again.\n\nOriginal Java code's loop:\n\nfor (int i = 1; i < array.length; i++) {\n    if (countMax < array[i]) countMax = array[i];\n}\n\nWait array's indices go from 0 to 1000. The loop starts at i=1. So the first element (i=0) is not checked. That would be a bug, right? Because if the input index is 0, its count is in array[0], but it won't be considered in the maximum. So perhaps the problem requires that the input numbers are from 1 to 1000? \n\n Looking at the problem, perhaps the code is correct according to the problem's constraints. Let me see. Maybe the problem specifies the input numbers are between 1 and 1000? Let me think. Since it's codeforces problem 296A, maybe I should look up the problem statement in mind.\n\nAssuming problem's input constraints: each number is between 1 and 1000. Then array[0] won't be used, so starting from 1 makes sense. Otherwise, if the problem allows 0, then this code has a bug. But since the code uses the indices as the input numbers and increments array[index], if input numbers can be 0, then the max should start from i=0. But in the code here, that's not the case. So maybe the problem constraints ensure that the indices are at least 1. Let's proceed with the translation as given, perhaps the original problem has the input numbers starting from 1.\n\nSo in C code:\n\nInitialize max to -1. Then loop from i=1 to 1000 (since array is size 1001, indices 0-1000). Wait, since in Java the array is [1001], so in C, array's size is 1001, and the maximum is 1000. So in the for loop:\n\nIn C, for (i=1; i < 1001; i++). But in Java, the loop is i < array.length where array.length is 1001, so that's the same.\n\nSo for the maximum, we need to consider all elements starting at 1?\n\nWait in C, array indexes 0 to 1000. So code:\n\nint countMax = -1;\n\nfor (int i = 1; i < 1001; i++) {\n    if (array[i] > countMax) {\n        countMax = array[i];\n    }\n}\n\nThen proceed with the conditions.\n\nNow the conditions:\n\nif (n % 2 ==0) {\n\n   if (countMax <= n /2 ) then yes else no\n\nelse:\n\n   if countMax <= (n/2 +1) then yes else no.\n\nBut since in C, integer division is truncating, for n odd, n/2 gives the floor, so n/2 +1 is the ceiling.\n\nWait suppose n is 5. Then n/2 is 2 (5 /2 is 2 in integer division), adding 1: 3. So that would be correct. For example, maximum allowed is (5+1)/2 =3. So the code seems correct.\n\nNow putting the code together.\n\nFirst, the reading of n, then the counts.\n\nFirst step: in main:\n\nRead n first with scanf(\"%d\", &n); then read n times, each time reading an integer, say x, and do array[x]++.\n\nWait, but how?\n\nIn C, after reading n, then loop for i from 0 to n-1.\n\nEach time read an integer. Since the next numbers are n in total, but perhaps all in one line. So perhaps:\n\n#include <stdio.h>\n\nint main() {\n\n    int n;\n    scanf(\"%d\", &n);\n\n    int array[1001] = {0};\n\n    for (int i = 0; i < n; i++) {\n        int x;\n        scanf(\"%d\", &x);\n        array[x]++;\n    }\n\n    // find max count\n    int countMax = -1;\n    for (int i =1; i < 1001; i++) {\n        if (array[i] > countMax) countMax = array[i];\n    }\n\n    // determine the result\n    int allowed =0;\n    if( n %2 ==0 ) {\n        if (countMax <= (n /2 )) {\n            allowed =1;\n        }\n    } else {\n        if (countMax <= (n /2 +1) ) {\n            allowed =1;\n        }\n    }\n\n    printf(allowed ? \"YES\":\"NO\");\n\n    return 0;\n}\n\nWait wait: that's the proposed code. But there are some things to consider. Let me check for possible errors.\n\nWait, the array is initialized to zero. So all are zeros. For each input x, we increment array[x].\n\nBut the input x can be 0? Well, in the original Java code, the problem might allow that, but the initial code's maximum skip. But if the problem's x can be zero and count that, the code would be wrong. But as per the given Java code, they start their loop at i=1, so in C we do similarly, which follows the same approach as the original code, even if potentially wrong for zero. Since we are translating, we need to preserve the original logic exactly.\n\nNext: in the loop of reading x: the problem says that after n is given, the next n integers are the array. So scanf can read them as per the input. But what if the input numbers are multiple in a line, or after newlines?\n\nWell, scanf reads until it finds a number, so as long as the input is space/newline separated numbers, it should be okay.\n\nWait but in the Java code, the InputReader class's next() method reads tokens, so effectively splitting on whitespace. Thus, the input is expected to be space-separated. So the C code should do the same.\n\nBut sometimes, in programming competition problems, after the first number n, the other numbers can be in the next line. But the code with scanner is okay.\n\nTesting possible edge cases.\n\nTesting for n =1? Suppose input is 1 followed by 5. Then array[5] is 1. countMax is 1. Then since n is odd, the allowed is (1/2 +1)=0.5 +1=1.5? Wait integer division: n is 1, n/2 is 0, so 0 +1 =1. So 1 <=1: yes, so \"YES\".\n\nAnother test case. Let's say n=2, inputs [1,1]. countMax is 2, which is equal to n/2 (1). So the code will print \"YES\".\n\nWait but wait, when n is even, allowed up to n/2. For n=2, n/2 is 1. So if max is 2, which is greater than 1, so \"NO\", but in that example, the max is 2 which is more than 1, so code outputs \"NO\". Let me see:\n\nIf the code's condition for n even is if countMax <= n/2 then yes. So 2 is more than 1 would print \"NO\" correctly.\n\nWait the sample test case where input is 2 1 1:\n\nn is even (2), countMax is 2. So 2 <=1? No, so print NO, which is correct.\n\nAnother case: n=3, input [1,1,1]. countMax is 3. For n=3, n/2 is 1, +1 becomes 2. 3>2, so output NO. But if input is [1,2,2], counts are 1 and 2, so max is 2. 3/2+1 =2, so OK, so output YES.\n\nSo the code seems to work.\n\nWait now the main thing: in the code above, I wrote:\n\nfor (int i =1; i <1001; i++), but in C, arrays are 0-based, so the indexes go from 0 to 1000. So that's correct.\n\nBut the initial code in Java starts the loop from 1 to array.length. So that is from 1 up to 1000 (since array.length is 1001, the last index is 1000). So that's correct in C's code as well.\n\nNow is there any problem with the array size? Since in C, the size is 1001. So all indices from 0 to 1000. So if the input x can be 1000, that's okay. If the input has a value higher than 1000, then array[x] is out of bound. But given that in the problem's original constraints (assuming from the given code), the numbers are up to 1000 (since array has size 1001), then that's okay.\n\nSo to prevent array overflows, we can assume the problem's inputs are in the allowed range.\n\nNow, the code in C can be written as above.\n\nWait, but in C the for loops: in the code written earlier, the for loops can use 'int i' inside. But in C89, variables have to be declared at the top. But assuming we can use C99 or higher. \n\nAlternatively, the main code would be:\n\n#include <stdio.h>\n\nint main() {\n    int n;\n    if (scanf(\"%d\", &n) != 1) return 1;\n\n    int array[1001] = {0};\n    int x;\n\n    for (int i = 0; i < n; i++) {\n        if(scanf(\"%d\", &x) !=1 ) return 1;\n        array[x]++;\n    }\n\n    int countMax = -1;\n    for (int i = 1; i < 1001; i++) {\n        if (array[i] > countMax) {\n            countMax = array[i];\n        }\n    }\n\n    int allowed =0;\n    if (n %2 ==0) {\n        if (countMax <= (n/2)) allowed =1;\n    } else {\n        if (countMax <= (n/2 +1)) allowed =1;\n    }\n\n    printf(allowed ? \"YES\":\"NO\");\n\n    return 0;\n}\n\nWait but wait: in the first part, the scanf for n must be checked. Well, the original Java code just reads, assuming it's correct. In programming competition code, sometimes people don't check, but maybe to match exactly, but since it's code translation, perhaps proceed as per original.\n\nWait also, the line array[X] increments when x could be up to 1000. So that's okay.\n\nWait also, what about leading or trailing spaces? scanf would consume any whitespace.\n\nAnother thing: the original Java code is from codeforces problem 296A, which is: \n\nProblem 296A: \"Copying Homework\". The problem requires that you have an array a of n elements. You can do some operations where you can take two of the elements and set them equal to their median. The minimum possible number of operations needed to make all elements equal is... but in the problem statement, the actual question might require that the number of occurrences of any number does not exceed ceil(n/2), which is the condition checked here.\n\nTherefore, the code is correct in its logic, and the array is initialized properly.\n\nSo this code in C should work."
  }
}