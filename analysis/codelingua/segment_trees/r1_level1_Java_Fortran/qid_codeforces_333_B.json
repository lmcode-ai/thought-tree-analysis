{
  "qid": "codeforces_333_B",
  "tree": {
    "id": "root",
    "children": [
      {
        "id": "thought_0",
        "text": "Okay, I need to translate this Java code to Fortran.",
        "label": "language_mapping",
        "relation": "elaboration",
        "children": [
          {
            "id": "thought_1",
            "text": "Let me start by understanding what the Java code does.",
            "label": "code_analysis",
            "relation": "Continuation",
            "children": [
              {
                "id": "thought_2",
                "text": "The main part reads two integers n and m.",
                "label": "high_level_plan",
                "relation": "Continuation",
                "children": [
                  {
                    "id": "thought_3",
                    "text": "Then, it processes m pairs of integers (r and c), adding them to bannedRows and bannedCols sets, but only if they are between 2 and n-1 inclusive.",
                    "label": "code_analysis",
                    "relation": "Continuation",
                    "children": [
                      {
                        "id": "thought_4",
                        "text": "Then, the answer is calculated as (n-2)*2 minus the sizes of the banned sets.",
                        "label": "high_level_plan",
                        "relation": "Continuation",
                        "children": [
                          {
                            "id": "thought_5",
                            "text": "If n is odd, there's a check for the middle element not being in either set to subtract one more from the answer. So first, Fortran doesn't have built-in sets, so I need to represent the banned rows and columns using arrays or some structure.",
                            "label": "high_level_plan",
                            "relation": "Continuation",
                            "children": [
                              {
                                "id": "thought_6",
                                "text": "Maybe use logical arrays where the index represents the row or column, and the value is true if banned.",
                                "label": "high_level_plan",
                                "relation": "Continuation",
                                "children": [
                                  {
                                    "id": "thought_8",
                                    "text": "Since the possible values for r and c are from 1 to n, maybe we can create two logical arrays of size n.",
                                    "label": "high_level_plan",
                                    "relation": "Continuation",
                                    "children": [
                                      {
                                        "id": "thought_9",
                                        "text": "For each r read, if it's between 2 and n-1, mark it as banned in the row array. Same for columns.",
                                        "label": "high_level_plan",
                                        "relation": "Continuation",
                                        "children": [
                                          {
                                            "id": "thought_10",
                                            "text": "Then, the number of banned rows is the count of true values in the row array, same for columns.",
                                            "label": "high_level_plan",
                                            "relation": "Continuation",
                                            "children": [],
                                            "parent_id": "thought_9"
                                          }
                                        ],
                                        "parent_id": "thought_8"
                                      }
                                    ],
                                    "parent_id": "thought_6"
                                  }
                                ],
                                "parent_id": "thought_5"
                              },
                              {
                                "id": "thought_7",
                                "text": "The Java code uses a set for rows and columns.",
                                "label": "code_analysis",
                                "relation": "Continuation",
                                "children": [],
                                "parent_id": "thought_5"
                              }
                            ],
                            "parent_id": "thought_4"
                          },
                          {
                            "id": "thought_11",
                            "text": "Wait, but in the Java code, the initial answer is (n-2)*2, which I think represents the maximum possible cells on the edges (assuming all middle rows and columns are allowed). Then subtract the number of banned rows and columns. But wait, the rows and columns are the ones that are in the middle. So for example, rows 2 to n-1 are considered, and if they are banned, each contributes to subtracting 1 from the answer. Similarly for columns. So in Fortran, after reading all the m entries, we need to count how many rows in 2..n-1 are banned, and same for columns. So steps:\n\n1. Read n and m.\n\n2.",
                            "label": "code_analysis",
                            "relation": "Continuation",
                            "children": [
                              {
                                "id": "thought_12",
                                "text": "Initialize two logical arrays, bannedRows and bannedCols, of size up to n, initialized to .false. 3. For each of m entries, read r and c:\n\n   - if r is between 2 and n-1, set bannedRows(r) = .true.\n\n   - if c is between 2 and n-1, set bannedCols(c) = .true. Then compute the count of banned rows and cols by counting the number of .true. entries in bannedRows(2:n-1) and bannedCols(2:n-1).",
                                "label": "code_analysis",
                                "relation": "Continuation",
                                "children": [
                                  {
                                    "id": "thought_13",
                                    "text": "Wait, but the original code adds to the set only if r is >1 and <n. So the bannedRows set contains all the rows in 2..n-1 that are banned. So in Fortran, the count is the number of true elements in bannedRows from 2 to n-1. So for the counts:\n\ncount_rows = count(bannedRows(2:n-1))\ncount_cols = count(bannedCols(2:n-1))",
                                    "label": "code_analysis",
                                    "relation": "Continuation",
                                    "children": [
                                      {
                                        "id": "thought_14",
                                        "text": "The initial answer is (n-2)*2 - count_rows - count_cols.",
                                        "label": "empty",
                                        "relation": "Continuation",
                                        "children": [],
                                        "parent_id": "thought_13"
                                      },
                                      {
                                        "id": "thought_15",
                                        "text": "Then, if n is odd, check if the middle row (and column) is not banned. The middle is (n+1)/2.",
                                        "label": "code_analysis",
                                        "relation": "Continuation",
                                        "children": [
                                          {
                                            "id": "thought_16",
                                            "text": "For example, if n is 5, the middle is 3. So check if bannedRows(mid) is .false.",
                                            "label": "mental_execution",
                                            "relation": "Continuation",
                                            "children": [],
                                            "parent_id": "thought_15"
                                          },
                                          {
                                            "id": "thought_17",
                                            "text": "and bannedCols(mid) is .false.",
                                            "label": "code_analysis",
                                            "relation": "Continuation",
                                            "children": [
                                              {
                                                "id": "thought_18",
                                                "text": "If both are false, subtract 1 from answer. So putting this all together in Fortran. Now, handling input.",
                                                "label": "high_level_plan",
                                                "relation": "Continuation",
                                                "children": [
                                                  {
                                                    "id": "thought_20",
                                                    "text": "In Fortran, reading from standard input can be done with read(*,*) statements. But need to read m pairs of integers.",
                                                    "label": "high_level_plan",
                                                    "relation": "Continuation",
                                                    "children": [
                                                      {
                                                        "id": "thought_21",
                                                        "text": "For each of m loops, read r and c.\n\nBut in Fortran, when reading multiple values, sometimes the input is read line by line. So maybe read each line as a pair of integers.",
                                                        "label": "high_level_plan",
                                                        "relation": "Continuation",
                                                        "children": [
                                                          {
                                                            "id": "thought_22",
                                                            "text": "For example, in each iteration of m, read a line containing two integers. But how to handle this?",
                                                            "label": "high_level_plan",
                                                            "relation": "Continuation",
                                                            "children": [],
                                                            "parent_id": "thought_21"
                                                          },
                                                          {
                                                            "id": "thought_23",
                                                            "text": "The original code may read from a line with multiple entries. So the Java code uses a StringTokenizer, which splits on whitespace.",
                                                            "label": "code_analysis",
                                                            "relation": "Continuation",
                                                            "children": [
                                                              {
                                                                "id": "thought_24",
                                                                "text": "In Fortran, when you read using read(*,*) r, c, it will read two integers from the input, regardless of line breaks. So that should be okay. But need to make sure that the input is correctly read. So for m pairs, read r and c each time. So code outline:\n\nprogram codeforces_333_B\n  implicit none\n  integer :: n, m\n  integer :: i, r, c, answer, mid\n  logical, allocatable :: bannedRows(:), bannedCols(:)\n  integer :: count_rows, count_cols\n\n  ! Read n and m\n  read(*,*) n, m\n\n  allocate(bannedRows(n), bannedCols(n))\n  bannedRows = .false. bannedCols = .false. do i = 1, m\n    read(*,*) r, c\n    if (r > 1 .and.",
                                                                "label": "code_analysis",
                                                                "relation": "Continuation",
                                                                "children": [
                                                                  {
                                                                    "id": "thought_25",
                                                                    "text": "r < n) then\n      bannedRows(r) = .true. end if\n    if (c > 1 .and.",
                                                                    "label": "code_analysis",
                                                                    "relation": "Continuation",
                                                                    "children": [],
                                                                    "parent_id": "thought_24"
                                                                  },
                                                                  {
                                                                    "id": "thought_26",
                                                                    "text": "c < n) then\n      bannedCols(c) = .true. end if\n  end do\n\n  ! Calculate counts\n  if (n <= 2) then\n    count_rows = 0\n    count_cols = 0\n  else\n    count_rows = count(bannedRows(2:n-1))\n    count_cols = count(bannedCols(2:n-1))\n  end if\n\n  answer = (n-2)*2 - count_rows - count_cols\n\n  if (mod(n,2) /= 0) then\n    mid = (n + 1)/2\n    if (.not. bannedRows(mid) .and. .not. bannedCols(mid)) then\n      answer = answer - 1\n    end if\n  end if\n\n  print *, answer\n\n  deallocate(bannedRows, bannedCols)\n\nend program codeforces_333_B\n\nWait, but in the Java code, the initial answer is (n-2)*2. For example, when n is 4, (4-2)*2=4. Then subtract banned rows and cols. But in the case when n is 2, (2-2)*2=0.",
                                                                    "label": "code_analysis",
                                                                    "relation": "Continuation",
                                                                    "children": [
                                                                      {
                                                                        "id": "thought_27",
                                                                        "text": "Then, banned rows and cols would be zero, but since the initial answer is zero, the answer would be zero.",
                                                                        "label": "mental_execution",
                                                                        "relation": "Continuation",
                                                                        "children": [],
                                                                        "parent_id": "thought_26"
                                                                      },
                                                                      {
                                                                        "id": "thought_28",
                                                                        "text": "Which makes sense because for a 2x2 grid, there are no middle rows or columns. So the code should handle n=2 correctly. But in the count_rows calculation, if n <= 2, then 2:n-1 is an invalid slice. For example, if n=2, 2:n-1 is 2:1, which is empty. So the count would be zero. So maybe the code doesn't need the if (n <=2) check, because for n=2, 2:n-1 is an empty array, and count(bannedRows(2:1)) would return zero. So maybe the code can work without that check. Let me test.",
                                                                        "label": "code_analysis",
                                                                        "relation": "Continuation",
                                                                        "children": [
                                                                          {
                                                                            "id": "thought_29",
                                                                            "text": "In Fortran, when you have an array slice like 2:n-1 and n is 2, then 2:1 is an empty array.",
                                                                            "label": "language_mapping",
                                                                            "relation": "Continuation",
                                                                            "children": [],
                                                                            "parent_id": "thought_28"
                                                                          },
                                                                          {
                                                                            "id": "thought_30",
                                                                            "text": "The count of a empty array is zero. So the code can safely remove the if (n <=2) part. So the code can be simplified:\n\ncount_rows = count(bannedRows(2:n-1)) count_cols = count(bannedCols(2:n-1))",
                                                                            "label": "bug_fixing",
                                                                            "relation": "Continuation",
                                                                            "children": [
                                                                              {
                                                                                "id": "thought_31",
                                                                                "text": "Because if 2 > n-1, the slice is empty and count returns zero. So the code can remove the if condition. So revised code:\n\nprogram codeforces_333_B\n  implicit none\n  integer :: n, m\n  integer :: i, r, c, answer, mid\n  logical, allocatable :: bannedRows(:), bannedCols(:)\n  integer :: count_rows, count_cols\n\n  read(*,*) n, m\n\n  allocate(bannedRows(n), bannedCols(n))\n  bannedRows = .false. bannedCols = .false. do i = 1, m\n    read(*,*) r, c\n    if (r > 1 .and.",
                                                                                "label": "bug_fixing",
                                                                                "relation": "Continuation",
                                                                                "children": [],
                                                                                "parent_id": "thought_30"
                                                                              }
                                                                            ],
                                                                            "parent_id": "thought_28"
                                                                          }
                                                                        ],
                                                                        "parent_id": "thought_26"
                                                                      }
                                                                    ],
                                                                    "parent_id": "thought_24"
                                                                  },
                                                                  {
                                                                    "id": "thought_32",
                                                                    "text": "r < n) then\n      bannedRows(r) = .true. end if\n    if (c > 1 .and.",
                                                                    "label": "code_analysis",
                                                                    "relation": "Continuation",
                                                                    "children": [
                                                                      {
                                                                        "id": "thought_33",
                                                                        "text": "c < n) then\n      bannedCols(c) = .true. end if\n  end do\n\n  count_rows = count(bannedRows(2:n-1))\n  count_cols = count(bannedCols(2:n-1)) answer = (n-2)*2 - count_rows - count_cols\n\n  if (mod(n, 2) /= 0) then\n    mid = (n + 1) / 2\n    if (.not. bannedRows(mid) .and. .not. bannedCols(mid)) then\n      answer = answer - 1\n    end if\n  end if\n\n  print *, answer\n\n  deallocate(bannedRows, bannedCols)\n\nend program codeforces_333_B\n\nWait, but in Fortran, when you divide integers, (n+1)/2 for n odd would be correct. For example, n=5: (5+1)/2 = 3 in integer division. Yes. Now, testing some cases. Sample Input 1: Let's say n=3, m=0. Then answer is (3-2)*2=2. If n is odd (3 mod 2 =1), check mid=2. Since m=0, mid is not banned. So subtract 1. Answer is 1. Another case: n=4, m=0. Answer is (4-2)*2=4. n even, no adjustment. So answer 4. Another case: n=5, m=1, r=3, c=3. Then bannedRows(3)=.true., bannedCols(3)=.true. count_rows=1 (since 2:4 includes rows 2,3,4. bannedRows(3) is true, others false. So count is 1). count_cols=1. Answer is (5-2)*2 -1 -1=6-2=4. Then n is odd, mid=3.",
                                                                        "label": "mental_execution",
                                                                        "relation": "Continuation",
                                                                        "children": [
                                                                          {
                                                                            "id": "thought_34",
                                                                            "text": "bannedRows(3) is true, so no subtraction. So answer 4. Another case: n=5, m=0. answer = 3*2=6. Then check mid=3, not banned. So subtract 1, answer 5. So code seems to handle that. Now, possible issues: When n=1? The original Java code probably isn't handling that, but the problem constraints probably have n>=2. But in Fortran, if n=1, bannedRows is size 1, and 2:n-1 would be 2:0, which is empty. So counts are zero. Then (n-2)*2 is (1-2)*2= -2. But the problem likely ensures n>=2. So perhaps we can assume n >=2.",
                                                                            "label": "mental_execution",
                                                                            "relation": "Continuation",
                                                                            "children": [
                                                                              {
                                                                                "id": "thought_36",
                                                                                "text": "The code uses bannedRows(r) where r can be from 1 to n. So yes.",
                                                                                "label": "code_analysis",
                                                                                "relation": "Continuation",
                                                                                "children": [],
                                                                                "parent_id": "thought_34"
                                                                              }
                                                                            ],
                                                                            "parent_id": "thought_33"
                                                                          },
                                                                          {
                                                                            "id": "thought_35",
                                                                            "text": "Another thing: Fortran logical array indices.",
                                                                            "label": "code_analysis",
                                                                            "relation": "Continuation",
                                                                            "children": [],
                                                                            "parent_id": "thought_33"
                                                                          },
                                                                          {
                                                                            "id": "thought_41",
                                                                            "text": "I need to make sure to handle the mid check correctly.",
                                                                            "label": "high_level_plan",
                                                                            "relation": "Continuation",
                                                                            "children": [],
                                                                            "parent_id": "thought_33"
                                                                          },
                                                                          {
                                                                            "id": "thought_42",
                                                                            "text": "In Java, it checks if both the row and column mid are not present in bannedRows and bannedCols.",
                                                                            "label": "code_analysis",
                                                                            "relation": "Continuation",
                                                                            "children": [
                                                                              {
                                                                                "id": "thought_43",
                                                                                "text": "In Fortran, bannedRows(mid) is .false. if not banned. So the code checks .not.",
                                                                                "label": "code_analysis",
                                                                                "relation": "Continuation",
                                                                                "children": [
                                                                                  {
                                                                                    "id": "thought_44",
                                                                                    "text": "bannedRows(mid) and same for cols. Yes. So the translated code should be correct.",
                                                                                    "label": "code_analysis",
                                                                                    "relation": "Continuation",
                                                                                    "children": [],
                                                                                    "parent_id": "thought_43"
                                                                                  }
                                                                                ],
                                                                                "parent_id": "thought_42"
                                                                              }
                                                                            ],
                                                                            "parent_id": "thought_33"
                                                                          }
                                                                        ],
                                                                        "parent_id": "thought_32"
                                                                      }
                                                                    ],
                                                                    "parent_id": "thought_24"
                                                                  }
                                                                ],
                                                                "parent_id": "thought_23"
                                                              }
                                                            ],
                                                            "parent_id": "thought_21"
                                                          }
                                                        ],
                                                        "parent_id": "thought_20"
                                                      },
                                                      {
                                                        "id": "thought_37",
                                                        "text": "Now, the input part: for m pairs, read r and c.",
                                                        "label": "high_level_plan",
                                                        "relation": "Continuation",
                                                        "children": [
                                                          {
                                                            "id": "thought_38",
                                                            "text": "Each pair is read as two integers. So for m lines (if each line has one pair), or any format where the pairs are read correctly.",
                                                            "label": "code_analysis",
                                                            "relation": "Continuation",
                                                            "children": [
                                                              {
                                                                "id": "thought_39",
                                                                "text": "In Java, the FastReader uses a StringTokenizer, which splits the input into tokens, so it's possible that all the input is in one line.",
                                                                "label": "code_analysis",
                                                                "relation": "Continuation",
                                                                "children": [],
                                                                "parent_id": "thought_38"
                                                              },
                                                              {
                                                                "id": "thought_40",
                                                                "text": "In Fortran, the read(*,*) r, c will read the next two integers from input, regardless of line breaks. So that's correct. So this code should work.",
                                                                "label": "code_analysis",
                                                                "relation": "Continuation",
                                                                "children": [],
                                                                "parent_id": "thought_38"
                                                              }
                                                            ],
                                                            "parent_id": "thought_37"
                                                          }
                                                        ],
                                                        "parent_id": "thought_20"
                                                      }
                                                    ],
                                                    "parent_id": "thought_18"
                                                  }
                                                ],
                                                "parent_id": "thought_17"
                                              }
                                            ],
                                            "parent_id": "thought_15"
                                          }
                                        ],
                                        "parent_id": "thought_13"
                                      }
                                    ],
                                    "parent_id": "thought_12"
                                  }
                                ],
                                "parent_id": "thought_11"
                              },
                              {
                                "id": "thought_19",
                                "text": "The Java code uses a FastReader class which reads tokens.",
                                "label": "code_analysis",
                                "relation": "Continuation",
                                "children": [],
                                "parent_id": "thought_11"
                              }
                            ],
                            "parent_id": "thought_4"
                          }
                        ],
                        "parent_id": "thought_3"
                      }
                    ],
                    "parent_id": "thought_2"
                  }
                ],
                "parent_id": "thought_1"
              }
            ],
            "parent_id": "thought_0"
          }
        ],
        "parent_id": "root"
      }
    ],
    "metadata": {},
    "original_reasoning": "Okay, I need to translate this Java code to Fortran. Let me start by understanding what the Java code does. \n\nThe main part reads two integers n and m. Then, it processes m pairs of integers (r and c), adding them to bannedRows and bannedCols sets, but only if they are between 2 and n-1 inclusive. Then, the answer is calculated as (n-2)*2 minus the sizes of the banned sets. If n is odd, there's a check for the middle element not being in either set to subtract one more from the answer.\n\nSo first, Fortran doesn't have built-in sets, so I need to represent the banned rows and columns using arrays or some structure. Maybe use logical arrays where the index represents the row or column, and the value is true if banned.\n\nThe Java code uses a set for rows and columns. Since the possible values for r and c are from 1 to n, maybe we can create two logical arrays of size n. For each r read, if it's between 2 and n-1, mark it as banned in the row array. Same for columns.\n\nThen, the number of banned rows is the count of true values in the row array, same for columns. \n\nWait, but in the Java code, the initial answer is (n-2)*2, which I think represents the maximum possible cells on the edges (assuming all middle rows and columns are allowed). Then subtract the number of banned rows and columns. But wait, the rows and columns are the ones that are in the middle. So for example, rows 2 to n-1 are considered, and if they are banned, each contributes to subtracting 1 from the answer. Similarly for columns.\n\nSo in Fortran, after reading all the m entries, we need to count how many rows in 2..n-1 are banned, and same for columns.\n\nSo steps:\n\n1. Read n and m.\n\n2. Initialize two logical arrays, bannedRows and bannedCols, of size up to n, initialized to .false.\n\n3. For each of m entries, read r and c:\n\n   - if r is between 2 and n-1, set bannedRows(r) = .true.\n\n   - if c is between 2 and n-1, set bannedCols(c) = .true.\n\nThen compute the count of banned rows and cols by counting the number of .true. entries in bannedRows(2:n-1) and bannedCols(2:n-1).\n\nWait, but the original code adds to the set only if r is >1 and <n. So the bannedRows set contains all the rows in 2..n-1 that are banned. So in Fortran, the count is the number of true elements in bannedRows from 2 to n-1.\n\nSo for the counts:\n\ncount_rows = count(bannedRows(2:n-1))\ncount_cols = count(bannedCols(2:n-1))\n\nThe initial answer is (n-2)*2 - count_rows - count_cols.\n\nThen, if n is odd, check if the middle row (and column) is not banned. The middle is (n+1)/2. For example, if n is 5, the middle is 3. So check if bannedRows(mid) is .false. and bannedCols(mid) is .false. If both are false, subtract 1 from answer.\n\nSo putting this all together in Fortran.\n\nNow, handling input. The Java code uses a FastReader class which reads tokens. In Fortran, reading from standard input can be done with read(*,*) statements. But need to read m pairs of integers. For each of m loops, read r and c.\n\nBut in Fortran, when reading multiple values, sometimes the input is read line by line. So maybe read each line as a pair of integers. For example, in each iteration of m, read a line containing two integers.\n\nBut how to handle this? The original code may read from a line with multiple entries. So the Java code uses a StringTokenizer, which splits on whitespace. In Fortran, when you read using read(*,*) r, c, it will read two integers from the input, regardless of line breaks. So that should be okay.\n\nBut need to make sure that the input is correctly read. So for m pairs, read r and c each time.\n\nSo code outline:\n\nprogram codeforces_333_B\n  implicit none\n  integer :: n, m\n  integer :: i, r, c, answer, mid\n  logical, allocatable :: bannedRows(:), bannedCols(:)\n  integer :: count_rows, count_cols\n\n  ! Read n and m\n  read(*,*) n, m\n\n  allocate(bannedRows(n), bannedCols(n))\n  bannedRows = .false.\n  bannedCols = .false.\n\n  do i = 1, m\n    read(*,*) r, c\n    if (r > 1 .and. r < n) then\n      bannedRows(r) = .true.\n    end if\n    if (c > 1 .and. c < n) then\n      bannedCols(c) = .true.\n    end if\n  end do\n\n  ! Calculate counts\n  if (n <= 2) then\n    count_rows = 0\n    count_cols = 0\n  else\n    count_rows = count(bannedRows(2:n-1))\n    count_cols = count(bannedCols(2:n-1))\n  end if\n\n  answer = (n-2)*2 - count_rows - count_cols\n\n  if (mod(n,2) /= 0) then\n    mid = (n + 1)/2\n    if (.not. bannedRows(mid) .and. .not. bannedCols(mid)) then\n      answer = answer - 1\n    end if\n  end if\n\n  print *, answer\n\n  deallocate(bannedRows, bannedCols)\n\nend program codeforces_333_B\n\nWait, but in the Java code, the initial answer is (n-2)*2. For example, when n is 4, (4-2)*2=4. Then subtract banned rows and cols.\n\nBut in the case when n is 2, (2-2)*2=0. Then, banned rows and cols would be zero, but since the initial answer is zero, the answer would be zero. Which makes sense because for a 2x2 grid, there are no middle rows or columns. So the code should handle n=2 correctly.\n\nBut in the count_rows calculation, if n <= 2, then 2:n-1 is an invalid slice. For example, if n=2, 2:n-1 is 2:1, which is empty. So the count would be zero. So maybe the code doesn't need the if (n <=2) check, because for n=2, 2:n-1 is an empty array, and count(bannedRows(2:1)) would return zero. So maybe the code can work without that check. Let me test.\n\nIn Fortran, when you have an array slice like 2:n-1 and n is 2, then 2:1 is an empty array. The count of a empty array is zero. So the code can safely remove the if (n <=2) part.\n\nSo the code can be simplified:\n\ncount_rows = count(bannedRows(2:n-1))\ncount_cols = count(bannedCols(2:n-1))\n\nBecause if 2 > n-1, the slice is empty and count returns zero.\n\nSo the code can remove the if condition.\n\nSo revised code:\n\nprogram codeforces_333_B\n  implicit none\n  integer :: n, m\n  integer :: i, r, c, answer, mid\n  logical, allocatable :: bannedRows(:), bannedCols(:)\n  integer :: count_rows, count_cols\n\n  read(*,*) n, m\n\n  allocate(bannedRows(n), bannedCols(n))\n  bannedRows = .false.\n  bannedCols = .false.\n\n  do i = 1, m\n    read(*,*) r, c\n    if (r > 1 .and. r < n) then\n      bannedRows(r) = .true.\n    end if\n    if (c > 1 .and. c < n) then\n      bannedCols(c) = .true.\n    end if\n  end do\n\n  count_rows = count(bannedRows(2:n-1))\n  count_cols = count(bannedCols(2:n-1))\n\n  answer = (n-2)*2 - count_rows - count_cols\n\n  if (mod(n, 2) /= 0) then\n    mid = (n + 1) / 2\n    if (.not. bannedRows(mid) .and. .not. bannedCols(mid)) then\n      answer = answer - 1\n    end if\n  end if\n\n  print *, answer\n\n  deallocate(bannedRows, bannedCols)\n\nend program codeforces_333_B\n\nWait, but in Fortran, when you divide integers, (n+1)/2 for n odd would be correct. For example, n=5: (5+1)/2 = 3 in integer division. Yes.\n\nNow, testing some cases.\n\nSample Input 1: Let's say n=3, m=0. Then answer is (3-2)*2=2. If n is odd (3 mod 2 =1), check mid=2. Since m=0, mid is not banned. So subtract 1. Answer is 1.\n\nAnother case: n=4, m=0. Answer is (4-2)*2=4. n even, no adjustment. So answer 4.\n\nAnother case: n=5, m=1, r=3, c=3. Then bannedRows(3)=.true., bannedCols(3)=.true. count_rows=1 (since 2:4 includes rows 2,3,4. bannedRows(3) is true, others false. So count is 1). count_cols=1. Answer is (5-2)*2 -1 -1=6-2=4. Then n is odd, mid=3. bannedRows(3) is true, so no subtraction. So answer 4.\n\nAnother case: n=5, m=0. answer = 3*2=6. Then check mid=3, not banned. So subtract 1, answer 5.\n\nSo code seems to handle that.\n\nNow, possible issues: When n=1? The original Java code probably isn't handling that, but the problem constraints probably have n>=2. But in Fortran, if n=1, bannedRows is size 1, and 2:n-1 would be 2:0, which is empty. So counts are zero. Then (n-2)*2 is (1-2)*2= -2. But the problem likely ensures n>=2. So perhaps we can assume n >=2.\n\nAnother thing: Fortran logical array indices. The code uses bannedRows(r) where r can be from 1 to n. So yes.\n\nNow, the input part: for m pairs, read r and c. Each pair is read as two integers. So for m lines (if each line has one pair), or any format where the pairs are read correctly.\n\nIn Java, the FastReader uses a StringTokenizer, which splits the input into tokens, so it's possible that all the input is in one line. In Fortran, the read(*,*) r, c will read the next two integers from input, regardless of line breaks. So that's correct.\n\nSo this code should work.\n\nI need to make sure to handle the mid check correctly. In Java, it checks if both the row and column mid are not present in bannedRows and bannedCols. In Fortran, bannedRows(mid) is .false. if not banned. So the code checks .not. bannedRows(mid) and same for cols.\n\nYes.\n\nSo the translated code should be correct."
  }
}