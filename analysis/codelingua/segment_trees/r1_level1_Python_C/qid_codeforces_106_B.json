{
  "qid": "codeforces_106_B",
  "tree": {
    "id": "root",
    "children": [
      {
        "id": "thought_0",
        "text": "Okay, I need to translate this Python code into C. Let's start by understanding what the Python code does. The code reads an integer n, then reads n lines of four integers each (S, R, H, C). These are stored in a list called input_array. Then, it determines which entries are outdated.",
        "label": "code_analysis",
        "relation": "elaboration",
        "children": [
          {
            "id": "thought_1",
            "text": "An entry i is considered outdated if there's another entry j where all three of S, R, H of i are less than those of j. So for each i, check all j (including itself?), and if any j has all three values higher, then i is outdated. Wait, but j loops through all n elements, including i. But comparing i to j when i == j would check if S_i < S_j (which is S_i < S_i), which is false. So that's okay. So the code builds the outdated list by appending any i that has at least one j (could be any) where all three of S, R, H are higher.",
            "label": "mental_execution",
            "relation": "Continuation",
            "children": [
              {
                "id": "thought_2",
                "text": "Then, it converts this list to a set to remove duplicates. But since the input_array entries are unique?",
                "label": "mental_execution",
                "relation": "Continuation",
                "children": [
                  {
                    "id": "thought_3",
                    "text": "Well, the code appends input_array[i] to outdated if the condition is met, so if there are multiple j's that make i outdated, the same input_array[i] is added multiple times. Then converting to a set removes duplicates. So the outdated set contains all entries that are outdated. Then, the code finds the entry that is not in outdated and has the minimum cost.",
                    "label": "mental_execution",
                    "relation": "Continuation",
                    "children": [
                      {
                        "id": "thought_4",
                        "text": "If multiple entries have the same minimum cost, the one with the smallest index (i+1) is chosen because the first occurrence would be picked since it checks in order and updates only when cost is strictly less than current minimum. Now, translating to C. Let's think about data structures. The input_array in Python is a list of tuples. In C, we can represent each entry as a struct.",
                        "label": "high_level_plan",
                        "relation": "Continuation",
                        "children": [
                          {
                            "id": "thought_5",
                            "text": "Let's define a struct, maybe called Company, with four integers S, R, H, C, and perhaps also an index to keep track of the original input order (since the output is the 1-based index of the entry).",
                            "label": "high_level_plan",
                            "relation": "Continuation",
                            "children": [
                              {
                                "id": "thought_6",
                                "text": "Wait, but in the Python code, the index is determined by the order in the input. So in C, when we process the entries, we need to remember their original positions. So perhaps the struct should include an 'id' field that is set to i+1 (the 1-based index) when reading each entry. So first, read n. Then read n lines, storing S, R, H, C, and their original index (i+1).",
                                "label": "high_level_plan",
                                "relation": "Continuation",
                                "children": [
                                  {
                                    "id": "thought_7",
                                    "text": "Then, for each company, check if it's outdated by comparing against all other companies. But in C, we can't have a set of structs like in Python. So we need another way to track which companies are outdated.",
                                    "label": "high_level_plan",
                                    "relation": "Continuation",
                                    "children": [
                                      {
                                        "id": "thought_8",
                                        "text": "Maybe create a boolean array 'is_outdated' of size n, initialized to false. Then for each i from 0 to n-1, check for each j from 0 to n-1 if company i is outdated by company j. If any j makes company i outdated, mark is_outdated[i] as true.",
                                        "label": "high_level_plan",
                                        "relation": "Continuation",
                                        "children": [
                                          {
                                            "id": "thought_34",
                                            "text": "However, in the code, for each i, j runs from 0 to n-1. So for each i, even if there are multiple j's that satisfy the condition, once is_outdated[i] is set to true, it's already marked. So in C, the code is correct.",
                                            "label": "code_analysis",
                                            "relation": "Continuation",
                                            "children": [],
                                            "parent_id": "thought_8"
                                          }
                                        ],
                                        "parent_id": "thought_7"
                                      },
                                      {
                                        "id": "thought_33",
                                        "text": "Now, translating into C.\n\nAnother thing to note: in Python, the 'input_array' may have duplicate entries. But in the code, when converting to a set, duplicates are removed. But in C, when we loop through all i and j, and mark is_outdated[i] as true if any j makes the condition true, duplicates are handled automatically. Because even if two entries are same, but their j's are checked.",
                                        "label": "language_mapping",
                                        "relation": "Continuation",
                                        "children": [
                                          {
                                            "id": "thought_35",
                                            "text": "Another point: the Python code uses a set to remove duplicates. But in the Python code, the code appends input_array[i] to outdated if any j makes the condition true. So if the same company (same S, R, H, C) is present multiple times in input_array, but for each i, it's added multiple times to outdated. Then converting to a set would remove duplicates. But in C, the is_outdated array is per i (each company), so even if two companies are identical, each is checked against all j's. So in C, it's correct. Thus, the code should work.",
                                            "label": "code_analysis",
                                            "relation": "Continuation",
                                            "children": [],
                                            "parent_id": "thought_33"
                                          }
                                        ],
                                        "parent_id": "thought_7"
                                      }
                                    ],
                                    "parent_id": "thought_6"
                                  }
                                ],
                                "parent_id": "thought_5"
                              }
                            ],
                            "parent_id": "thought_4"
                          }
                        ],
                        "parent_id": "thought_3"
                      }
                    ],
                    "parent_id": "thought_2"
                  }
                ],
                "parent_id": "thought_1"
              },
              {
                "id": "thought_9",
                "text": "Wait, in the Python code, the outdated list is all entries that are outdated by any other entry. So for each i, if there exists any j (could be any, including i, but in that case S_i < S_j would be false) such that S_i <",
                "label": "mental_execution",
                "relation": "Continuation",
                "children": [
                  {
                    "id": "thought_10",
                    "text": "S_j and R_i < R_j and H_i < H_j, then i is added to the outdated list. So the check is for any j. So in C, for each i, loop through all j, and if any j meets the condition, mark i as outdated. So the approach in C would be:\n\n1. Read n.\n\n2. Read n companies, storing their S, R, H, C, and their original index (i+1). 3. For each company i, check for each company j whether S_i < S_j, R_i < R_j, H_i < H_j. If any j satisfies this, mark i as outdated. 4. Then, among the companies not marked as outdated, find the one with the smallest cost.",
                    "label": "high_level_plan",
                    "relation": "Continuation",
                    "children": [
                      {
                        "id": "thought_11",
                        "text": "If there's a tie, pick the one with the smallest original index. So steps in code:\n\n- Define a struct to hold S, R, H, C, and index.\n\n- Read n.\n\n- Allocate an array of structs, size n.\n\n-",
                        "label": "high_level_plan",
                        "relation": "Continuation",
                        "children": [],
                        "parent_id": "thought_10"
                      },
                      {
                        "id": "thought_12",
                        "text": "For each i from 0 to n-1, read S, R, H, C, and store index as i+1.\n\n- Create a boolean array is_outdated[n], initialized to false.\n\n- For each i in 0..n-1:\n\n   - For each j in 0..n-1:\n\n      - Check if (input[i].S < input[j].S) && (input[i].R < input[j].R) && (input[i].H < input[j].H)\n\n      - If this is true for any j, set is_outdated[i] = true, break the j loop.\n\n- Then, iterate through all companies, find those where is_outdated[i] is false.\n\n- Among these, find the one with the smallest C. If multiple have the same C, choose the one with the smallest index. So now, the steps in code: In C, handling input. Need to read n, then n lines of four integers. Possible code structure:\n\n#include <stdio.h>\n#include <stdbool.h>\n\ntypedef struct {\n    int S;\n    int R;\n    int H;\n    int C;\n    int index;\n} Company;\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    Company companies[n];\n    for (int i = 0; i < n; i++) { scanf(\"%d %d % d % d\", &companies[i].S, &companies[i].R, &companies[i].H, &companies[i].C); companies[i].index = i + 1;\n    }\n    \n    bool is_outdated[n];\n    for (int i = 0; i < n; i++) {\n        is_outdated[i] = false;\n    }\n    \n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (companies[i].S < companies[j].S && companies[i].R < companies[j].R && companies[i].H < companies[j].H) {\n                is_outdated[i] = true;\n                break; // No need to check other j's once found\n            }\n        }\n    }\n    \n    int min_cost = 1000000; // Higher than possible C's?\n    int result = -1;\n    for (int i = 0; i < n; i++) { if (!is_outdated[i]) {\n            if (companies[i].C < min_cost) {\n                min_cost = companies[i].C;\n                result = companies[i].index;\n            } else if (companies[i].C == min_cost && companies[i].index < result) {\n                // Wait, in case of same cost, choose the one with smaller index\n                // But since we process in order, the first occurrence would have the smallest index\n                // So maybe no need for this check. Because the first one encountered with the min cost is the smallest index.\n                // For example, if we process in order 0..n-1, then companies are checked in order.",
                        "label": "high_level_plan",
                        "relation": "Continuation",
                        "children": [
                          {
                            "id": "thought_13",
                            "text": "The first one with min_cost will have the smallest index, and any subsequent one with same cost will have higher index. So in that case, the code can be simplified by not checking this.\n                // Wait, no.",
                            "label": "mental_execution",
                            "relation": "Continuation",
                            "children": [
                              {
                                "id": "thought_14",
                                "text": "Suppose there's a company at index 3 (original index 4) with cost 50, and later a company at index 1 (original index 2) also with cost 50.",
                                "label": "mental_execution",
                                "relation": "Continuation",
                                "children": [],
                                "parent_id": "thought_13"
                              },
                              {
                                "id": "thought_15",
                                "text": "Then, when processing i in order 0,1,2,3, the first with cost 50 is index 0, then when index 1 is processed, it's C is 50, which is equal to min_cost (50), but its original index is 2, which is less than the previous result's index (say, 4). So we need to check if the current C is equal to min_cost and then compare the index.\n\n                // So the code should check for C < min_cost, which updates. Otherwise, if C == min_cost, check if the current index is smaller than the result's index.",
                                "label": "mental_execution",
                                "relation": "Continuation",
                                "children": [
                                  {
                                    "id": "thought_16",
                                    "text": "If yes, update.\n\n                // So in the Python code, the code picks the first occurrence with the minimum cost. Because it iterates in order, and once the minimum is found, only a lower cost will update.",
                                    "label": "code_analysis",
                                    "relation": "Continuation",
                                    "children": [
                                      {
                                        "id": "thought_17",
                                        "text": "If a same cost comes later, it's ignored. So the code in Python will pick the first occurrence (smallest index) in case of ties.\n\n                //",
                                        "label": "mental_execution",
                                        "relation": "Continuation",
                                        "children": [
                                          {
                                            "id": "thought_18",
                                            "text": "Therefore, in C, when iterating in order (i from 0 to n-1), we need to update the result only if the current C is less than min_cost.",
                                            "label": "mental_execution",
                                            "relation": "Continuation",
                                            "children": [
                                              {
                                                "id": "thought_19",
                                                "text": "If it's equal, but the index is smaller than the current result's index, we should update.\n\n                // Wait, the Python code does:\n\n                // for i in range(n):\n                //     current_item = input_array[i]\n                //     cost = current_item[3]\n                //     if (current_item not in outdated and cost < minimum_cost):\n                //         minimum_cost = current_item[3]\n                // input_number = i + 1\n\n                //",
                                                "label": "mental_execution",
                                                "relation": "Contrast",
                                                "children": [
                                                  {
                                                    "id": "thought_20",
                                                    "text": "So, if the current cost is equal to the minimum, it does not update. So in case of a tie in cost, the first occurrence (smallest index) is retained.\n\n                // So in C, we need to do the same. So in the loop, for each company not outdated, if its C is less than min_cost, update. If equal, ignore. So the first occurrence with the minimal cost is kept.\n\n                // Therefore, in C, the code should not handle the equal case. So the code in C is:\n\n                // if (companies[i].C < min_cost) { ... }\n\n                // So the code is correct as written, because we process the companies in order.",
                                                    "label": "code_analysis",
                                                    "relation": "Continuation",
                                                    "children": [
                                                      {
                                                        "id": "thought_21",
                                                        "text": "The first company not outdated with the minimal C (in order) is the one that will be selected.\n\n                // So the Python code's logic is that the first company (in order) with the minimal cost that's not outdated is selected, since it checks in order and only updates when cost is strictly lower.\n\n                // So in C, the code as written (checking if C < min_cost) will correctly find the first occurrence with the minimal cost.\n\n                // Wait, no. Suppose two companies have the same minimal cost. For example, company 0 has C=100, company 1 has C=100, and both are not outdated. Then, the code will first process company 0. Since 100 < initial min_cost (100000), set min_cost=100, result=1. Then process company 1: 100 is not less than min_cost (100), so no update. So the code picks company 0's index (1), which is correct as per the Python code.\n\n                // So the code is correct.\n\n                // Therefore, in the C code, no need to check for equality. So the code in the loop is:\n\n                if (companies[i].C < min_cost) { ... }\n\n            }\n        }\n    }\n    \n    printf(\"%d\\n\", result);\n    \n    return 0;\n} Wait, but in the Python code, the minimum_cost is initialized to 100000, which is higher than any possible C (since C is read as an integer).",
                                                        "label": "mental_execution",
                                                        "relation": "Continuation",
                                                        "children": [
                                                          {
                                                            "id": "thought_22",
                                                            "text": "The C code should initialize min_cost to a value larger than any possible C. In the problem statement, the input for C is not specified, but in the Python code, the minimum is initially 1e5. So in C, perhaps the same approach: initial min_cost is 1e5? But in the code above, I used 1000000.",
                                                            "label": "code_analysis",
                                                            "relation": "Continuation",
                                                            "children": [
                                                              {
                                                                "id": "thought_23",
                                                                "text": "Wait, the Python code uses 100000 as the initial value, which is 1e5. So in C, the code should initialize min_cost to 100001, assuming that C can be up to 1e5.",
                                                                "label": "code_analysis",
                                                                "relation": "Continuation",
                                                                "children": [
                                                                  {
                                                                    "id": "thought_24",
                                                                    "text": "Wait, but perhaps the input's C can be up to any value, but the initial min_cost must be higher than all possible C. But how?",
                                                                    "label": "mental_execution",
                                                                    "relation": "Continuation",
                                                                    "children": [],
                                                                    "parent_id": "thought_23"
                                                                  },
                                                                  {
                                                                    "id": "thought_25",
                                                                    "text": "Well, the problem statement may not specify, but perhaps the Python code uses 1e5, so perhaps in the C code, we can do the same. Let me check the Python code again:\n\nminimum_cost = 100000\n\nSo initial value is 100,000. So in C, we can set min_cost to 100001, but wait, no. Suppose a company has C=100000. Then the code would pick that. So initializing min_cost to 100000, but in the code, if a company's C is 100000, then 100000 < 100000 is false. So the code would not pick it. So that's a problem.",
                                                                    "label": "mental_execution",
                                                                    "relation": "Continuation",
                                                                    "children": [
                                                                      {
                                                                        "id": "thought_26",
                                                                        "text": "Wait, the Python code initializes minimum_cost to 100000, then if a company's C is 100000, which is not less than 100000, so it's not chosen. But that's incorrect. So perhaps the initial value in the Python code is a mistake. Or perhaps the problem's constraints say that C is at most 1e5-1. Looking at the Python code:\n\nThe code initializes minimum_cost = 100000.",
                                                                        "label": "code_analysis",
                                                                        "relation": "Continuation",
                                                                        "children": [],
                                                                        "parent_id": "thought_25"
                                                                      },
                                                                      {
                                                                        "id": "thought_27",
                                                                        "text": "Then, for each current_item not in outdated, if cost < minimum_cost, then update. So if all C's are 1e5 or higher, then input_number would remain 0 (as input_number is initialized to 0). But in the problem statement, perhaps there is at least one company not outdated, so the code is correct. But in any case, the C code should follow the same logic. So in the C code, min_cost is initialized to 100000. So:\n\nIn the C code, set min_cost to 100000. Then, for a company not outdated, if its C is less than 100000, then it's considered. But what if all companies not outdated have C >= 100000? Then result would remain -1. But according to the problem statement, perhaps there is at least one company not outdated. So the code would print 0 or some undefined behavior. Hmm.",
                                                                        "label": "mental_execution",
                                                                        "relation": "Continuation",
                                                                        "children": [
                                                                          {
                                                                            "id": "thought_28",
                                                                            "text": "Wait, in the Python code, input_number is initialized to 0, which is the case if no company meets the condition. So in the C code, perhaps result should be initialized to 0. Let's see: In the Python code:\n\nminimum_cost = 100000\ninput_number = 0\n\nSo if all companies are outdated, then input_number remains 0. Otherwise, if there are companies not outdated, but all have C >= 100000, then input_number remains 0. But according to the problem's input, perhaps there's at least one company not outdated and with C <= 1e5. But maybe the problem expects that there is at least one non-outdated company. But regardless, the code should follow the same logic. So in the C code, result is initialized to 0. So in the code:\n\nint min_cost = 100000;\nint result = 0; Then, for each company not outdated:\n\nif (companies[i].C < min_cost) {\n    min_cost = companies[i].C; result = companies[i].index;\n} So if all companies are outdated, result remains 0.",
                                                                            "label": "code_analysis",
                                                                            "relation": "Continuation",
                                                                            "children": [
                                                                              {
                                                                                "id": "thought_29",
                                                                                "text": "Otherwise, the minimal is found. But in the problem statement, what's the expected output when all companies are outdated? The code would print 0. But the problem may not have such test cases.",
                                                                                "label": "mental_execution",
                                                                                "relation": "Continuation",
                                                                                "children": [],
                                                                                "parent_id": "thought_28"
                                                                              },
                                                                              {
                                                                                "id": "thought_30",
                                                                                "text": "However, the code should handle it as per the Python code. So in the C code, initializing min_cost to 100000, and result to 0. Then, if any non-outdated company has C less than 1e5, it's considered. So in the code:\n\nYes.",
                                                                                "label": "code_analysis",
                                                                                "relation": "Continuation",
                                                                                "children": [
                                                                                  {
                                                                                    "id": "thought_31",
                                                                                    "text": "Now, considering that in C, the 'companies' array is 0-based, but each company's index is stored as i+1. Now, testing the code with sample input. Sample Input 1:\n\nLet's say n=3. Company 1: S=1, R=1, H=1, C=10\n\nCompany 2: S=2, R=2, H=2, C=5\n\nCompany 3: S=3, R=3, H=3, C=1\n\nThen, company 1 is outdated by companies 2 and 3. Company 2 is outdated by company 3. So non-outdated is company 3. Its C is 1. So output is 3. The code should process this correctly. Another test case where two companies are not outdated and have the same C.\n\nn=2\n\nCompany 1: S=1, R=1, H=1, C=5 (index 1)\n\nCompany 2: S=2, R=2, H=2, C=5 (index 2) Neither is outdated. Then the code should select the first one (index 1) because it's checked first, and 5 < 100000.",
                                                                                    "label": "mental_execution",
                                                                                    "relation": "Continuation",
                                                                                    "children": [
                                                                                      {
                                                                                        "id": "thought_32",
                                                                                        "text": "Then, the next company's C is 5, which is not less than current min_cost (5). So the result is 1. So the code would handle that correctly. Now, possible edge cases: n=1. If the only company is not outdated, then it's selected. If it's outdated (but since there's no other j, j=0, then the condition would check S_0 < S_0, which is false. So the company is not outdated. So the code would select it. Thus, the code seems correct.",
                                                                                        "label": "mental_execution",
                                                                                        "relation": "Continuation",
                                                                                        "children": [],
                                                                                        "parent_id": "thought_31"
                                                                                      }
                                                                                    ],
                                                                                    "parent_id": "thought_30"
                                                                                  }
                                                                                ],
                                                                                "parent_id": "thought_28"
                                                                              }
                                                                            ],
                                                                            "parent_id": "thought_27"
                                                                          }
                                                                        ],
                                                                        "parent_id": "thought_25"
                                                                      }
                                                                    ],
                                                                    "parent_id": "thought_23"
                                                                  }
                                                                ],
                                                                "parent_id": "thought_22"
                                                              }
                                                            ],
                                                            "parent_id": "thought_21"
                                                          }
                                                        ],
                                                        "parent_id": "thought_20"
                                                      }
                                                    ],
                                                    "parent_id": "thought_19"
                                                  }
                                                ],
                                                "parent_id": "thought_18"
                                              }
                                            ],
                                            "parent_id": "thought_17"
                                          }
                                        ],
                                        "parent_id": "thought_16"
                                      }
                                    ],
                                    "parent_id": "thought_15"
                                  }
                                ],
                                "parent_id": "thought_13"
                              }
                            ],
                            "parent_id": "thought_12"
                          }
                        ],
                        "parent_id": "thought_10"
                      }
                    ],
                    "parent_id": "thought_9"
                  }
                ],
                "parent_id": "thought_1"
              }
            ],
            "parent_id": "thought_0"
          }
        ],
        "parent_id": "root"
      }
    ],
    "metadata": {},
    "original_reasoning": "Okay, I need to translate this Python code into C. Let's start by understanding what the Python code does. \n\nThe code reads an integer n, then reads n lines of four integers each (S, R, H, C). These are stored in a list called input_array. Then, it determines which entries are outdated. An entry i is considered outdated if there's another entry j where all three of S, R, H of i are less than those of j. So for each i, check all j (including itself?), and if any j has all three values higher, then i is outdated. Wait, but j loops through all n elements, including i. But comparing i to j when i == j would check if S_i < S_j (which is S_i < S_i), which is false. So that's okay. So the code builds the outdated list by appending any i that has at least one j (could be any) where all three of S, R, H are higher. Then, it converts this list to a set to remove duplicates. But since the input_array entries are unique? Well, the code appends input_array[i] to outdated if the condition is met, so if there are multiple j's that make i outdated, the same input_array[i] is added multiple times. Then converting to a set removes duplicates. So the outdated set contains all entries that are outdated.\n\nThen, the code finds the entry that is not in outdated and has the minimum cost. If multiple entries have the same minimum cost, the one with the smallest index (i+1) is chosen because the first occurrence would be picked since it checks in order and updates only when cost is strictly less than current minimum.\n\nNow, translating to C. Let's think about data structures. The input_array in Python is a list of tuples. In C, we can represent each entry as a struct. Let's define a struct, maybe called Company, with four integers S, R, H, C, and perhaps also an index to keep track of the original input order (since the output is the 1-based index of the entry). Wait, but in the Python code, the index is determined by the order in the input. So in C, when we process the entries, we need to remember their original positions. So perhaps the struct should include an 'id' field that is set to i+1 (the 1-based index) when reading each entry.\n\nSo first, read n. Then read n lines, storing S, R, H, C, and their original index (i+1). Then, for each company, check if it's outdated by comparing against all other companies.\n\nBut in C, we can't have a set of structs like in Python. So we need another way to track which companies are outdated. Maybe create a boolean array 'is_outdated' of size n, initialized to false. Then for each i from 0 to n-1, check for each j from 0 to n-1 if company i is outdated by company j. If any j makes company i outdated, mark is_outdated[i] as true.\n\nWait, in the Python code, the outdated list is all entries that are outdated by any other entry. So for each i, if there exists any j (could be any, including i, but in that case S_i < S_j would be false) such that S_i < S_j and R_i < R_j and H_i < H_j, then i is added to the outdated list. So the check is for any j. So in C, for each i, loop through all j, and if any j meets the condition, mark i as outdated.\n\nSo the approach in C would be:\n\n1. Read n.\n\n2. Read n companies, storing their S, R, H, C, and their original index (i+1).\n\n3. For each company i, check for each company j whether S_i < S_j, R_i < R_j, H_i < H_j. If any j satisfies this, mark i as outdated.\n\n4. Then, among the companies not marked as outdated, find the one with the smallest cost. If there's a tie, pick the one with the smallest original index.\n\nSo steps in code:\n\n- Define a struct to hold S, R, H, C, and index.\n\n- Read n.\n\n- Allocate an array of structs, size n.\n\n- For each i from 0 to n-1, read S, R, H, C, and store index as i+1.\n\n- Create a boolean array is_outdated[n], initialized to false.\n\n- For each i in 0..n-1:\n\n   - For each j in 0..n-1:\n\n      - Check if (input[i].S < input[j].S) && (input[i].R < input[j].R) && (input[i].H < input[j].H)\n\n      - If this is true for any j, set is_outdated[i] = true, break the j loop.\n\n- Then, iterate through all companies, find those where is_outdated[i] is false.\n\n- Among these, find the one with the smallest C. If multiple have the same C, choose the one with the smallest index.\n\nSo now, the steps in code:\n\nIn C, handling input. Need to read n, then n lines of four integers.\n\nPossible code structure:\n\n#include <stdio.h>\n#include <stdbool.h>\n\ntypedef struct {\n    int S;\n    int R;\n    int H;\n    int C;\n    int index;\n} Company;\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    Company companies[n];\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d %d %d\", &companies[i].S, &companies[i].R, &companies[i].H, &companies[i].C);\n        companies[i].index = i + 1;\n    }\n    \n    bool is_outdated[n];\n    for (int i = 0; i < n; i++) {\n        is_outdated[i] = false;\n    }\n    \n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (companies[i].S < companies[j].S && companies[i].R < companies[j].R && companies[i].H < companies[j].H) {\n                is_outdated[i] = true;\n                break; // No need to check other j's once found\n            }\n        }\n    }\n    \n    int min_cost = 1000000; // Higher than possible C's?\n    int result = -1;\n    for (int i = 0; i < n; i++) {\n        if (!is_outdated[i]) {\n            if (companies[i].C < min_cost) {\n                min_cost = companies[i].C;\n                result = companies[i].index;\n            } else if (companies[i].C == min_cost && companies[i].index < result) {\n                // Wait, in case of same cost, choose the one with smaller index\n                // But since we process in order, the first occurrence would have the smallest index\n                // So maybe no need for this check. Because the first one encountered with the min cost is the smallest index.\n                // For example, if we process in order 0..n-1, then companies are checked in order. The first one with min_cost will have the smallest index, and any subsequent one with same cost will have higher index. So in that case, the code can be simplified by not checking this.\n                // Wait, no. Suppose there's a company at index 3 (original index 4) with cost 50, and later a company at index 1 (original index 2) also with cost 50. Then, when processing i in order 0,1,2,3, the first with cost 50 is index 0, then when index 1 is processed, it's C is 50, which is equal to min_cost (50), but its original index is 2, which is less than the previous result's index (say, 4). So we need to check if the current C is equal to min_cost and then compare the index.\n\n                // So the code should check for C < min_cost, which updates. Otherwise, if C == min_cost, check if the current index is smaller than the result's index. If yes, update.\n\n                // So in the Python code, the code picks the first occurrence with the minimum cost. Because it iterates in order, and once the minimum is found, only a lower cost will update. If a same cost comes later, it's ignored. So the code in Python will pick the first occurrence (smallest index) in case of ties.\n\n                // Therefore, in C, when iterating in order (i from 0 to n-1), we need to update the result only if the current C is less than min_cost. If it's equal, but the index is smaller than the current result's index, we should update.\n\n                // Wait, the Python code does:\n\n                // for i in range(n):\n                //     current_item = input_array[i]\n                //     cost = current_item[3]\n                //     if (current_item not in outdated and cost < minimum_cost):\n                //         minimum_cost = current_item[3]\n                //         input_number = i + 1\n\n                // So, if the current cost is equal to the minimum, it does not update. So in case of a tie in cost, the first occurrence (smallest index) is retained.\n\n                // So in C, we need to do the same. So in the loop, for each company not outdated, if its C is less than min_cost, update. If equal, ignore. So the first occurrence with the minimal cost is kept.\n\n                // Therefore, in C, the code should not handle the equal case. So the code in C is:\n\n                // if (companies[i].C < min_cost) { ... }\n\n                // So the code is correct as written, because we process the companies in order. The first company not outdated with the minimal C (in order) is the one that will be selected.\n\n                // So the Python code's logic is that the first company (in order) with the minimal cost that's not outdated is selected, since it checks in order and only updates when cost is strictly lower.\n\n                // So in C, the code as written (checking if C < min_cost) will correctly find the first occurrence with the minimal cost.\n\n                // Wait, no. Suppose two companies have the same minimal cost. For example, company 0 has C=100, company 1 has C=100, and both are not outdated. Then, the code will first process company 0. Since 100 < initial min_cost (100000), set min_cost=100, result=1. Then process company 1: 100 is not less than min_cost (100), so no update. So the code picks company 0's index (1), which is correct as per the Python code.\n\n                // So the code is correct.\n\n                // Therefore, in the C code, no need to check for equality. So the code in the loop is:\n\n                if (companies[i].C < min_cost) { ... }\n\n            }\n        }\n    }\n    \n    printf(\"%d\\n\", result);\n    \n    return 0;\n}\n\nWait, but in the Python code, the minimum_cost is initialized to 100000, which is higher than any possible C (since C is read as an integer). The C code should initialize min_cost to a value larger than any possible C. In the problem statement, the input for C is not specified, but in the Python code, the minimum is initially 1e5. So in C, perhaps the same approach: initial min_cost is 1e5? But in the code above, I used 1000000. Wait, the Python code uses 100000 as the initial value, which is 1e5. So in C, the code should initialize min_cost to 100001, assuming that C can be up to 1e5. Wait, but perhaps the input's C can be up to any value, but the initial min_cost must be higher than all possible C. But how? Well, the problem statement may not specify, but perhaps the Python code uses 1e5, so perhaps in the C code, we can do the same. Let me check the Python code again:\n\nminimum_cost = 100000\n\nSo initial value is 100,000. So in C, we can set min_cost to 100001, but wait, no. Suppose a company has C=100000. Then the code would pick that. So initializing min_cost to 100000, but in the code, if a company's C is 100000, then 100000 < 100000 is false. So the code would not pick it. So that's a problem. Wait, the Python code initializes minimum_cost to 100000, then if a company's C is 100000, which is not less than 100000, so it's not chosen. But that's incorrect. So perhaps the initial value in the Python code is a mistake. Or perhaps the problem's constraints say that C is at most 1e5-1.\n\nLooking at the Python code:\n\nThe code initializes minimum_cost = 100000. Then, for each current_item not in outdated, if cost < minimum_cost, then update. So if all C's are 1e5 or higher, then input_number would remain 0 (as input_number is initialized to 0). But in the problem statement, perhaps there is at least one company not outdated, so the code is correct.\n\nBut in any case, the C code should follow the same logic. So in the C code, min_cost is initialized to 100000. So:\n\nIn the C code, set min_cost to 100000. Then, for a company not outdated, if its C is less than 100000, then it's considered. But what if all companies not outdated have C >= 100000? Then result would remain -1. But according to the problem statement, perhaps there is at least one company not outdated. So the code would print 0 or some undefined behavior. Hmm. Wait, in the Python code, input_number is initialized to 0, which is the case if no company meets the condition. So in the C code, perhaps result should be initialized to 0. Let's see:\n\nIn the Python code:\n\nminimum_cost = 100000\ninput_number = 0\n\nSo if all companies are outdated, then input_number remains 0. Otherwise, if there are companies not outdated, but all have C >= 100000, then input_number remains 0. But according to the problem's input, perhaps there's at least one company not outdated and with C <= 1e5. But maybe the problem expects that there is at least one non-outdated company. But regardless, the code should follow the same logic.\n\nSo in the C code, result is initialized to 0. So in the code:\n\nint min_cost = 100000;\nint result = 0;\n\nThen, for each company not outdated:\n\nif (companies[i].C < min_cost) {\n    min_cost = companies[i].C;\n    result = companies[i].index;\n}\n\nSo if all companies are outdated, result remains 0. Otherwise, the minimal is found.\n\nBut in the problem statement, what's the expected output when all companies are outdated? The code would print 0. But the problem may not have such test cases. However, the code should handle it as per the Python code.\n\nSo in the C code, initializing min_cost to 100000, and result to 0. Then, if any non-outdated company has C less than 1e5, it's considered. So in the code:\n\nYes.\n\nNow, considering that in C, the 'companies' array is 0-based, but each company's index is stored as i+1.\n\nNow, testing the code with sample input.\n\nSample Input 1:\n\nLet's say n=3.\n\nCompany 1: S=1, R=1, H=1, C=10\n\nCompany 2: S=2, R=2, H=2, C=5\n\nCompany 3: S=3, R=3, H=3, C=1\n\nThen, company 1 is outdated by companies 2 and 3. Company 2 is outdated by company 3. So non-outdated is company 3. Its C is 1. So output is 3.\n\nThe code should process this correctly.\n\nAnother test case where two companies are not outdated and have the same C.\n\nn=2\n\nCompany 1: S=1, R=1, H=1, C=5 (index 1)\n\nCompany 2: S=2, R=2, H=2, C=5 (index 2)\n\nNeither is outdated. Then the code should select the first one (index 1) because it's checked first, and 5 < 100000. Then, the next company's C is 5, which is not less than current min_cost (5). So the result is 1.\n\nSo the code would handle that correctly.\n\nNow, possible edge cases: n=1. If the only company is not outdated, then it's selected. If it's outdated (but since there's no other j, j=0, then the condition would check S_0 < S_0, which is false. So the company is not outdated. So the code would select it.\n\nThus, the code seems correct.\n\nNow, translating into C.\n\nAnother thing to note: in Python, the 'input_array' may have duplicate entries. But in the code, when converting to a set, duplicates are removed. But in C, when we loop through all i and j, and mark is_outdated[i] as true if any j makes the condition true, duplicates are handled automatically. Because even if two entries are same, but their j's are checked. However, in the code, for each i, j runs from 0 to n-1. So for each i, even if there are multiple j's that satisfy the condition, once is_outdated[i] is set to true, it's already marked.\n\nSo in C, the code is correct.\n\nAnother point: the Python code uses a set to remove duplicates. But in the Python code, the code appends input_array[i] to outdated if any j makes the condition true. So if the same company (same S, R, H, C) is present multiple times in input_array, but for each i, it's added multiple times to outdated. Then converting to a set would remove duplicates. But in C, the is_outdated array is per i (each company), so even if two companies are identical, each is checked against all j's. So in C, it's correct.\n\nThus, the code should work."
  }
}