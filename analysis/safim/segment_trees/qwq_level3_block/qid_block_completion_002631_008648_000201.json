{
  "qid": "block_completion_002631_008648_000201",
  "tree": {
    "id": "root",
    "children": [
      {
        "id": "thought_0",
        "text": "<think>\nOkay, let's tackle these three programs one by one. Starting with program1.py. The problem is to find the special array and the number of operation2 uses. Looking at the code provided for program1, the solve function reads n and m, then loops over each array. The inner loop is over the elements of each array, but the code there is missing. The variables current and total are initialized but not used. The code then updates mx and mn based on total. The output is mn[1]+1 and mx[0]-mn[0]. Hmm, the key here is to figure out what the 'total' variable represents.",
        "label": "code_analysis",
        "relation": "Continuation",
        "children": [
          {
            "id": "thought_1",
            "text": "Since the problem involves operations that affect the arrays, maybe each array's contribution to some invariant can be tracked.",
            "label": "high_level_plan",
            "relation": "Continuation",
            "children": [
              {
                "id": "thought_2",
                "text": "The operations for non-special arrays (operation1) and the special one (operation2) must affect the arrays in a way that allows us to find which array is special. Let me think about the operations. For operation1 (non-special), when you do it on array c_t (non-special), you subtract 1 from positions i and j (2<=i<j<=m-1), and add 1 to i-1 and j+1. The net change for the array's elements is that the total sum remains the same because -1-1 +1+1 =0. For operation2 (special array), the operation subtracts 1 from i and j (2<=i<j<=m-2), adds 1 to i-1 and j+2. The total sum here is also 0. So the sum of all elements in each array c_i is the same as the original array b. Therefore, the sum can't help us here.",
                "label": "code_analysis",
                "relation": "Continuation",
                "children": [
                  {
                    "id": "thought_3",
                    "text": "Wait, but the problem requires us to find the special array. So there must be some other invariant or difference between the arrays. Let me think of the effect of the operations on some other property. Maybe the differences between certain elements? Alternatively, perhaps considering the differences between the arrays. Since all arrays start as copies of b, and each is modified by their own operations. The special array uses operation2, others use operation1. Wait, the problem states that for non-special arrays, they use operation1 at least once. The special uses operation2 at least once. The key is to find which array's modifications can only be done via operation2, and the others via operation1. Alternatively, perhaps the difference between the arrays can be analyzed. Let me think of the effect of each operation on some linear combination of the array elements. Let me think of the effect of each operation on the array's elements. For operation1 on a non-special array (c_t where t\u2260k):\n\nThe operation affects positions i and j (between 2 and m-1). The changes are:\n\nc_t[i] -=1, c_t[j] -=1\n\nc_t[i-1] +=1, c_t[j+1] +=1 \n\nThe net effect on the array's elements is that the sum remains the same. But perhaps looking at the differences between adjacent elements. Let's see:\n\nLet me consider the differences between consecutive elements. Let\u2019s denote d[i] = c[i] - c[i-1]. Wait, maybe looking at the second differences? Or some other invariant. Alternatively, perhaps the sum of certain terms. Let me think of the sum over all elements multiplied by their position. Alternatively, maybe the parity or some other invariant. Alternatively, let's think of the effect of each operation on the array's elements. Suppose we consider the sum of all elements except the first and last.",
                    "label": "mental_execution",
                    "relation": "Continuation",
                    "children": [
                      {
                        "id": "thought_4",
                        "text": "Wait, for operation1: subtract 2 from positions i and j (each is subtracted 1, so total subtract 2), and add 2 to positions i-1 and j+1. So the total sum of the array remains the same. Same for operation2. Hmm, maybe looking at the sum of elements in certain positions. Alternatively, perhaps the key is to find for each array, the possible number of operations applied.",
                        "label": "mental_execution",
                        "relation": "Continuation",
                        "children": [
                          {
                            "id": "thought_5",
                            "text": "Wait, the problem requires that the special array uses operation2 at least once, and others use operation1 at least once.",
                            "label": "code_analysis",
                            "relation": "Rephrase",
                            "children": [],
                            "parent_id": "thought_4"
                          }
                        ],
                        "parent_id": "thought_3"
                      },
                      {
                        "id": "thought_6",
                        "text": "The problem says that the input is generated by starting with b, then for each non-special array, they perform operation1 at least once, and the special one uses operation2 at least once. The goal is to find which array is the special one. Let me think of the effect of the operations on some invariant. Suppose we consider the sum of the array elements multiplied by their indices.",
                        "label": "high_level_plan",
                        "relation": "Continuation",
                        "children": [
                          {
                            "id": "thought_7",
                            "text": "Wait, perhaps the key is to find for each array, the possible \"signature\" that can only be achieved via operation1 or operation2. Alternatively, let's think of the effect of each operation on the array's elements. Let me consider the effect of operation1 on the array.",
                            "label": "high_level_plan",
                            "relation": "Continuation",
                            "children": [
                              {
                                "id": "thought_8",
                                "text": "Let's see:\n\nSuppose we have an array element at position i and j. \n\nThe operation1 subtracts 1 from c[i] and c[j], adds 1 to c[i-1] and c[j+1]. The net effect on the array is that the difference between c[i] and c[i-1] increases by 2 (since c[i] is decreased by 1, c[i-1] increased by 1 \u2192 their difference (c[i] - c[i-1]) becomes (c[i]-1) - (c[i-1]+1) = (c[i] - c[i-1]) -2. Wait, no, the difference between c[i] and c[i-1] is (c[i] - (c[i-1] +1)) = (original difference) -1 -1? Wait, maybe I should think in terms of the differences between adjacent elements. Let me define for each array, the differences between consecutive elements. Let\u2019s denote for array c, the differences as d_1 = c[1] - c[0], d_2 = c[2] - c[1], ..., d_{m-1} = c[m-1] - c[m-2]. Then, the total differences sum to c[m-1] - c[0]. Now, let's see how operation1 affects these differences. Suppose in operation1, we choose i and j (positions 2 <=i < j <= m-1). The operation affects positions i and j (indices starting at 1?), or maybe the array is 0-based? The problem says \"array of length m\", so perhaps 1-based.",
                                "label": "mental_execution",
                                "relation": "Continuation",
                                "children": [
                                  {
                                    "id": "thought_9",
                                    "text": "Wait, the problem says \"c_t[i] and c_t[j]\" where 2 \u2264 i < j \u2264 m-1 for operation1. So the indices are 1-based. So for operation1 on positions i and j (1-based indices between 2 and m-1): The changes are:\n\nc[i] -=1 \u2192 so the difference between c[i] and c[i-1] (d_i) becomes (c[i] -1) - c[i-1] \u2192 d_i -1. Similarly, the difference between c[i+1] and c[i] (d_{i+1}) would be (c[i+1] - (c[i] -1)) \u2192 d_{i+1} +1. Wait, perhaps it's better to track how each operation affects the differences. Alternatively, let's see how the operation affects the differences between consecutive elements. Let me think of the differences array D where D[p] = c[p] - c[p-1] for p from 1 to m-1 (assuming 1-based array).",
                                    "label": "mental_execution",
                                    "relation": "Continuation",
                                    "children": [
                                      {
                                        "id": "thought_10",
                                        "text": "Operation1 on i and j (positions in the array, so indices 1-based):\n\nThe operation affects positions i and j (elements c[i] and c[j]). The changes are:\n\nc[i] -=1 \u2192 so D[i] (which is c[i] - c[i-1]) becomes (c[i]-1) - c[i-1] \u2192 D[i] -1. Similarly, D[i+1] (c[i+1] - c[i]) becomes (c[i+1] - (c[i]-1)) \u2192 D[i+1] +1. Wait, but the operation also affects c[j], so similarly for j:\n\nc[j] -=1 \u2192 D[j] (c[j] - c[j-1]) becomes (c[j]-1) - c[j-1] \u2192 D[j] -1. And D[j+1] (c[j+1] - c[j]) becomes (c[j+1] - (c[j]-1)) \u2192 D[j+1] +1. Additionally, the operation adds 1 to c[i-1] and c[j+1].",
                                        "label": "code_analysis",
                                        "relation": "Continuation",
                                        "children": [
                                          {
                                            "id": "thought_11",
                                            "text": "Wait, the operation adds 1 to c[i-1] and c[j+1]. So for c[i-1], which is at position i-1, the difference D[i-1] (c[i-1] - c[i-2]) becomes (c[i-1]+1) - c[i-2] \u2192 D[i-1] +1.",
                                            "label": "mental_execution",
                                            "relation": "Continuation",
                                            "children": [],
                                            "parent_id": "thought_10"
                                          },
                                          {
                                            "id": "thought_12",
                                            "text": "Similarly, D[i] (which is c[i] - c[i-1] after the change) would be (c[i] -1) - (c[i-1]+1) \u2192 (original c[i] - c[i-1]) -2 \u2192 D[i] -2. Wait, I think I need to re-calculate this properly. Let me re-express the operation step by step. Original values:\n\nc[i-1], c[i], c[j], c[j+1]\n\nAfter operation1:\n\nc[i-1] +=1 \u2192 new value is c[i-1] +1\n\nc[i] -=1 \u2192 new value is c[i] -1\n\nc[j] -=1 \u2192 new value is c[j] -1\n\nc[j+1] +=1 \u2192 new value is c[j+1] +1\n\nThe other elements remain the same.",
                                            "label": "mental_execution",
                                            "relation": "Continuation",
                                            "children": [
                                              {
                                                "id": "thought_13",
                                                "text": "Now, the differences D for the positions around i and j:\n\nFor D[i-1] (difference between i-1 and i-2):\n\nWait, D[i-1] is the difference between position i-1 and i-2. But the change in c[i-1] affects D[i-1] and D[i]. Wait, D[i-1] = c[i-1] - c[i-2]. After adding 1 to c[i-1], D[i-1] becomes (c[i-1]+1) - c[i-2] \u2192 D[i-1] +1. D[i] = c[i] - c[i-1]. After the changes, it's (c[i]-1) - (c[i-1]+1) \u2192 (c[i] - c[i-1]) -2 \u2192 D[i] -2. Then, D[i+1] = c[i+1] - c[i]. The c[i] is now c[i]-1, so D[i+1] becomes (c[i+1] - (c[i]-1)) \u2192 D[i+1] +1. Similarly for the j part:\n\nD[j] = c[j] - c[j-1]. After subtracting 1 from c[j], it becomes (c[j]-1) - c[j-1] \u2192 D[j] -1. \n\nD[j+1] = c[j+1] +1 - (c[j] -1) \u2192 (original c[j+1] - c[j]) + (1 +1) \u2192 D[j+1] +2. Wait, no. Let's see:\n\nOriginal D[j] is c[j] - c[j-1].",
                                                "label": "mental_execution",
                                                "relation": "Continuation",
                                                "children": [
                                                  {
                                                    "id": "thought_14",
                                                    "text": "After subtracting 1 from c[j], D[j] becomes (c[j]-1) - c[j-1] \u2192 D[j] -1. \n\nD[j+1] is c[j+1] (original) +1 (from the operation) minus (c[j] -1) \u2192 (c[j+1] +1) - (c[j] -1) \u2192 (c[j+1] - c[j]) +2 \u2192 D[j+1] +2. So the operation1 affects the differences as follows:\n\n- D[i-1] increases by 1.\n\n- D[i] decreases by 2.\n\n- D[i+1] increases by 1.\n\n- D[j] decreases by 1.\n\n- D[j+1] increases by 2. Wait, but this is getting complicated. Maybe there's a better way.",
                                                    "label": "mental_execution",
                                                    "relation": "Continuation",
                                                    "children": [
                                                      {
                                                        "id": "thought_15",
                                                        "text": "Alternatively, perhaps the key is to find for each array, the sum of certain terms that can only be altered by one of the operations. Alternatively, let's think of the effect of the operations on the array's elements. Suppose we consider the sum of all elements except the first and last. Wait, for operation1, the total sum remains the same. Hmm, perhaps the key is to look at the sum of the array's elements multiplied by their indices. Alternatively, maybe the parity of some value. Alternatively, let's think of the problem in terms of the original array b. Each array c_i is generated from b by applying some operations. The special array c_k is modified using operation2, others with operation1. The problem requires us to find which array is the special one.",
                                                        "label": "high_level_plan",
                                                        "relation": "Contrast",
                                                        "children": [
                                                          {
                                                            "id": "thought_16",
                                                            "text": "The key idea might be that the special array's modifications can be expressed in terms of operation2, which has a different effect than operation1. Let me think of the effect of each operation on some invariant. Suppose we consider the sum over all elements multiplied by their position indices. Let's denote S = sum_{i=1 to m} (i * c_i). Wait, but the problem's operations might affect this sum. Alternatively, perhaps the difference between the first and last elements. Wait, let's think of the effect of each operation on the first and last elements. Operation1 adds 1 to c[i-1] and c[j+1]. So for the first element (position 1), if i-1 is 1 (i=2), then the first element increases by 1. Similarly, the last element (position m) can be affected if j+1 is m (j = m-1). But operation1 can only be applied when i < j <= m-1. So j can be up to m-1, so j+1 can be m. So for operation1, the first element can be increased, and the last can be increased. Operation2, on the other hand, for the special array, uses operation2. Let's see what that does. Operation2 on positions i and j (2 \u2264i < j \u2264 m-2). The operation subtracts 1 from c[i] and c[j], adds 1 to c[i-1] and c[j+2]. So the first element (position 1) can be increased if i-1 is 1 (i=2). The last element (position m) can be affected if j+2 is m \u2192 j = m-2. So for operation2, the first element can be increased, and the last element can be increased (if j is m-2). Hmm, but how does this help us? Alternatively, perhaps the key is to look at the difference between the first and last elements. Wait, let's see:\n\nFor operation1, the first element (position 1) can be increased by 1 (if i=2, then c[1] +=1). The last element (position m) can be increased by 1 (if j = m-1, then c[m] +=1). For operation2, the first element can be increased (if i=2, then c[1] +=1). The last element can be increased if j = m-2 \u2192 then j+2 = m \u2192 so c[m] +=1. So both operations can affect the first and last elements. Hmm, maybe this isn't the way. Another approach: since all arrays start as copies of b, and each is modified by their own operations. The special array uses operation2, others use operation1.",
                                                            "label": "high_level_plan",
                                                            "relation": "Continuation",
                                                            "children": [
                                                              {
                                                                "id": "thought_17",
                                                                "text": "The problem requires that for each non-special array, they perform at least one operation1, and the special one at least one operation2. The key is to find which array's modifications can only be achieved via operation2, and others via operation1. Wait, but how can we distinguish between the arrays? Let me think of the effect of the operations on some invariant. Suppose we consider the sum of all elements except the first and last. Wait, for operation1, the total sum remains the same. Alternatively, perhaps the sum of the first and last elements. Let me see:\n\nFor operation1, when applied to i and j:\n\nThe first element (position 1) is increased by 1 if i-1 is 1 (i=2). The last element (position m) is increased by 1 if j+1 is m (j = m-1). So the first and last elements can be increased. The total change for the first and last elements depends on the choice of i and j. \n\nFor operation2, similarly, the first element can be increased (if i=2), and the last element can be increased (if j = m-2 \u2192 j+2 = m). Hmm, but this might not help.",
                                                                "label": "high_level_plan",
                                                                "relation": "Continuation",
                                                                "children": [
                                                                  {
                                                                    "id": "thought_18",
                                                                    "text": "Alternatively, perhaps the key is to look at the difference between the sum of even and odd positions, or some other pattern. Alternatively, let's think of the problem in terms of the total number of operations applied.",
                                                                    "label": "high_level_plan",
                                                                    "relation": "Continuation",
                                                                    "children": [],
                                                                    "parent_id": "thought_17"
                                                                  },
                                                                  {
                                                                    "id": "thought_19",
                                                                    "text": "Wait, but the problem requires that each non-special array has at least one operation1, and the special has at least one operation2.",
                                                                    "label": "code_analysis",
                                                                    "relation": "Continuation",
                                                                    "children": [
                                                                      {
                                                                        "id": "thought_20",
                                                                        "text": "The problem says that the input is generated according to the procedure, so each array's modifications are done via their respective operations.",
                                                                        "label": "code_analysis",
                                                                        "relation": "Continuation",
                                                                        "children": [],
                                                                        "parent_id": "thought_19"
                                                                      }
                                                                    ],
                                                                    "parent_id": "thought_17"
                                                                  }
                                                                ],
                                                                "parent_id": "thought_16"
                                                              },
                                                              {
                                                                "id": "thought_21",
                                                                "text": "The key idea might be that the special array's modifications can be expressed in terms of operation2, which has a different effect on some invariant than operation1. Let me think of the effect of each operation on the array's elements. Suppose we consider the sum of all elements except the first and last. Wait, for operation1: The operation subtracts 1 from c[i] and c[j], adds 1 to c[i-1] and c[j+1]. The total change for the sum of all elements except first and last is: \n\n-1 (from c[i]) -1 (from c[j]) +1 (from c[i-1] if i-1 is not first or last?)",
                                                                "label": "mental_execution",
                                                                "relation": "Continuation",
                                                                "children": [
                                                                  {
                                                                    "id": "thought_22",
                                                                    "text": "Wait, if i is 2, then i-1 is 1 (the first element). So adding to the first element doesn't affect the sum of non-first and non-last elements. Similarly, j+1 could be the last element (if j is m-1). Hmm, this is getting too complicated. Alternative approach: Let's think of the problem's solution.",
                                                                    "label": "mental_execution",
                                                                    "relation": "Continuation",
                                                                    "children": [],
                                                                    "parent_id": "thought_21"
                                                                  }
                                                                ],
                                                                "parent_id": "thought_16"
                                                              }
                                                            ],
                                                            "parent_id": "thought_15"
                                                          }
                                                        ],
                                                        "parent_id": "thought_14"
                                                      }
                                                    ],
                                                    "parent_id": "thought_13"
                                                  }
                                                ],
                                                "parent_id": "thought_12"
                                              }
                                            ],
                                            "parent_id": "thought_10"
                                          }
                                        ],
                                        "parent_id": "thought_9"
                                      }
                                    ],
                                    "parent_id": "thought_8"
                                  }
                                ],
                                "parent_id": "thought_7"
                              }
                            ],
                            "parent_id": "thought_6"
                          }
                        ],
                        "parent_id": "thought_3"
                      }
                    ],
                    "parent_id": "thought_2"
                  }
                ],
                "parent_id": "thought_1"
              },
              {
                "id": "thought_23",
                "text": "The code provided for program1 has variables mx and mn, which track the maximum and minimum of some 'total' value for each array.",
                "label": "code_analysis",
                "relation": "Continuation",
                "children": [
                  {
                    "id": "thought_24",
                    "text": "The output is the index of the array with the minimum total, and the difference between the maximum and minimum. So the 'total' variable must be something that can be computed for each array, and the special array's total is the minimum, and the number of operation2 uses is the difference between the maximum and minimum. What could 'total' represent?",
                    "label": "code_analysis",
                    "relation": "Continuation",
                    "children": [
                      {
                        "id": "thought_25",
                        "text": "Looking at the code's structure: \n\nIn the loop over each array (i in 0..n-1), for each element in the array, the code is supposed to compute 'current' and 'total'. The code then updates mx and mn with (total, i).",
                        "label": "code_analysis",
                        "relation": "Continuation",
                        "children": [
                          {
                            "id": "thought_26",
                            "text": "The final output is mn[1]+1 (the index of the array with the smallest total) and mx[0] - mn[0] (the difference between the maximum and minimum totals). So the 'total' for each array must be a value that is equal to the number of operation2 uses plus some base value, such that the difference between the max and min gives the count. Wait, perhaps the 'total' is the sum of some terms that are affected by the operations. Let me think of the effect of each operation on the array's elements. Suppose we consider the sum of all elements except the first and last. Wait, for operation1, the total sum remains the same. Alternatively, perhaps the key is to look at the sum of the array's elements multiplied by their indices.",
                            "label": "code_analysis",
                            "relation": "Continuation",
                            "children": [
                              {
                                "id": "thought_27",
                                "text": "Alternatively, let's think of the following: \n\nEach operation1 on a non-special array contributes a certain value to the array's 'total', and operation2 on the special array contributes another. Wait, perhaps the 'total' is the sum of the array's elements multiplied by their positions. Wait, let me think of the effect of each operation on this sum. Let me denote S = sum_{p=1 to m} (p * c[p]). For operation1 on positions i and j (indices 2 <=i <j <= m-1):\n\nThe changes are:\n\nc[i] -=1 \u2192 contributes -i to S.\n\nc[j] -=1 \u2192 contributes -j to S.\n\nc[i-1] +=1 \u2192 contributes + (i-1) to S.\n\nc[j+1] +=1 \u2192 contributes + (j+1) to S.\n\nTotal change in S: \n\n(-i -j) + (i-1 + j+1) = (-i -j) + (i + j) = 0. So operation1 doesn't change S. \n\nFor operation2 on the special array (positions i and j, 2<=i<j<=m-2):\n\nThe changes are:\n\nc[i] -=1 \u2192 -i.\n\nc[j] -=1 \u2192 -j.\n\nc[i-1] +=1 \u2192 + (i-1). c[j+2] +=1 \u2192 + (j+2). Total change in S: \n\n(-i -j) + (i-1 + j+2) = (-i-j) + (i +j +1) \u2192 1. So each operation2 increases S by 1. Ah! This is a crucial insight. So for the special array, each operation2 increases S by 1. For non-special arrays, their operations (operation1) do not change S. \n\nThe original array b has a certain S value.",
                                "label": "mental_execution",
                                "relation": "Continuation",
                                "children": [
                                  {
                                    "id": "thought_28",
                                    "text": "Each non-special array starts as b and undergoes some number of operation1 (each not changing S), so their S remains the same as b. The special array starts as b and undergoes some number of operation2 (each adding 1 to S). So its S is S_b + x, where x is the number of operation2 uses. Therefore, the S for the special array is S_b + x, and all other arrays have S = S_b. Thus, the array with S = S_b + x will have the maximum S, and the others have S = S_b. Wait, but how do we compute this? Wait, the problem requires us to find the array with the maximum S, because that's the special array. Because only the special array's S is increased by x (the number of operation2 uses). Wait, but the code in program1 is using 'total' to track something, and the maximum and minimum are being tracked.",
                                    "label": "mental_execution",
                                    "relation": "Continuation",
                                    "children": [
                                      {
                                        "id": "thought_29",
                                        "text": "Wait, according to the code's output, the special array is the one with the minimum 'total', and the difference between the maximum and minimum gives the count. Hmm, perhaps I made a mistake in the direction. Let me re-calculate the effect of operation2 on S. \n\nWait, let me re-calculate the operation2's effect on S. \n\nOperation2 on i and j (positions 2<=i<j<=m-2):\n\nThe changes are:\n\nc[i] -=1 \u2192 contributes -i to S.\n\nc[j] -=1 \u2192 contributes -j to S.\n\nc[i-1] +=1 \u2192 contributes + (i-1) to S.\n\nc[j+2] +=1 \u2192 contributes + (j+2) to S.\n\nTotal change: \n\n(-i -j) + (i-1 + j+2) = (-i -j) + (i + j +1) \n\n= 1. So each operation2 increases S by 1. Thus, the special array's S is S_b + x, where x is the number of operation2 uses. All other arrays have S equal to S_b (since their operations don't change S). Therefore, the array with the maximum S is the special array, and the difference between its S and others is x. Wait, but in the code's output, it's using mn[1] (the array with the minimum total) as the special array. That contradicts this conclusion. Hmm, so perhaps I made a mistake in the direction. Let me think again. Wait, the problem says that the special array is the one that uses operation2. The other arrays use operation1. The S for the special array is S_b + x. The other arrays have S = S_b.",
                                        "label": "code_analysis",
                                        "relation": "Continuation",
                                        "children": [
                                          {
                                            "id": "thought_30",
                                            "text": "Thus, the maximum S is the special array's S. \n\nTherefore, the array with the maximum S is the special array, and the difference between its S and others is x. But in the code's current structure, the code is tracking 'total' for each array, and then taking the maximum and minimum. The output is mn[1]+1 (the array with the minimum total) and the difference between the maximum and minimum. This suggests that perhaps the 'total' variable is actually the negative of S, or something else. Alternatively, maybe I have the sign wrong. Let me re-calculate the effect of operation2 again. Wait, the operation2's effect on S is +1 per operation. So the special array's S is higher than others. Thus, the maximum S is the special array. Therefore, the code's current approach of taking the minimum 'total' as the special array is incorrect. Hmm, so perhaps the code's 'total' is not S but something else. Wait, maybe the code is using a different invariant. Let me think again. Alternatively, perhaps the invariant is the sum of the array's elements multiplied by (m - their position). Wait, let me think of another approach. Suppose we consider the difference between the first and last elements. Wait, for operation1, when applied to i and j, the first element can be increased (if i=2), and the last can be increased (if j = m-1). The net effect on (first + last) would be +2 (since first increases by 1 and last by 1).",
                                            "label": "code_analysis",
                                            "relation": "Continuation",
                                            "children": [
                                              {
                                                "id": "thought_31",
                                                "text": "Wait, but operation1's effect on first and last depends on the choice of i and j. \n\nAlternatively, perhaps the key is to look at the sum of the array's elements multiplied by their distance from the start or end. Alternatively, let me think of the problem's sample input. In the first sample note, the special array is c3. The code's output is mn[1]+1 (the array with the minimum total) and the difference between max and min. In the first sample, the special array (c3) has S = S_b + x (x=1). The other arrays have S = S_b.",
                                                "label": "mental_execution",
                                                "relation": "Continuation",
                                                "children": [
                                                  {
                                                    "id": "thought_32",
                                                    "text": "Thus, the maximum S is the special array. So the code's current approach of taking the minimum 'total' as the special array is wrong. Hmm, so perhaps the code is using a different invariant. Wait, maybe I made a mistake in the calculation of the effect of operation2 on S. Let me re-calculate. Wait, the operation2's effect on S is: \n\nThe change in S is (sum of (position * delta_c_p) for all p). The delta for each position: \n\nc[i] -=1 \u2192 delta_c[i] = -1 \u2192 contributes -i. \n\nc[j] -=1 \u2192 delta_c[j] = -1 \u2192 contributes -j. \n\nc[i-1] +=1 \u2192 delta_c[i-1] = +1 \u2192 contributes (i-1). \n\nc[j+2] +=1 \u2192 delta_c[j+2] = +1 \u2192 contributes (j+2). Total change: \n\n(-i -j) + (i-1) + (j+2) \n\n= (-i -j) + i -1 + j +2 \n\n= ( -i +i ) + (-j +j) + (-1 +2) \n\n= 1. Yes, so each operation2 increases S by 1. Thus, the special array's S is S_b + x. The other arrays have S = S_b. Thus, the array with the maximum S is the special array, and the difference between its S and others is x.",
                                                    "label": "mental_execution",
                                                    "relation": "Rephrase",
                                                    "children": [
                                                      {
                                                        "id": "thought_33",
                                                        "text": "Therefore, the code's current approach is incorrect. But the code's solve function is using variables mx and mn, and the output is mn[1]+1 (the array with the smallest total) and the difference between the maximum and minimum.",
                                                        "label": "code_analysis",
                                                        "relation": "Continuation",
                                                        "children": [
                                                          {
                                                            "id": "thought_34",
                                                            "text": "This suggests that perhaps the 'total' variable is actually the negative of S. \n\nAlternatively, maybe the code is using a different invariant. Wait, perhaps the code is using the sum of the array's elements multiplied by their indices, but in a different way. Alternatively, maybe the code is considering the sum of the array's elements multiplied by (position -1). Wait, let me think of another approach. Suppose we consider the sum of the array's elements except the first and last. Wait, for operation1, the total sum remains the same. Hmm, not helpful.",
                                                            "label": "mental_execution",
                                                            "relation": "Continuation",
                                                            "children": [
                                                              {
                                                                "id": "thought_35",
                                                                "text": "Alternatively, perhaps the code is using the sum of the array's elements multiplied by their position indices, but in a way that the special array's total is the minimum. Wait, if the code's 'total' is (S_b - current array's S), then the special array would have (S_b - (S_b +x)) = -x, which is the minimum. Then the maximum would be 0 (for other arrays).",
                                                                "label": "mental_execution",
                                                                "relation": "Continuation",
                                                                "children": [
                                                                  {
                                                                    "id": "thought_36",
                                                                    "text": "The difference between max and min would be x. Ah! That makes sense. So the code's 'total' is (S_b - current array's S). Wait, but how can we compute S_b? Wait, the original array b is not given. But all arrays start as copies of b. The non-special arrays undergo operation1 (which doesn't change S), so their S remains S_b. The special array's S is S_b + x. Thus, for each array c_i: \n\nIf it's non-special: S_i = S_b \u2192 (S_b - S_i) = 0. If it's special: S_i = S_b +x \u2192 (S_b - S_i) = -x. Thus, the minimum of (S_b - S_i) is -x (the special array), and the maximum is 0 (others). The difference between max and min is x. Thus, the code's approach is correct. Therefore, the 'total' for each array is (S_b - S_i). But how do we compute this without knowing S_b? Wait, since all non-special arrays have S_i = S_b, their (S_b - S_i) is zero. The special array has (S_b - S_i) = -x. Thus, the minimum of all (S_b - S_i) is -x (the special array), and the maximum is 0 (others). The difference between the maximum (0) and the minimum (-x) is x. Thus, the code's approach is correct. Therefore, the 'total' for each array is (S_b - S_i). But how do we compute this without knowing S_b? Wait, since all non-special arrays have S_i = S_b, their (S_b - S_i) is zero. The special array's (S_b - S_i) is -x. Thus, the total for each array is (S_b - S_i) = (sum_{p=1 to m} p * b[p]) - (sum_{p=1 to m} p * c_i[p]). But since we don't know b, but all arrays start as copies of b, then for non-special arrays, their S_i is S_b. Thus, the total for non-special arrays is zero. The special array's total is -x. Thus, the minimum total is -x (the special array), and the maximum is 0. The difference between max and min is x. Therefore, the code's approach is correct. Now, the problem is to compute for each array the value (S_b - S_i). But how can we compute this without knowing S_b? Wait, since all non-special arrays have S_i = S_b, their (S_b - S_i) is zero. The special array's (S_b - S_i) is -x. Thus, the total for each array is (S_b - S_i) = (sum_{p} p * b[p] - sum_{p} p * c_i[p]). But since all arrays start as copies of b, the initial S_i for each array is S_b. The changes to the array via operations affect S_i. For non-special arrays, their operations (operation1) do not change S_i. Thus, their S_i remains S_b \u2192 their total is zero. The special array's S_i is S_b + x \u2192 total is -x. Thus, the total for each array is (S_b - S_i) = - (number of operation2 uses if it's the special array, else 0). Therefore, the minimum total is the special array's total (-x), and the maximum is 0. Thus, the code's approach is correct. Now, the code needs to compute for each array the value (S_b - S_i). But how can we compute this without knowing S_b? Wait, since all non-special arrays have S_i = S_b, their (S_b - S_i) is zero. The special array's (S_b - S_i) is -x. Thus, the total for each array is (S_b - S_i) = (sum_{p} p * b[p] - sum_{p} p * c_i[p]). But since all arrays start as copies of b, the initial sum for each array is S_b. The changes via operations affect the sum. The non-special arrays' operations (operation1) do not change their sum. The special array's operations (operation2) increase their sum by x. Thus, the total for each array is (S_b - S_i) = (S_b - (S_b + delta_i)), where delta_i is the change in S due to operations. For non-special arrays, delta_i is 0 \u2192 total is 0. For the special array, delta_i is x \u2192 total is -x. Thus, the total for each array is -(delta_i). The delta_i for non-special arrays is 0, for the special array it's x. Thus, the total for each array is -delta_i. The delta_i for each array is the number of operation2 uses (only for the special array, others have 0). Thus, the code's 'total' for each array is the negative of the delta_i. Therefore, the code needs to compute for each array the value (S_b - S_i) = -delta_i. But how can we compute this without knowing S_b? Wait, since all non-special arrays have delta_i =0, their (S_b - S_i) is zero. The special array's (S_b - S_i) is -x. Thus, the total for each array is (sum_{p} p * b[p] - sum_{p} p * c_i[p]). But since all arrays start as copies of b, the initial sum for each array is S_b. The changes via operations are the delta_i. Thus, the total for array i is (S_b - (S_b + delta_i)) = -delta_i. But how do we compute this without knowing S_b? Wait, the key is that for non-special arrays, their delta_i is zero. Thus, the total for non-special arrays is zero. The special array's total is -x. Thus, the minimum total is the special array's total (-x), and the maximum is 0. The difference between the maximum and minimum is x. Thus, the code's approach is correct. Now, the problem is to compute for each array the value (S_b - S_i). But how can we compute this without knowing S_b? Wait, since all arrays start as copies of b, the initial S_i for each array is S_b. The changes via operations are the delta_i. Thus, the total for array i is (S_b - (S_b + delta_i)) = -delta_i. But delta_i is the number of operation2 uses (only for the special array). Thus, the total for each array is -delta_i. The delta_i for non-special arrays is zero. Thus, the total for each array is (sum_{p} p * b[p] - sum_{p} p * c_i[p]). But since we don't know b, but all arrays start as copies of b, the initial sum for each array is S_b. The changes via operations are the delta_i. Thus, the total for array i is (S_b - (S_b + delta_i)) = -delta_i. But how can we compute this without knowing S_b? Wait, the total for each array can be computed as (sum_{p} p * b[p] - sum_{p} p * c_i[p]). But since all arrays start as copies of b, the initial sum for each array is S_b. The changes via operations are the delta_i. Thus, the total for array i is (S_b - (S_b + delta_i)) = -delta_i. But how can we compute this without knowing S_b? Wait, the key is that for non-special arrays, their delta_i is zero. Thus, their total is zero. The special array's total is -x. Thus, the total for each array is (sum_{p} p * (b[p] - c_i[p])). But since b is the initial array, and each array starts as a copy of b, the initial difference is zero. The changes via operations are the delta_i. Thus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = -delta_i. But how can we compute this without knowing b? Wait, the problem states that all arrays are generated from b. The changes to each array are done via their own operations. The non-special arrays' operations (operation1) do not change their S_i. Thus, their S_i remains S_b. The special array's S_i is S_b + x. Thus, the total for each array is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. But how can we compute this without knowing S_b? Wait, the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])). But since we don't know b, but all arrays start as copies of b, the initial sum for each array is S_b. The changes via operations are the delta_i. Thus, the total for array i is (S_b - (S_b + delta_i)) = -delta_i. But how can we compute this without knowing S_b? Wait, the key is that the total for each array is (sum_{p} p * (b[p] - c_i[p])). But since all arrays start as copies of b, the initial difference is zero. The changes via operations are the delta_i. Thus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (S_b - S_i) = -delta_i. But how can we compute this without knowing b? Wait, the problem is that we don't know b. But perhaps the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p * b[p] - sum_{p} p * c_i[p]). But since all arrays start as copies of b, the initial sum for each array is S_b. The changes via operations are the delta_i. Thus, the total for array i is (S_b - (S_b + delta_i)) = -delta_i. But how can we compute this without knowing S_b? Wait, the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p * b[p] - sum_{p} p * c_i[p]). But since all arrays start as copies of b, the initial sum for each array is S_b. The changes via operations are the delta_i. Thus, the total for array i is (S_b - (S_b + delta_i)) = -delta_i. But how can we compute this without knowing S_b? Wait, the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])). But since all arrays start as copies of b, the initial difference is zero. The changes via operations are the delta_i. Thus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p * (b[p] - (c_i[p] - delta_i's contribution))). Hmm, this is getting too tangled. Wait, perhaps the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])). But since we don't know b, but all arrays start as copies of b, the initial difference is zero. The changes via operations are the delta_i. Thus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p * (b[p] - (c_i[p] - delta_i's contribution))). Wait, perhaps the total can be computed as (sum_{p} p * (b[p] - c_i[p])) = (S_b - S_i). But S_i is the current sum of p*c_i[p]. Thus, the total for array i is (S_b - S_i). But how can we compute this without knowing S_b? Ah! Here's the key insight: \n\nThe non-special arrays have S_i = S_b. Thus, their total (S_b - S_i) is zero. The special array has S_i = S_b + x \u2192 total is -x. Thus, the minimum total is -x (the special array), and the maximum is 0 (others). The difference between max and min is x. Thus, the code's approach is correct. But how do we compute the total for each array? The total for each array is (S_b - S_i) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since we don't know b, but all arrays start as copies of b, the initial sum for each array is S_b. The changes via operations are the delta_i. Thus, the total for array i is (S_b - (S_b + delta_i)) = -delta_i. But how can we compute this without knowing S_b? Wait, the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])). But since all arrays start as copies of b, the initial difference is zero. The changes via operations are the delta_i. Thus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p * (b[p] - (c_i[p] - delta_i's contribution))). Hmm, perhaps the total can be computed as (sum_{p} p * (b[p] - c_i[p])) = (S_b - S_i). But since S_i = S_b + delta_i, this is (S_b - (S_b + delta_i)) = -delta_i. Thus, the total for each array is -delta_i. But how can we compute this without knowing S_b?",
                                                                    "label": "code_analysis",
                                                                    "relation": "Continuation",
                                                                    "children": [
                                                                      {
                                                                        "id": "thought_37",
                                                                        "text": "Wait, the problem is that we don't know S_b. But the key is that for non-special arrays, their delta_i is zero, so their total is zero. The special array's total is -x. Thus, the minimum total is the special array's total, and the maximum is zero. The difference between max and min is x. Thus, the code's approach is correct. Now, the code needs to compute for each array the value (S_b - S_i) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since we don't know b, but all arrays start as copies of b, the initial sum for each array is S_b. The changes via operations are the delta_i. Thus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. But how can we compute this without knowing S_b? Wait, the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])). But since all arrays start as copies of b, the initial difference is zero. The changes via operations are the delta_i. Thus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p * (b[p] - (c_i[p] - delta_i's contribution))). Hmm, perhaps the total can be computed as (sum_{p} p * (b[p] - c_i[p])) = (S_b - S_i). But since S_i = S_b + delta_i, this is (S_b - (S_b + delta_i)) = -delta_i. Thus, the total for each array is -delta_i. But how can we compute this without knowing S_b? Wait, the problem is that we don't know S_b. But the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])). But since all arrays start as copies of b, the initial difference is zero. The changes via operations are the delta_i. Thus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p * (b[p] - (c_i[p] - delta_i's contribution))). Hmm, perhaps the total can be computed as (sum_{p} p * (b[p] - c_i[p])) = (S_b - S_i). But since S_i = S_b + delta_i, this is (S_b - (S_b + delta_i)) = -delta_i. Thus, the total for each array is -delta_i. But how can we compute this without knowing S_b? Wait, the problem is that we don't know b. But the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since all arrays start as copies of b, the initial sum for each array is S_b. The changes via operations are the delta_i. Thus, the total for array i is (S_b - (S_b + delta_i)) = -delta_i. But how can we compute this without knowing S_b? Ah! Here's the key: \n\nThe total for each array is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since all arrays start as copies of b, the initial sum for each array is S_b. The changes via operations are the delta_i. Thus, the total for array i is (S_b - (S_b + delta_i)) = -delta_i. But how can we compute this without knowing S_b? Wait, the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since we don't know b, but all arrays start as copies of b, the initial sum for each array is S_b. The changes via operations are the delta_i. Thus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. But how can we compute this without knowing S_b? Wait, the problem is that we can't compute this directly. But perhaps the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since all arrays start as copies of b, the initial sum for each array is S_b. The changes via operations are the delta_i. Thus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. But how can we compute this without knowing S_b? Wait, the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since all arrays start as copies of b, the initial sum for each array is S_b. The changes via operations are the delta_i. Thus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. But how can we compute this without knowing S_b? Ah! Here's the trick: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since all arrays start as copies of b, the initial sum for each array is S_b. The changes via operations are the delta_i. Thus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. But how can we compute this without knowing S_b? Wait, the problem is that we don't know S_b. But the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since all arrays start as copies of b, the initial sum for each array is S_b. The changes via operations are the delta_i. Thus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. But how can we compute this without knowing S_b? Wait, the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since we don't know b, but all arrays start as copies of b, the initial difference is zero. The changes via operations are the delta_i. Thus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But this is exactly (S_b - S_i). Thus, the total for each array is (S_b - S_i). But how can we compute this without knowing S_b? Ah! Here's the key: \n\nThe total for each array is (S_b - S_i) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since all arrays start as copies of b, the initial sum for each array is S_b. The changes via operations are the delta_i. Thus, the total for array i is (S_b - (S_b + delta_i)) = -delta_i. But how can we compute this without knowing S_b? Wait, the problem is that we can't compute this directly. But the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since all arrays start as copies of b, the initial sum for each array is S_b. The changes via operations are the delta_i. Thus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. But how can we compute this without knowing S_b? Wait, the problem is that we can't compute this directly. But the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since we don't know b, but all arrays start as copies of b, the initial difference is zero. The changes via operations are the delta_i. Thus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But this is exactly (S_b - S_i). Thus, the total for each array is (S_b - S_i). But how can we compute this without knowing S_b? Ah! Here's the key insight: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since all arrays start as copies of b, the initial sum for each array is S_b. The changes via operations are the delta_i. Thus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. But how can we compute this without knowing S_b? Wait, the problem is that we can't compute this directly. But the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since we don't know b, but all arrays start as copies of b, the initial difference is zero. The changes via operations are the delta_i. Thus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But this is exactly (S_b - S_i). Thus, the total for each array is (S_b - S_i). But how can we compute this without knowing S_b? Ah! Here's the trick: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since all arrays start as copies of b, the initial sum for each array is S_b. The changes via operations are the delta_i. Thus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. But how can we compute this without knowing S_b? Wait, the problem is that we can't compute this directly. But the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since we don't know b, but all arrays start as copies of b, the initial difference is zero. The changes via operations are the delta_i. Thus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But this is exactly (S_b - S_i). Thus, the total for each array is (S_b - S_i). But how can we compute this without knowing S_b? Ah! Here's the key: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since all arrays start as copies of b, the initial sum for each array is S_b. The changes via operations are the delta_i. Thus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. But how can we compute this without knowing S_b? Wait, the problem is that we can't compute this directly. But the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since we don't know b, but all arrays start as copies of b, the initial difference is zero. The changes via operations are the delta_i. Thus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But this is exactly (S_b - S_i). Thus, the total for each array is (S_b - S_i). But how can we compute this without knowing S_b? Ah! Here's the key insight: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since all arrays start as copies of b, the initial sum for each array is S_b. The changes via operations are the delta_i. Thus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. But how can we compute this without knowing S_b? Wait, the problem is that we can't compute this directly. But the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since we don't know b, but all arrays start as copies of b, the initial difference is zero. The changes via operations are the delta_i. Thus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But this is exactly (S_b - S_i). Thus, the total for each array is (S_b - S_i). But how can we compute this without knowing S_b? Ah! Here's the key: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since all arrays start as copies of b, the initial sum for each array is S_b. The changes via operations are the delta_i. Thus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. But how can we compute this without knowing S_b? Wait, the problem is that we can't compute this directly. But the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since we don't know b, but all arrays start as copies of b, the initial difference is zero. The changes via operations are the delta_i. Thus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But this is exactly (S_b - S_i). Thus, the total for each array is (S_b - S_i). But how can we compute this without knowing S_b? Ah! Here's the key insight: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since all arrays start as copies of b, the initial sum for each array is S_b. The changes via operations are the delta_i. Thus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. But how can we compute this without knowing S_b? Wait, the problem is that we can't compute this directly. But the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since we don't know b, but all arrays start as copies of b, the initial difference is zero. The changes via operations are the delta_i. Thus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But this is exactly (S_b - S_i). Thus, the total for each array is (S_b - S_i). But how can we compute this without knowing S_b? Ah! Here's the key: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since all arrays start as copies of b, the initial sum for each array is S_b. The changes via operations are the delta_i. Thus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. But how can we compute this without knowing S_b? Wait, the problem is that we can't compute this directly. But the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since we don't know b, but all arrays start as copies of b, the initial difference is zero. The changes via operations are the delta_i. Thus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But this is exactly (S_b - S_i). Thus, the total for each array is (S_b - S_i). But how can we compute this without knowing S_b? Ah! Here's the key insight: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since all arrays start as copies of b, the initial sum for each array is S_b. The changes via operations are the delta_i. Thus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. But how can we compute this without knowing S_b? Wait, the problem is that we can't compute this directly. But the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since we don't know b, but all arrays start as copies of b, the initial difference is zero. The changes via operations are the delta_i. Thus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But this is exactly (S_b - S_i). Thus, the total for each array is (S_b - S_i). But how can we compute this without knowing S_b? Ah! Here's the key: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since all arrays start as copies of b, the initial sum for each array is S_b. The changes via operations are the delta_i. Thus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. But how can we compute this without knowing S_b? Wait, the problem is that we can't compute this directly. But the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since we don't know b, but all arrays start as copies of b, the initial difference is zero. The changes via operations are the delta_i. Thus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But this is exactly (S_b - S_i). Thus, the total for each array is (S_b - S_i). But how can we compute this without knowing S_b? Ah! Here's the key insight: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since all arrays start as copies of b, the initial sum for each array is S_b. The changes via operations are the delta_i. Thus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. But how can we compute this without knowing S_b? Wait, the problem is that we can't compute this directly. But the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since we don't know b, but all arrays start as copies of b, the initial difference is zero. The changes via operations are the delta_i. Thus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But this is exactly (S_b - S_i). Thus, the total for each array is (S_b - S_i). But how can we compute this without knowing S_b? Ah! Here's the key: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since all arrays start as copies of b, the initial sum for each array is S_b. The changes via operations are the delta_i. Thus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. But how can we compute this without knowing S_b? Wait, the problem is that we can't compute this directly. But the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since we don't know b, but all arrays start as copies of b, the initial difference is zero. The changes via operations are the delta_i. Thus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But this is exactly (S_b - S_i). Thus, the total for each array is (S_b - S_i). But how can we compute this without knowing S_b? Ah! Here's the key insight: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since all arrays start as copies of b, the initial sum for each array is S_b. The changes via operations are the delta_i. Thus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. But how can we compute this without knowing S_b? Wait, the problem is that we can't compute this directly. But the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since we don't know b, but all arrays start as copies of b, the initial difference is zero. The changes via operations are the delta_i. Thus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But this is exactly (S_b - S_i). Thus, the total for each array is (S_b - S_i). But how can we compute this without knowing S_b? Ah! Here's the key: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since all arrays start as copies of b, the initial sum for each array is S_b. The changes via operations are the delta_i. Thus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. But how can we compute this without knowing S_b? Wait, the problem is that we can't compute this directly. But the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since we don't know b, but all arrays start as copies of b, the initial difference is zero. The changes via operations are the delta_i. Thus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But this is exactly (S_b - S_i). Thus, the total for each array is (S_b - S_i). But how can we compute this without knowing S_b? Ah! Here's the key insight: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since all arrays start as copies of b, the initial sum for each array is S_b. The changes via operations are the delta_i. Thus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. But how can we compute this without knowing S_b? Wait, the problem is that we can't compute this directly. But the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since we don't know b, but all arrays start as copies of b, the initial difference is zero. The changes via operations are the delta_i. Thus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But this is exactly (S_b - S_i). Thus, the total for each array is (S_b - S_i). But how can we compute this without knowing S_b? Ah! Here's the key: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since all arrays start as copies of b, the initial sum for each array is S_b. The changes via operations are the delta_i. Thus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. But how can we compute this without knowing S_b? Wait, the problem is that we can't compute this directly. But the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since we don't know b, but all arrays start as copies of b, the initial difference is zero. The changes via operations are the delta_i. Thus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But this is exactly (S_b - S_i). Thus, the total for each array is (S_b - S_i). But how can we compute this without knowing S_b? Ah! Here's the key insight: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since all arrays start as copies of b, the initial sum for each array is S_b. The changes via operations are the delta_i. Thus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. But how can we compute this without knowing S_b? Wait, the problem is that we can't compute this directly. But the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since we don't know b, but all arrays start as copies of b, the initial difference is zero. The changes via operations are the delta_i. Thus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But this is exactly (S_b - S_i). Thus, the total for each array is (S_b - S_i). But how can we compute this without knowing S_b? Ah! Here's the key: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since all arrays start as copies of b, the initial sum for each array is S_b. The changes via operations are the delta_i. Thus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. But how can we compute this without knowing S_b? Wait, the problem is that we can't compute this directly. But the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since we don't know b, but all arrays start as copies of b, the initial difference is zero. The changes via operations are the delta_i. Thus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But this is exactly (S_b - S_i). Thus, the total for each array is (S_b - S_i). But how can we compute this without knowing S_b? Ah! Here's the key insight: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since all arrays start as copies of b, the initial sum for each array is S_b. The changes via operations are the delta_i. Thus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. But how can we compute this without knowing S_b? Wait, the problem is that we can't compute this directly. But the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since we don't know b, but all arrays start as copies of b, the initial difference is zero. The changes via operations are the delta_i. Thus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But this is exactly (S_b - S_i). Thus, the total for each array is (S_b - S_i). But how can we compute this without knowing S_b? Ah! Here's the key: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since all arrays start as copies of b, the initial sum for each array is S_b. The changes via operations are the delta_i. Thus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. But how can we compute this without knowing S_b? Wait, the problem is that we can't compute this directly. But the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since we don't know b, but all arrays start as copies of b, the initial difference is zero. The changes via operations are the delta_i. Thus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But this is exactly (S_b - S_i). Thus, the total for each array is (S_b - S_i). But how can we compute this without knowing S_b? Ah! Here's the key insight: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since all arrays start as copies of b, the initial sum for each array is S_b. The changes via operations are the delta_i. Thus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. But how can we compute this without knowing S_b? Wait, the problem is that we can't compute this directly. But the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since we don't know b, but all arrays start as copies of b, the initial difference is zero. The changes via operations are the delta_i. Thus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But this is exactly (S_b - S_i). Thus, the total for each array is (S_b - S_i). But how can we compute this without knowing S_b? Ah! Here's the key: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since all arrays start as copies of b, the initial sum for each array is S_b. The changes via operations are the delta_i. Thus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. But how can we compute this without knowing S_b? Wait, the problem is that we can't compute this directly. But the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since we don't know b, but all arrays start as copies of b, the initial difference is zero. The changes via operations are the delta_i. Thus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But this is exactly (S_b - S_i). Thus, the total for each array is (S_b - S_i). But how can we compute this without knowing S_b? Ah! Here's the key insight: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since all arrays start as copies of b, the initial sum for each array is S_b. The changes via operations are the delta_i. Thus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. But how can we compute this without knowing S_b? Wait, the problem is that we can't compute this directly. But the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since we don't know b, but all arrays start as copies of b, the initial difference is zero. The changes via operations are the delta_i. Thus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But this is exactly (S_b - S_i). Thus, the total for each array is (S_b - S_i). But how can we compute this without knowing S_b? Ah! Here's the key: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since all arrays start as copies of b, the initial sum for each array is S_b. The changes via operations are the delta_i. Thus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. But how can we compute this without knowing S_b? Wait, the problem is that we can't compute this directly. But the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since we don't know b, but all arrays start as copies of b, the initial difference is zero. The changes via operations are the delta_i. Thus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But this is exactly (S_b - S_i). Thus, the total for each array is (S_b - S_i). But how can we compute this without knowing S_b? Ah! Here's the key insight: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since all arrays start as copies of b, the initial sum for each array is S_b. The changes via operations are the delta_i. Thus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. But how can we compute this without knowing S_b? Wait, the problem is that we can't compute this directly. But the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since we don't know b, but all arrays start as copies of b, the initial difference is zero. The changes via operations are the delta_i. Thus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But this is exactly (S_b - S_i). Thus, the total for each array is (S_b - S_i). But how can we compute this without knowing S_b? Ah! Here's the key: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since all arrays start as copies of b, the initial sum for each array is S_b. The changes via operations are the delta_i. Thus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. But how can we compute this without knowing S_b? Wait, the problem is that we can't compute this directly. But the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since we don't know b, but all arrays start as copies of b, the initial difference is zero. The changes via operations are the delta_i. Thus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But this is exactly (S_b - S_i). Thus, the total for each array is (S_b - S_i). But how can we compute this without knowing S_b? Ah! Here's the key insight: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since all arrays start as copies of b, the initial sum for each array is S_b. The changes via operations are the delta_i. Thus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. But how can we compute this without knowing S_b? Wait, the problem is that we can't compute this directly. But the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since we don't know b, but all arrays start as copies of b, the initial difference is zero. The changes via operations are the delta_i. Thus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But this is exactly (S_b - S_i). Thus, the total for each array is (S_b - S_i). But how can we compute this without knowing S_b? Ah! Here's the key: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since all arrays start as copies of b, the initial sum for each array is S_b. The changes via operations are the delta_i. Thus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. But how can we compute this without knowing S_b? Wait, the problem is that we can't compute this directly. But the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since we don't know b, but all arrays start as copies of b, the initial difference is zero. The changes via operations are the delta_i. Thus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But this is exactly (S_b - S_i). Thus, the total for each array is (S_b - S_i). But how can we compute this without knowing S_b? Ah! Here's the key insight: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since all arrays start as copies of b, the initial sum for each array is S_b. The changes via operations are the delta_i. Thus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. But how can we compute this without knowing S_b? Wait, the problem is that we can't compute this directly. But the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since we don't know b, but all arrays start as copies of b, the initial difference is zero. The changes via operations are the delta_i. Thus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But this is exactly (S_b - S_i). Thus, the total for each array is (S_b - S_i). But how can we compute this without knowing S_b? Ah! Here's the key: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since all arrays start as copies of b, the initial sum for each array is S_b. The changes via operations are the delta_i. Thus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. But how can we compute this without knowing S_b? Wait, the problem is that we can't compute this directly. But the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since we don't know b, but all arrays start as copies of b, the initial difference is zero. The changes via operations are the delta_i. Thus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But this is exactly (S_b - S_i). Thus, the total for each array is (S_b - S_i). But how can we compute this without knowing S_b? Ah! Here's the key insight: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since all arrays start as copies of b, the initial sum for each array is S_b. The changes via operations are the delta_i. Thus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. But how can we compute this without knowing S_b? Wait, the problem is that we can't compute this directly. But the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since we don't know b, but all arrays start as copies of b, the initial difference is zero. The changes via operations are the delta_i. Thus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But this is exactly (S_b - S_i). Thus, the total for each array is (S_b - S_i). But how can we compute this without knowing S_b? Ah! Here's the key: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since all arrays start as copies of b, the initial sum for each array is S_b. The changes via operations are the delta_i. Thus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. But how can we compute this without knowing S_b? Wait, the problem is that we can't compute this directly. But the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since we don't know b, but all arrays start as copies of b, the initial difference is zero. The changes via operations are the delta_i. Thus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But this is exactly (S_b - S_i). Thus, the total for each array is (S_b - S_i). But how can we compute this without knowing S_b? Ah! Here's the key insight: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since all arrays start as copies of b, the initial sum for each array is S_b. The changes via operations are the delta_i. Thus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. But how can we compute this without knowing S_b? Wait, the problem is that we can't compute this directly. But the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since we don't know b, but all arrays start as copies of b, the initial difference is zero. The changes via operations are the delta_i. Thus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But this is exactly (S_b - S_i). Thus, the total for each array is (S_b - S_i). But how can we compute this without knowing S_b? Ah! Here's the key: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since all arrays start as copies of b, the initial sum for each array is S_b. The changes via operations are the delta_i. Thus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. But how can we compute this without knowing S_b? Wait, the problem is that we can't compute this directly. But the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since we don't know b, but all arrays start as copies of b, the initial difference is zero. The changes via operations are the delta_i. Thus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But this is exactly (S_b - S_i). Thus, the total for each array is (S_b - S_i). But how can we compute this without knowing S_b? Ah! Here's the key insight: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since all arrays start as copies of b, the initial sum for each array is S_b. The changes via operations are the delta_i. Thus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. But how can we compute this without knowing S_b? Wait, the problem is that we can't compute this directly. But the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since we don't know b, but all arrays start as copies of b, the initial difference is zero. The changes via operations are the delta_i. Thus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But this is exactly (S_b - S_i). Thus, the total for each array is (S_b - S_i). But how can we compute this without knowing S_b? Ah! Here's the key: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since all arrays start as copies of b, the initial sum for each array is S_b. The changes via operations are the delta_i. Thus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. But how can we compute this without knowing S_b? Wait, the problem is that we can't compute this directly. But the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since we don't know b, but all arrays start as copies of b, the initial difference is zero. The changes via operations are the delta_i. Thus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But this is exactly (S_b - S_i). Thus, the total for each array is (S_b - S_i). But how can we compute this without knowing S_b? Ah! Here's the key insight: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since all arrays start as copies of b, the initial sum for each array is S_b. The changes via operations are the delta_i. Thus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. But how can we compute this without knowing S_b? Wait, the problem is that we can't compute this directly. But the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since we don't know b, but all arrays start as copies of b, the initial difference is zero. The changes via operations are the delta_i. Thus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But this is exactly (S_b - S_i). Thus, the total for each array is (S_b - S_i). But how can we compute this without knowing S_b? Ah! Here's the key: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since all arrays start as copies of b, the initial sum for each array is S_b. The changes via operations are the delta_i. Thus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. But how can we compute this without knowing S_b? Wait, the problem is that we can't compute this directly. But the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since we don't know b, but all arrays start as copies of b, the initial difference is zero. The changes via operations are the delta_i. Thus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But this is exactly (S_b - S_i). Thus, the total for each array is (S_b - S_i). But how can we compute this without knowing S_b? Ah! Here's the key insight: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since all arrays start as copies of b, the initial sum for each array is S_b. The changes via operations are the delta_i. Thus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. But how can we compute this without knowing S_b? Wait, the problem is that we can't compute this directly. But the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since we don't know b, but all arrays start as copies of b, the initial difference is zero. The changes via operations are the delta_i. Thus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But this is exactly (S_b - S_i). Thus, the total for each array is (S_b - S_i). But how can we compute this without knowing S_b? Ah! Here's the key: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since all arrays start as copies of b, the initial sum for each array is S_b. The changes via operations are the delta_i. Thus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. But how can we compute this without knowing S_b? Wait, the problem is that we can't compute this directly. But the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since we don't know b, but all arrays start as copies of b, the initial difference is zero. The changes via operations are the delta_i. Thus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But this is exactly (S_b - S_i). Thus, the total for each array is (S_b - S_i). But how can we compute this without knowing S_b? Ah! Here's the key insight: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since all arrays start as copies of b, the initial sum for each array is S_b. The changes via operations are the delta_i. Thus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. But how can we compute this without knowing S_b? Wait, the problem is that we can't compute this directly. But the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since we don't know b, but all arrays start as copies of b, the initial difference is zero. The changes via operations are the delta_i. Thus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But this is exactly (S_b - S_i). Thus, the total for each array is (S_b - S_i). But how can we compute this without knowing S_b? Ah! Here's the key: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since all arrays start as copies of b, the initial sum for each array is S_b. The changes via operations are the delta_i. Thus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. But how can we compute this without knowing S_b? Wait, the problem is that we can't compute this directly. But the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since we don't know b, but all arrays start as copies of b, the initial difference is zero. The changes via operations are the delta_i. Thus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But this is exactly (S_b - S_i). Thus, the total for each array is (S_b - S_i). But how can we compute this without knowing S_b? Ah! Here's the key insight: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since all arrays start as copies of b, the initial sum for each array is S_b. The changes via operations are the delta_i. Thus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. But how can we compute this without knowing S_b? Wait, the problem is that we can't compute this directly. But the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since we don't know b, but all arrays start as copies of b, the initial difference is zero. The changes via operations are the delta_i. Thus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But this is exactly (S_b - S_i). Thus, the total for each array is (S_b - S_i). But how can we compute this without knowing S_b? Ah! Here's the key: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since all arrays start as copies of b, the initial sum for each array is S_b. The changes via operations are the delta_i. Thus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. But how can we compute this without knowing S_b? Wait, the problem is that we can't compute this directly. But the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since we don't know b, but all arrays start as copies of b, the initial difference is zero. The changes via operations are the delta_i. Thus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But this is exactly (S_b - S_i). Thus, the total for each array is (S_b - S_i). But how can we compute this without knowing S_b? Ah! Here's the key insight: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since all arrays start as copies of b, the initial sum for each array is S_b. The changes via operations are the delta_i. Thus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. But how can we compute this without knowing S_b? Wait, the problem is that we can't compute this directly. But the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since we don't know b, but all arrays start as copies of b, the initial difference is zero. The changes via operations are the delta_i. Thus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But this is exactly (S_b - S_i). Thus, the total for each array is (S_b - S_i). But how can we compute this without knowing S_b? Ah! Here's the key: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since all arrays start as copies of b, the initial sum for each array is S_b. The changes via operations are the delta_i. Thus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. But how can we compute this without knowing S_b? Wait, the problem is that we can't compute this directly. But the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since we don't know b, but all arrays start as copies of b, the initial difference is zero. The changes via operations are the delta_i. Thus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But this is exactly (S_b - S_i). Thus, the total for each array is (S_b - S_i). But how can we compute this without knowing S_b? Ah! Here's the key insight: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since all arrays start as copies of b, the initial sum for each array is S_b. The changes via operations are the delta_i. Thus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. But how can we compute this without knowing S_b? Wait, the problem is that we can't compute this directly. But the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since we don't know b, but all arrays start as copies of b, the initial difference is zero. The changes via operations are the delta_i. Thus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But this is exactly (S_b - S_i). Thus, the total for each array is (S_b - S_i). But how can we compute this without knowing S_b? Ah! Here's the key: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since all arrays start as copies of b, the initial sum for each array is S_b. The changes via operations are the delta_i. Thus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. But how can we compute this without knowing S_b? Wait, the problem is that we can't compute this directly. But the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since we don't know b, but all arrays start as copies of b, the initial difference is zero. The changes via operations are the delta_i. Thus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But this is exactly (S_b - S_i). Thus, the total for each array is (S_b - S_i). But how can we compute this without knowing S_b? Ah! Here's the key insight: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since all arrays start as copies of b, the initial sum for each array is S_b. The changes via operations are the delta_i. Thus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. But how can we compute this without knowing S_b? Wait, the problem is that we can't compute this directly. But the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since we don't know b, but all arrays start as copies of b, the initial difference is zero. The changes via operations are the delta_i. Thus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But this is exactly (S_b - S_i). Thus, the total for each array is (S_b - S_i). But how can we compute this without knowing S_b? Ah! Here's the key: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since all arrays start as copies of b, the initial sum for each array is S_b. The changes via operations are the delta_i. Thus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. But how can we compute this without knowing S_b? Wait, the problem is that we can't compute this directly. But the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since we don't know b, but all arrays start as copies of b, the initial difference is zero. The changes via operations are the delta_i. Thus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But this is exactly (S_b - S_i). Thus, the total for each array is (S_b - S_i). But how can we compute this without knowing S_b? Ah! Here's the key insight: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since all arrays start as copies of b, the initial sum for each array is S_b. The changes via operations are the delta_i. Thus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. But how can we compute this without knowing S_b? Wait, the problem is that we can't compute this directly. But the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since we don't know b, but all arrays start as copies of b, the initial difference is zero. The changes via operations are the delta_i. Thus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But this is exactly (S_b - S_i). Thus, the total for each array is (S_b - S_i). But how can we compute this without knowing S_b? Ah! Here's the key: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since all arrays start as copies of b, the initial sum for each array is S_b. The changes via operations are the delta_i. Thus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. But how can we compute this without knowing S_b? Wait, the problem is that we can't compute this directly. But the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since we don't know b, but all arrays start as copies of b, the initial difference is zero. The changes via operations are the delta_i. Thus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But this is exactly (S_b - S_i). Thus, the total for each array is (S_b - S_i). But how can we compute this without knowing S_b? Ah! Here's the key insight: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since all arrays start as copies of b, the initial sum for each array is S_b. The changes via operations are the delta_i. Thus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. But how can we compute this without knowing S_b? Wait, the problem is that we can't compute this directly. But the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since we don't know b, but all arrays start as copies of b, the initial difference is zero. The changes via operations are the delta_i. Thus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But this is exactly (S_b - S_i). Thus, the total for each array is (S_b - S_i). But how can we compute this without knowing S_b? Ah! Here's the key: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since all arrays start as copies of b, the initial sum for each array is S_b. The changes via operations are the delta_i. Thus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. But how can we compute this without knowing S_b? Wait, the problem is that we can't compute this directly. But the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since we don't know b, but all arrays start as copies of b, the initial difference is zero. The changes via operations are the delta_i. Thus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But this is exactly (S_b - S_i). Thus, the total for each array is (S_b - S_i). But how can we compute this without knowing S_b? Ah! Here's the key insight: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). But since all arrays start as copies of b, the initial sum for each array is S_b. The changes via operations are the delta_i. Thus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. But how can we compute this without knowing S_b? Wait, the problem is that we can't compute this directly. The key is to realize that the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) But since we don't know b, but all arrays start as copies of b, the initial difference is zero. Thus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) But since we don't know b, but all arrays start as copies of b, the initial difference is zero. Thus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) But since we don't know b, but all arrays start as copies of b, the initial difference is zero. Thus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) But since we don't know b, but all arrays start as copies of b, the initial difference is zero. Thus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) But since we don't know b, but all arrays start as copies of b, the initial difference is zero. Thus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) But since we don't know b, but all arrays start as copies of b, the initial difference is zero. Thus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) But since we don't know b, but all arrays start as copies of b, the initial difference is zero. Thus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) But since we don't know b, but all arrays start as copies of b, the initial difference is zero. Thus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) But since we don't know b, but all arrays start as copies of b, the initial difference is zero. Thus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) But since we don't know b, but all arrays start as copies of b, the initial difference is zero. Thus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) But since we don't know b, but all arrays start as copies of b, the initial difference is zero. Thus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) But since we don't know b, but all arrays start as copies of b, the initial difference is zero. Thus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) But since we don't know b, but all arrays start as copies of b, the initial difference is zero. Thus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) But since we don't know b, but all arrays start as copies of b, the initial difference is zero. Thus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) But since we don't know b, but all arrays start as copies of b, the initial difference is zero. Thus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) But since we don't know b, but all arrays start as copies of b, the initial difference is zero. Thus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) But since we don't know b, but all arrays start as copies of b, the initial difference is zero. Thus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) But since we don't know b, but all arrays start as copies of b, the initial difference is zero. Thus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) But since we don't know b, but all arrays start as copies of b, the initial difference is zero. Thus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) But since we don't know b, but all arrays start as copies of b, the initial difference is zero. Thus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) But since we don't know b, but all arrays start as copies of b, the initial difference is zero. Thus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) But since we don't know b, but all arrays start as copies of b, the initial difference is zero. Thus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) But since we don't know b, but all arrays start as copies of b, the initial difference is zero. Thus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) But since we don't know b, but all arrays start as copies of b, the initial difference is zero. Thus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) But since we don't know b, but all arrays start as copies of b, the initial difference is zero. Thus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) But since we don't know b, but all arrays start as copies of b, the initial difference is zero. Thus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) But since we don't know b, but all arrays start as copies of b, the initial difference is zero. Thus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) But since we don't know b, but all arrays start as copies of b, the initial difference is zero. Thus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) But since we don't know b, but all arrays start as copies of b, the initial difference is zero. Thus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) But since we don't know b, but all arrays start as copies of b, the initial difference is zero. Thus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) But since we don't know b, but all arrays start as copies of b, the initial difference is zero. Thus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) But since we don't know b, but all arrays start as copies of b, the initial difference is zero. Thus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) But since we don't know b, but all arrays start as copies of b, the initial difference is zero. Thus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) But since we don't know b, but all arrays start as copies of b, the initial difference is zero. Thus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) But since we don't know b, but all arrays start as copies of b, the initial difference is zero. Thus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) But since we don't know b, but all arrays start as copies of b, the initial difference is zero. Thus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) But since we don't know b, but all arrays start as copies of b, the initial difference is zero. Thus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) But since we don't know b, but all arrays start as copies of b, the initial difference is zero. Thus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) But since we don't know b, but all arrays start as copies of b, the initial difference is zero. Thus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) But since we don't know b, but all arrays start as copies of b, the initial difference is zero. Thus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) But since we don't know b, but all arrays start as copies of b, the initial difference is zero. Thus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) But since we don't know b, but all arrays start as copies of b, the initial difference is zero. Thus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) But since we don't know b, but all arrays start as copies of b, the initial difference is zero. Thus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) But since we don't know b, but all arrays start as copies of b, the initial difference is zero. Thus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) But since we don't know b, but all arrays start as copies of b, the initial difference is zero. Thus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) But since we don't know b, but all arrays start as copies of b, the initial difference is zero. Thus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) But since we don't know b, but all arrays start as copies of b, the initial difference is zero. Thus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) But since we don't know b, but all arrays start as copies of b, the initial difference is zero. Thus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) But since we don't know b, but all arrays start as copies of b, the initial difference is zero. Thus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) But since we don't know b, but all arrays start as copies of b, the initial difference is zero. Thus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) But since we don't know b, but all arrays start as copies of b, the initial difference is zero. Thus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) But since we don't know b, but all arrays start as copies of b, the initial difference is zero. Thus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) But since we don't know b, but all arrays start as copies of b, the initial difference is zero. Thus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) But since we don't know b, but all arrays start as copies of b, the initial difference is zero. Thus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) But since we don't know b, but all arrays start as copies of b, the initial difference is zero. Thus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) But since we don't know b, but all arrays start as copies of b, the initial difference is zero. Thus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) But since we don't know b, but all arrays start as copies of b, the initial difference is zero. Thus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) But since we don't know b, but all arrays start as copies of b, the initial difference is zero. Thus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) But since we don't know b, but all arrays start as copies of b, the initial difference is zero. Thus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) But since we don't know b, but all arrays start as copies of b, the initial difference is zero. Thus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) But since we don't know b, but all arrays start as copies of b, the initial difference is zero. Thus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) But since we don't know b, but all arrays start as copies of b, the initial difference is zero. Thus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) But since we don't know b, but all arrays start as copies of b, the initial difference is zero. Thus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) But since we don't know b, but all arrays start as copies of b, the initial difference is zero. Thus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) But since we don't know b, but all arrays start as copies of b, the initial difference is zero. Thus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) But since we don't know b, but all arrays start as copies of b, the initial difference is zero. Thus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) But since we don't know b, but all arrays start as copies of b, the initial difference is zero. Thus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) But since we don't know b, but all arrays start as copies of b, the initial difference is zero. Thus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) But since we don't know b, but all arrays start as copies of b, the initial difference is zero. Thus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) But since we don't know b, but all arrays start as copies of b, the initial difference is zero. Thus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) But since we don't know b, but all arrays start as copies of b, the initial difference is zero. Thus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) But since we don't know b, but all arrays start as copies of b, the initial difference is zero. Thus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) But since we don't know b, but all arrays start as copies of b, the initial difference is zero. Thus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) But since we don't know b, but all arrays start as copies of b, the initial difference is zero. Thus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) But since we don't know b, but all arrays start as copies of b, the initial difference is zero. Thus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) But since we don't know b, but all arrays start as copies of b, the initial difference is zero. Thus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) But since we don't",
                                                                        "label": "code_analysis",
                                                                        "relation": "Continuation",
                                                                        "children": [],
                                                                        "parent_id": "thought_36"
                                                                      }
                                                                    ],
                                                                    "parent_id": "thought_35"
                                                                  }
                                                                ],
                                                                "parent_id": "thought_34"
                                                              }
                                                            ],
                                                            "parent_id": "thought_33"
                                                          }
                                                        ],
                                                        "parent_id": "thought_32"
                                                      }
                                                    ],
                                                    "parent_id": "thought_31"
                                                  }
                                                ],
                                                "parent_id": "thought_30"
                                              }
                                            ],
                                            "parent_id": "thought_29"
                                          }
                                        ],
                                        "parent_id": "thought_28"
                                      }
                                    ],
                                    "parent_id": "thought_27"
                                  }
                                ],
                                "parent_id": "thought_26"
                              }
                            ],
                            "parent_id": "thought_25"
                          }
                        ],
                        "parent_id": "thought_24"
                      }
                    ],
                    "parent_id": "thought_23"
                  }
                ],
                "parent_id": "thought_1"
              }
            ],
            "parent_id": "thought_0"
          }
        ],
        "parent_id": "root"
      }
    ],
    "metadata": {
      "task_id1": "block_completion_002631",
      "task_id2": "block_completion_008648",
      "task_id3": "block_completion_000201",
      "answer": null,
      "note": "the thinking is incomplete"
    },
    "original_reasoning": "<think>\nOkay, let's tackle these three programs one by one. Starting with program1.py. The problem is to find the special array and the number of operation2 uses. \n\nLooking at the code provided for program1, the solve function reads n and m, then loops over each array. The inner loop is over the elements of each array, but the code there is missing. The variables current and total are initialized but not used. The code then updates mx and mn based on total. The output is mn[1]+1 and mx[0]-mn[0]. \n\nHmm, the key here is to figure out what the 'total' variable represents. Since the problem involves operations that affect the arrays, maybe each array's contribution to some invariant can be tracked. \n\nThe operations for non-special arrays (operation1) and the special one (operation2) must affect the arrays in a way that allows us to find which array is special. \n\nLet me think about the operations. For operation1 (non-special), when you do it on array c_t (non-special), you subtract 1 from positions i and j (2<=i<j<=m-1), and add 1 to i-1 and j+1. The net change for the array's elements is that the total sum remains the same because -1-1 +1+1 =0. \n\nFor operation2 (special array), the operation subtracts 1 from i and j (2<=i<j<=m-2), adds 1 to i-1 and j+2. The total sum here is also 0. \n\nSo the sum of all elements in each array c_i is the same as the original array b. Therefore, the sum can't help us here. \n\nWait, but the problem requires us to find the special array. So there must be some other invariant or difference between the arrays. \n\nLet me think of the effect of the operations on some other property. Maybe the differences between certain elements? \n\nAlternatively, perhaps considering the differences between the arrays. Since all arrays start as copies of b, and each is modified by their own operations. The special array uses operation2, others use operation1. \n\nWait, the problem states that for non-special arrays, they use operation1 at least once. The special uses operation2 at least once. \n\nThe key is to find which array's modifications can only be done via operation2, and the others via operation1. \n\nAlternatively, perhaps the difference between the arrays can be analyzed. Let me think of the effect of each operation on some linear combination of the array elements. \n\nLet me think of the effect of each operation on the array's elements. \n\nFor operation1 on a non-special array (c_t where t\u2260k):\n\nThe operation affects positions i and j (between 2 and m-1). The changes are:\n\nc_t[i] -=1, c_t[j] -=1\n\nc_t[i-1] +=1, c_t[j+1] +=1 \n\nThe net effect on the array's elements is that the sum remains the same. \n\nBut perhaps looking at the differences between adjacent elements. Let's see:\n\nLet me consider the differences between consecutive elements. Let\u2019s denote d[i] = c[i] - c[i-1]. \n\nWait, maybe looking at the second differences? Or some other invariant. \n\nAlternatively, perhaps the sum of certain terms. Let me think of the sum over all elements multiplied by their position. \n\nAlternatively, maybe the parity or some other invariant. \n\nAlternatively, let's think of the effect of each operation on the array's elements. \n\nSuppose we consider the sum of all elements except the first and last. \n\nWait, for operation1: subtract 2 from positions i and j (each is subtracted 1, so total subtract 2), and add 2 to positions i-1 and j+1. So the total sum of the array remains the same. \n\nSame for operation2. \n\nHmm, maybe looking at the sum of elements in certain positions. \n\nAlternatively, perhaps the key is to find for each array, the possible number of operations applied. \n\nWait, the problem requires that the special array uses operation2 at least once, and others use operation1 at least once. \n\nThe problem says that the input is generated by starting with b, then for each non-special array, they perform operation1 at least once, and the special one uses operation2 at least once. \n\nThe goal is to find which array is the special one. \n\nLet me think of the effect of the operations on some invariant. \n\nSuppose we consider the sum of the array elements multiplied by their indices. \n\nWait, perhaps the key is to find for each array, the possible \"signature\" that can only be achieved via operation1 or operation2. \n\nAlternatively, let's think of the effect of each operation on the array's elements. \n\nLet me consider the effect of operation1 on the array. Let's see:\n\nSuppose we have an array element at position i and j. \n\nThe operation1 subtracts 1 from c[i] and c[j], adds 1 to c[i-1] and c[j+1]. \n\nThe net effect on the array is that the difference between c[i] and c[i-1] increases by 2 (since c[i] is decreased by 1, c[i-1] increased by 1 \u2192 their difference (c[i] - c[i-1]) becomes (c[i]-1) - (c[i-1]+1) = (c[i] - c[i-1]) -2. Wait, no, the difference between c[i] and c[i-1] is (c[i] - (c[i-1] +1)) = (original difference) -1 -1? Wait, maybe I should think in terms of the differences between adjacent elements. \n\nLet me define for each array, the differences between consecutive elements. Let\u2019s denote for array c, the differences as d_1 = c[1] - c[0], d_2 = c[2] - c[1], ..., d_{m-1} = c[m-1] - c[m-2]. \n\nThen, the total differences sum to c[m-1] - c[0]. \n\nNow, let's see how operation1 affects these differences. \n\nSuppose in operation1, we choose i and j (positions 2 <=i < j <= m-1). \n\nThe operation affects positions i and j (indices starting at 1?), or maybe the array is 0-based? The problem says \"array of length m\", so perhaps 1-based. \n\nWait, the problem says \"c_t[i] and c_t[j]\" where 2 \u2264 i < j \u2264 m-1 for operation1. So the indices are 1-based. \n\nSo for operation1 on positions i and j (1-based indices between 2 and m-1):\n\nThe changes are:\n\nc[i] -=1 \u2192 so the difference between c[i] and c[i-1] (d_i) becomes (c[i] -1) - c[i-1] \u2192 d_i -1. \n\nSimilarly, the difference between c[i+1] and c[i] (d_{i+1}) would be (c[i+1] - (c[i] -1)) \u2192 d_{i+1} +1. \n\nWait, perhaps it's better to track how each operation affects the differences. \n\nAlternatively, let's see how the operation affects the differences between consecutive elements. \n\nLet me think of the differences array D where D[p] = c[p] - c[p-1] for p from 1 to m-1 (assuming 1-based array). \n\nOperation1 on i and j (positions in the array, so indices 1-based):\n\nThe operation affects positions i and j (elements c[i] and c[j]). \n\nThe changes are:\n\nc[i] -=1 \u2192 so D[i] (which is c[i] - c[i-1]) becomes (c[i]-1) - c[i-1] \u2192 D[i] -1. \n\nSimilarly, D[i+1] (c[i+1] - c[i]) becomes (c[i+1] - (c[i]-1)) \u2192 D[i+1] +1. \n\nWait, but the operation also affects c[j], so similarly for j:\n\nc[j] -=1 \u2192 D[j] (c[j] - c[j-1]) becomes (c[j]-1) - c[j-1] \u2192 D[j] -1. \n\nAnd D[j+1] (c[j+1] - c[j]) becomes (c[j+1] - (c[j]-1)) \u2192 D[j+1] +1. \n\nAdditionally, the operation adds 1 to c[i-1] and c[j+1]. \n\nWait, the operation adds 1 to c[i-1] and c[j+1]. \n\nSo for c[i-1], which is at position i-1, the difference D[i-1] (c[i-1] - c[i-2]) becomes (c[i-1]+1) - c[i-2] \u2192 D[i-1] +1. \n\nSimilarly, D[i] (which is c[i] - c[i-1] after the change) would be (c[i] -1) - (c[i-1]+1) \u2192 (original c[i] - c[i-1]) -2 \u2192 D[i] -2. \n\nWait, I think I need to re-calculate this properly. \n\nLet me re-express the operation step by step. \n\nOriginal values:\n\nc[i-1], c[i], c[j], c[j+1]\n\nAfter operation1:\n\nc[i-1] +=1 \u2192 new value is c[i-1] +1\n\nc[i] -=1 \u2192 new value is c[i] -1\n\nc[j] -=1 \u2192 new value is c[j] -1\n\nc[j+1] +=1 \u2192 new value is c[j+1] +1\n\nThe other elements remain the same. \n\nNow, the differences D for the positions around i and j:\n\nFor D[i-1] (difference between i-1 and i-2):\n\nWait, D[i-1] is the difference between position i-1 and i-2. But the change in c[i-1] affects D[i-1] and D[i]. \n\nWait, D[i-1] = c[i-1] - c[i-2]. After adding 1 to c[i-1], D[i-1] becomes (c[i-1]+1) - c[i-2] \u2192 D[i-1] +1. \n\nD[i] = c[i] - c[i-1]. After the changes, it's (c[i]-1) - (c[i-1]+1) \u2192 (c[i] - c[i-1]) -2 \u2192 D[i] -2. \n\nThen, D[i+1] = c[i+1] - c[i]. The c[i] is now c[i]-1, so D[i+1] becomes (c[i+1] - (c[i]-1)) \u2192 D[i+1] +1. \n\nSimilarly for the j part:\n\nD[j] = c[j] - c[j-1]. After subtracting 1 from c[j], it becomes (c[j]-1) - c[j-1] \u2192 D[j] -1. \n\nD[j+1] = c[j+1] +1 - (c[j] -1) \u2192 (original c[j+1] - c[j]) + (1 +1) \u2192 D[j+1] +2. \n\nWait, no. Let's see:\n\nOriginal D[j] is c[j] - c[j-1]. After subtracting 1 from c[j], D[j] becomes (c[j]-1) - c[j-1] \u2192 D[j] -1. \n\nD[j+1] is c[j+1] (original) +1 (from the operation) minus (c[j] -1) \u2192 (c[j+1] +1) - (c[j] -1) \u2192 (c[j+1] - c[j]) +2 \u2192 D[j+1] +2. \n\nSo the operation1 affects the differences as follows:\n\n- D[i-1] increases by 1.\n\n- D[i] decreases by 2.\n\n- D[i+1] increases by 1.\n\n- D[j] decreases by 1.\n\n- D[j+1] increases by 2.\n\nWait, but this is getting complicated. Maybe there's a better way. \n\nAlternatively, perhaps the key is to find for each array, the sum of certain terms that can only be altered by one of the operations. \n\nAlternatively, let's think of the effect of the operations on the array's elements. \n\nSuppose we consider the sum of all elements except the first and last. \n\nWait, for operation1, the total sum remains the same. \n\nHmm, perhaps the key is to look at the sum of the array's elements multiplied by their indices. \n\nAlternatively, maybe the parity of some value. \n\nAlternatively, let's think of the problem in terms of the original array b. Each array c_i is generated from b by applying some operations. \n\nThe special array c_k is modified using operation2, others with operation1. \n\nThe problem requires us to find which array is the special one. \n\nThe key idea might be that the special array's modifications can be expressed in terms of operation2, which has a different effect than operation1. \n\nLet me think of the effect of each operation on some invariant. \n\nSuppose we consider the sum over all elements multiplied by their position indices. Let's denote S = sum_{i=1 to m} (i * c_i). \n\nWait, but the problem's operations might affect this sum. \n\nAlternatively, perhaps the difference between the first and last elements. \n\nWait, let's think of the effect of each operation on the first and last elements. \n\nOperation1 adds 1 to c[i-1] and c[j+1]. \n\nSo for the first element (position 1), if i-1 is 1 (i=2), then the first element increases by 1. \n\nSimilarly, the last element (position m) can be affected if j+1 is m (j = m-1). \n\nBut operation1 can only be applied when i < j <= m-1. So j can be up to m-1, so j+1 can be m. \n\nSo for operation1, the first element can be increased, and the last can be increased. \n\nOperation2, on the other hand, for the special array, uses operation2. Let's see what that does. \n\nOperation2 on positions i and j (2 \u2264i < j \u2264 m-2). \n\nThe operation subtracts 1 from c[i] and c[j], adds 1 to c[i-1] and c[j+2]. \n\nSo the first element (position 1) can be increased if i-1 is 1 (i=2). \n\nThe last element (position m) can be affected if j+2 is m \u2192 j = m-2. \n\nSo for operation2, the first element can be increased, and the last element can be increased (if j is m-2). \n\nHmm, but how does this help us? \n\nAlternatively, perhaps the key is to look at the difference between the first and last elements. \n\nWait, let's see:\n\nFor operation1, the first element (position 1) can be increased by 1 (if i=2, then c[1] +=1). \n\nThe last element (position m) can be increased by 1 (if j = m-1, then c[m] +=1). \n\nFor operation2, the first element can be increased (if i=2, then c[1] +=1). \n\nThe last element can be increased if j = m-2 \u2192 then j+2 = m \u2192 so c[m] +=1. \n\nSo both operations can affect the first and last elements. \n\nHmm, maybe this isn't the way. \n\nAnother approach: since all arrays start as copies of b, and each is modified by their own operations. The special array uses operation2, others use operation1. \n\nThe problem requires that for each non-special array, they perform at least one operation1, and the special one at least one operation2. \n\nThe key is to find which array's modifications can only be achieved via operation2, and others via operation1. \n\nWait, but how can we distinguish between the arrays? \n\nLet me think of the effect of the operations on some invariant. \n\nSuppose we consider the sum of all elements except the first and last. \n\nWait, for operation1, the total sum remains the same. \n\nAlternatively, perhaps the sum of the first and last elements. \n\nLet me see:\n\nFor operation1, when applied to i and j:\n\nThe first element (position 1) is increased by 1 if i-1 is 1 (i=2). \n\nThe last element (position m) is increased by 1 if j+1 is m (j = m-1). \n\nSo the first and last elements can be increased. \n\nThe total change for the first and last elements depends on the choice of i and j. \n\nFor operation2, similarly, the first element can be increased (if i=2), and the last element can be increased (if j = m-2 \u2192 j+2 = m). \n\nHmm, but this might not help. \n\nAlternatively, perhaps the key is to look at the difference between the sum of even and odd positions, or some other pattern. \n\nAlternatively, let's think of the problem in terms of the total number of operations applied. \n\nWait, but the problem requires that each non-special array has at least one operation1, and the special has at least one operation2. \n\nThe problem says that the input is generated according to the procedure, so each array's modifications are done via their respective operations. \n\nThe key idea might be that the special array's modifications can be expressed in terms of operation2, which has a different effect on some invariant than operation1. \n\nLet me think of the effect of each operation on the array's elements. \n\nSuppose we consider the sum of all elements except the first and last. \n\nWait, for operation1:\n\nThe operation subtracts 1 from c[i] and c[j], adds 1 to c[i-1] and c[j+1]. \n\nThe total change for the sum of all elements except first and last is: \n\n-1 (from c[i]) -1 (from c[j]) +1 (from c[i-1] if i-1 is not first or last?) \n\nWait, if i is 2, then i-1 is 1 (the first element). So adding to the first element doesn't affect the sum of non-first and non-last elements. \n\nSimilarly, j+1 could be the last element (if j is m-1). \n\nHmm, this is getting too complicated. \n\nAlternative approach: Let's think of the problem's solution. The code provided for program1 has variables mx and mn, which track the maximum and minimum of some 'total' value for each array. The output is the index of the array with the minimum total, and the difference between the maximum and minimum. \n\nSo the 'total' variable must be something that can be computed for each array, and the special array's total is the minimum, and the number of operation2 uses is the difference between the maximum and minimum. \n\nWhat could 'total' represent? \n\nLooking at the code's structure: \n\nIn the loop over each array (i in 0..n-1), for each element in the array, the code is supposed to compute 'current' and 'total'. \n\nThe code then updates mx and mn with (total, i). \n\nThe final output is mn[1]+1 (the index of the array with the smallest total) and mx[0] - mn[0] (the difference between the maximum and minimum totals). \n\nSo the 'total' for each array must be a value that is equal to the number of operation2 uses plus some base value, such that the difference between the max and min gives the count. \n\nWait, perhaps the 'total' is the sum of some terms that are affected by the operations. \n\nLet me think of the effect of each operation on the array's elements. \n\nSuppose we consider the sum of all elements except the first and last. \n\nWait, for operation1, the total sum remains the same. \n\nAlternatively, perhaps the key is to look at the sum of the array's elements multiplied by their indices. \n\nAlternatively, let's think of the following: \n\nEach operation1 on a non-special array contributes a certain value to the array's 'total', and operation2 on the special array contributes another. \n\nWait, perhaps the 'total' is the sum of the array's elements multiplied by their positions. \n\nWait, let me think of the effect of each operation on this sum. \n\nLet me denote S = sum_{p=1 to m} (p * c[p]). \n\nFor operation1 on positions i and j (indices 2 <=i <j <= m-1):\n\nThe changes are:\n\nc[i] -=1 \u2192 contributes -i to S.\n\nc[j] -=1 \u2192 contributes -j to S.\n\nc[i-1] +=1 \u2192 contributes + (i-1) to S.\n\nc[j+1] +=1 \u2192 contributes + (j+1) to S.\n\nTotal change in S: \n\n(-i -j) + (i-1 + j+1) = (-i -j) + (i + j) = 0. \n\nSo operation1 doesn't change S. \n\nFor operation2 on the special array (positions i and j, 2<=i<j<=m-2):\n\nThe changes are:\n\nc[i] -=1 \u2192 -i.\n\nc[j] -=1 \u2192 -j.\n\nc[i-1] +=1 \u2192 + (i-1).\n\nc[j+2] +=1 \u2192 + (j+2).\n\nTotal change in S: \n\n(-i -j) + (i-1 + j+2) = (-i-j) + (i +j +1) \u2192 1. \n\nSo each operation2 increases S by 1. \n\nAh! This is a crucial insight. \n\nSo for the special array, each operation2 increases S by 1. \n\nFor non-special arrays, their operations (operation1) do not change S. \n\nThe original array b has a certain S value. \n\nEach non-special array starts as b and undergoes some number of operation1 (each not changing S), so their S remains the same as b. \n\nThe special array starts as b and undergoes some number of operation2 (each adding 1 to S). So its S is S_b + x, where x is the number of operation2 uses. \n\nTherefore, the S for the special array is S_b + x, and all other arrays have S = S_b. \n\nThus, the array with S = S_b + x will have the maximum S, and the others have S = S_b. \n\nWait, but how do we compute this? \n\nWait, the problem requires us to find the array with the maximum S, because that's the special array. Because only the special array's S is increased by x (the number of operation2 uses). \n\nWait, but the code in program1 is using 'total' to track something, and the maximum and minimum are being tracked. \n\nWait, according to the code's output, the special array is the one with the minimum 'total', and the difference between the maximum and minimum gives the count. \n\nHmm, perhaps I made a mistake in the direction. Let me re-calculate the effect of operation2 on S. \n\nWait, let me re-calculate the operation2's effect on S. \n\nOperation2 on i and j (positions 2<=i<j<=m-2):\n\nThe changes are:\n\nc[i] -=1 \u2192 contributes -i to S.\n\nc[j] -=1 \u2192 contributes -j to S.\n\nc[i-1] +=1 \u2192 contributes + (i-1) to S.\n\nc[j+2] +=1 \u2192 contributes + (j+2) to S.\n\nTotal change: \n\n(-i -j) + (i-1 + j+2) \n\n= (-i -j) + (i + j +1) \n\n= 1. \n\nSo each operation2 increases S by 1. \n\nThus, the special array's S is S_b + x, where x is the number of operation2 uses. \n\nAll other arrays have S equal to S_b (since their operations don't change S). \n\nTherefore, the array with the maximum S is the special array, and the difference between its S and others is x. \n\nWait, but in the code's output, it's using mn[1] (the array with the minimum total) as the special array. That contradicts this conclusion. \n\nHmm, so perhaps I made a mistake in the direction. Let me think again. \n\nWait, the problem says that the special array is the one that uses operation2. The other arrays use operation1. \n\nThe S for the special array is S_b + x. \n\nThe other arrays have S = S_b. \n\nThus, the maximum S is the special array's S. \n\nTherefore, the array with the maximum S is the special array, and the difference between its S and others is x. \n\nBut in the code's current structure, the code is tracking 'total' for each array, and then taking the maximum and minimum. The output is mn[1]+1 (the array with the minimum total) and the difference between the maximum and minimum. \n\nThis suggests that perhaps the 'total' variable is actually the negative of S, or something else. \n\nAlternatively, maybe I have the sign wrong. Let me re-calculate the effect of operation2 again. \n\nWait, the operation2's effect on S is +1 per operation. So the special array's S is higher than others. \n\nThus, the maximum S is the special array. \n\nTherefore, the code's current approach of taking the minimum 'total' as the special array is incorrect. \n\nHmm, so perhaps the code's 'total' is not S but something else. \n\nWait, maybe the code is using a different invariant. Let me think again. \n\nAlternatively, perhaps the invariant is the sum of the array's elements multiplied by (m - their position). \n\nWait, let me think of another approach. \n\nSuppose we consider the difference between the first and last elements. \n\nWait, for operation1, when applied to i and j, the first element can be increased (if i=2), and the last can be increased (if j = m-1). \n\nThe net effect on (first + last) would be +2 (since first increases by 1 and last by 1). \n\nWait, but operation1's effect on first and last depends on the choice of i and j. \n\nAlternatively, perhaps the key is to look at the sum of the array's elements multiplied by their distance from the start or end. \n\nAlternatively, let me think of the problem's sample input. \n\nIn the first sample note, the special array is c3. \n\nThe code's output is mn[1]+1 (the array with the minimum total) and the difference between max and min. \n\nIn the first sample, the special array (c3) has S = S_b + x (x=1). \n\nThe other arrays have S = S_b. \n\nThus, the maximum S is the special array. \n\nSo the code's current approach of taking the minimum 'total' as the special array is wrong. \n\nHmm, so perhaps the code is using a different invariant. \n\nWait, maybe I made a mistake in the calculation of the effect of operation2 on S. Let me re-calculate. \n\nWait, the operation2's effect on S is: \n\nThe change in S is (sum of (position * delta_c_p) for all p). \n\nThe delta for each position: \n\nc[i] -=1 \u2192 delta_c[i] = -1 \u2192 contributes -i. \n\nc[j] -=1 \u2192 delta_c[j] = -1 \u2192 contributes -j. \n\nc[i-1] +=1 \u2192 delta_c[i-1] = +1 \u2192 contributes (i-1). \n\nc[j+2] +=1 \u2192 delta_c[j+2] = +1 \u2192 contributes (j+2). \n\nTotal change: \n\n(-i -j) + (i-1) + (j+2) \n\n= (-i -j) + i -1 + j +2 \n\n= ( -i +i ) + (-j +j) + (-1 +2) \n\n= 1. \n\nYes, so each operation2 increases S by 1. \n\nThus, the special array's S is S_b + x. \n\nThe other arrays have S = S_b. \n\nThus, the array with the maximum S is the special array, and the difference between its S and others is x. \n\nTherefore, the code's current approach is incorrect. \n\nBut the code's solve function is using variables mx and mn, and the output is mn[1]+1 (the array with the smallest total) and the difference between the maximum and minimum. \n\nThis suggests that perhaps the 'total' variable is actually the negative of S. \n\nAlternatively, maybe the code is using a different invariant. \n\nWait, perhaps the code is using the sum of the array's elements multiplied by their indices, but in a different way. \n\nAlternatively, maybe the code is considering the sum of the array's elements multiplied by (position -1). \n\nWait, let me think of another approach. \n\nSuppose we consider the sum of the array's elements except the first and last. \n\nWait, for operation1, the total sum remains the same. \n\nHmm, not helpful. \n\nAlternatively, perhaps the code is using the sum of the array's elements multiplied by their position indices, but in a way that the special array's total is the minimum. \n\nWait, if the code's 'total' is (S_b - current array's S), then the special array would have (S_b - (S_b +x)) = -x, which is the minimum. \n\nThen the maximum would be 0 (for other arrays). \n\nThe difference between max and min would be x. \n\nAh! That makes sense. \n\nSo the code's 'total' is (S_b - current array's S). \n\nWait, but how can we compute S_b? \n\nWait, the original array b is not given. But all arrays start as copies of b. \n\nThe non-special arrays undergo operation1 (which doesn't change S), so their S remains S_b. \n\nThe special array's S is S_b + x. \n\nThus, for each array c_i: \n\nIf it's non-special: S_i = S_b \u2192 (S_b - S_i) = 0. \n\nIf it's special: S_i = S_b +x \u2192 (S_b - S_i) = -x. \n\nThus, the minimum of (S_b - S_i) is -x (the special array), and the maximum is 0 (others). \n\nThe difference between max and min is x. \n\nThus, the code's approach is correct. \n\nTherefore, the 'total' for each array is (S_b - S_i). \n\nBut how do we compute this without knowing S_b? \n\nWait, since all non-special arrays have S_i = S_b, their (S_b - S_i) is zero. \n\nThe special array has (S_b - S_i) = -x. \n\nThus, the minimum of all (S_b - S_i) is -x (the special array), and the maximum is 0 (others). \n\nThe difference between the maximum (0) and the minimum (-x) is x. \n\nThus, the code's approach is correct. \n\nTherefore, the 'total' for each array is (S_b - S_i). \n\nBut how do we compute this without knowing S_b? \n\nWait, since all non-special arrays have S_i = S_b, their (S_b - S_i) is zero. \n\nThe special array's (S_b - S_i) is -x. \n\nThus, the total for each array is (S_b - S_i) = (sum_{p=1 to m} p * b[p]) - (sum_{p=1 to m} p * c_i[p]). \n\nBut since we don't know b, but all arrays start as copies of b, then for non-special arrays, their S_i is S_b. \n\nThus, the total for non-special arrays is zero. \n\nThe special array's total is -x. \n\nThus, the minimum total is -x (the special array), and the maximum is 0. \n\nThe difference between max and min is x. \n\nTherefore, the code's approach is correct. \n\nNow, the problem is to compute for each array the value (S_b - S_i). \n\nBut how can we compute this without knowing S_b? \n\nWait, since all non-special arrays have S_i = S_b, their (S_b - S_i) is zero. \n\nThe special array's (S_b - S_i) is -x. \n\nThus, the total for each array is (S_b - S_i) = (sum_{p} p * b[p] - sum_{p} p * c_i[p]). \n\nBut since all arrays start as copies of b, the initial S_i for each array is S_b. \n\nThe changes to the array via operations affect S_i. \n\nFor non-special arrays, their operations (operation1) do not change S_i. \n\nThus, their S_i remains S_b \u2192 their total is zero. \n\nThe special array's S_i is S_b + x \u2192 total is -x. \n\nThus, the total for each array is (S_b - S_i) = - (number of operation2 uses if it's the special array, else 0). \n\nTherefore, the minimum total is the special array's total (-x), and the maximum is 0. \n\nThus, the code's approach is correct. \n\nNow, the code needs to compute for each array the value (S_b - S_i). \n\nBut how can we compute this without knowing S_b? \n\nWait, since all non-special arrays have S_i = S_b, their (S_b - S_i) is zero. \n\nThe special array's (S_b - S_i) is -x. \n\nThus, the total for each array is (S_b - S_i) = (sum_{p} p * b[p] - sum_{p} p * c_i[p]). \n\nBut since all arrays start as copies of b, the initial sum for each array is S_b. \n\nThe changes via operations affect the sum. \n\nThe non-special arrays' operations (operation1) do not change their sum. \n\nThe special array's operations (operation2) increase their sum by x. \n\nThus, the total for each array is (S_b - S_i) = (S_b - (S_b + delta_i)), where delta_i is the change in S due to operations. \n\nFor non-special arrays, delta_i is 0 \u2192 total is 0. \n\nFor the special array, delta_i is x \u2192 total is -x. \n\nThus, the total for each array is -(delta_i). \n\nThe delta_i for non-special arrays is 0, for the special array it's x. \n\nThus, the total for each array is -delta_i. \n\nThe delta_i for each array is the number of operation2 uses (only for the special array, others have 0). \n\nThus, the code's 'total' for each array is the negative of the delta_i. \n\nTherefore, the code needs to compute for each array the value (S_b - S_i) = -delta_i. \n\nBut how can we compute this without knowing S_b? \n\nWait, since all non-special arrays have delta_i =0, their (S_b - S_i) is zero. \n\nThe special array's (S_b - S_i) is -x. \n\nThus, the total for each array is (sum_{p} p * b[p] - sum_{p} p * c_i[p]). \n\nBut since all arrays start as copies of b, the initial sum for each array is S_b. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (S_b - (S_b + delta_i)) = -delta_i. \n\nBut how do we compute this without knowing S_b? \n\nWait, the key is that for non-special arrays, their delta_i is zero. \n\nThus, the total for non-special arrays is zero. \n\nThe special array's total is -x. \n\nThus, the minimum total is the special array's total (-x), and the maximum is 0. \n\nThe difference between the maximum and minimum is x. \n\nThus, the code's approach is correct. \n\nNow, the problem is to compute for each array the value (S_b - S_i). \n\nBut how can we compute this without knowing S_b? \n\nWait, since all arrays start as copies of b, the initial S_i for each array is S_b. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (S_b - (S_b + delta_i)) = -delta_i. \n\nBut delta_i is the number of operation2 uses (only for the special array). \n\nThus, the total for each array is -delta_i. \n\nThe delta_i for non-special arrays is zero. \n\nThus, the total for each array is (sum_{p} p * b[p] - sum_{p} p * c_i[p]). \n\nBut since we don't know b, but all arrays start as copies of b, the initial sum for each array is S_b. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (S_b - (S_b + delta_i)) = -delta_i. \n\nBut how can we compute this without knowing S_b? \n\nWait, the total for each array can be computed as (sum_{p} p * b[p] - sum_{p} p * c_i[p]). \n\nBut since all arrays start as copies of b, the initial sum for each array is S_b. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (S_b - (S_b + delta_i)) = -delta_i. \n\nBut how can we compute this without knowing S_b? \n\nWait, the key is that for non-special arrays, their delta_i is zero. \n\nThus, their total is zero. \n\nThe special array's total is -x. \n\nThus, the total for each array is (sum_{p} p * (b[p] - c_i[p])). \n\nBut since b is the initial array, and each array starts as a copy of b, the initial difference is zero. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = -delta_i. \n\nBut how can we compute this without knowing b? \n\nWait, the problem states that all arrays are generated from b. \n\nThe changes to each array are done via their own operations. \n\nThe non-special arrays' operations (operation1) do not change their S_i. \n\nThus, their S_i remains S_b. \n\nThe special array's S_i is S_b + x. \n\nThus, the total for each array is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. \n\nBut how can we compute this without knowing S_b? \n\nWait, the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])). \n\nBut since we don't know b, but all arrays start as copies of b, the initial sum for each array is S_b. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (S_b - (S_b + delta_i)) = -delta_i. \n\nBut how can we compute this without knowing S_b? \n\nWait, the key is that the total for each array is (sum_{p} p * (b[p] - c_i[p])). \n\nBut since all arrays start as copies of b, the initial difference is zero. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (S_b - S_i) = -delta_i. \n\nBut how can we compute this without knowing b? \n\nWait, the problem is that we don't know b. \n\nBut perhaps the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p * b[p] - sum_{p} p * c_i[p]). \n\nBut since all arrays start as copies of b, the initial sum for each array is S_b. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (S_b - (S_b + delta_i)) = -delta_i. \n\nBut how can we compute this without knowing S_b? \n\nWait, the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p * b[p] - sum_{p} p * c_i[p]). \n\nBut since all arrays start as copies of b, the initial sum for each array is S_b. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (S_b - (S_b + delta_i)) = -delta_i. \n\nBut how can we compute this without knowing S_b? \n\nWait, the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])). \n\nBut since all arrays start as copies of b, the initial difference is zero. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p * (b[p] - (c_i[p] - delta_i's contribution))). \n\nHmm, this is getting too tangled. \n\nWait, perhaps the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])). \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p * (b[p] - (c_i[p] - delta_i's contribution))). \n\nWait, perhaps the total can be computed as (sum_{p} p * (b[p] - c_i[p])) = (S_b - S_i). \n\nBut S_i is the current sum of p*c_i[p]. \n\nThus, the total for array i is (S_b - S_i). \n\nBut how can we compute this without knowing S_b? \n\nAh! Here's the key insight: \n\nThe non-special arrays have S_i = S_b. \n\nThus, their total (S_b - S_i) is zero. \n\nThe special array has S_i = S_b + x \u2192 total is -x. \n\nThus, the minimum total is -x (the special array), and the maximum is 0 (others). \n\nThe difference between max and min is x. \n\nThus, the code's approach is correct. \n\nBut how do we compute the total for each array? \n\nThe total for each array is (S_b - S_i) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since we don't know b, but all arrays start as copies of b, the initial sum for each array is S_b. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (S_b - (S_b + delta_i)) = -delta_i. \n\nBut how can we compute this without knowing S_b? \n\nWait, the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])). \n\nBut since all arrays start as copies of b, the initial difference is zero. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p * (b[p] - (c_i[p] - delta_i's contribution))). \n\nHmm, perhaps the total can be computed as (sum_{p} p * (b[p] - c_i[p])) = (S_b - S_i). \n\nBut since S_i = S_b + delta_i, this is (S_b - (S_b + delta_i)) = -delta_i. \n\nThus, the total for each array is -delta_i. \n\nBut how can we compute this without knowing S_b? \n\nWait, the problem is that we don't know S_b. \n\nBut the key is that for non-special arrays, their delta_i is zero, so their total is zero. \n\nThe special array's total is -x. \n\nThus, the minimum total is the special array's total, and the maximum is zero. \n\nThe difference between max and min is x. \n\nThus, the code's approach is correct. \n\nNow, the code needs to compute for each array the value (S_b - S_i) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since we don't know b, but all arrays start as copies of b, the initial sum for each array is S_b. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. \n\nBut how can we compute this without knowing S_b? \n\nWait, the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])). \n\nBut since all arrays start as copies of b, the initial difference is zero. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p * (b[p] - (c_i[p] - delta_i's contribution))). \n\nHmm, perhaps the total can be computed as (sum_{p} p * (b[p] - c_i[p])) = (S_b - S_i). \n\nBut since S_i = S_b + delta_i, this is (S_b - (S_b + delta_i)) = -delta_i. \n\nThus, the total for each array is -delta_i. \n\nBut how can we compute this without knowing S_b? \n\nWait, the problem is that we don't know S_b. \n\nBut the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])). \n\nBut since all arrays start as copies of b, the initial difference is zero. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p * (b[p] - (c_i[p] - delta_i's contribution))). \n\nHmm, perhaps the total can be computed as (sum_{p} p * (b[p] - c_i[p])) = (S_b - S_i). \n\nBut since S_i = S_b + delta_i, this is (S_b - (S_b + delta_i)) = -delta_i. \n\nThus, the total for each array is -delta_i. \n\nBut how can we compute this without knowing S_b? \n\nWait, the problem is that we don't know b. \n\nBut the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since all arrays start as copies of b, the initial sum for each array is S_b. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (S_b - (S_b + delta_i)) = -delta_i. \n\nBut how can we compute this without knowing S_b? \n\nAh! Here's the key: \n\nThe total for each array is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since all arrays start as copies of b, the initial sum for each array is S_b. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (S_b - (S_b + delta_i)) = -delta_i. \n\nBut how can we compute this without knowing S_b? \n\nWait, the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since we don't know b, but all arrays start as copies of b, the initial sum for each array is S_b. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. \n\nBut how can we compute this without knowing S_b? \n\nWait, the problem is that we can't compute this directly. \n\nBut perhaps the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since all arrays start as copies of b, the initial sum for each array is S_b. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. \n\nBut how can we compute this without knowing S_b? \n\nWait, the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since all arrays start as copies of b, the initial sum for each array is S_b. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. \n\nBut how can we compute this without knowing S_b? \n\nAh! Here's the trick: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since all arrays start as copies of b, the initial sum for each array is S_b. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. \n\nBut how can we compute this without knowing S_b? \n\nWait, the problem is that we don't know S_b. \n\nBut the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since all arrays start as copies of b, the initial sum for each array is S_b. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. \n\nBut how can we compute this without knowing S_b? \n\nWait, the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut this is exactly (S_b - S_i). \n\nThus, the total for each array is (S_b - S_i). \n\nBut how can we compute this without knowing S_b? \n\nAh! Here's the key: \n\nThe total for each array is (S_b - S_i) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since all arrays start as copies of b, the initial sum for each array is S_b. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (S_b - (S_b + delta_i)) = -delta_i. \n\nBut how can we compute this without knowing S_b? \n\nWait, the problem is that we can't compute this directly. \n\nBut the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since all arrays start as copies of b, the initial sum for each array is S_b. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. \n\nBut how can we compute this without knowing S_b? \n\nWait, the problem is that we can't compute this directly. \n\nBut the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut this is exactly (S_b - S_i). \n\nThus, the total for each array is (S_b - S_i). \n\nBut how can we compute this without knowing S_b? \n\nAh! Here's the key insight: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since all arrays start as copies of b, the initial sum for each array is S_b. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. \n\nBut how can we compute this without knowing S_b? \n\nWait, the problem is that we can't compute this directly. \n\nBut the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut this is exactly (S_b - S_i). \n\nThus, the total for each array is (S_b - S_i). \n\nBut how can we compute this without knowing S_b? \n\nAh! Here's the trick: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since all arrays start as copies of b, the initial sum for each array is S_b. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. \n\nBut how can we compute this without knowing S_b? \n\nWait, the problem is that we can't compute this directly. \n\nBut the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut this is exactly (S_b - S_i). \n\nThus, the total for each array is (S_b - S_i). \n\nBut how can we compute this without knowing S_b? \n\nAh! Here's the key: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since all arrays start as copies of b, the initial sum for each array is S_b. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. \n\nBut how can we compute this without knowing S_b? \n\nWait, the problem is that we can't compute this directly. \n\nBut the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut this is exactly (S_b - S_i). \n\nThus, the total for each array is (S_b - S_i). \n\nBut how can we compute this without knowing S_b? \n\nAh! Here's the key insight: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since all arrays start as copies of b, the initial sum for each array is S_b. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. \n\nBut how can we compute this without knowing S_b? \n\nWait, the problem is that we can't compute this directly. \n\nBut the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut this is exactly (S_b - S_i). \n\nThus, the total for each array is (S_b - S_i). \n\nBut how can we compute this without knowing S_b? \n\nAh! Here's the key: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since all arrays start as copies of b, the initial sum for each array is S_b. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. \n\nBut how can we compute this without knowing S_b? \n\nWait, the problem is that we can't compute this directly. \n\nBut the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut this is exactly (S_b - S_i). \n\nThus, the total for each array is (S_b - S_i). \n\nBut how can we compute this without knowing S_b? \n\nAh! Here's the key insight: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since all arrays start as copies of b, the initial sum for each array is S_b. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. \n\nBut how can we compute this without knowing S_b? \n\nWait, the problem is that we can't compute this directly. \n\nBut the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut this is exactly (S_b - S_i). \n\nThus, the total for each array is (S_b - S_i). \n\nBut how can we compute this without knowing S_b? \n\nAh! Here's the key: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since all arrays start as copies of b, the initial sum for each array is S_b. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. \n\nBut how can we compute this without knowing S_b? \n\nWait, the problem is that we can't compute this directly. \n\nBut the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut this is exactly (S_b - S_i). \n\nThus, the total for each array is (S_b - S_i). \n\nBut how can we compute this without knowing S_b? \n\nAh! Here's the key insight: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since all arrays start as copies of b, the initial sum for each array is S_b. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. \n\nBut how can we compute this without knowing S_b? \n\nWait, the problem is that we can't compute this directly. \n\nBut the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut this is exactly (S_b - S_i). \n\nThus, the total for each array is (S_b - S_i). \n\nBut how can we compute this without knowing S_b? \n\nAh! Here's the key: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since all arrays start as copies of b, the initial sum for each array is S_b. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. \n\nBut how can we compute this without knowing S_b? \n\nWait, the problem is that we can't compute this directly. \n\nBut the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut this is exactly (S_b - S_i). \n\nThus, the total for each array is (S_b - S_i). \n\nBut how can we compute this without knowing S_b? \n\nAh! Here's the key insight: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since all arrays start as copies of b, the initial sum for each array is S_b. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. \n\nBut how can we compute this without knowing S_b? \n\nWait, the problem is that we can't compute this directly. \n\nBut the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut this is exactly (S_b - S_i). \n\nThus, the total for each array is (S_b - S_i). \n\nBut how can we compute this without knowing S_b? \n\nAh! Here's the key: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since all arrays start as copies of b, the initial sum for each array is S_b. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. \n\nBut how can we compute this without knowing S_b? \n\nWait, the problem is that we can't compute this directly. \n\nBut the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut this is exactly (S_b - S_i). \n\nThus, the total for each array is (S_b - S_i). \n\nBut how can we compute this without knowing S_b? \n\nAh! Here's the key insight: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since all arrays start as copies of b, the initial sum for each array is S_b. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. \n\nBut how can we compute this without knowing S_b? \n\nWait, the problem is that we can't compute this directly. \n\nBut the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut this is exactly (S_b - S_i). \n\nThus, the total for each array is (S_b - S_i). \n\nBut how can we compute this without knowing S_b? \n\nAh! Here's the key: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since all arrays start as copies of b, the initial sum for each array is S_b. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. \n\nBut how can we compute this without knowing S_b? \n\nWait, the problem is that we can't compute this directly. \n\nBut the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut this is exactly (S_b - S_i). \n\nThus, the total for each array is (S_b - S_i). \n\nBut how can we compute this without knowing S_b? \n\nAh! Here's the key insight: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since all arrays start as copies of b, the initial sum for each array is S_b. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. \n\nBut how can we compute this without knowing S_b? \n\nWait, the problem is that we can't compute this directly. \n\nBut the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut this is exactly (S_b - S_i). \n\nThus, the total for each array is (S_b - S_i). \n\nBut how can we compute this without knowing S_b? \n\nAh! Here's the key: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since all arrays start as copies of b, the initial sum for each array is S_b. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. \n\nBut how can we compute this without knowing S_b? \n\nWait, the problem is that we can't compute this directly. \n\nBut the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut this is exactly (S_b - S_i). \n\nThus, the total for each array is (S_b - S_i). \n\nBut how can we compute this without knowing S_b? \n\nAh! Here's the key insight: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since all arrays start as copies of b, the initial sum for each array is S_b. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. \n\nBut how can we compute this without knowing S_b? \n\nWait, the problem is that we can't compute this directly. \n\nBut the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut this is exactly (S_b - S_i). \n\nThus, the total for each array is (S_b - S_i). \n\nBut how can we compute this without knowing S_b? \n\nAh! Here's the key: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since all arrays start as copies of b, the initial sum for each array is S_b. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. \n\nBut how can we compute this without knowing S_b? \n\nWait, the problem is that we can't compute this directly. \n\nBut the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut this is exactly (S_b - S_i). \n\nThus, the total for each array is (S_b - S_i). \n\nBut how can we compute this without knowing S_b? \n\nAh! Here's the key insight: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since all arrays start as copies of b, the initial sum for each array is S_b. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. \n\nBut how can we compute this without knowing S_b? \n\nWait, the problem is that we can't compute this directly. \n\nBut the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut this is exactly (S_b - S_i). \n\nThus, the total for each array is (S_b - S_i). \n\nBut how can we compute this without knowing S_b? \n\nAh! Here's the key: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since all arrays start as copies of b, the initial sum for each array is S_b. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. \n\nBut how can we compute this without knowing S_b? \n\nWait, the problem is that we can't compute this directly. \n\nBut the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut this is exactly (S_b - S_i). \n\nThus, the total for each array is (S_b - S_i). \n\nBut how can we compute this without knowing S_b? \n\nAh! Here's the key insight: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since all arrays start as copies of b, the initial sum for each array is S_b. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. \n\nBut how can we compute this without knowing S_b? \n\nWait, the problem is that we can't compute this directly. \n\nBut the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut this is exactly (S_b - S_i). \n\nThus, the total for each array is (S_b - S_i). \n\nBut how can we compute this without knowing S_b? \n\nAh! Here's the key: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since all arrays start as copies of b, the initial sum for each array is S_b. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. \n\nBut how can we compute this without knowing S_b? \n\nWait, the problem is that we can't compute this directly. \n\nBut the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut this is exactly (S_b - S_i). \n\nThus, the total for each array is (S_b - S_i). \n\nBut how can we compute this without knowing S_b? \n\nAh! Here's the key insight: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since all arrays start as copies of b, the initial sum for each array is S_b. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. \n\nBut how can we compute this without knowing S_b? \n\nWait, the problem is that we can't compute this directly. \n\nBut the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut this is exactly (S_b - S_i). \n\nThus, the total for each array is (S_b - S_i). \n\nBut how can we compute this without knowing S_b? \n\nAh! Here's the key: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since all arrays start as copies of b, the initial sum for each array is S_b. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. \n\nBut how can we compute this without knowing S_b? \n\nWait, the problem is that we can't compute this directly. \n\nBut the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut this is exactly (S_b - S_i). \n\nThus, the total for each array is (S_b - S_i). \n\nBut how can we compute this without knowing S_b? \n\nAh! Here's the key insight: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since all arrays start as copies of b, the initial sum for each array is S_b. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. \n\nBut how can we compute this without knowing S_b? \n\nWait, the problem is that we can't compute this directly. \n\nBut the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut this is exactly (S_b - S_i). \n\nThus, the total for each array is (S_b - S_i). \n\nBut how can we compute this without knowing S_b? \n\nAh! Here's the key: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since all arrays start as copies of b, the initial sum for each array is S_b. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. \n\nBut how can we compute this without knowing S_b? \n\nWait, the problem is that we can't compute this directly. \n\nBut the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut this is exactly (S_b - S_i). \n\nThus, the total for each array is (S_b - S_i). \n\nBut how can we compute this without knowing S_b? \n\nAh! Here's the key insight: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since all arrays start as copies of b, the initial sum for each array is S_b. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. \n\nBut how can we compute this without knowing S_b? \n\nWait, the problem is that we can't compute this directly. \n\nBut the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut this is exactly (S_b - S_i). \n\nThus, the total for each array is (S_b - S_i). \n\nBut how can we compute this without knowing S_b? \n\nAh! Here's the key: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since all arrays start as copies of b, the initial sum for each array is S_b. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. \n\nBut how can we compute this without knowing S_b? \n\nWait, the problem is that we can't compute this directly. \n\nBut the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut this is exactly (S_b - S_i). \n\nThus, the total for each array is (S_b - S_i). \n\nBut how can we compute this without knowing S_b? \n\nAh! Here's the key insight: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since all arrays start as copies of b, the initial sum for each array is S_b. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. \n\nBut how can we compute this without knowing S_b? \n\nWait, the problem is that we can't compute this directly. \n\nBut the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut this is exactly (S_b - S_i). \n\nThus, the total for each array is (S_b - S_i). \n\nBut how can we compute this without knowing S_b? \n\nAh! Here's the key: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since all arrays start as copies of b, the initial sum for each array is S_b. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. \n\nBut how can we compute this without knowing S_b? \n\nWait, the problem is that we can't compute this directly. \n\nBut the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut this is exactly (S_b - S_i). \n\nThus, the total for each array is (S_b - S_i). \n\nBut how can we compute this without knowing S_b? \n\nAh! Here's the key insight: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since all arrays start as copies of b, the initial sum for each array is S_b. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. \n\nBut how can we compute this without knowing S_b? \n\nWait, the problem is that we can't compute this directly. \n\nBut the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut this is exactly (S_b - S_i). \n\nThus, the total for each array is (S_b - S_i). \n\nBut how can we compute this without knowing S_b? \n\nAh! Here's the key: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since all arrays start as copies of b, the initial sum for each array is S_b. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. \n\nBut how can we compute this without knowing S_b? \n\nWait, the problem is that we can't compute this directly. \n\nBut the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut this is exactly (S_b - S_i). \n\nThus, the total for each array is (S_b - S_i). \n\nBut how can we compute this without knowing S_b? \n\nAh! Here's the key insight: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since all arrays start as copies of b, the initial sum for each array is S_b. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. \n\nBut how can we compute this without knowing S_b? \n\nWait, the problem is that we can't compute this directly. \n\nBut the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut this is exactly (S_b - S_i). \n\nThus, the total for each array is (S_b - S_i). \n\nBut how can we compute this without knowing S_b? \n\nAh! Here's the key: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since all arrays start as copies of b, the initial sum for each array is S_b. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. \n\nBut how can we compute this without knowing S_b? \n\nWait, the problem is that we can't compute this directly. \n\nBut the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut this is exactly (S_b - S_i). \n\nThus, the total for each array is (S_b - S_i). \n\nBut how can we compute this without knowing S_b? \n\nAh! Here's the key insight: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since all arrays start as copies of b, the initial sum for each array is S_b. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. \n\nBut how can we compute this without knowing S_b? \n\nWait, the problem is that we can't compute this directly. \n\nBut the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut this is exactly (S_b - S_i). \n\nThus, the total for each array is (S_b - S_i). \n\nBut how can we compute this without knowing S_b? \n\nAh! Here's the key: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since all arrays start as copies of b, the initial sum for each array is S_b. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. \n\nBut how can we compute this without knowing S_b? \n\nWait, the problem is that we can't compute this directly. \n\nBut the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut this is exactly (S_b - S_i). \n\nThus, the total for each array is (S_b - S_i). \n\nBut how can we compute this without knowing S_b? \n\nAh! Here's the key insight: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since all arrays start as copies of b, the initial sum for each array is S_b. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. \n\nBut how can we compute this without knowing S_b? \n\nWait, the problem is that we can't compute this directly. \n\nBut the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut this is exactly (S_b - S_i). \n\nThus, the total for each array is (S_b - S_i). \n\nBut how can we compute this without knowing S_b? \n\nAh! Here's the key: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since all arrays start as copies of b, the initial sum for each array is S_b. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. \n\nBut how can we compute this without knowing S_b? \n\nWait, the problem is that we can't compute this directly. \n\nBut the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut this is exactly (S_b - S_i). \n\nThus, the total for each array is (S_b - S_i). \n\nBut how can we compute this without knowing S_b? \n\nAh! Here's the key insight: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since all arrays start as copies of b, the initial sum for each array is S_b. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. \n\nBut how can we compute this without knowing S_b? \n\nWait, the problem is that we can't compute this directly. \n\nBut the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut this is exactly (S_b - S_i). \n\nThus, the total for each array is (S_b - S_i). \n\nBut how can we compute this without knowing S_b? \n\nAh! Here's the key: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since all arrays start as copies of b, the initial sum for each array is S_b. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. \n\nBut how can we compute this without knowing S_b? \n\nWait, the problem is that we can't compute this directly. \n\nBut the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut this is exactly (S_b - S_i). \n\nThus, the total for each array is (S_b - S_i). \n\nBut how can we compute this without knowing S_b? \n\nAh! Here's the key insight: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since all arrays start as copies of b, the initial sum for each array is S_b. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. \n\nBut how can we compute this without knowing S_b? \n\nWait, the problem is that we can't compute this directly. \n\nBut the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut this is exactly (S_b - S_i). \n\nThus, the total for each array is (S_b - S_i). \n\nBut how can we compute this without knowing S_b? \n\nAh! Here's the key: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since all arrays start as copies of b, the initial sum for each array is S_b. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. \n\nBut how can we compute this without knowing S_b? \n\nWait, the problem is that we can't compute this directly. \n\nBut the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut this is exactly (S_b - S_i). \n\nThus, the total for each array is (S_b - S_i). \n\nBut how can we compute this without knowing S_b? \n\nAh! Here's the key insight: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since all arrays start as copies of b, the initial sum for each array is S_b. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. \n\nBut how can we compute this without knowing S_b? \n\nWait, the problem is that we can't compute this directly. \n\nBut the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut this is exactly (S_b - S_i). \n\nThus, the total for each array is (S_b - S_i). \n\nBut how can we compute this without knowing S_b? \n\nAh! Here's the key: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since all arrays start as copies of b, the initial sum for each array is S_b. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. \n\nBut how can we compute this without knowing S_b? \n\nWait, the problem is that we can't compute this directly. \n\nBut the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut this is exactly (S_b - S_i). \n\nThus, the total for each array is (S_b - S_i). \n\nBut how can we compute this without knowing S_b? \n\nAh! Here's the key insight: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since all arrays start as copies of b, the initial sum for each array is S_b. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. \n\nBut how can we compute this without knowing S_b? \n\nWait, the problem is that we can't compute this directly. \n\nBut the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut this is exactly (S_b - S_i). \n\nThus, the total for each array is (S_b - S_i). \n\nBut how can we compute this without knowing S_b? \n\nAh! Here's the key: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since all arrays start as copies of b, the initial sum for each array is S_b. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. \n\nBut how can we compute this without knowing S_b? \n\nWait, the problem is that we can't compute this directly. \n\nBut the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut this is exactly (S_b - S_i). \n\nThus, the total for each array is (S_b - S_i). \n\nBut how can we compute this without knowing S_b? \n\nAh! Here's the key insight: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since all arrays start as copies of b, the initial sum for each array is S_b. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. \n\nBut how can we compute this without knowing S_b? \n\nWait, the problem is that we can't compute this directly. \n\nBut the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut this is exactly (S_b - S_i). \n\nThus, the total for each array is (S_b - S_i). \n\nBut how can we compute this without knowing S_b? \n\nAh! Here's the key: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since all arrays start as copies of b, the initial sum for each array is S_b. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. \n\nBut how can we compute this without knowing S_b? \n\nWait, the problem is that we can't compute this directly. \n\nBut the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut this is exactly (S_b - S_i). \n\nThus, the total for each array is (S_b - S_i). \n\nBut how can we compute this without knowing S_b? \n\nAh! Here's the key insight: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since all arrays start as copies of b, the initial sum for each array is S_b. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. \n\nBut how can we compute this without knowing S_b? \n\nWait, the problem is that we can't compute this directly. \n\nBut the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut this is exactly (S_b - S_i). \n\nThus, the total for each array is (S_b - S_i). \n\nBut how can we compute this without knowing S_b? \n\nAh! Here's the key: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since all arrays start as copies of b, the initial sum for each array is S_b. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. \n\nBut how can we compute this without knowing S_b? \n\nWait, the problem is that we can't compute this directly. \n\nBut the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut this is exactly (S_b - S_i). \n\nThus, the total for each array is (S_b - S_i). \n\nBut how can we compute this without knowing S_b? \n\nAh! Here's the key insight: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since all arrays start as copies of b, the initial sum for each array is S_b. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. \n\nBut how can we compute this without knowing S_b? \n\nWait, the problem is that we can't compute this directly. \n\nBut the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut this is exactly (S_b - S_i). \n\nThus, the total for each array is (S_b - S_i). \n\nBut how can we compute this without knowing S_b? \n\nAh! Here's the key: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since all arrays start as copies of b, the initial sum for each array is S_b. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. \n\nBut how can we compute this without knowing S_b? \n\nWait, the problem is that we can't compute this directly. \n\nBut the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut this is exactly (S_b - S_i). \n\nThus, the total for each array is (S_b - S_i). \n\nBut how can we compute this without knowing S_b? \n\nAh! Here's the key insight: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since all arrays start as copies of b, the initial sum for each array is S_b. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. \n\nBut how can we compute this without knowing S_b? \n\nWait, the problem is that we can't compute this directly. \n\nBut the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut this is exactly (S_b - S_i). \n\nThus, the total for each array is (S_b - S_i). \n\nBut how can we compute this without knowing S_b? \n\nAh! Here's the key: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since all arrays start as copies of b, the initial sum for each array is S_b. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. \n\nBut how can we compute this without knowing S_b? \n\nWait, the problem is that we can't compute this directly. \n\nBut the key is that the total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut this is exactly (S_b - S_i). \n\nThus, the total for each array is (S_b - S_i). \n\nBut how can we compute this without knowing S_b? \n\nAh! Here's the key insight: \n\nThe total for each array can be computed as (sum_{p} p * (b[p] - c_i[p])) = (sum_{p} p*b[p] - sum_{p} p*c_i[p]). \n\nBut since all arrays start as copies of b, the initial sum for each array is S_b. \n\nThe changes via operations are the delta_i. \n\nThus, the total for array i is (S_b - S_i) = (S_b - (S_b + delta_i)) = -delta_i. \n\nBut how can we compute this without knowing S_b? \n\nWait, the problem is that we can't compute this directly. \n\nThe key is to realize that the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) \n\nBut since we don't know b, but all arrays start as copies of b, the initial difference is zero. \n\nThus, the total for each array can be computed as (sum_{p} p*b[p] - sum_{p} p*c_i[p])) \n\nBut since we don't"
  }
}