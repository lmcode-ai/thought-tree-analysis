{
  "qid": "block_completion_000689",
  "tree": {
    "id": "root",
    "children": [
      {
        "id": "thought_0",
        "text": "Okay, let's see.",
        "label": "empty",
        "relation": "elaboration",
        "children": [
          {
            "id": "thought_1",
            "text": "The problem is to determine if after performing any number of operations (add 1 to odd indices or even indices), we can make all elements in the array have the same parity\u2014either all even or all odd. Hmm, the operations affect the parity of the elements. Because adding 1 changes the parity. So each operation flips the parity of certain elements. Let's think about the parity after each operation. First, let's model the possible changes. Let's consider the current parity (even or odd) of each element.",
            "label": "high_level_plan",
            "relation": "Continuation",
            "children": [
              {
                "id": "thought_2",
                "text": "Each time we perform an odd-index operation, all elements at positions 1, 3, 5, etc. (1-based) have their parity flipped. Similarly, even-index operations flip the parity of elements at 2,4,6, etc. The key is to find if there exists a way to apply these operations such that all elements end up with the same parity. Let's consider the parity of each element. Let's represent each element's parity as 0 (even) or 1 (odd). Then, for each element, after some operations, we need all to be 0 or all to be 1.",
                "label": "mental_execution",
                "relation": "Continuation",
                "children": [
                  {
                    "id": "thought_3",
                    "text": "Each operation can be applied any number of times. But since applying the same operation twice would flip the parity twice, which cancels out. So effectively, each operation can be applied 0 or 1 times. Because applying it more times is equivalent to mod 2. Wait, that's an important point.",
                    "label": "mental_execution",
                    "relation": "Continuation",
                    "children": [
                      {
                        "id": "thought_4",
                        "text": "Because adding 1 twice to the same indices would be equivalent to adding 2, which doesn't change the parity. So the number of times we apply an odd or even operation is modulo 2. So we can model each operation as a binary choice: apply it once or not.",
                        "label": "mental_execution",
                        "relation": "Rephrase",
                        "children": [
                          {
                            "id": "thought_5",
                            "text": "Because applying it even times is the same as not applying it, and applying it once is the same as any odd number of times. So the possible combinations are:\n\n- Apply odd operation 0 or 1 times.\n- Apply even operation 0 or 1 times.",
                            "label": "mental_execution",
                            "relation": "Rephrase",
                            "children": [
                              {
                                "id": "thought_6",
                                "text": "Wait, but since each operation can be done any number of times, but the effect on parity is only whether it's done even or odd times. So the total possibilities are four combinations:\n\n1. Neither odd nor even operations applied. 2. Only odd operation applied once (or any odd number of times). 3. Only even operation applied once. 4. Both operations applied once each.",
                                "label": "mental_execution",
                                "relation": "Rephrase",
                                "children": [
                                  {
                                    "id": "thought_7",
                                    "text": "Each of these combinations will result in a certain transformation of the parities of the elements. So for each element in the array, after applying a certain combination of operations, what is its parity? Let's model each possible combination and see what the parity of each element becomes. Let me denote:\n\nOriginal parity of element at position i is a_i (0 or 1).",
                                    "label": "high_level_plan",
                                    "relation": "Continuation",
                                    "children": [
                                      {
                                        "id": "thought_8",
                                        "text": "Then, after applying x (0 or 1) odd operations and y (0 or 1) even operations, the parity of element i is:\n\na_i ^ (x if i is odd else 0) ^ (y if i is even else 0)\n\nBecause each odd operation toggles the parity of all odd indices, and each even operation toggles the even indices. So for each element, if it's in an odd index, it's toggled x times (mod 2).",
                                        "label": "code_analysis",
                                        "relation": "Continuation",
                                        "children": [
                                          {
                                            "id": "thought_9",
                                            "text": "Similarly, even indices toggled y times. So the final parity is original a_i plus x (if i is odd) plus y (if i is even), mod 2. So for all elements to have the same parity (either all 0 or all 1), there must exist x and y (each 0 or 1) such that for all i:\n\na_i ^ (x*(i%2 == 1) ) ^ (y*(i%2 == 0)) == target_parity.",
                                            "label": "code_analysis",
                                            "relation": "Continuation",
                                            "children": [
                                              {
                                                "id": "thought_10",
                                                "text": "And the target_parity can be either 0 or 1. So we need to check if for any combination of x and y (0 or 1), and any target parity, all elements after transformation have the same parity. Wait, but perhaps target parity can be fixed once x and y are chosen.",
                                                "label": "mental_execution",
                                                "relation": "Continuation",
                                                "children": [
                                                  {
                                                    "id": "thought_11",
                                                    "text": "For example, after choosing x and y, the transformed parities must all be the same. So for a given x and y (each 0 or 1), check if all transformed parities are the same.",
                                                    "label": "mental_execution",
                                                    "relation": "Continuation",
                                                    "children": [
                                                      {
                                                        "id": "thought_12",
                                                        "text": "If any of the four combinations (x,y) leads to all elements having the same parity (could be 0 or 1), then the answer is YES. So the plan is: For each test case:\n\n1. Compute the parity (a_i % 2) for each element. 2. For all possible x (0 or 1) and y (0 or 1):\n\n   a. For each element i, compute new_parity = a_i_parity ^ (x if i is odd) ^ (y if i is even)\n\n   b. Check if all new_parity are the same. c. If for any x, y combination this is true, then output YES.\n\n3. If none of the four combinations work, output NO.",
                                                        "label": "high_level_plan",
                                                        "relation": "Continuation",
                                                        "children": [
                                                          {
                                                            "id": "thought_13",
                                                            "text": "Because the four combinations cover all possibilities of applying odd and even operations any number of times (since applying more than once is equivalent to mod 2). So the code can be structured as:\n\nFor each test case:\n\n- Read n, then the array.\n\n- Compute parities (0 or 1) for each element.",
                                                            "label": "high_level_plan",
                                                            "relation": "Continuation",
                                                            "children": [
                                                              {
                                                                "id": "thought_14",
                                                                "text": "- Check all four possible x and y (0 or 1 each):\n\n   for x in 0,1:\n\n      for y in 0,1:\n\n          check if all elements after applying x and y have the same parity.",
                                                                "label": "test_generation",
                                                                "relation": "Continuation",
                                                                "children": [
                                                                  {
                                                                    "id": "thought_15",
                                                                    "text": "if yes, then answer is YES.\n\n- If none found, answer is NO. So in code, for each test case:\n\nWe can loop through x in 0 and 1, y in 0 and 1. For each (x, y):\n\n   create a variable, say, expected_parity.",
                                                                    "label": "high_level_plan",
                                                                    "relation": "Continuation",
                                                                    "children": [
                                                                      {
                                                                        "id": "thought_16",
                                                                        "text": "For the first element, compute its transformed parity. Then check if all other elements have the same transformed parity. Alternatively, compute the transformed parity for each element and check if they are all equal. Yes. So for each x and y:\n\n   bool valid = true;\n\n   int first_parity = (parity[0] ^ (x * (0+1 is odd? )) ^ (y * (0+1 is even? )) Wait, indexes are 0-based or 1-based?",
                                                                        "label": "mental_execution",
                                                                        "relation": "Continuation",
                                                                        "children": [
                                                                          {
                                                                            "id": "thought_17",
                                                                            "text": "In the problem statement, the array is given as a_1, a_2, etc. So in code, when we read the array, the first element is a_1 (1-based). So in the code, the array is 0-based, but in the problem description, the indices are 1-based. So for each element in the array (0-based in code), when considering whether it's in an odd or even position (1-based), we need to adjust.",
                                                                            "label": "code_analysis",
                                                                            "relation": "Continuation",
                                                                            "children": [
                                                                              {
                                                                                "id": "thought_18",
                                                                                "text": "For example, in code, the elements are stored as val[0], val[1], val[2], etc. So for 1-based indices, the parity is (i+1) % 2. So if i is 0 (1-based index 1), it's odd. So for code index i, the original 1-based index is i+1. So the parity of the index is (i+1) % 2. So for even 1-based index (i+1), then the code index is even in the 1-based sense. So for code index i:\n\nif (i+1) % 2 == 1 \u2192 odd index (1-based), so x is applied. if (i+1) % 2 == 0 \u2192 even index (1-based), so y is applied. So for each code index i:\n\ntransformed_parity = original_parity[i] ^ (x * ((i+1) % 2)) ) ^ (y * ( (i+1) % 2 == 0 ) ) Wait, no.",
                                                                                "label": "code_analysis",
                                                                                "relation": "Continuation",
                                                                                "children": [
                                                                                  {
                                                                                    "id": "thought_19",
                                                                                    "text": "Wait, for code index i (0-based), the 1-based index is i+1. So for odd 1-based index (i+1) is odd \u2192 x is applied (if x is 1).",
                                                                                    "label": "code_analysis",
                                                                                    "relation": "Continuation",
                                                                                    "children": [
                                                                                      {
                                                                                        "id": "thought_20",
                                                                                        "text": "For even 1-based index \u2192 y is applied (if y is 1). So for each code index i, the transformed parity is:\n\noriginal_parity[i] ^ (x * ((i+1) % 2)) ^ (y * ((i+1) % 2 == 0 ? 1 : 0)). Yes. So in code:\n\nfor each x in 0,1:\n\n   for each y in 0,1:\n\n       bool ok = true;\n\n       int target = -1;\n\n       for (int i=0; i < n; i++) {\n\n           int p = (val[i] % 2); if ((i+1) % 2 == 1) { // odd index (1-based), apply x\n\n               p ^= x;\n\n           } else { // even index, apply y\n\n               p ^= y;\n\n           }\n\n           if (i == 0) {\n\n               target = p;\n\n           } else {\n\n               if (p != target) {\n\n                   ok = false;\n\n                   break;\n\n               }\n\n           }\n\n       }\n\n       if (ok) {\n\n           // found a possible combination\n\n           cout << \"YES\" << endl;\n\n           goto next_test_case;\n\n       } So if any of the four combinations (x,y) leads to all parities being the same, then output YES. Otherwise, NO. So that's the approach. Now, coding this in C++. The code given has a skeleton.",
                                                                                        "label": "code_analysis",
                                                                                        "relation": "Continuation",
                                                                                        "children": [
                                                                                          {
                                                                                            "id": "thought_21",
                                                                                            "text": "The main loop is in the while(t--) loop. So inside each test case, read n, read the array. Then check all four possibilities. So the code for the test case would be:\n\ncin >> n;\n\nfor (int i=0; i < n; i++) {\n\n    cin >> val[i];\n\n}\n\n// compute parities (but perhaps not needed; can compute on the fly)\n\n// check all x and y (0 or 1)\n\nbool possible = false;\n\nfor (int x=0; x < 2; x++) {\n\n    for (int y=0; y < 2; y++) {\n\n        int first_p = (val[0] % 2);\n\n        int idx = 0; // code index 0 is 1-based index 1, which is odd. if ((idx+1) % 2 == 1) {\n\n            first_p ^= x;\n\n        } else {\n\n            first_p ^= y;\n\n        }\n\n        bool valid = true;\n\n        for (int i=1; i <n; i++) {\n\n            int p = val[i] % 2;\n\n            if ((i+1) %2 ==1) { // odd index 1-based, apply x.\n\n                p ^=x;\n\n            } else {\n\n                p ^=y;\n\n            }\n\n            if (p != first_p) {\n\n                valid = false;\n\n                break;\n\n            }\n\n        }\n\n        if (valid) {\n\n            possible = true;\n\n            break;\n\n        }\n\n    }\n\n    if (possible) break;\n\n}\n\nif (possible) {\n\n    cout << \"YES\" << endl;\n\n} else {\n\n    cout << \"NO\" << endl;\n\n}\n\nYes. So that's the code. Now, edge cases:\n\nTest case where all elements are even. Then original x=0, y=0 will have all even. So possible. Another case where the array is of even length. For example, n=2. But the code should handle all cases. So the code inside the test case loop is as above. So putting it all together. The missing code is inside the while(t--) loop. So the code to fill in is:\n\ncin >> n;\n\nfor (int i = 0; i < n; i++) {\n\n    cin >> val[i];\n\n}\n\nbool possible = false;\n\nfor (int x = 0; x < 2; x++) {\n\n    for (int y = 0; y < 2; y++) {\n\n        int target;\n\n        bool valid = true;\n\n        for (int i = 0; i < n; i++) {\n\n            int p = val[i] % 2;\n\n            if ((i + 1) % 2 == 1) { // odd index (1-based)\n\n                p ^= x;\n\n            } else {\n\n                p ^= y;\n\n            }\n\n            if (i == 0) {\n\n                target = p;\n\n            } else if (p != target) {\n\n                valid = false;\n\n                break;\n\n            }\n\n        }\n\n        if (valid) {\n\n            possible = true;\n\n            break;\n\n        }\n\n    }\n\n    if (possible) break;\n\n}\n\ncout << (possible ? \"YES\" : \"NO\") << endl;\n\nWait, but in code, when the first element is processed, i=0. So (i+1) is 1 \u2192 odd index. So x is applied.",
                                                                                            "label": "code_analysis",
                                                                                            "relation": "Continuation",
                                                                                            "children": [],
                                                                                            "parent_id": "thought_20"
                                                                                          },
                                                                                          {
                                                                                            "id": "thought_22",
                                                                                            "text": "Then, for the rest elements, check if their transformed p matches the first element's transformed p. If all match, valid is true. Yes. So that's the code. So the code inside the while(t--) loop is:\n\nRead n, then the array. Then check all four combinations of x and y. If any combination works, output YES. Else, NO. So the missing code is:\n\n        cin >> n;\n        for(int i=0;i<n;i++){\n            cin >> val[i];\n        }\n        bool ok = false;\n        for(int x=0;x<=1;x++){\n            for(int y=0;y<=1;y++){\n                bool valid = true;\n                int parity;\n                for(int i=0;i<n;i++){\n                    int p = val[i]%2;\n                    if( (i+1)%2 ==1 ){\n                        p ^=x;\n                    }else{\n                        p ^=y;\n                    }\n                    if(i==0){\n                        parity = p;\n                    }else{\n                        if(p ! = parity){\n                            valid = false;\n                            break;\n                        }\n                    }\n                }\n                if(valid){\n                    ok = true;\n                    break;\n                }\n            }\n            if(ok) break;\n        }\n        cout << (ok ? \"YES\" : \"NO\") << endl;\n\nBut in code, variables should be declared. But in the given code, val is a global array of size 1e5. So the code is okay. So that's the code to fill in.",
                                                                                            "label": "bug_fixing",
                                                                                            "relation": "Continuation",
                                                                                            "children": [],
                                                                                            "parent_id": "thought_20"
                                                                                          }
                                                                                        ],
                                                                                        "parent_id": "thought_19"
                                                                                      }
                                                                                    ],
                                                                                    "parent_id": "thought_18"
                                                                                  }
                                                                                ],
                                                                                "parent_id": "thought_17"
                                                                              }
                                                                            ],
                                                                            "parent_id": "thought_16"
                                                                          }
                                                                        ],
                                                                        "parent_id": "thought_15"
                                                                      }
                                                                    ],
                                                                    "parent_id": "thought_14"
                                                                  }
                                                                ],
                                                                "parent_id": "thought_13"
                                                              }
                                                            ],
                                                            "parent_id": "thought_12"
                                                          }
                                                        ],
                                                        "parent_id": "thought_11"
                                                      }
                                                    ],
                                                    "parent_id": "thought_10"
                                                  }
                                                ],
                                                "parent_id": "thought_9"
                                              }
                                            ],
                                            "parent_id": "thought_8"
                                          }
                                        ],
                                        "parent_id": "thought_7"
                                      }
                                    ],
                                    "parent_id": "thought_6"
                                  }
                                ],
                                "parent_id": "thought_5"
                              }
                            ],
                            "parent_id": "thought_4"
                          }
                        ],
                        "parent_id": "thought_3"
                      }
                    ],
                    "parent_id": "thought_2"
                  }
                ],
                "parent_id": "thought_1"
              }
            ],
            "parent_id": "thought_0"
          }
        ],
        "parent_id": "root"
      }
    ],
    "metadata": {
      "state": "success",
      "answer": "cin >> n;\nfor(int i=0; i<n; i++) cin >> val[i];\nbool ok = false;\nfor(int x=0; x<2; x++) {\n    for(int y=0; y<2; y++) {\n        bool valid = true;\n        int target = -1;\n        for(int i=0; i<n; i++) {\n            int p = val[i] % 2;\n            if((i+1) % 2 == 1) p ^= x;\n            else p ^= y;\n            if(i == 0) target = p;\n            else if(p != target) { valid = false; break; }\n        }\n        if(valid) { ok = true; break; }\n    }\n    if(ok) break;\n}\ncout << (ok ? \"YES\" : \"NO\") << endl;"
    },
    "original_reasoning": "Okay, let's see. The problem is to determine if after performing any number of operations (add 1 to odd indices or even indices), we can make all elements in the array have the same parity\u2014either all even or all odd.\n\nHmm, the operations affect the parity of the elements. Because adding 1 changes the parity. So each operation flips the parity of certain elements. Let's think about the parity after each operation.\n\nFirst, let's model the possible changes. Let's consider the current parity (even or odd) of each element. Each time we perform an odd-index operation, all elements at positions 1, 3, 5, etc. (1-based) have their parity flipped. Similarly, even-index operations flip the parity of elements at 2,4,6, etc.\n\nThe key is to find if there exists a way to apply these operations such that all elements end up with the same parity.\n\nLet's consider the parity of each element. Let's represent each element's parity as 0 (even) or 1 (odd). Then, for each element, after some operations, we need all to be 0 or all to be 1.\n\nEach operation can be applied any number of times. But since applying the same operation twice would flip the parity twice, which cancels out. So effectively, each operation can be applied 0 or 1 times. Because applying it more times is equivalent to mod 2.\n\nWait, that's an important point. Because adding 1 twice to the same indices would be equivalent to adding 2, which doesn't change the parity. So the number of times we apply an odd or even operation is modulo 2. So we can model each operation as a binary choice: apply it once or not. Because applying it even times is the same as not applying it, and applying it once is the same as any odd number of times.\n\nSo the possible combinations are:\n\n- Apply odd operation 0 or 1 times.\n- Apply even operation 0 or 1 times.\n\nWait, but since each operation can be done any number of times, but the effect on parity is only whether it's done even or odd times. So the total possibilities are four combinations:\n\n1. Neither odd nor even operations applied.\n2. Only odd operation applied once (or any odd number of times).\n3. Only even operation applied once.\n4. Both operations applied once each.\n\nEach of these combinations will result in a certain transformation of the parities of the elements.\n\nSo for each element in the array, after applying a certain combination of operations, what is its parity?\n\nLet's model each possible combination and see what the parity of each element becomes.\n\nLet me denote:\n\nOriginal parity of element at position i is a_i (0 or 1).\n\nThen, after applying x (0 or 1) odd operations and y (0 or 1) even operations, the parity of element i is:\n\na_i ^ (x if i is odd else 0) ^ (y if i is even else 0)\n\nBecause each odd operation toggles the parity of all odd indices, and each even operation toggles the even indices. So for each element, if it's in an odd index, it's toggled x times (mod 2). Similarly, even indices toggled y times.\n\nSo the final parity is original a_i plus x (if i is odd) plus y (if i is even), mod 2.\n\nSo for all elements to have the same parity (either all 0 or all 1), there must exist x and y (each 0 or 1) such that for all i:\n\na_i ^ (x*(i%2 == 1) ) ^ (y*(i%2 == 0)) == target_parity.\n\nAnd the target_parity can be either 0 or 1. So we need to check if for any combination of x and y (0 or 1), and any target parity, all elements after transformation have the same parity.\n\nWait, but perhaps target parity can be fixed once x and y are chosen. For example, after choosing x and y, the transformed parities must all be the same. So for a given x and y (each 0 or 1), check if all transformed parities are the same. If any of the four combinations (x,y) leads to all elements having the same parity (could be 0 or 1), then the answer is YES.\n\nSo the plan is:\n\nFor each test case:\n\n1. Compute the parity (a_i % 2) for each element.\n\n2. For all possible x (0 or 1) and y (0 or 1):\n\n   a. For each element i, compute new_parity = a_i_parity ^ (x if i is odd) ^ (y if i is even)\n\n   b. Check if all new_parity are the same.\n\n   c. If for any x, y combination this is true, then output YES.\n\n3. If none of the four combinations work, output NO.\n\nBecause the four combinations cover all possibilities of applying odd and even operations any number of times (since applying more than once is equivalent to mod 2).\n\nSo the code can be structured as:\n\nFor each test case:\n\n- Read n, then the array.\n\n- Compute parities (0 or 1) for each element.\n\n- Check all four possible x and y (0 or 1 each):\n\n   for x in 0,1:\n\n      for y in 0,1:\n\n          check if all elements after applying x and y have the same parity.\n\n          if yes, then answer is YES.\n\n- If none found, answer is NO.\n\nSo in code, for each test case:\n\nWe can loop through x in 0 and 1, y in 0 and 1.\n\nFor each (x, y):\n\n   create a variable, say, expected_parity. For the first element, compute its transformed parity. Then check if all other elements have the same transformed parity.\n\nAlternatively, compute the transformed parity for each element and check if they are all equal.\n\nYes. So for each x and y:\n\n   bool valid = true;\n\n   int first_parity = (parity[0] ^ (x * (0+1 is odd? )) ^ (y * (0+1 is even? )) \n\nWait, indexes are 0-based or 1-based?\n\nIn the problem statement, the array is given as a_1, a_2, etc. So in code, when we read the array, the first element is a_1 (1-based). So in the code, the array is 0-based, but in the problem description, the indices are 1-based.\n\nSo for each element in the array (0-based in code), when considering whether it's in an odd or even position (1-based), we need to adjust.\n\nFor example, in code, the elements are stored as val[0], val[1], val[2], etc. So for 1-based indices, the parity is (i+1) % 2. So if i is 0 (1-based index 1), it's odd. So for code index i, the original 1-based index is i+1. So the parity of the index is (i+1) % 2. So for even 1-based index (i+1), then the code index is even in the 1-based sense.\n\nSo for code index i:\n\nif (i+1) % 2 == 1 \u2192 odd index (1-based), so x is applied.\n\nif (i+1) % 2 == 0 \u2192 even index (1-based), so y is applied.\n\nSo for each code index i:\n\ntransformed_parity = original_parity[i] ^ (x * ((i+1) % 2)) ) ^ (y * ( (i+1) % 2 == 0 ) )\n\nWait, no. Wait, for code index i (0-based), the 1-based index is i+1. So for odd 1-based index (i+1) is odd \u2192 x is applied (if x is 1). For even 1-based index \u2192 y is applied (if y is 1).\n\nSo for each code index i, the transformed parity is:\n\noriginal_parity[i] ^ (x * ((i+1) % 2)) ^ (y * ((i+1) % 2 == 0 ? 1 : 0)).\n\nYes.\n\nSo in code:\n\nfor each x in 0,1:\n\n   for each y in 0,1:\n\n       bool ok = true;\n\n       int target = -1;\n\n       for (int i=0; i < n; i++) {\n\n           int p = (val[i] % 2);\n\n           if ((i+1) % 2 == 1) { // odd index (1-based), apply x\n\n               p ^= x;\n\n           } else { // even index, apply y\n\n               p ^= y;\n\n           }\n\n           if (i == 0) {\n\n               target = p;\n\n           } else {\n\n               if (p != target) {\n\n                   ok = false;\n\n                   break;\n\n               }\n\n           }\n\n       }\n\n       if (ok) {\n\n           // found a possible combination\n\n           cout << \"YES\" << endl;\n\n           goto next_test_case;\n\n       }\n\nSo if any of the four combinations (x,y) leads to all parities being the same, then output YES. Otherwise, NO.\n\nSo that's the approach.\n\nNow, coding this in C++. The code given has a skeleton. The main loop is in the while(t--) loop. So inside each test case, read n, read the array. Then check all four possibilities.\n\nSo the code for the test case would be:\n\ncin >> n;\n\nfor (int i=0; i < n; i++) {\n\n    cin >> val[i];\n\n}\n\n// compute parities (but perhaps not needed; can compute on the fly)\n\n// check all x and y (0 or 1)\n\nbool possible = false;\n\nfor (int x=0; x < 2; x++) {\n\n    for (int y=0; y < 2; y++) {\n\n        int first_p = (val[0] % 2);\n\n        int idx = 0; // code index 0 is 1-based index 1, which is odd.\n\n        if ((idx+1) % 2 == 1) {\n\n            first_p ^= x;\n\n        } else {\n\n            first_p ^= y;\n\n        }\n\n        bool valid = true;\n\n        for (int i=1; i <n; i++) {\n\n            int p = val[i] % 2;\n\n            if ((i+1) %2 ==1) { // odd index 1-based, apply x.\n\n                p ^=x;\n\n            } else {\n\n                p ^=y;\n\n            }\n\n            if (p != first_p) {\n\n                valid = false;\n\n                break;\n\n            }\n\n        }\n\n        if (valid) {\n\n            possible = true;\n\n            break;\n\n        }\n\n    }\n\n    if (possible) break;\n\n}\n\nif (possible) {\n\n    cout << \"YES\" << endl;\n\n} else {\n\n    cout << \"NO\" << endl;\n\n}\n\nYes. So that's the code.\n\nNow, edge cases:\n\nTest case where all elements are even. Then original x=0, y=0 will have all even. So possible.\n\nAnother case where the array is of even length. For example, n=2.\n\nBut the code should handle all cases.\n\nSo the code inside the test case loop is as above.\n\nSo putting it all together.\n\nThe missing code is inside the while(t--) loop.\n\nSo the code to fill in is:\n\ncin >> n;\n\nfor (int i = 0; i < n; i++) {\n\n    cin >> val[i];\n\n}\n\nbool possible = false;\n\nfor (int x = 0; x < 2; x++) {\n\n    for (int y = 0; y < 2; y++) {\n\n        int target;\n\n        bool valid = true;\n\n        for (int i = 0; i < n; i++) {\n\n            int p = val[i] % 2;\n\n            if ((i + 1) % 2 == 1) { // odd index (1-based)\n\n                p ^= x;\n\n            } else {\n\n                p ^= y;\n\n            }\n\n            if (i == 0) {\n\n                target = p;\n\n            } else if (p != target) {\n\n                valid = false;\n\n                break;\n\n            }\n\n        }\n\n        if (valid) {\n\n            possible = true;\n\n            break;\n\n        }\n\n    }\n\n    if (possible) break;\n\n}\n\ncout << (possible ? \"YES\" : \"NO\") << endl;\n\nWait, but in code, when the first element is processed, i=0. So (i+1) is 1 \u2192 odd index. So x is applied.\n\nThen, for the rest elements, check if their transformed p matches the first element's transformed p.\n\nIf all match, valid is true.\n\nYes.\n\nSo that's the code.\n\nSo the code inside the while(t--) loop is:\n\nRead n, then the array.\n\nThen check all four combinations of x and y.\n\nIf any combination works, output YES.\n\nElse, NO.\n\nSo the missing code is:\n\n        cin >> n;\n        for(int i=0;i<n;i++){\n            cin >> val[i];\n        }\n        bool ok = false;\n        for(int x=0;x<=1;x++){\n            for(int y=0;y<=1;y++){\n                bool valid = true;\n                int parity;\n                for(int i=0;i<n;i++){\n                    int p = val[i]%2;\n                    if( (i+1)%2 ==1 ){\n                        p ^=x;\n                    }else{\n                        p ^=y;\n                    }\n                    if(i==0){\n                        parity = p;\n                    }else{\n                        if(p != parity){\n                            valid = false;\n                            break;\n                        }\n                    }\n                }\n                if(valid){\n                    ok = true;\n                    break;\n                }\n            }\n            if(ok) break;\n        }\n        cout << (ok ? \"YES\" : \"NO\") << endl;\n\nBut in code, variables should be declared. But in the given code, val is a global array of size 1e5. So the code is okay.\n\nSo that's the code to fill in."
  }
}