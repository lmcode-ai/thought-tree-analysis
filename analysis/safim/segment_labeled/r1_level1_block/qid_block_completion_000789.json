{
  "segments": [
    {
      "text": "Okay, let's see.",
      "start_char": 0,
      "end_char": 16,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "The problem is about Alice and Bob eating candies from the left and right respectively, such that their total weights are equal, and we need to find the maximum number of candies they can eat in total. Hmm. So, the approach here is probably using a two-pointer technique. Like, we start with Alice taking from the left, Bob from the right. We need to track the sum of Alice's candies and Bob's sum. When Alice's sum is less than Bob's, we add more from the left. If Bob's is less, we add from the right.",
      "start_char": 17,
      "end_char": 521,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "And whenever their sums are equal, we record the number of candies eaten (i + (n-1 -j +1) maybe?), and then check if we can add more. But how? Wait, the key is to maximize the total number of candies when their sums are equal. So, we need to find the earliest point where the sums are equal and see if we can proceed further. Wait, maybe the approach is to have two pointers, left and right. We calculate the sum for Alice (left_sum) starting from the left, and Bob's sum (right_sum) starting from the right.",
      "start_char": 522,
      "end_char": 1032,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Then, whenever left_sum equals right_sum, we note the total candies (left_count + right_count) and see if that's the maximum. Then, move the pointers accordingly. But how to move the pointers to find all possible equal sums.",
      "start_char": 1033,
      "end_char": 1257,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "For example, if left_sum is smaller than right_sum, we need to add more to Alice's sum. So we move the left pointer to the right. If the right_sum is smaller, add from the right by moving the right pointer left. We do this until the pointers cross each other. Let's think with an example. Like the second test case in the note: [3,1,4,1,5,9]. The sum for Alice is 3+1+4=8, and for Bob, 9+5+1=15. Wait, no, the example in the note says that Alice eats the first three (3+1+4=8?), but maybe the example in the note is different. Wait, no, the second test case says the answer is 6 because they eat all 6 candies. Oh right, because the sum is 7 each. Wait maybe the example is different. Let me check the note again. Wait in the second test case example, the input is 3 1 4 1 5 9, but the sum of the first three is 3+1+4=8? Wait the note says that Alice eats the first three from the left (7?), maybe I'm getting the numbers wrong. Wait the note says:",
      "start_char": 1259,
      "end_char": 2209,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "For the second test case, Alice eats the first three from the left with total weight 7. Wait that's 3 + 1 + 4? 3+1 is 4, plus 4 makes 8. Hmm maybe the actual input was different. Oh well, maybe it's better to focus on the problem. So the idea is that we have two pointers, left and right. We track the sum of Alice and Bob. If Alice's sum is less than Bob's, we add the next left candy. If Bob's sum is less, we add the next right candy.",
      "start_char": 2211,
      "end_char": 2649,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "When they are equal, we record the total candies eaten (left count plus right count), then we can choose to add either side, but need to proceed. Wait, but once the sums are equal, maybe the next step is to check if adding more can keep the sums equal. But how? Alternatively, whenever the sums are equal, we can note the current total.",
      "start_char": 2650,
      "end_char": 2987,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Then, we have to continue moving the pointers to see if there's a higher total. So the maximum will be the maximum of all such equal sums. Let me think of the algorithm steps:\n\nInitialize left_ptr = 0, right_ptr = n-1. sum_alice = 0, sum_bob = 0.\n\nmax_candies = 0. count_alice = 0, count_bob =0. Wait, maybe we need to track the sum and counts. For example:\n\nsum_alice starts at 0. We take the first candy (left_ptr increments to 0), sum_alice += w[0], count_alice is 1. Compare sum_alice with sum_bob (which is 0). Since sum_alice is larger, sum_bob += w[right_ptr], right_ptr moves to n-2, count_bob is 1. Wait, no.",
      "start_char": 2988,
      "end_char": 3609,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Maybe the initial step is to have sum_alice and sum_bob as 0, and the pointers not yet processed. Wait, here's the algorithm: Initialize left = 0, right = n-1. sum_alice = 0, sum_bob = 0.\n\nmax_candies = 0. left_count =0, right_count =0. We need to loop while left <= right. But how to process:\n\nIf sum_alice <= sum_bob: then take the next left candy. Add to sum_alice, increment left. Else: take next right candy. Add to sum_bob, decrement right. But whenever sum_alice and sum_bob are equal, we check if left_count + right_count is larger than current max_candies. Then, we can proceed to take either next left or right, but which one?",
      "start_char": 3611,
      "end_char": 4255,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Wait, maybe during the process, whenever the two sums are equal, we can update the max_candies. Then continue adding to the side with the smaller sum. Wait for example:\n\nsum_alice is 5, sum_bob is 5. Then, if left <= right, we can add to the sum which is smaller. But if both are equal, perhaps we can add to either side. But which one gives a better chance for more total candies? Hmm, but perhaps the optimal is to capture the current sum and then proceed. Let's see. Let's take the first test case in the note:\n\nInput is 2, with candies 1 and 1. Then, Alice takes 1 (sum 1), Bob takes 1 (sum 1). They have eaten 2 candies. That's the answer.",
      "start_char": 4257,
      "end_char": 4903,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Another example: if the array is [1,1,1], then Alice takes 1, Bob takes 1. Sums are equal, total 2. But if they take 3 each (sum 3), but that would require Alice taking all three from left (sum 3) and Bob taking all three from right (sum 3). But that's impossible because they can't eat the same candies. Wait, in this case, the entire array can't be eaten by both. So the maximum is 2. Wait, so in this case, the optimal is when they take 1 each from left and right, sum 1 each. Then, the next steps would be to check. So the algorithm would be: Initialize sum_alice = 0, sum_bob =0. left=0, right =n-1. max_candies=0.\n\nloop while left <= right: if sum_alice <= sum_bob:\n\n       add w[left] to sum_alice, increment left.\n\n   else:\n\n       add w[right] to sum_bob, decrement right. after each addition, check if sum_alice == sum_bob. If yes, update max_candies as left + (n - right -1).",
      "start_char": 4905,
      "end_char": 5804,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Wait, because the left variable is the number of candies taken by Alice (left starts at 0, after adding, left is 1: so left counts how many she took). Similarly, right is the index, but the number of candies Bob took is (n-1 - right +1) = (n - right). Because initially, right is n-1.",
      "start_char": 5806,
      "end_char": 6090,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "When you take a right candy, you add w[right], then right becomes right-1. So the number of candies Bob has taken is (n-1 - (right+1) +1) )? Wait, maybe not. Let's see. Suppose the original right is n-1. When we take one candy from the right, right becomes n-2. So Bob has taken 1 candy. The count is (n-1 - right). Because when right is n-1, he's taken 0. When he takes one, right is n-2, count is 1.",
      "start_char": 6091,
      "end_char": 6493,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Wait, for each step:\n\nsum_bob is the sum of candies from the right, starting from the end. So for example, if he takes k candies, then those are the last k candies. So the count of Bob's candies is (original right index +1) - (current right index +1). Because original right is n-1. After taking m steps, right is r. So the number of candies taken by Bob is (n-1 - r). Because initially, right is n-1 (taken 0). If he takes one, right is n-2, so (n-1 - (n-2))=1. So yes. So the total number of candies when sum_alice == sum_bob is (left) + (n-1 - right). So during each step, after adding to sum_alice or sum_bob, we check if the sums are equal, and if so, update max_candies as the maximum between current max and left + (n-1 - right). So the code needs to track left and right pointers, sum_alice and sum_bob, and each time we add to one of them, check if the sums are equal, and then calculate the current total. This approach would work because we greedily add to the smaller sum. Whenever the sums are equal, we record the possible total. And since we process the pointers until they cross, we'll check all possible cases where the sums are equal. Let me test this logic against the sample inputs. Sample 1:\n\nTest case 1: n=2, w=1 1. Initial sum_alice=0, sum_bob=0.\n\nsum_alice <= sum_bob, so add 1 (sum_alice becomes 1, left=1). Now check sum_alice (1) vs sum_bob (0). Since sum_alice > sum_bob, add right. Take 1 (sum_bob becomes 1, right=0). Now check sums equal. So total is left=1, (n-1 - right) = (1 - 0) =1. So 1+1=2. Which matches the sample. Sample 2:\n\nTest case 2: n=6, w=3 1 4 1 5 9. The correct answer is 6. Let's see. sum_alice starts at 0, sum_bob 0. sum_alice is <= sum_bob (0 <=0). So add 3 to sum_alice (sum_alice=3), left=1. sum_alice (3) > sum_bob (0). So add right (9). sum_bob=9, right=4. Now, sum_alice 3 < sum_bob 9. So add left (1). sum_alice 4, left=2. sum_alice (4) < 9. Add left (4), sum_alice 8, left=3. sum_alice (8) < sum_bob (9). Add left (1). sum_alice 9, left=4. Now sum_alice (9) equals sum_bob (9). Total is 4 (left) + (5 -4) =4+1=5. But the sample says answer is 6. Hmm. Wait what's happening here. Wait the sample says Alice eats first three candies (3+1+4=8), Bob eats first three from the right (9+5+1=15). Wait maybe I'm miscalculating. Wait maybe the sample's input is different. Wait in the note for the second test case: the input is 3 1 4 1 5 9. But according to the note, the answer is 6. So Alice takes 3, 1, 4 (sum 8?), Bob takes 9,5,1 (sum 15). Then, they can't. Wait the note says that the answer is 6 because all candies are eaten. So perhaps the example is different. Oh, maybe the sum is 7 each. Hmm. Maybe I'm missing something here. Let me see the note again.",
      "start_char": 6495,
      "end_char": 9226,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Ah, the note says:\n\nFor the second test case, Alice will eat the first three candies from the left (with total weight 7) and Bob will eat the first three candies from the right (with total weight 7). Oh, so the input must be different. Like perhaps the array is [3,1,3,1,1,3].",
      "start_char": 9228,
      "end_char": 9504,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Or something that sums to 7 for the first three and 7 for the last three. So perhaps my algorithm isn't handling that scenario correctly. Alternatively, perhaps the example in the note is:\n\nTest case 2 input: [7,3,1,5,1,3], so that first three sum to 7+3+1=11, but no. Let's think differently.",
      "start_char": 9505,
      "end_char": 9799,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "Wait, according to the note, after both eat three candies, the total is 7 each, and all candies are eaten (so 6 total). So the array must be of length 6, and when Alice eats the first three, Bob eats the last three, and their sums are equal. So for example, the array could be [1,2,4,4,2,1]. Alice's sum is 1+2+4=7, Bob's sum is 1+2+4=7. Then, the total is 6. In that case, according to the algorithm:\n\nsum_alice starts at 0. sum_bob is 0. Since they are equal, add to left (sum_alice becomes 1, left=1). Now sum_alice (1) is > sum_bob (0). Add to right (sum_bob=1, right=4). Now sums are 1 and 1. Total is 1 (left) + (5-4) =1 +1=2. Then, since sum_alice is 1 == sum_bob 1, update max_candies to 2. Now, sum_alice <= sum_bob (1 <=1), so add next left (2). sum_alice=3, left=2. sum_alice (3) > sum_bob (1). So add to right (sum_bob=3, right=3). Now sums are 3 and 3. Total is 2 + (5-3) =2+2=4. Update max. Then, sum_alice is 3 <=3. Add next left (4). sum_alice=7, left=3. sum_alice (7) >3. Add right (sum_bob +=4. sum_bob=7, right=2. Now sums are equal. Total is 3 + (5-2) =3+3=6. So max is now 6. Then, since left (3) <= right (2) is false, loop ends. So the algorithm returns 6, which is correct. So the algorithm works for this case. So the key is to check after each addition if the sums are equal and update the max_candies. So in the code, after adding to sum_alice or sum_bob, we check if they are equal, and compute the current total (left + (n-1 - right)). Then, keep track of the maximum. So the code needs to do: Initialize sum_alice=0, sum_bob=0, left=0, right =n-1, max_candies=0.\n\nLoop while left <= right: if sum_alice <= sum_bob:\n\n       sum_alice += w[left]\n\n       left +=1\n\n   else:\n\n       sum_bob += w[right]\n\n       right -=1\n\n   if sum_alice == sum_bob:\n\n       current_total = left + (n-1 - right) if current_total > max_candies:\n\n           max_candies = current_total\n\nSo the code should have this logic.",
      "start_char": 9801,
      "end_char": 11748,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Now, looking back at the given code structure:\n\nThe code has a for loop with i and j, starting at 0 and n-1. But in the given code, the variables are i and j. But the loop is for(int i=0,j=n-1; i<=j; ). So inside the loop, we need to adjust i and j, and sum_alice and sum_bob, and track the maximum. But the variables in the code are named i and j. So let's see. The given code has:\n\nfor(int i=0,j=n-1; i<=j; ){\n\n   /* TODO */\n\n} So, we need to track sum_alice and sum_bob, and for each step, add to one of them. Then, check if the sums are equal and update num (which is the maximum).",
      "start_char": 11750,
      "end_char": 12338,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "So, in the code:\n\nInside the loop, we'll have:\n\nsum_alice starts at 0. sum_bob starts at 0. But wait, in the given code, the variables are not initialized. So in the code, after reading n and the array, the code initializes num=0, sum=0. Then, the for loop with i and j.\n\nWait, the original code has:\n\nfor(int i=0,j=n-1; i<=j; ){\n\n   /* TODO */\n\n} But sum_alice and sum_bob are not declared. So, in the code, the variables need to be initialized. So, the missing code should have sum_alice and sum_bob as 0, and then manage the loop. So, the code inside the for loop would be something like:\n\nif (sum_alice <= sum_bob) {\n\n    sum_alice += w[i];\n\n    i++;\n\n} else {\n\n    sum_bob += w[j];\n\n    j--;\n\n} if (sum_alice == sum_bob) {\n\n    num = i + (n - j - 1);\n\n} But wait, in the code, the variable 'sum' is initialized to 0. Wait the code given has:\n\nint num=0,sum=0;\n\nSo sum is initialized to 0, but perhaps that's sum_alice and sum_bob?",
      "start_char": 12340,
      "end_char": 13282,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Wait, in the given code, the variables are sum and num. But in the problem's logic, we need two sums: sum_alice and sum_bob. So the given code's sum is perhaps sum_alice, but there's no variable for sum_bob. So that's a problem.",
      "start_char": 13284,
      "end_char": 13512,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Wait, but in the code given, the variables in the loop are sum and num, but in the problem's code structure, the code as written is incomplete. So perhaps in the given code, the variables sum_alice and sum_bob are not declared. So the correct code would have to manage those variables.",
      "start_char": 13514,
      "end_char": 13799,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "So, the code's missing part is inside the for loop. So the variables sum_alice and sum_bob need to be initialized outside the loop, then updated each iteration. So, the missing code in the loop would:\n\nInitialize sum_alice and sum_bob to 0. Wait, but in the given code, sum is initialized to 0. But in the problem's code, the initial code has:\n\nint num=0, sum=0;\n\nfor (int i=0,j=n-1; i<=j; ) {\n\n   /* TODO */\n\n} But sum is a single variable, which is probably a mistake.",
      "start_char": 13802,
      "end_char": 14274,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "Because sum can't track both Alice and Bob's sums. So this is where the code is missing. So the correct code would need to have sum_alice and sum_bob variables. So the code inside the loop should:\n\n- Check if sum_alice <= sum_bob. If so, add the current i-th element to sum_alice, and increment i. Else, add j-th element to sum_bob and decrement j.\n\n- After each addition, check if sum_alice == sum_bob. If so, compute the current count (i + (n-1 -j +1) ??? Wait, wait. Wait, the current i is the number of elements Alice has eaten. Because when you start with i=0, after adding, i increments. So the number of elements is i (since after adding, i is 1, which represents 1 element). Similarly, j starts at n-1. After adding j-th element, j becomes n-2, so the number of elements Bob has eaten is (n-1 - j). For example, j was n-1 (0 elements). After adding, j becomes n-2, so (n-1 - (n-2)) =1 element. So when sum_alice equals sum_bob, the total is i + (n-1 -j). So in the code, inside the loop:\n\nsum_alice and sum_bob are variables that need to be initialized to 0 before the loop. But in the given code, the variables are not present. So the missing code should declare these variables and manage them. So the correct code inside the loop is:\n\nsum_alice and sum_bob are initialized to 0 outside the loop. Wait no. Because for each test case, sum_alice and sum_bob start at 0. So the code should be:\n\nint num=0;\n\nlong long sum_alice = 0, sum_bob = 0;\n\nfor (int i=0, j = n-1; i <= j; ) {\n\n    if (sum_alice <= sum_bob) {\n\n        sum_alice += w[i];\n\n        i++;\n\n    } else {\n\n        sum_bob += w[j];\n\n        j--;\n\n    }\n\n    if (sum_alice == sum_bob) {\n\n        num = i + (n - j -1);\n\n    }\n\n} But wait, this will overwrite num each time, but we need to keep the maximum. So, in the code, 'num' is initialized to 0.",
      "start_char": 14276,
      "end_char": 16106,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "Each time sum_alice equals sum_bob, we compute the current total and check if it's larger than 'num'. So the code should compare and set num to the maximum. But in the given code, 'num' is initialized to 0. So the correct code would be:\n\nif (sum_alice == sum_bob) {\n\n    int current = i + (n - j -1);\n\n    if (current > num) {\n\n        num = current;\n\n    }\n\n}\n\nBut in the code, the variables i and j are being updated. So after incrementing i or decrementing j, we check if sum_alice == sum_bob, and compute the current. So, in the code:\n\nInside the loop, after adding to sum_alice or sum_bob, we check if the sums are equal. If yes, calculate the current total (i + (n-1 -j +1? Or i + (n - j -1) ?",
      "start_char": 16107,
      "end_char": 16808,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Wait, for example, when i is incremented to 3, that means Alice has eaten 3 elements (indices 0,1,2). So the count is i.\n\nBob's count is (n-1 -j +1).",
      "start_char": 16810,
      "end_char": 16959,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Because j is the current index, which is the first not eaten. So for example, if j is 2, then Bob has eaten from n-1 down to 3 (since j is now 2). So the number of elements is (n-1 - j) = (n-1 - j) = 4 elements if j is n-5, etc. Wait, if j is 3, and after adding j=3, j is decremented to 2. So the number of elements Bob has eaten is (n-1 - j) because j is now 2. For example, if n=6, j starts at 5 (index 5). After adding, j becomes 4. So Bob has eaten 1 element (5). If j is 4, then n-1 -j = 5-4 =1. Wait, the number of elements Bob has eaten is (n-1 - j). Because:\n\nOriginal j is n-1 (Bob hasn't eaten anything). After adding one element, j becomes n-2: eaten 1 element (n-1 - (n-2) =1). And so on. So for current j, the number of elements Bob has eaten is (n-1 - j). So when sum_alice equals sum_bob, the current total is i (Alice's count) + (n-1 -j) (Bob's count). So in code: current = i + (n - 1 - j); Wait, no. Because j is the current index.",
      "start_char": 16960,
      "end_char": 17917,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "For example, after eating some elements, j is the current right index. So if j is k, then Bob has eaten all elements from n-1 down to k+1. So the count is (n-1 - (k) ) = n-1 -k. Yes. So current = i + (n-1 -j). So, in the code, after updating i or j, check if sum_alice == sum_bob. If yes, compute current as i + (n-1 -j). Then, if current is larger than num, update num. So the code inside the loop is:\n\nif (sum_alice == sum_bob) {\n\n    int current = i + (n-1 -j);\n\n    if (current > num) {\n\n        num = current;\n\n    }\n\n}\n\nBut in the code given, the variables sum_alice and sum_bob are not declared. So the code needs to declare them. So the missing code inside the loop would:\n\n- Declare sum_alice and sum_bob as 0 before the loop. So, the variables sum_alice and sum_bob are initialized to 0 before the loop starts. So the code would be:\n\nint num=0;\n\nlong long sum_alice=0, sum_bob=0;\n\nfor (int i=0, j=n-1; i<=j; ) {\n\n    if (sum_alice <= sum_bob) {\n\n        sum_alice += w[i];\n\n        i++;\n\n    } else {\n\n        sum_bob += w[j];\n\n        j--;\n\n    }\n\n    if (sum_alice == sum_bob) {\n\n        int current = i + (n-1 - j); if (current > num) {\n\n            num = current;\n\n        }\n\n    }\n\n}\n\nSo that's the code that needs to be filled in the TODO section. But in the given code, the variables sum_alice and sum_bob are not declared. So the code in the TODO section should declare them. But wait, no.",
      "start_char": 17918,
      "end_char": 19340,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "Because in the given code, there is a variable sum declared as 0. But that's probably a mistake, and the correct code needs to have sum_alice and sum_bob. So the original code has:\n\nint num=0,sum=0;\n\nfor(int i=0,j=n-1;i<=j;){\n    /* TODO: Your code here */\n} So the sum variable is initialized to 0. But sum is supposed to track sum_alice and sum_bob? Probably not. So the code in the TODO needs to replace the sum variable with sum_alice and sum_bob. But how to do that within the given code structure. Wait, perhaps the original code's sum is a typo and should be split into sum_alice and sum_bob. So the correct code inside the loop would be:\n\n    if (sum_alice <= sum_bob) {\n\n        sum_alice += w[i];\n\n        i++;\n\n    } else {\n\n        sum_bob += w[j];\n\n        j--;\n\n    }\n\n    if (sum_alice == sum_bob) {\n\n        num = i + (n - j -1);\n\n    } But sum_alice and sum_bob need to be declared and initialized to 0.",
      "start_char": 19342,
      "end_char": 20267,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "In the given code, the variables sum and num are initialized to 0. So perhaps the sum variable is being used for sum_alice, and sum_bob is a new variable. Wait, no. The code has sum=0. So the code is likely wrong, and the correct code should use two variables. So in the given code, the variables sum_alice and sum_bob need to be declared inside the loop, but since it's a for loop, they can't. So the code should have sum_alice and sum_bob declared before the loop. So the code should be:\n\nInside the main loop for each test case:\n\nint n=0,w[200005]={0};\n\ncin>>n;\n\nfor(int i=0;i<n;i++) cin>>w[i];\n\nint num=0;\n\nlong long sum_alice =0, sum_bob=0;\n\nfor(int i=0,j=n-1; i<=j;){\n\n    if (sum_alice <= sum_bob) {\n\n        sum_alice += w[i];\n\n        i++;\n\n    } else {\n\n        sum_bob += w[j];\n\n        j--;\n\n    }\n\n    if (sum_alice == sum_bob) {\n\n        num = max(num, i + (n -1 - j));\n\n    }\n\n}\n\ncout << num << endl;\n\n} So the variables sum_alice and sum_bob are declared and initialized to 0 before the loop. The loop updates them and checks if they are equal.",
      "start_char": 20270,
      "end_char": 21334,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "Each time they are equal, the current total is calculated as i (number of Alice's candies) plus (n-1 -j) (number of Bob's candies). We take the maximum between the current num and the new value. Thus, the code inside the loop is the part that's missing in the original code's TODO section. So, the missing code is:\n\nif (sum_alice <= sum_bob) {\n\n    sum_alice += w[i];\n\n    i++;\n\n} else {\n\n    sum_bob += w[j];\n\n    j--;\n\n}\n\nif (sum_alice == sum_bob) {\n\n    num = max(num, i + (n - 1 - j));\n\n}\n\nBut in C++, the max function is in the algorithm header, which is already included. So using max is allowed. So, the code inside the TODO section would be:\n\nif (sum_alice <= sum_bob) {\n\n    sum_alice += w[i];\n\n    i++;\n\n} else {\n\n    sum_bob += w[j];\n\n    j--;\n\n}\n\nif (sum_alice == sum_bob) {\n\n    num = max(num, i + (n -1 - j));\n\n}\n\nBut in the given code's main function, sum_alice and sum_bob are not declared. So the code is incomplete. So the missing code must include the initialization of sum_alice and sum_bob. But looking back at the code given:\n\nThe code before the loop is:\n\nint num=0,sum=0;\n\nfor(int i=0,j=n-1;i<=j; ){\n\n    /* TODO */\n\n} So the variables sum_alice and sum_bob are not declared. So the code is missing the declarations. But in the given code, sum is declared as 0. So perhaps sum is sum_alice, and we need to declare sum_bob as a new variable. So perhaps the code should be:\n\nsum_alice and sum_bob are initialized to 0. But in the given code, sum is already declared. So maybe the code uses sum for sum_alice and sum_bob for sum_bob.",
      "start_char": 21335,
      "end_char": 22893,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Wait, but that would be impossible. So the code is missing the declaration of sum_bob. So in the given code's loop, sum is sum_alice, and sum_bob is another variable. But the code in the TODO must handle that.",
      "start_char": 22897,
      "end_char": 23106,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Alternatively, maybe the code uses sum as sum_alice and another variable sum2 as sum_bob. But perhaps the code is missing the declaration of sum_alice and sum_bob, and the variables sum and sum2 are used. But in the original code, sum is initialized to 0. So perhaps the code should use sum for sum_alice, and sum_bob is another variable. But how to fit this into the code.",
      "start_char": 23108,
      "end_char": 23481,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Alternatively, perhaps the code's sum is not used, and sum_alice and sum_bob are declared inside the loop. But in C++, variables must be declared in the same scope as the loop. So in the code, sum_alice and sum_bob must be declared before the loop. So the correct code would be:\n\nint num=0;\n\nlong long sum_alice=0, sum_bob=0;\n\nfor (int i=0, j=n-1; i<=j; ) {\n\n    if (sum_alice <= sum_bob) {\n\n        sum_alice += w[i];\n\n        i++;\n\n    } else {\n\n        sum_bob += w[j];\n\n        j--;\n\n    }\n\n    if (sum_alice == sum_bob) {\n\n        num = max(num, i + (n -1 - j));\n\n    }\n\n} Thus, the missing code inside the loop is the code inside the loop's body. So the code that needs to be filled in the TODO section is:\n\n            if (sum_alice <= sum_bob) {\n\n                sum_alice += w[i];\n\n                i++;\n\n            } else {\n\n                sum_bob += w[j];\n\n                j--;\n\n            }\n\n            if (sum_alice == sum_bob) {\n\n                num = max(num, i + (n - 1 - j));\n\n            } But how is sum_alice and sum_bob declared in the given code? They are not. So in the given code, the variables sum_alice and sum_bob are not present, but the code has a sum variable.",
      "start_char": 23485,
      "end_char": 24682,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "This suggests that the given code is missing the declarations for sum_alice and sum_bob, and the code in the TODO must include these declarations. But in C++, you can't declare variables inside the loop's condition. So the correct way is to declare them before the loop. But the given code has:\n\nint num=0,sum=0;\n\nfor(int i=0,j=n-1;i<=j;){\n    /* TODO */\n} So sum is initialized to 0. But sum is sum_alice, and sum_bob needs to be another variable. So perhaps the code should be:\n\nint num=0;\n\nlong long sum_alice=0, sum_bob=0;\n\nfor(int i=0,j=n-1; i<=j; ){\n\n    if(sum_alice <= sum_bob){\n\n        sum_alice += w[i];\n\n        i++;\n\n    } else {\n\n        sum_bob += w[j];\n\n        j--;\n\n    }\n\n    if(sum_alice == sum_bob){\n\n        num = max(num, i + (n-1 -j));\n\n    }\n\n} So the code uses sum_alice and sum_bob variables, which are declared before the loop. But in the original code, sum is declared as a variable. So perhaps the original code is a mistake, and the correct code should replace sum with sum_alice and sum_bob.",
      "start_char": 24685,
      "end_char": 25712,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "So, in the given code, the variables num and sum are declared. But sum is not used, and the code uses sum_alice and sum_bob. But the code given in the problem has sum=0. So the sum variable is redundant. So the correct code would replace sum with sum_alice and sum_bob. So the missing code in the TODO section is:\n\n            if (sum_alice <= sum_bob) {\n\n                sum_alice += w[i];\n\n                i++;\n\n            } else {\n\n                sum_bob += w[j];\n\n                j--;\n\n            }\n\n            if (sum_alice == sum_bob) {\n\n                num = max(num, i + (n-1 -j));\n\n            } But sum_alice and sum_bob need to be initialized to 0 before the loop.",
      "start_char": 25716,
      "end_char": 26397,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "So, the code needs to have:\n\nsum_alice and sum_bob initialized to 0. But in the given code, sum is initialized to 0. So perhaps the original code's sum was intended to be sum_alice, but that's wrong.",
      "start_char": 26400,
      "end_char": 26599,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Thus, the correct code is to declare sum_alice and sum_bob, initialize them to 0, and then proceed. So the missing code is the code inside the loop that handles sum_alice and sum_bob, and updates the pointers. So the code to fill in the TODO is:\n\n            if (sum_alice <= sum_bob) {\n\n                sum_alice += w[i];\n\n                i++;\n\n            } else {\n\n                sum_bob += w[j];\n\n                j--;\n\n            }\n\n            if (sum_alice == sum_bob) {\n\n                num = max(num, i + (n -1 - j));\n\n            } But sum_alice and sum_bob must be declared and initialized to 0 before the loop.",
      "start_char": 26602,
      "end_char": 27227,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "In the given code, the variables num and sum are initialized as 0. So sum is redundant. So the correct code should replace sum with sum_alice and sum_bob. But in the given code's main loop, the variables sum_alice and sum_bob are not declared. So the correct code would have to declare sum_alice and sum_bob before the loop. But according to the problem statement, we have to fill in the missing code.",
      "start_char": 27230,
      "end_char": 27631,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "The code provided already has a sum variable. So perhaps the code is supposed to use sum and another variable, but that's unclear. Alternatively, perhaps the code's sum variable is sum_alice, and sum_bob is a new variable. But how to fit that. But given the original code's structure, the sum variable is declared as:\n\nint num=0,sum=0;\n\nBut sum is of type int, which could overflow for large numbers.",
      "start_char": 27635,
      "end_char": 28037,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Because each w_i can be up to 1e4, and n up to 2e5, so sum can be up to 2e9, which is larger than int's capacity (which is about 2e9 for 32-bit int). So using long long is necessary. But the original code has sum as an int. That's a problem. So the correct code must use long long for sum_alice and sum_bob.",
      "start_char": 28038,
      "end_char": 28345,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Thus, the code must declare sum_alice and sum_bob as long long, initialized to 0. But in the given code's main loop, sum is declared as an int. So perhaps that's an error. So, putting it all together, the missing code inside the loop is:\n\n            if (sum_alice <= sum_bob) {\n\n                sum_alice += w[i];\n\n                i++;\n\n            } else {\n\n                sum_bob += w[j];\n\n                j--;\n\n            }\n\n            if (sum_alice == sum_bob) {\n\n                num = max(num, i + (n - 1 - j));\n\n            } And before the loop, sum_alice and sum_bob are initialized to 0. But in the given code, the variables sum_alice and sum_bob are not present. So the code must declare them. But the problem's code has the variables declared as sum and num. So perhaps the code is incorrect, and the solution requires modifying that.",
      "start_char": 28348,
      "end_char": 29199,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "However, the user's instruction says to output only the missing code, which is the part that goes into the TODO section. But according to the given code structure, sum is already declared. So perhaps the code should use sum as sum_alice and another variable for sum_bob. But this is ambiguous.",
      "start_char": 29203,
      "end_char": 29496,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Alternatively, perhaps the code uses sum for sum_alice and another variable sum2 for sum_bob. But the code provided doesn't declare sum2.",
      "start_char": 29500,
      "end_char": 29637,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "So, the correct code must include the declarations of sum_alice and sum_bob. But since the code is inside the loop, and the loop is inside the for loop, perhaps the code must declare them before the loop. But the user's code is:\n\nint main() {\n    ... while (t--) {\n        ... \n        int num=0, sum=0;\n        for (int i=0,j=n-1; ... ) {\n            /* TODO */\n        }\n        cout << num << endl;\n    }\n} So, inside the while loop, for each test case, num and sum are declared as 0. Then, the for loop. So the missing code inside the for loop's body is the code that uses sum and another variable (perhaps sum2) to track the two sums. But since sum is declared as int, which could be too small, but the problem constraints require long long.",
      "start_char": 29640,
      "end_char": 30392,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "So, the correct approach is to declare sum_alice and sum_bob as long long variables, initialized to 0, inside the for loop's scope. But in C++, you can't declare variables inside the for loop's condition. So perhaps they are declared before the loop. Wait, the code in the main function for each test case is:\n\nint n=0,w[200005]={0};\n\ncin>>n;\n\nfor(int i=0;i<n;i++) cin>>w[i];\n\nint num=0,sum=0;\n\nfor(int i=0,j=n-1;i<=j; ){\n\n    /* TODO: Your code here */\n\n}\n\ncout<<num<<endl;\n\n} So the variables sum_alice and sum_bob need to be declared inside the for loop's body. But variables declared inside a loop's body are reinitialized each iteration. Wait, no.",
      "start_char": 30397,
      "end_char": 31050,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The for loop's body is executed each time the loop runs. So if we declare sum_alice and sum_bob inside the loop's body, they will be initialized each iteration. But in this case, the loop is for (i=0,j=n-1; i<=j; ), and the sum_alice and sum_bob need to be tracked across iterations. Thus, sum_alice and sum_bob need to be declared outside the loop but inside the for loop's scope. So, the variables must be declared before the loop starts. So the correct code is:\n\nint num=0;\n\nlong long sum_alice = 0, sum_bob = 0;\n\nfor (int i=0, j=n-1; i <=j; ) {\n\n    if (sum_alice <= sum_bob) {\n\n        sum_alice += w[i];\n\n        i++;\n\n    } else {\n\n        sum_bob += w[j];\n\n        j--;\n\n    }\n\n    if (sum_alice == sum_bob) {\n\n        num = max(num, i + (n -1 - j));\n\n    }\n\n} So the variables sum_alice and sum_bob are declared outside the for loop but inside the test case processing (after the input is read). But in the given code, the variables sum and num are declared. So the code must be modified to declare sum_alice and sum_bob. But the given code has sum declared as an int. So the code must replace sum with sum_alice and sum_bob, which are long long variables. Thus, the code inside the TODO is:\n\nif (sum_alice <= sum_bob) {\n\n    sum_alice += w[i];\n\n    i++;\n\n} else {\n\n    sum_bob += w[j];\n\n    j--;\n\n}\n\nif (sum_alice == sum_bob) {\n\n    num = max(num, i + (n - 1 - j));\n\n} And the variables sum_alice and sum_bob are declared and initialized to 0 before the loop. But according to the given code's structure, the variables sum_alice and sum_bob are not declared. So the code must include their declarations. But the user's instruction says to output only the missing code that fills the TODO part. So the code that's missing is the code inside the loop. But the declarations of sum_alice and sum_bob must be done outside the loop. So how can that be handled?",
      "start_char": 31053,
      "end_char": 32922,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Ah, because the variables sum_alice and sum_bob are declared before the loop. So in the given code, the variables must be declared. But in the provided code, sum is declared as an int, which is probably a mistake. But according to the user's problem, we need to output only the missing code that fills the TODO part. So even if the original code has variables sum and num, but the correct code needs sum_alice and sum_bob, we have to assume that the variables are declared. But the original code's sum is not used. So perhaps the code should be modified to use sum_alice and sum_bob. Thus, the correct code for the TODO is:\n\n// Inside the for loop:\n\nif (sum_alice <= sum_bob) {\n\n    sum_alice += w[i];\n\n    i++;\n\n} else {\n\n    sum_bob += w[j];\n\n    j--;\n\n}\n\nif (sum_alice == sum_bob) {\n\n    num = max(num, i + (n - 1 - j));\n\n} But sum_alice and sum_bob must be declared and initialized to 0 before the loop. So the code for the test case is:\n\nint num=0;\n\nlong long sum_alice=0, sum_bob=0;\n\nfor(int i=0,j=n-1; i<=j; ){ if (sum_alice <= sum_bob) {\n\n        sum_alice += w[i];\n\n        i++;\n\n    } else {\n\n        sum_bob += w[j];\n\n        j--;\n\n    }\n\n    if (sum_alice == sum_bob) {\n\n        num = max(num, i + (n-1 -j));\n\n    }\n\n}\n\nBut according to the problem's code, the code after reading the array has:\n\nint num=0, sum=0; So the correct code would replace sum=0 with sum_alice and sum_bob=0. But according to the user's instruction, we have to output only the missing code. So the missing code is the code inside the loop. But the variables sum_alice and sum_bob must be declared and initialized to 0 before the loop. But since the code provided already has sum declared, perhaps the code is using sum as sum_alice and sum_bob as another variable. But that's not possible. So this is a bit confusing. But given the code provided, the missing code inside the loop would be:\n\nsum_alice and sum_bob are initialized to 0, and the code inside the loop is:\n\n            if (sum_alice <= sum_bob) {\n\n                sum_alice += w[i];\n\n                i++;\n\n            } else {\n\n                sum_bob += w[j];\n\n                j--;\n\n            }\n\n            if (sum_alice == sum_bob) {\n\n                num = max(num, i + (n - 1 - j));\n\n            }\n\nBut this code would require sum_alice and sum_bob to be declared and initialized outside the loop. So, assuming that sum_alice and sum_bob are declared and initialized to 0, the code inside the TODO is:\n\n            if (sum_alice <= sum_bob) {\n\n                sum_alice += w[i];\n\n                i++;\n\n            } else {\n\n                sum_bob += w[j];\n\n                j--;\n\n            }\n\n            if (sum_alice == sum_bob) {\n\n                num = max(num, i + (n - 1 - j));\n\n            } Thus, the missing code is this part. But how to handle the declarations. But according to the problem's code, the variables are not declared. So perhaps the user's code has to be modified to declare sum_alice and sum_bob, but the user's instruction says to output only the missing code. But the user's code already has variables declared as:\n\nint num=0,sum=0; So perhaps the code is supposed to use sum as sum_alice and another variable sum2 as sum_bob. But the code would then have:\n\nint num=0, sum=0, sum2=0;\n\nfor (int i=0,j=n-1; ... ) But sum and sum2 are of type int, which can overflow. But given that the sample inputs may not have such large numbers, perhaps the code would work. But according to the problem's constraints, the sum can be up to 2e5 * 1e4 = 2e9, which is larger than the maximum value for a 32-bit int (which is about 2e9), so using 64-bit integers is necessary. But in C++, if the variables are declared as long long, that would be better. So perhaps the correct code should declare sum_alice and sum_bob as long long variables. But the problem's code doesn't have these variables declared. So the answer must include the code that declares sum_alice and sum_bob, but according to the user's instruction, only the missing code is to be output. But the missing code is inside the loop's TODO section. So the code inside the loop's body is:\n\n            if (sum_alice <= sum_bob) {\n\n                sum_alice += w[i];\n\n                i++;\n\n            } else {\n\n                sum_bob += w[j];\n\n                j--;\n\n            }\n\n            if (sum_alice == sum_bob) {\n\n                num = max(num, i + (n - 1 - j));\n\n            } But sum_alice and sum_bob must be declared before the loop. But given that the code provided does not declare them, this is impossible. So perhaps the code is supposed to use the existing sum variable for sum_alice and another variable for sum_bob. But this is getting too ambiguous.",
      "start_char": 32928,
      "end_char": 37651,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "However, based on the problem's description and the sample inputs, the correct code must use two variables for the sums, and the missing code is the part inside the loop. Therefore, the correct missing code is:\n\n            if (sum_alice <= sum_bob) {\n\n                sum_alice += w[i];\n\n                i++;\n\n            } else {\n\n                sum_bob += w[j];\n\n                j--;\n\n            }\n\n            if (sum_alice == sum_bob) {\n\n                num = max(num, i + (n - 1 - j));\n\n            }\n\nAssuming that sum_alice and sum_bob are declared and initialized to 0 before the loop. So the code that needs to be filled in the TODO is:\n\nsum_alice += w[i];\ni++;\n} else {\nsum_bob += w[j];\nj--;\n}\nif (sum_alice == sum_bob) {\nnum = max(num, i + (n -1 - j));\n} But the code must check the condition and add to sum_alice or sum_bob, then check if they are equal. So, the final code to be filled in the TODO is:\n\nif (sum_alice <= sum_bob) {\n    sum_alice += w[i];\n    i++;\n} else {\n    sum_bob += w[j];\n    j--;\n}\nif (sum_alice == sum_bob) {\n    num = max(num, i + (n - 1 - j));\n}",
      "start_char": 37655,
      "end_char": 38745,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    }
  ],
  "metadata": {
    "state": "compile_failed",
    "answer": "if (sum <= sum_bob) {\n    sum += w[i];\n    i++;\n} else {\n    sum_bob += w[j];\n    j--;\n}\nif (sum == sum_bob) {\n    num = max(num, i + (n - 1 - j));\n}"
  },
  "original_reasoning": "Okay, let's see. The problem is about Alice and Bob eating candies from the left and right respectively, such that their total weights are equal, and we need to find the maximum number of candies they can eat in total. Hmm.\n\nSo, the approach here is probably using a two-pointer technique. Like, we start with Alice taking from the left, Bob from the right. We need to track the sum of Alice's candies and Bob's sum. When Alice's sum is less than Bob's, we add more from the left. If Bob's is less, we add from the right. And whenever their sums are equal, we record the number of candies eaten (i + (n-1 -j +1) maybe?), and then check if we can add more. But how?\n\nWait, the key is to maximize the total number of candies when their sums are equal. So, we need to find the earliest point where the sums are equal and see if we can proceed further.\n\nWait, maybe the approach is to have two pointers, left and right. We calculate the sum for Alice (left_sum) starting from the left, and Bob's sum (right_sum) starting from the right. Then, whenever left_sum equals right_sum, we note the total candies (left_count + right_count) and see if that's the maximum. Then, move the pointers accordingly.\n\nBut how to move the pointers to find all possible equal sums. For example, if left_sum is smaller than right_sum, we need to add more to Alice's sum. So we move the left pointer to the right. If the right_sum is smaller, add from the right by moving the right pointer left. We do this until the pointers cross each other.\n\nLet's think with an example. Like the second test case in the note: [3,1,4,1,5,9]. The sum for Alice is 3+1+4=8, and for Bob, 9+5+1=15. Wait, no, the example in the note says that Alice eats the first three (3+1+4=8?), but maybe the example in the note is different. Wait, no, the second test case says the answer is 6 because they eat all 6 candies. Oh right, because the sum is 7 each. Wait maybe the example is different. Let me check the note again.\n\nWait in the second test case example, the input is 3 1 4 1 5 9, but the sum of the first three is 3+1+4=8? Wait the note says that Alice eats the first three from the left (7?), maybe I'm getting the numbers wrong. Wait the note says:\n\nFor the second test case, Alice eats the first three from the left with total weight 7. Wait that's 3 + 1 + 4? 3+1 is 4, plus 4 makes 8. Hmm maybe the actual input was different. Oh well, maybe it's better to focus on the problem.\n\nSo the idea is that we have two pointers, left and right. We track the sum of Alice and Bob. If Alice's sum is less than Bob's, we add the next left candy. If Bob's sum is less, we add the next right candy. When they are equal, we record the total candies eaten (left count plus right count), then we can choose to add either side, but need to proceed. Wait, but once the sums are equal, maybe the next step is to check if adding more can keep the sums equal. But how?\n\nAlternatively, whenever the sums are equal, we can note the current total. Then, we have to continue moving the pointers to see if there's a higher total. So the maximum will be the maximum of all such equal sums.\n\nLet me think of the algorithm steps:\n\nInitialize left_ptr = 0, right_ptr = n-1.\n\nsum_alice = 0, sum_bob = 0.\n\nmax_candies = 0.\n\ncount_alice = 0, count_bob =0.\n\nWait, maybe we need to track the sum and counts. For example:\n\nsum_alice starts at 0. We take the first candy (left_ptr increments to 0), sum_alice += w[0], count_alice is 1. Compare sum_alice with sum_bob (which is 0). Since sum_alice is larger, sum_bob += w[right_ptr], right_ptr moves to n-2, count_bob is 1.\n\nWait, no. Maybe the initial step is to have sum_alice and sum_bob as 0, and the pointers not yet processed.\n\nWait, here's the algorithm:\n\nInitialize left = 0, right = n-1.\n\nsum_alice = 0, sum_bob = 0.\n\nmax_candies = 0.\n\nleft_count =0, right_count =0.\n\nWe need to loop while left <= right.\n\nBut how to process:\n\nIf sum_alice <= sum_bob: then take the next left candy. Add to sum_alice, increment left.\n\nElse: take next right candy. Add to sum_bob, decrement right.\n\nBut whenever sum_alice and sum_bob are equal, we check if left_count + right_count is larger than current max_candies. Then, we can proceed to take either next left or right, but which one?\n\nWait, maybe during the process, whenever the two sums are equal, we can update the max_candies. Then continue adding to the side with the smaller sum.\n\nWait for example:\n\nsum_alice is 5, sum_bob is 5. Then, if left <= right, we can add to the sum which is smaller. But if both are equal, perhaps we can add to either side. But which one gives a better chance for more total candies? Hmm, but perhaps the optimal is to capture the current sum and then proceed. Let's see.\n\nLet's take the first test case in the note:\n\nInput is 2, with candies 1 and 1. Then, Alice takes 1 (sum 1), Bob takes 1 (sum 1). They have eaten 2 candies. That's the answer.\n\nAnother example: if the array is [1,1,1], then Alice takes 1, Bob takes 1. Sums are equal, total 2. But if they take 3 each (sum 3), but that would require Alice taking all three from left (sum 3) and Bob taking all three from right (sum 3). But that's impossible because they can't eat the same candies. Wait, in this case, the entire array can't be eaten by both. So the maximum is 2.\n\nWait, so in this case, the optimal is when they take 1 each from left and right, sum 1 each. Then, the next steps would be to check.\n\nSo the algorithm would be:\n\nInitialize sum_alice = 0, sum_bob =0.\n\nleft=0, right =n-1.\n\nmax_candies=0.\n\nloop while left <= right:\n\n   if sum_alice <= sum_bob:\n\n       add w[left] to sum_alice, increment left.\n\n   else:\n\n       add w[right] to sum_bob, decrement right.\n\n   after each addition, check if sum_alice == sum_bob. If yes, update max_candies as left + (n - right -1).\n\nWait, because the left variable is the number of candies taken by Alice (left starts at 0, after adding, left is 1: so left counts how many she took). Similarly, right is the index, but the number of candies Bob took is (n-1 - right +1) = (n - right). Because initially, right is n-1. When you take a right candy, you add w[right], then right becomes right-1. So the number of candies Bob has taken is (n-1 - (right+1) +1) )? Wait, maybe not. Let's see.\n\nSuppose the original right is n-1. When we take one candy from the right, right becomes n-2. So Bob has taken 1 candy. The count is (n-1 - right). Because when right is n-1, he's taken 0. When he takes one, right is n-2, count is 1.\n\nWait, for each step:\n\nsum_bob is the sum of candies from the right, starting from the end. So for example, if he takes k candies, then those are the last k candies.\n\nSo the count of Bob's candies is (original right index +1) - (current right index +1). Because original right is n-1. After taking m steps, right is r. So the number of candies taken by Bob is (n-1 - r). Because initially, right is n-1 (taken 0). If he takes one, right is n-2, so (n-1 - (n-2))=1. So yes.\n\nSo the total number of candies when sum_alice == sum_bob is (left) + (n-1 - right).\n\nSo during each step, after adding to sum_alice or sum_bob, we check if the sums are equal, and if so, update max_candies as the maximum between current max and left + (n-1 - right).\n\nSo the code needs to track left and right pointers, sum_alice and sum_bob, and each time we add to one of them, check if the sums are equal, and then calculate the current total.\n\nThis approach would work because we greedily add to the smaller sum. Whenever the sums are equal, we record the possible total. And since we process the pointers until they cross, we'll check all possible cases where the sums are equal.\n\nLet me test this logic against the sample inputs.\n\nSample 1:\n\nTest case 1: n=2, w=1 1.\n\nInitial sum_alice=0, sum_bob=0.\n\nsum_alice <= sum_bob, so add 1 (sum_alice becomes 1, left=1). Now check sum_alice (1) vs sum_bob (0). Since sum_alice > sum_bob, add right. Take 1 (sum_bob becomes 1, right=0). Now check sums equal. So total is left=1, (n-1 - right) = (1 - 0) =1. So 1+1=2. Which matches the sample.\n\nSample 2:\n\nTest case 2: n=6, w=3 1 4 1 5 9.\n\nThe correct answer is 6. Let's see.\n\nsum_alice starts at 0, sum_bob 0.\n\nsum_alice is <= sum_bob (0 <=0). So add 3 to sum_alice (sum_alice=3), left=1. sum_alice (3) > sum_bob (0). So add right (9). sum_bob=9, right=4. Now, sum_alice 3 < sum_bob 9. So add left (1). sum_alice 4, left=2. sum_alice (4) < 9. Add left (4), sum_alice 8, left=3. sum_alice (8) < sum_bob (9). Add left (1). sum_alice 9, left=4. Now sum_alice (9) equals sum_bob (9). Total is 4 (left) + (5 -4) =4+1=5. But the sample says answer is 6. Hmm. Wait what's happening here.\n\nWait the sample says Alice eats first three candies (3+1+4=8), Bob eats first three from the right (9+5+1=15). Wait maybe I'm miscalculating.\n\nWait maybe the sample's input is different. Wait in the note for the second test case: the input is 3 1 4 1 5 9. But according to the note, the answer is 6. So Alice takes 3, 1, 4 (sum 8?), Bob takes 9,5,1 (sum 15). Then, they can't. Wait the note says that the answer is 6 because all candies are eaten. So perhaps the example is different. Oh, maybe the sum is 7 each. Hmm. Maybe I'm missing something here. Let me see the note again.\n\nAh, the note says:\n\nFor the second test case, Alice will eat the first three candies from the left (with total weight 7) and Bob will eat the first three candies from the right (with total weight 7). Oh, so the input must be different. Like perhaps the array is [3,1,3,1,1,3]. Or something that sums to 7 for the first three and 7 for the last three. So perhaps my algorithm isn't handling that scenario correctly.\n\nAlternatively, perhaps the example in the note is:\n\nTest case 2 input: [7,3,1,5,1,3], so that first three sum to 7+3+1=11, but no. Let's think differently.\n\nWait, according to the note, after both eat three candies, the total is 7 each, and all candies are eaten (so 6 total). So the array must be of length 6, and when Alice eats the first three, Bob eats the last three, and their sums are equal. So for example, the array could be [1,2,4,4,2,1]. Alice's sum is 1+2+4=7, Bob's sum is 1+2+4=7. Then, the total is 6.\n\nIn that case, according to the algorithm:\n\nsum_alice starts at 0. sum_bob is 0. Since they are equal, add to left (sum_alice becomes 1, left=1). Now sum_alice (1) is > sum_bob (0). Add to right (sum_bob=1, right=4). Now sums are 1 and 1. Total is 1 (left) + (5-4) =1 +1=2. Then, since sum_alice is 1 == sum_bob 1, update max_candies to 2. Now, sum_alice <= sum_bob (1 <=1), so add next left (2). sum_alice=3, left=2. sum_alice (3) > sum_bob (1). So add to right (sum_bob=3, right=3). Now sums are 3 and 3. Total is 2 + (5-3) =2+2=4. Update max. Then, sum_alice is 3 <=3. Add next left (4). sum_alice=7, left=3. sum_alice (7) >3. Add right (sum_bob +=4. sum_bob=7, right=2. Now sums are equal. Total is 3 + (5-2) =3+3=6. So max is now 6. Then, since left (3) <= right (2) is false, loop ends. So the algorithm returns 6, which is correct.\n\nSo the algorithm works for this case.\n\nSo the key is to check after each addition if the sums are equal and update the max_candies.\n\nSo in the code, after adding to sum_alice or sum_bob, we check if they are equal, and compute the current total (left + (n-1 - right)). Then, keep track of the maximum.\n\nSo the code needs to do:\n\nInitialize sum_alice=0, sum_bob=0, left=0, right =n-1, max_candies=0.\n\nLoop while left <= right:\n\n   if sum_alice <= sum_bob:\n\n       sum_alice += w[left]\n\n       left +=1\n\n   else:\n\n       sum_bob += w[right]\n\n       right -=1\n\n   if sum_alice == sum_bob:\n\n       current_total = left + (n-1 - right)\n\n       if current_total > max_candies:\n\n           max_candies = current_total\n\nSo the code should have this logic.\n\nNow, looking back at the given code structure:\n\nThe code has a for loop with i and j, starting at 0 and n-1. But in the given code, the variables are i and j. But the loop is for(int i=0,j=n-1; i<=j; ). So inside the loop, we need to adjust i and j, and sum_alice and sum_bob, and track the maximum.\n\nBut the variables in the code are named i and j. So let's see.\n\nThe given code has:\n\nfor(int i=0,j=n-1; i<=j; ){\n\n   /* TODO */\n\n}\n\nSo, we need to track sum_alice and sum_bob, and for each step, add to one of them. Then, check if the sums are equal and update num (which is the maximum).\n\nSo, in the code:\n\nInside the loop, we'll have:\n\nsum_alice starts at 0.\n\nsum_bob starts at 0.\n\nBut wait, in the given code, the variables are not initialized. So in the code, after reading n and the array, the code initializes num=0, sum=0. Then, the for loop with i and j.\n\nWait, the original code has:\n\nfor(int i=0,j=n-1; i<=j; ){\n\n   /* TODO */\n\n}\n\nBut sum_alice and sum_bob are not declared. So, in the code, the variables need to be initialized.\n\nSo, the missing code should have sum_alice and sum_bob as 0, and then manage the loop.\n\nSo, the code inside the for loop would be something like:\n\nif (sum_alice <= sum_bob) {\n\n    sum_alice += w[i];\n\n    i++;\n\n} else {\n\n    sum_bob += w[j];\n\n    j--;\n\n}\n\nif (sum_alice == sum_bob) {\n\n    num = i + (n - j - 1);\n\n}\n\nBut wait, in the code, the variable 'sum' is initialized to 0. Wait the code given has:\n\nint num=0,sum=0;\n\nSo sum is initialized to 0, but perhaps that's sum_alice and sum_bob?\n\nWait, in the given code, the variables are sum and num. But in the problem's logic, we need two sums: sum_alice and sum_bob.\n\nSo the given code's sum is perhaps sum_alice, but there's no variable for sum_bob. So that's a problem. Wait, but in the code given, the variables in the loop are sum and num, but in the problem's code structure, the code as written is incomplete.\n\nSo perhaps in the given code, the variables sum_alice and sum_bob are not declared. So the correct code would have to manage those variables.\n\nSo, the code's missing part is inside the for loop. So the variables sum_alice and sum_bob need to be initialized outside the loop, then updated each iteration.\n\nSo, the missing code in the loop would:\n\nInitialize sum_alice and sum_bob to 0.\n\nWait, but in the given code, sum is initialized to 0. But in the problem's code, the initial code has:\n\nint num=0, sum=0;\n\nfor (int i=0,j=n-1; i<=j; ) {\n\n   /* TODO */\n\n}\n\nBut sum is a single variable, which is probably a mistake. Because sum can't track both Alice and Bob's sums. So this is where the code is missing.\n\nSo the correct code would need to have sum_alice and sum_bob variables. So the code inside the loop should:\n\n- Check if sum_alice <= sum_bob. If so, add the current i-th element to sum_alice, and increment i. Else, add j-th element to sum_bob and decrement j.\n\n- After each addition, check if sum_alice == sum_bob. If so, compute the current count (i + (n-1 -j +1) ??? Wait, wait.\n\nWait, the current i is the number of elements Alice has eaten. Because when you start with i=0, after adding, i increments. So the number of elements is i (since after adding, i is 1, which represents 1 element).\n\nSimilarly, j starts at n-1. After adding j-th element, j becomes n-2, so the number of elements Bob has eaten is (n-1 - j). For example, j was n-1 (0 elements). After adding, j becomes n-2, so (n-1 - (n-2)) =1 element.\n\nSo when sum_alice equals sum_bob, the total is i + (n-1 -j).\n\nSo in the code, inside the loop:\n\nsum_alice and sum_bob are variables that need to be initialized to 0 before the loop.\n\nBut in the given code, the variables are not present. So the missing code should declare these variables and manage them.\n\nSo the correct code inside the loop is:\n\nsum_alice and sum_bob are initialized to 0 outside the loop.\n\nWait no. Because for each test case, sum_alice and sum_bob start at 0.\n\nSo the code should be:\n\nint num=0;\n\nlong long sum_alice = 0, sum_bob = 0;\n\nfor (int i=0, j = n-1; i <= j; ) {\n\n    if (sum_alice <= sum_bob) {\n\n        sum_alice += w[i];\n\n        i++;\n\n    } else {\n\n        sum_bob += w[j];\n\n        j--;\n\n    }\n\n    if (sum_alice == sum_bob) {\n\n        num = i + (n - j -1);\n\n    }\n\n}\n\nBut wait, this will overwrite num each time, but we need to keep the maximum.\n\nSo, in the code, 'num' is initialized to 0. Each time sum_alice equals sum_bob, we compute the current total and check if it's larger than 'num'. So the code should compare and set num to the maximum.\n\nBut in the given code, 'num' is initialized to 0. So the correct code would be:\n\nif (sum_alice == sum_bob) {\n\n    int current = i + (n - j -1);\n\n    if (current > num) {\n\n        num = current;\n\n    }\n\n}\n\nBut in the code, the variables i and j are being updated. So after incrementing i or decrementing j, we check if sum_alice == sum_bob, and compute the current.\n\nSo, in the code:\n\nInside the loop, after adding to sum_alice or sum_bob, we check if the sums are equal. If yes, calculate the current total (i + (n-1 -j +1? Or i + (n - j -1) ?\n\nWait, for example, when i is incremented to 3, that means Alice has eaten 3 elements (indices 0,1,2). So the count is i.\n\nBob's count is (n-1 -j +1). Because j is the current index, which is the first not eaten. So for example, if j is 2, then Bob has eaten from n-1 down to 3 (since j is now 2). So the number of elements is (n-1 - j) = (n-1 - j) = 4 elements if j is n-5, etc.\n\nWait, if j is 3, and after adding j=3, j is decremented to 2. So the number of elements Bob has eaten is (n-1 - j) because j is now 2. For example, if n=6, j starts at 5 (index 5). After adding, j becomes 4. So Bob has eaten 1 element (5). If j is 4, then n-1 -j = 5-4 =1.\n\nWait, the number of elements Bob has eaten is (n-1 - j). Because:\n\nOriginal j is n-1 (Bob hasn't eaten anything). After adding one element, j becomes n-2: eaten 1 element (n-1 - (n-2) =1). And so on.\n\nSo for current j, the number of elements Bob has eaten is (n-1 - j).\n\nSo when sum_alice equals sum_bob, the current total is i (Alice's count) + (n-1 -j) (Bob's count).\n\nSo in code:\n\ncurrent = i + (n - 1 - j);\n\nWait, no. Because j is the current index. For example, after eating some elements, j is the current right index. So if j is k, then Bob has eaten all elements from n-1 down to k+1. So the count is (n-1 - (k) ) = n-1 -k.\n\nYes. So current = i + (n-1 -j).\n\nSo, in the code, after updating i or j, check if sum_alice == sum_bob. If yes, compute current as i + (n-1 -j). Then, if current is larger than num, update num.\n\nSo the code inside the loop is:\n\nif (sum_alice == sum_bob) {\n\n    int current = i + (n-1 -j);\n\n    if (current > num) {\n\n        num = current;\n\n    }\n\n}\n\nBut in the code given, the variables sum_alice and sum_bob are not declared. So the code needs to declare them.\n\nSo the missing code inside the loop would:\n\n- Declare sum_alice and sum_bob as 0 before the loop.\n\nSo, the variables sum_alice and sum_bob are initialized to 0 before the loop starts.\n\nSo the code would be:\n\nint num=0;\n\nlong long sum_alice=0, sum_bob=0;\n\nfor (int i=0, j=n-1; i<=j; ) {\n\n    if (sum_alice <= sum_bob) {\n\n        sum_alice += w[i];\n\n        i++;\n\n    } else {\n\n        sum_bob += w[j];\n\n        j--;\n\n    }\n\n    if (sum_alice == sum_bob) {\n\n        int current = i + (n-1 - j);\n\n        if (current > num) {\n\n            num = current;\n\n        }\n\n    }\n\n}\n\nSo that's the code that needs to be filled in the TODO section.\n\nBut in the given code, the variables sum_alice and sum_bob are not declared. So the code in the TODO section should declare them. But wait, no. Because in the given code, there is a variable sum declared as 0. But that's probably a mistake, and the correct code needs to have sum_alice and sum_bob.\n\nSo the original code has:\n\nint num=0,sum=0;\n\nfor(int i=0,j=n-1;i<=j;){\n    /* TODO: Your code here */\n}\n\nSo the sum variable is initialized to 0. But sum is supposed to track sum_alice and sum_bob? Probably not. So the code in the TODO needs to replace the sum variable with sum_alice and sum_bob.\n\nBut how to do that within the given code structure.\n\nWait, perhaps the original code's sum is a typo and should be split into sum_alice and sum_bob.\n\nSo the correct code inside the loop would be:\n\n    if (sum_alice <= sum_bob) {\n\n        sum_alice += w[i];\n\n        i++;\n\n    } else {\n\n        sum_bob += w[j];\n\n        j--;\n\n    }\n\n    if (sum_alice == sum_bob) {\n\n        num = i + (n - j -1);\n\n    }\n\nBut sum_alice and sum_bob need to be declared and initialized to 0.\n\nIn the given code, the variables sum and num are initialized to 0. So perhaps the sum variable is being used for sum_alice, and sum_bob is a new variable.\n\nWait, no. The code has sum=0. So the code is likely wrong, and the correct code should use two variables.\n\nSo in the given code, the variables sum_alice and sum_bob need to be declared inside the loop, but since it's a for loop, they can't. So the code should have sum_alice and sum_bob declared before the loop.\n\nSo the code should be:\n\nInside the main loop for each test case:\n\nint n=0,w[200005]={0};\n\ncin>>n;\n\nfor(int i=0;i<n;i++) cin>>w[i];\n\nint num=0;\n\nlong long sum_alice =0, sum_bob=0;\n\nfor(int i=0,j=n-1; i<=j;){\n\n    if (sum_alice <= sum_bob) {\n\n        sum_alice += w[i];\n\n        i++;\n\n    } else {\n\n        sum_bob += w[j];\n\n        j--;\n\n    }\n\n    if (sum_alice == sum_bob) {\n\n        num = max(num, i + (n -1 - j));\n\n    }\n\n}\n\ncout << num << endl;\n\n}\n\nSo the variables sum_alice and sum_bob are declared and initialized to 0 before the loop. The loop updates them and checks if they are equal. Each time they are equal, the current total is calculated as i (number of Alice's candies) plus (n-1 -j) (number of Bob's candies). We take the maximum between the current num and the new value.\n\nThus, the code inside the loop is the part that's missing in the original code's TODO section.\n\nSo, the missing code is:\n\nif (sum_alice <= sum_bob) {\n\n    sum_alice += w[i];\n\n    i++;\n\n} else {\n\n    sum_bob += w[j];\n\n    j--;\n\n}\n\nif (sum_alice == sum_bob) {\n\n    num = max(num, i + (n - 1 - j));\n\n}\n\nBut in C++, the max function is in the algorithm header, which is already included. So using max is allowed.\n\nSo, the code inside the TODO section would be:\n\nif (sum_alice <= sum_bob) {\n\n    sum_alice += w[i];\n\n    i++;\n\n} else {\n\n    sum_bob += w[j];\n\n    j--;\n\n}\n\nif (sum_alice == sum_bob) {\n\n    num = max(num, i + (n -1 - j));\n\n}\n\nBut in the given code's main function, sum_alice and sum_bob are not declared. So the code is incomplete. So the missing code must include the initialization of sum_alice and sum_bob.\n\nBut looking back at the code given:\n\nThe code before the loop is:\n\nint num=0,sum=0;\n\nfor(int i=0,j=n-1;i<=j; ){\n\n    /* TODO */\n\n}\n\nSo the variables sum_alice and sum_bob are not declared. So the code is missing the declarations. But in the given code, sum is declared as 0. So perhaps sum is sum_alice, and we need to declare sum_bob as a new variable.\n\nSo perhaps the code should be:\n\nsum_alice and sum_bob are initialized to 0. But in the given code, sum is already declared. So maybe the code uses sum for sum_alice and sum_bob for sum_bob.\n\nWait, but that would be impossible. So the code is missing the declaration of sum_bob. So in the given code's loop, sum is sum_alice, and sum_bob is another variable. But the code in the TODO must handle that.\n\nAlternatively, maybe the code uses sum as sum_alice and another variable sum2 as sum_bob.\n\nBut perhaps the code is missing the declaration of sum_alice and sum_bob, and the variables sum and sum2 are used. But in the original code, sum is initialized to 0. So perhaps the code should use sum for sum_alice, and sum_bob is another variable.\n\nBut how to fit this into the code.\n\nAlternatively, perhaps the code's sum is not used, and sum_alice and sum_bob are declared inside the loop.\n\nBut in C++, variables must be declared in the same scope as the loop. So in the code, sum_alice and sum_bob must be declared before the loop.\n\nSo the correct code would be:\n\nint num=0;\n\nlong long sum_alice=0, sum_bob=0;\n\nfor (int i=0, j=n-1; i<=j; ) {\n\n    if (sum_alice <= sum_bob) {\n\n        sum_alice += w[i];\n\n        i++;\n\n    } else {\n\n        sum_bob += w[j];\n\n        j--;\n\n    }\n\n    if (sum_alice == sum_bob) {\n\n        num = max(num, i + (n -1 - j));\n\n    }\n\n}\n\nThus, the missing code inside the loop is the code inside the loop's body.\n\nSo the code that needs to be filled in the TODO section is:\n\n            if (sum_alice <= sum_bob) {\n\n                sum_alice += w[i];\n\n                i++;\n\n            } else {\n\n                sum_bob += w[j];\n\n                j--;\n\n            }\n\n            if (sum_alice == sum_bob) {\n\n                num = max(num, i + (n - 1 - j));\n\n            }\n\nBut how is sum_alice and sum_bob declared in the given code? They are not. So in the given code, the variables sum_alice and sum_bob are not present, but the code has a sum variable.\n\nThis suggests that the given code is missing the declarations for sum_alice and sum_bob, and the code in the TODO must include these declarations.\n\nBut in C++, you can't declare variables inside the loop's condition. So the correct way is to declare them before the loop.\n\nBut the given code has:\n\nint num=0,sum=0;\n\nfor(int i=0,j=n-1;i<=j;){\n    /* TODO */\n}\n\nSo sum is initialized to 0. But sum is sum_alice, and sum_bob needs to be another variable.\n\nSo perhaps the code should be:\n\nint num=0;\n\nlong long sum_alice=0, sum_bob=0;\n\nfor(int i=0,j=n-1; i<=j; ){\n\n    if(sum_alice <= sum_bob){\n\n        sum_alice += w[i];\n\n        i++;\n\n    } else {\n\n        sum_bob += w[j];\n\n        j--;\n\n    }\n\n    if(sum_alice == sum_bob){\n\n        num = max(num, i + (n-1 -j));\n\n    }\n\n}\n\nSo the code uses sum_alice and sum_bob variables, which are declared before the loop.\n\nBut in the original code, sum is declared as a variable. So perhaps the original code is a mistake, and the correct code should replace sum with sum_alice and sum_bob.\n\nSo, in the given code, the variables num and sum are declared. But sum is not used, and the code uses sum_alice and sum_bob.\n\nBut the code given in the problem has sum=0. So the sum variable is redundant. So the correct code would replace sum with sum_alice and sum_bob.\n\nSo the missing code in the TODO section is:\n\n            if (sum_alice <= sum_bob) {\n\n                sum_alice += w[i];\n\n                i++;\n\n            } else {\n\n                sum_bob += w[j];\n\n                j--;\n\n            }\n\n            if (sum_alice == sum_bob) {\n\n                num = max(num, i + (n-1 -j));\n\n            }\n\nBut sum_alice and sum_bob need to be initialized to 0 before the loop.\n\nSo, the code needs to have:\n\nsum_alice and sum_bob initialized to 0.\n\nBut in the given code, sum is initialized to 0. So perhaps the original code's sum was intended to be sum_alice, but that's wrong.\n\nThus, the correct code is to declare sum_alice and sum_bob, initialize them to 0, and then proceed.\n\nSo the missing code is the code inside the loop that handles sum_alice and sum_bob, and updates the pointers.\n\nSo the code to fill in the TODO is:\n\n            if (sum_alice <= sum_bob) {\n\n                sum_alice += w[i];\n\n                i++;\n\n            } else {\n\n                sum_bob += w[j];\n\n                j--;\n\n            }\n\n            if (sum_alice == sum_bob) {\n\n                num = max(num, i + (n -1 - j));\n\n            }\n\nBut sum_alice and sum_bob must be declared and initialized to 0 before the loop.\n\nIn the given code, the variables num and sum are initialized as 0. So sum is redundant. So the correct code should replace sum with sum_alice and sum_bob.\n\nBut in the given code's main loop, the variables sum_alice and sum_bob are not declared.\n\nSo the correct code would have to declare sum_alice and sum_bob before the loop.\n\nBut according to the problem statement, we have to fill in the missing code. The code provided already has a sum variable. So perhaps the code is supposed to use sum and another variable, but that's unclear.\n\nAlternatively, perhaps the code's sum variable is sum_alice, and sum_bob is a new variable. But how to fit that.\n\nBut given the original code's structure, the sum variable is declared as:\n\nint num=0,sum=0;\n\nBut sum is of type int, which could overflow for large numbers. Because each w_i can be up to 1e4, and n up to 2e5, so sum can be up to 2e9, which is larger than int's capacity (which is about 2e9 for 32-bit int). So using long long is necessary.\n\nBut the original code has sum as an int. That's a problem. So the correct code must use long long for sum_alice and sum_bob.\n\nThus, the code must declare sum_alice and sum_bob as long long, initialized to 0.\n\nBut in the given code's main loop, sum is declared as an int. So perhaps that's an error.\n\nSo, putting it all together, the missing code inside the loop is:\n\n            if (sum_alice <= sum_bob) {\n\n                sum_alice += w[i];\n\n                i++;\n\n            } else {\n\n                sum_bob += w[j];\n\n                j--;\n\n            }\n\n            if (sum_alice == sum_bob) {\n\n                num = max(num, i + (n - 1 - j));\n\n            }\n\nAnd before the loop, sum_alice and sum_bob are initialized to 0. But in the given code, the variables sum_alice and sum_bob are not present. So the code must declare them.\n\nBut the problem's code has the variables declared as sum and num. So perhaps the code is incorrect, and the solution requires modifying that.\n\nHowever, the user's instruction says to output only the missing code, which is the part that goes into the TODO section.\n\nBut according to the given code structure, sum is already declared. So perhaps the code should use sum as sum_alice and another variable for sum_bob.\n\nBut this is ambiguous.\n\nAlternatively, perhaps the code uses sum for sum_alice and another variable sum2 for sum_bob.\n\nBut the code provided doesn't declare sum2.\n\nSo, the correct code must include the declarations of sum_alice and sum_bob. But since the code is inside the loop, and the loop is inside the for loop, perhaps the code must declare them before the loop.\n\nBut the user's code is:\n\nint main() {\n    ... \n    while (t--) {\n        ... \n        int num=0, sum=0;\n        for (int i=0,j=n-1; ... ) {\n            /* TODO */\n        }\n        cout << num << endl;\n    }\n}\n\nSo, inside the while loop, for each test case, num and sum are declared as 0. Then, the for loop.\n\nSo the missing code inside the for loop's body is the code that uses sum and another variable (perhaps sum2) to track the two sums.\n\nBut since sum is declared as int, which could be too small, but the problem constraints require long long.\n\nSo, the correct approach is to declare sum_alice and sum_bob as long long variables, initialized to 0, inside the for loop's scope. But in C++, you can't declare variables inside the for loop's condition. So perhaps they are declared before the loop.\n\nWait, the code in the main function for each test case is:\n\nint n=0,w[200005]={0};\n\ncin>>n;\n\nfor(int i=0;i<n;i++) cin>>w[i];\n\nint num=0,sum=0;\n\nfor(int i=0,j=n-1;i<=j; ){\n\n    /* TODO: Your code here */\n\n}\n\ncout<<num<<endl;\n\n}\n\nSo the variables sum_alice and sum_bob need to be declared inside the for loop's body. But variables declared inside a loop's body are reinitialized each iteration.\n\nWait, no. The for loop's body is executed each time the loop runs. So if we declare sum_alice and sum_bob inside the loop's body, they will be initialized each iteration. But in this case, the loop is for (i=0,j=n-1; i<=j; ), and the sum_alice and sum_bob need to be tracked across iterations.\n\nThus, sum_alice and sum_bob need to be declared outside the loop but inside the for loop's scope. So, the variables must be declared before the loop starts.\n\nSo the correct code is:\n\nint num=0;\n\nlong long sum_alice = 0, sum_bob = 0;\n\nfor (int i=0, j=n-1; i <=j; ) {\n\n    if (sum_alice <= sum_bob) {\n\n        sum_alice += w[i];\n\n        i++;\n\n    } else {\n\n        sum_bob += w[j];\n\n        j--;\n\n    }\n\n    if (sum_alice == sum_bob) {\n\n        num = max(num, i + (n -1 - j));\n\n    }\n\n}\n\nSo the variables sum_alice and sum_bob are declared outside the for loop but inside the test case processing (after the input is read). But in the given code, the variables sum and num are declared. So the code must be modified to declare sum_alice and sum_bob.\n\nBut the given code has sum declared as an int. So the code must replace sum with sum_alice and sum_bob, which are long long variables.\n\nThus, the code inside the TODO is:\n\nif (sum_alice <= sum_bob) {\n\n    sum_alice += w[i];\n\n    i++;\n\n} else {\n\n    sum_bob += w[j];\n\n    j--;\n\n}\n\nif (sum_alice == sum_bob) {\n\n    num = max(num, i + (n - 1 - j));\n\n}\n\nAnd the variables sum_alice and sum_bob are declared and initialized to 0 before the loop.\n\nBut according to the given code's structure, the variables sum_alice and sum_bob are not declared. So the code must include their declarations.\n\nBut the user's instruction says to output only the missing code that fills the TODO part. So the code that's missing is the code inside the loop.\n\nBut the declarations of sum_alice and sum_bob must be done outside the loop. So how can that be handled?\n\nAh, because the variables sum_alice and sum_bob are declared before the loop. So in the given code, the variables must be declared. But in the provided code, sum is declared as an int, which is probably a mistake.\n\nBut according to the user's problem, we need to output only the missing code that fills the TODO part. So even if the original code has variables sum and num, but the correct code needs sum_alice and sum_bob, we have to assume that the variables are declared.\n\nBut the original code's sum is not used. So perhaps the code should be modified to use sum_alice and sum_bob.\n\nThus, the correct code for the TODO is:\n\n// Inside the for loop:\n\nif (sum_alice <= sum_bob) {\n\n    sum_alice += w[i];\n\n    i++;\n\n} else {\n\n    sum_bob += w[j];\n\n    j--;\n\n}\n\nif (sum_alice == sum_bob) {\n\n    num = max(num, i + (n - 1 - j));\n\n}\n\nBut sum_alice and sum_bob must be declared and initialized to 0 before the loop. So the code for the test case is:\n\nint num=0;\n\nlong long sum_alice=0, sum_bob=0;\n\nfor(int i=0,j=n-1; i<=j; ){\n\n    if (sum_alice <= sum_bob) {\n\n        sum_alice += w[i];\n\n        i++;\n\n    } else {\n\n        sum_bob += w[j];\n\n        j--;\n\n    }\n\n    if (sum_alice == sum_bob) {\n\n        num = max(num, i + (n-1 -j));\n\n    }\n\n}\n\nBut according to the problem's code, the code after reading the array has:\n\nint num=0, sum=0;\n\nSo the correct code would replace sum=0 with sum_alice and sum_bob=0.\n\nBut according to the user's instruction, we have to output only the missing code. So the missing code is the code inside the loop.\n\nBut the variables sum_alice and sum_bob must be declared and initialized to 0 before the loop. But since the code provided already has sum declared, perhaps the code is using sum as sum_alice and sum_bob as another variable. But that's not possible.\n\nSo this is a bit confusing. But given the code provided, the missing code inside the loop would be:\n\nsum_alice and sum_bob are initialized to 0, and the code inside the loop is:\n\n            if (sum_alice <= sum_bob) {\n\n                sum_alice += w[i];\n\n                i++;\n\n            } else {\n\n                sum_bob += w[j];\n\n                j--;\n\n            }\n\n            if (sum_alice == sum_bob) {\n\n                num = max(num, i + (n - 1 - j));\n\n            }\n\nBut this code would require sum_alice and sum_bob to be declared and initialized outside the loop.\n\nSo, assuming that sum_alice and sum_bob are declared and initialized to 0, the code inside the TODO is:\n\n            if (sum_alice <= sum_bob) {\n\n                sum_alice += w[i];\n\n                i++;\n\n            } else {\n\n                sum_bob += w[j];\n\n                j--;\n\n            }\n\n            if (sum_alice == sum_bob) {\n\n                num = max(num, i + (n - 1 - j));\n\n            }\n\nThus, the missing code is this part. But how to handle the declarations.\n\nBut according to the problem's code, the variables are not declared. So perhaps the user's code has to be modified to declare sum_alice and sum_bob, but the user's instruction says to output only the missing code.\n\nBut the user's code already has variables declared as:\n\nint num=0,sum=0;\n\nSo perhaps the code is supposed to use sum as sum_alice and another variable sum2 as sum_bob.\n\nBut the code would then have:\n\nint num=0, sum=0, sum2=0;\n\nfor (int i=0,j=n-1; ... )\n\nBut sum and sum2 are of type int, which can overflow. But given that the sample inputs may not have such large numbers, perhaps the code would work. But according to the problem's constraints, the sum can be up to 2e5 * 1e4 = 2e9, which is larger than the maximum value for a 32-bit int (which is about 2e9), so using 64-bit integers is necessary.\n\nBut in C++, if the variables are declared as long long, that would be better.\n\nSo perhaps the correct code should declare sum_alice and sum_bob as long long variables.\n\nBut the problem's code doesn't have these variables declared. So the answer must include the code that declares sum_alice and sum_bob, but according to the user's instruction, only the missing code is to be output.\n\nBut the missing code is inside the loop's TODO section. So the code inside the loop's body is:\n\n            if (sum_alice <= sum_bob) {\n\n                sum_alice += w[i];\n\n                i++;\n\n            } else {\n\n                sum_bob += w[j];\n\n                j--;\n\n            }\n\n            if (sum_alice == sum_bob) {\n\n                num = max(num, i + (n - 1 - j));\n\n            }\n\nBut sum_alice and sum_bob must be declared before the loop.\n\nBut given that the code provided does not declare them, this is impossible. So perhaps the code is supposed to use the existing sum variable for sum_alice and another variable for sum_bob.\n\nBut this is getting too ambiguous. However, based on the problem's description and the sample inputs, the correct code must use two variables for the sums, and the missing code is the part inside the loop.\n\nTherefore, the correct missing code is:\n\n            if (sum_alice <= sum_bob) {\n\n                sum_alice += w[i];\n\n                i++;\n\n            } else {\n\n                sum_bob += w[j];\n\n                j--;\n\n            }\n\n            if (sum_alice == sum_bob) {\n\n                num = max(num, i + (n - 1 - j));\n\n            }\n\nAssuming that sum_alice and sum_bob are declared and initialized to 0 before the loop.\n\nSo the code that needs to be filled in the TODO is:\n\nsum_alice += w[i];\ni++;\n} else {\nsum_bob += w[j];\nj--;\n}\nif (sum_alice == sum_bob) {\nnum = max(num, i + (n -1 - j));\n}\n\nBut the code must check the condition and add to sum_alice or sum_bob, then check if they are equal.\n\nSo, the final code to be filled in the TODO is:\n\nif (sum_alice <= sum_bob) {\n    sum_alice += w[i];\n    i++;\n} else {\n    sum_bob += w[j];\n    j--;\n}\nif (sum_alice == sum_bob) {\n    num = max(num, i + (n - 1 - j));\n}"
}