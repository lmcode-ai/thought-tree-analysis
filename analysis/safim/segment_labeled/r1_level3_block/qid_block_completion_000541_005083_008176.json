{
  "segments": [
    {
      "text": "We are given three programs with missing parts. We must output only the missing code for each program in a JSON object. For program1.py:\nThe missing part is in the BFS loop. We need to mark the node as visited and add it to the queue. For program2.py:\nThe missing part is the modular inverse function. We can use Fermat's little theorem since MOD is prime. For program3.py:\nThe missing part is reading the test cases. We know the first integer is the number of test cases. For each test case, we read an integer n and then a list of n integers. Let's break down each program:\n\nProgram1.py:\nThe TODO is inside a BFS.",
      "start_char": 0,
      "end_char": 619,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "We are traversing from node i to all its neighbors (with the condition that the edge exists only if the distance is the minimum from i). We have a visited array `v`. We need to set `v[y] = 1` and then append `y` to the queue. So the missing code is:\n    v[y] = 1\n    queue.append(y) But note: the code is inside a while loop and for loop for the neighbors.",
      "start_char": 620,
      "end_char": 977,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Program2.py:\nWe need to write the function `inv(x)` which returns the modular inverse of x modulo MOD (which is 998244353). We can use pow(x, MOD-2, MOD). So the missing code is:\n    return pow(x, MOD-2, MOD) Program3.py:\nWe are reading multiple test cases. The first integer is t (number of test cases). Then for each test case, we read n and then n integers. The input_arr is already read as a list of integers. The variable `n` is the first integer (number of test cases). Then we have t test cases. In the loop, we do:\n    n_i = input_arr[pos]; pos += 1\n    arr = input_arr[pos:pos+n_i]\n    pos += n_i\n    test_cases.append(arr)\n\nBut note: the variable `n` at the top is the number of test cases, but we have a local variable `n` that we are using for the first integer of the test case. However, in the code we have already read the first integer (the number of test cases) into `n = input_arr[0]`. Then we are reading each test case. So the missing code is:\n    t = n   # but note: the variable n is the number of test cases, but we have already used n for that. Actually, the variable n at the top is the number of test cases, but we are going to read each test case. Actually, the code has:\n    n = input_arr[0]   # the first integer is the number of test cases\n    test_cases = []\n    pos = 1\n    while pos <= len_input - 1:\n        # TODO: read one test case\n\nBut note: the variable `n` is the number of test cases. We are going to read `n` test cases? Actually, the while condition is based on the entire input. Alternatively, we can use a for loop for `n` times. But the problem says: the input consists of multiple test cases. The first integer is t (the number of test cases). Then each test case has an integer n and then n integers. So we can do:\n\n    for i in range(n):   # n is the number of test cases\n        size = input_arr[pos]; pos += 1\n        arr = input_arr[pos:pos+size] pos += size\n        test_cases.append(arr) But note: the variable `n` is the number of test cases.",
      "start_char": 980,
      "end_char": 2993,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "However, the code above uses `n` as the number of test cases, but we have a variable `n` that we set to the first integer. So we can do:\n\n    t = n   # but we already have n = input_arr[0], so t = n\n    for i in range(t):\n        n_i = input_arr[pos]; pos += 1\n        a = input_arr[pos:pos+n_i]\n        pos += n_i\n        test_cases.append(a) But the code uses a while loop. We can change to a for loop, but the problem says \"while pos <= len_input-1\". Actually, we know the exact number of test cases, so we can use a for loop.",
      "start_char": 2995,
      "end_char": 3525,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "Alternatively, we can do:\n\n    for i in range(n):\n        # read one test case\n\nBut the original code uses a while loop. However, the problem says the input has exactly t test cases. So we can do:\n\n    for _ in range(n):   # n is the number of test cases\n        size = input_arr[pos]; pos += 1\n        arr = input_arr[pos:pos+size] pos += size\n        test_cases.append(arr) But note: the variable `n` is the number of test cases. We can also do:\n\n    while n > 0:\n        n_i = input_arr[pos]; pos += 1\n        arr = input_arr[pos:pos+n_i]\n        pos += n_i\n        test_cases.append(arr)\n        n -= 1\n\nBut the problem says: the first integer is t (the number of test cases) and we stored it in `n`. So we can do:\n\n    for i in range(n):\n        n_i = input_arr[pos]; pos += 1\n        arr = input_arr[pos:pos+n_i]\n        pos += n_i\n        test_cases.append(arr)\n\nBut note: the variable `n` is the number of test cases, and we are going to read `n` test cases. However, the code has a while loop condition: `while pos <= len_input - 1`. But if we use a for loop for `n` times, we don't need the condition. But the problem says the input has exactly the data for `n` test cases. So we can do:\n\n    for i in range(n):\n        size = input_arr[pos]; pos += 1\n        a = input_arr[pos:pos+size] pos += size\n        test_cases.append(a) But the original code has a while loop. We can change it to a for loop. Alternatively, we can do:\n\n    while pos < len_input:\n        n_i = input_arr[pos]; pos += 1\n        arr = input_arr[pos:pos+n_i]\n        pos += n_i\n        test_cases.append(arr)\n\nBut note: the first integer is the number of test cases, so we don't need to rely on the while condition.",
      "start_char": 3527,
      "end_char": 5245,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The problem says the input has exactly the test cases. But the problem says: the first integer is t, then t test cases. So we know the number of test cases. Therefore, we can use a for loop. However, the code currently uses a while loop. We can change it to a for loop without affecting correctness. But the problem says: \"Output only the missing code\". We are allowed to change the while loop to a for loop?",
      "start_char": 5246,
      "end_char": 5657,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Actually, the TODO is only the body of the while loop. But the problem says: \"Complete the code ... with missing lines or blocks\". Looking at the code, the TODO is inside the while loop. But the while loop condition is already written. We are to complete the body of the while loop. But the body of the while loop should read one test case. So:\n\n    n_i = input_arr[pos]   # the next integer is the size of the array for this test case\n    pos += 1\n    arr = input_arr[pos:pos+n_i]\n    pos += n_i\n    test_cases.append(arr) And then the while loop condition will break when we have read all the input. But note: the while condition is `while pos <= len_input - 1`. We are reading one test case at a time.",
      "start_char": 5658,
      "end_char": 6366,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "We break when we have read all. But we know the number of test cases is `n` (the first integer). So we can also do a for loop. However, the code structure is a while loop. We are not told to change the loop structure. So we can do:\n\n    n_i = input_arr[pos]\n    pos += 1\n    arr = input_arr[pos:pos+n_i]\n    pos += n_i\n    test_cases.append(arr)\n\nThis will be the body of the while loop.",
      "start_char": 6367,
      "end_char": 6756,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The while loop condition will take care of stopping when we run out of input. But note: the number of test cases is `n`, so we are going to read `n` test cases?",
      "start_char": 6757,
      "end_char": 6917,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Actually, the variable `n` is the number of test cases, but we are using a while loop that runs until the entire input is consumed. This is safe because the input has exactly the data for `n` test cases. So we can do:\n\n    # Inside the while loop:\n    size = input_arr[pos]\n    pos += 1\n    arr = input_arr[pos:pos+size]\n    pos += size\n    test_cases.append(arr) But note: the variable `n` (the number of test cases) is not used in the while loop. We are reading until the input is exhausted. This is acceptable because the input has exactly the data for `n` test cases.",
      "start_char": 6919,
      "end_char": 7492,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "However, the problem says: the first integer is t (the number of test cases). Then we have t test cases. So the total integers are 1 + t*(1 + n_i) and the sum of n_i for all test cases is the total. The while loop condition will break when we have read all. So the missing code for program3.py is:\n\n    size = input_arr[pos]\n    pos += 1\n    arr = input_arr[pos:pos+size]\n    pos += size\n    test_cases.append(arr) But note: the variable `pos` must be updated. Now, let's write the JSON object.",
      "start_char": 7494,
      "end_char": 7991,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Important: The output must be a JSON string with keys \"program1\", \"program2\", \"program3\", and the value is the missing code as a string (without markdown, and without the entire program). We must be cautious about the exact code. For program1.py, the missing code is two lines. We write:\n\n    v[y] = 1\n    queue.append(y) But note: the indentation. The code is inside the for loop and the if condition. We must preserve the same indentation level as the comment. The comment is at 8 spaces (since it's inside the while and for). So we write:\n\n        v[y] = 1\n        queue.append(y)\n\nBut note: the original code has 4-space indentation. The for loop is at 8 spaces, and the if condition is at 12 spaces. The TODO is at 16 spaces. We are to replace the TODO with two lines at 16 spaces. Actually, the TODO is at the same level as the if condition? Let me see:\n\n        for y in g[x]:\n            if v[y] == 0:\n                # TODO: Your code here\n\nWe are inside the for loop (indented 8) and then inside the if (indented 12). The TODO is at 16. We need to write two lines at 16 spaces. So:\n\n                v[y] = 1\n                queue.append(y)\n\nBut note: the code after the TODO is the rest of the while loop. We are replacing the TODO with two lines. So the missing code for program1.py is:\n\n                v[y] = 1\n                queue.append(y)",
      "start_char": 7993,
      "end_char": 9354,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "For program2.py, the missing code is the function `inv(x)`:\n\n    return pow(x, MOD-2, MOD)\n\nBut note: we must write the entire function body? The function is:\n\ndef inv(x):\n    # TODO:",
      "start_char": 9356,
      "end_char": 9539,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "Your code here\n\nWe replace the TODO with:\n\n    return pow(x, MOD-2, MOD)\n\nBut note: we are using the built-in pow with modulus. For program3.py, the missing code is the body of the while loop. We write:\n\n    size = input_arr[pos]; pos += 1\n    arr = input_arr[pos:pos+size]\n    pos += size\n    test_cases.append(arr)\n\nBut note: we can write it as multiple lines. Alternatively, we can write:\n\n    n_i = input_arr[pos]\n    pos += 1\n    a = input_arr[pos:pos+n_i]\n    pos += n_i\n    test_cases.append(a)\n\nBut the variable name doesn't matter. We'll use the same as above. Now, we output the JSON. However, note that the code for program3.py has a while loop that runs until `pos <= len_input - 1`.",
      "start_char": 9540,
      "end_char": 10239,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "We are reading one test case per iteration. This is correct. But note: the input might be exactly consumed, so we break when we have read all. Now, the JSON:\n\n{\n    \"program1\": \"                v[y] = 1\\n                queue.append(y)\",\n    \"program2\": \"    return pow(x, MOD-2, MOD)\",\n    \"program3\": \"        n_i = input_arr[pos]\\n        pos += 1\\n        a = input_arr[pos:pos+n_i]\\n        pos += n_i\\n        test_cases.append(a)\"\n}\n\nBut note: the program3.py code is inside the while loop. The while loop is:\n\n    while pos <= len_input - 1:\n        # TODO: Your code here\n\nWe are replacing the TODO with 4 lines. The indentation: the while loop is at 4 spaces, so the body should be at 8. But the TODO is at 8 (as a comment). We write the code at 8 spaces. But the code we wrote above is at 8 spaces? Actually, the code we wrote:\n\n        n_i = input_arr[pos]\n        pos += 1\n        a = input_arr[pos:pos+n_i]\n        pos += n_i\n        test_cases.append(a)\n\nBut note: the variable `test_cases` is defined outside. So the missing code for program3.py is:\n\n        n_i = input_arr[pos]\n        pos += 1\n        a = input_arr[pos:pos+n_i]\n        pos += n_i\n        test_cases.append(a)\n\nBut we can write it in one line? No, it's multiple lines. Alternatively, we can write:\n\n        size = input_arr[pos]; pos += 1; arr = input_arr[pos:pos+size]; pos += size; test_cases.append(arr) But that is less readable. We'll write as multiple lines. Now, we must escape the newlines in the JSON string. But the problem says to output the JSON.",
      "start_char": 10240,
      "end_char": 11791,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "We can write the string with newlines. But the problem says: \"Output the missing code, NOT as markdown code.\" and then the JSON. We'll write the JSON with the string values containing the code with newlines. Alternatively, we can use triple quotes? But the problem says to output the JSON.",
      "start_char": 11792,
      "end_char": 12084,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "We'll write the JSON as a string with the necessary escapes. But the problem does not specify the output format beyond being JSON. We can use the standard JSON escaping.",
      "start_char": 12086,
      "end_char": 12256,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "However, to make it simple, we can write the code without newlines and use \\n. But the problem says to output the code as it would appear. But the problem says: \"Output only the missing code\", meaning the exact lines that are missing.",
      "start_char": 12258,
      "end_char": 12492,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "We'll use the exact code with newlines, and then in the JSON we use the newline escape \\n. But note: the problem says \"Output the missing code, NOT as markdown code.\" and then the JSON. So we are to output a JSON string that contains the code as a string with embedded newlines. So:\n\n\"program1\": \"                v[y] = 1\\n                queue.append(y)\"\n\nBut wait, the program1 code has two lines. We must have two lines. Similarly for the others. Alternatively, we can write the JSON without escaping the newlines? But that would break the JSON. We must escape the newlines as \\n. But the problem does not specify. We'll use the standard JSON.",
      "start_char": 12495,
      "end_char": 13146,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "However, the problem says: \"Output only the missing code so that ... runs correctly.\" and then the format. We are to output the JSON.",
      "start_char": 13149,
      "end_char": 13282,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "We'll generate the JSON with the necessary escapes. But to avoid manual escaping, we can use a dictionary and then json.dumps. But we are writing the answer, so we must write the escaped string. Alternatively, we can write:\n\n{ \"program1\": \"                v[y] = 1\\n                queue.append(y)\", ... }\n\nBut note: the program1 code has two lines. We write the two lines with a newline in between. Similarly, program3 has 5 lines? Actually, 5 lines? Let me count:\n\n        n_i = input_arr[pos]\n        pos += 1\n        a = input_arr[pos:pos+n_i]\n        pos += n_i\n        test_cases.append(a)\n\nThat's 5 lines. But we can write it as 5 lines in the string with \\n. But note: the last line of program3.py's missing code does not have a trailing newline? Actually, the entire block is 5 lines. So the JSON string for program3 will be:\n\n        n_i = input_arr[pos]\\n        pos += 1\\n        a = input_arr[pos:pos+n_i]\\n        pos += n_i\\n        test_cases.append(a)\n\nBut note: the indentation is 8 spaces per line. We are writing the same. Now, let's write the entire JSON. But note: the program2 code is one line. Final JSON:\n\n{\n    \"program1\": \"                v[y] = 1\\n                queue.append(y)\",\n    \"program2\": \"    return pow(x, MOD-2, MOD)\",\n    \"program3\": \"        n_i = input_arr[pos]\\n        pos += 1\\n        a = input_arr[pos:pos+n_i]\\n        pos += n_i\\n        test_cases.append(a)\"\n}\n\nBut wait, in program2, the function body is one line. We have:\n\n    return pow(x, MOD-2, MOD)\n\nBut note: the MOD is 998244353, which is defined. We don't change that. In program3, we use the variable `a` for the array.",
      "start_char": 13284,
      "end_char": 14925,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The function `diff_ops` expects the array as `arr` and then uses `arr[0]` and so on. So the variable name `a` is acceptable.",
      "start_char": 14926,
      "end_char": 15050,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Alternatively, we can use `arr` to be consistent with the function, but it doesn't matter. Now, we output the JSON. But note: the problem says \"Output only the missing code\", meaning we output the JSON and nothing else. So we write:\n\n{\"program1\": \"                v[y] = 1\\n                queue.append(y)\", \"program2\": \"    return pow(x, MOD-2, MOD)\", \"program3\": \"        n_i = input_arr[pos]\\n        pos += 1\\n        a = input_arr[pos:pos+n_i]\\n        pos += n_i\\n        test_cases.append(a)\"}\n\nBut we must be cautious: the program1 code has 16 spaces at the beginning of each line? Actually, the two lines are at the same indentation level: 16 spaces (because they are inside the if and for). So the string is:\n\n\"                v[y] = 1\\n                queue.append(y)\"\n\nBut note: the length of the spaces: the for loop is at 8, the if is at 12, and then the two lines are at 16. So 16 spaces. But in the program1 code, the TODO is at 16? Actually, the TODO is a comment at 16. We are replacing it with two lines at 16. So the above is correct. Alternatively, we can write without the exact spaces? But we must preserve the indentation.",
      "start_char": 15052,
      "end_char": 16204,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "We have counted: the for loop is 8, the if is 12, and then the two lines are 16. But the code in the problem uses 4-space indentation? We assume so. So we output the JSON as above. But note: the program3 code: the while loop is at 4 spaces, and the body we are writing is at 8. So each line of the body has 8 spaces at the beginning? Actually, the code we are writing is:\n\n        n_i = input_arr[pos]\n        pos += 1\n        a = input_arr[pos:pos+n_i]\n        pos += n_i\n        test_cases.append(a)\n\nEach line is indented 8 spaces relative to the while loop. But the while loop is at 4, so the body is at 8. So the string for program3 is:\n\n\"        n_i = input_arr[pos]\\n        pos += 1\\n        a = input_arr[pos:pos+n_i]\\n        pos += n_i\\n        test_cases.append(a)\"\n\nBut note: the variable `test_cases` is defined as a list, and we are appending the array `a`. This is correct. Now, we write the JSON without extra spaces to save bytes? The problem does not specify. We'll write without extra spaces. Final JSON string:\n\n{\"program1\":\"                v[y] = 1\\n                queue.append(y)\",\"program2\":\"    return pow(x, MOD-2, MOD)\",\"program3\":\"        n_i = input_arr[pos]\\n        pos += 1\\n        a = input_arr[pos:pos+n_i]\\n        pos += n_i\\n        test_cases.append(a)\"}\n\nBut note: the program2 code: the function body is one line, and we have 4 spaces at the beginning (because the function definition is at 0, and the body is indented 4). But the function in the code is:\n\ndef inv(x):\n    # TODO:",
      "start_char": 16206,
      "end_char": 17736,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Your code here\n\nWe are replacing the TODO with a line at 4 spaces. So we write:\n\n\"    return pow(x, MOD-2, MOD)\"\n\nThis has 4 spaces? Actually, the function body should be indented 4 spaces. The string \"    \" is 4 spaces. But the code we wrote: \"    return pow(x, MOD-2, MOD)\" has 4 spaces at the beginning?",
      "start_char": 17737,
      "end_char": 18043,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "Actually, the string we wrote is \"    return ...\", which is 4 spaces. But note: the function body must be indented. So it's correct. We are done.",
      "start_char": 18045,
      "end_char": 18190,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    }
  ],
  "metadata": {
    "task_id1": "block_completion_000541",
    "task_id2": "block_completion_005083",
    "task_id3": "block_completion_008176"
  },
  "original_reasoning": "We are given three programs with missing parts. We must output only the missing code for each program in a JSON object.\n\nFor program1.py:\nThe missing part is in the BFS loop. We need to mark the node as visited and add it to the queue.\n\nFor program2.py:\nThe missing part is the modular inverse function. We can use Fermat's little theorem since MOD is prime.\n\nFor program3.py:\nThe missing part is reading the test cases. We know the first integer is the number of test cases. For each test case, we read an integer n and then a list of n integers.\n\nLet's break down each program:\n\nProgram1.py:\nThe TODO is inside a BFS. We are traversing from node i to all its neighbors (with the condition that the edge exists only if the distance is the minimum from i). We have a visited array `v`. We need to set `v[y] = 1` and then append `y` to the queue.\n\nSo the missing code is:\n    v[y] = 1\n    queue.append(y)\n\nBut note: the code is inside a while loop and for loop for the neighbors.\n\nProgram2.py:\nWe need to write the function `inv(x)` which returns the modular inverse of x modulo MOD (which is 998244353). We can use pow(x, MOD-2, MOD).\n\nSo the missing code is:\n    return pow(x, MOD-2, MOD)\n\nProgram3.py:\nWe are reading multiple test cases. The first integer is t (number of test cases). Then for each test case, we read n and then n integers.\n\nThe input_arr is already read as a list of integers. The variable `n` is the first integer (number of test cases). Then we have t test cases.\n\nIn the loop, we do:\n    n_i = input_arr[pos]; pos += 1\n    arr = input_arr[pos:pos+n_i]\n    pos += n_i\n    test_cases.append(arr)\n\nBut note: the variable `n` at the top is the number of test cases, but we have a local variable `n` that we are using for the first integer of the test case. However, in the code we have already read the first integer (the number of test cases) into `n = input_arr[0]`. Then we are reading each test case.\n\nSo the missing code is:\n    t = n   # but note: the variable n is the number of test cases, but we have already used n for that. Actually, the variable n at the top is the number of test cases, but we are going to read each test case.\n\nActually, the code has:\n    n = input_arr[0]   # the first integer is the number of test cases\n    test_cases = []\n    pos = 1\n    while pos <= len_input - 1:\n        # TODO: read one test case\n\nBut note: the variable `n` is the number of test cases. We are going to read `n` test cases? Actually, the while condition is based on the entire input. Alternatively, we can use a for loop for `n` times.\n\nBut the problem says: the input consists of multiple test cases. The first integer is t (the number of test cases). Then each test case has an integer n and then n integers.\n\nSo we can do:\n\n    for i in range(n):   # n is the number of test cases\n        size = input_arr[pos]; pos += 1\n        arr = input_arr[pos:pos+size]\n        pos += size\n        test_cases.append(arr)\n\nBut note: the variable `n` is the number of test cases. However, the code above uses `n` as the number of test cases, but we have a variable `n` that we set to the first integer. So we can do:\n\n    t = n   # but we already have n = input_arr[0], so t = n\n    for i in range(t):\n        n_i = input_arr[pos]; pos += 1\n        a = input_arr[pos:pos+n_i]\n        pos += n_i\n        test_cases.append(a)\n\nBut the code uses a while loop. We can change to a for loop, but the problem says \"while pos <= len_input-1\". Actually, we know the exact number of test cases, so we can use a for loop.\n\nAlternatively, we can do:\n\n    for i in range(n):\n        # read one test case\n\nBut the original code uses a while loop. However, the problem says the input has exactly t test cases. So we can do:\n\n    for _ in range(n):   # n is the number of test cases\n        size = input_arr[pos]; pos += 1\n        arr = input_arr[pos:pos+size]\n        pos += size\n        test_cases.append(arr)\n\nBut note: the variable `n` is the number of test cases. We can also do:\n\n    while n > 0:\n        n_i = input_arr[pos]; pos += 1\n        arr = input_arr[pos:pos+n_i]\n        pos += n_i\n        test_cases.append(arr)\n        n -= 1\n\nBut the problem says: the first integer is t (the number of test cases) and we stored it in `n`. So we can do:\n\n    for i in range(n):\n        n_i = input_arr[pos]; pos += 1\n        arr = input_arr[pos:pos+n_i]\n        pos += n_i\n        test_cases.append(arr)\n\nBut note: the variable `n` is the number of test cases, and we are going to read `n` test cases.\n\nHowever, the code has a while loop condition: `while pos <= len_input - 1`. But if we use a for loop for `n` times, we don't need the condition. But the problem says the input has exactly the data for `n` test cases.\n\nSo we can do:\n\n    for i in range(n):\n        size = input_arr[pos]; pos += 1\n        a = input_arr[pos:pos+size]\n        pos += size\n        test_cases.append(a)\n\nBut the original code has a while loop. We can change it to a for loop.\n\nAlternatively, we can do:\n\n    while pos < len_input:\n        n_i = input_arr[pos]; pos += 1\n        arr = input_arr[pos:pos+n_i]\n        pos += n_i\n        test_cases.append(arr)\n\nBut note: the first integer is the number of test cases, so we don't need to rely on the while condition. The problem says the input has exactly the test cases.\n\nBut the problem says: the first integer is t, then t test cases. So we know the number of test cases. Therefore, we can use a for loop.\n\nHowever, the code currently uses a while loop. We can change it to a for loop without affecting correctness.\n\nBut the problem says: \"Output only the missing code\". We are allowed to change the while loop to a for loop? Actually, the TODO is only the body of the while loop. But the problem says: \"Complete the code ... with missing lines or blocks\".\n\nLooking at the code, the TODO is inside the while loop. But the while loop condition is already written. We are to complete the body of the while loop.\n\nBut the body of the while loop should read one test case. So:\n\n    n_i = input_arr[pos]   # the next integer is the size of the array for this test case\n    pos += 1\n    arr = input_arr[pos:pos+n_i]\n    pos += n_i\n    test_cases.append(arr)\n\nAnd then the while loop condition will break when we have read all the input.\n\nBut note: the while condition is `while pos <= len_input - 1`. We are reading one test case at a time. We break when we have read all.\n\nBut we know the number of test cases is `n` (the first integer). So we can also do a for loop. However, the code structure is a while loop. We are not told to change the loop structure.\n\nSo we can do:\n\n    n_i = input_arr[pos]\n    pos += 1\n    arr = input_arr[pos:pos+n_i]\n    pos += n_i\n    test_cases.append(arr)\n\nThis will be the body of the while loop. The while loop condition will take care of stopping when we run out of input.\n\nBut note: the number of test cases is `n`, so we are going to read `n` test cases? Actually, the variable `n` is the number of test cases, but we are using a while loop that runs until the entire input is consumed. This is safe because the input has exactly the data for `n` test cases.\n\nSo we can do:\n\n    # Inside the while loop:\n    size = input_arr[pos]\n    pos += 1\n    arr = input_arr[pos:pos+size]\n    pos += size\n    test_cases.append(arr)\n\nBut note: the variable `n` (the number of test cases) is not used in the while loop. We are reading until the input is exhausted. This is acceptable because the input has exactly the data for `n` test cases.\n\nHowever, the problem says: the first integer is t (the number of test cases). Then we have t test cases. So the total integers are 1 + t*(1 + n_i) and the sum of n_i for all test cases is the total. The while loop condition will break when we have read all.\n\nSo the missing code for program3.py is:\n\n    size = input_arr[pos]\n    pos += 1\n    arr = input_arr[pos:pos+size]\n    pos += size\n    test_cases.append(arr)\n\nBut note: the variable `pos` must be updated.\n\nNow, let's write the JSON object.\n\nImportant: The output must be a JSON string with keys \"program1\", \"program2\", \"program3\", and the value is the missing code as a string (without markdown, and without the entire program).\n\nWe must be cautious about the exact code.\n\nFor program1.py, the missing code is two lines. We write:\n\n    v[y] = 1\n    queue.append(y)\n\nBut note: the indentation. The code is inside the for loop and the if condition. We must preserve the same indentation level as the comment. The comment is at 8 spaces (since it's inside the while and for). So we write:\n\n        v[y] = 1\n        queue.append(y)\n\nBut note: the original code has 4-space indentation. The for loop is at 8 spaces, and the if condition is at 12 spaces. The TODO is at 16 spaces. We are to replace the TODO with two lines at 16 spaces.\n\nActually, the TODO is at the same level as the if condition? Let me see:\n\n        for y in g[x]:\n            if v[y] == 0:\n                # TODO: Your code here\n\nWe are inside the for loop (indented 8) and then inside the if (indented 12). The TODO is at 16. We need to write two lines at 16 spaces.\n\nSo:\n\n                v[y] = 1\n                queue.append(y)\n\nBut note: the code after the TODO is the rest of the while loop. We are replacing the TODO with two lines.\n\nSo the missing code for program1.py is:\n\n                v[y] = 1\n                queue.append(y)\n\nFor program2.py, the missing code is the function `inv(x)`:\n\n    return pow(x, MOD-2, MOD)\n\nBut note: we must write the entire function body? The function is:\n\ndef inv(x):\n    # TODO: Your code here\n\nWe replace the TODO with:\n\n    return pow(x, MOD-2, MOD)\n\nBut note: we are using the built-in pow with modulus.\n\nFor program3.py, the missing code is the body of the while loop. We write:\n\n    size = input_arr[pos]; pos += 1\n    arr = input_arr[pos:pos+size]\n    pos += size\n    test_cases.append(arr)\n\nBut note: we can write it as multiple lines.\n\nAlternatively, we can write:\n\n    n_i = input_arr[pos]\n    pos += 1\n    a = input_arr[pos:pos+n_i]\n    pos += n_i\n    test_cases.append(a)\n\nBut the variable name doesn't matter. We'll use the same as above.\n\nNow, we output the JSON.\n\nHowever, note that the code for program3.py has a while loop that runs until `pos <= len_input - 1`. We are reading one test case per iteration. This is correct.\n\nBut note: the input might be exactly consumed, so we break when we have read all.\n\nNow, the JSON:\n\n{\n    \"program1\": \"                v[y] = 1\\n                queue.append(y)\",\n    \"program2\": \"    return pow(x, MOD-2, MOD)\",\n    \"program3\": \"        n_i = input_arr[pos]\\n        pos += 1\\n        a = input_arr[pos:pos+n_i]\\n        pos += n_i\\n        test_cases.append(a)\"\n}\n\nBut note: the program3.py code is inside the while loop. The while loop is:\n\n    while pos <= len_input - 1:\n        # TODO: Your code here\n\nWe are replacing the TODO with 4 lines. The indentation: the while loop is at 4 spaces, so the body should be at 8. But the TODO is at 8 (as a comment). We write the code at 8 spaces.\n\nBut the code we wrote above is at 8 spaces? Actually, the code we wrote:\n\n        n_i = input_arr[pos]\n        pos += 1\n        a = input_arr[pos:pos+n_i]\n        pos += n_i\n        test_cases.append(a)\n\nBut note: the variable `test_cases` is defined outside.\n\nSo the missing code for program3.py is:\n\n        n_i = input_arr[pos]\n        pos += 1\n        a = input_arr[pos:pos+n_i]\n        pos += n_i\n        test_cases.append(a)\n\nBut we can write it in one line? No, it's multiple lines.\n\nAlternatively, we can write:\n\n        size = input_arr[pos]; pos += 1; arr = input_arr[pos:pos+size]; pos += size; test_cases.append(arr)\n\nBut that is less readable. We'll write as multiple lines.\n\nNow, we must escape the newlines in the JSON string. But the problem says to output the JSON. We can write the string with newlines.\n\nBut the problem says: \"Output the missing code, NOT as markdown code.\" and then the JSON.\n\nWe'll write the JSON with the string values containing the code with newlines.\n\nAlternatively, we can use triple quotes? But the problem says to output the JSON.\n\nWe'll write the JSON as a string with the necessary escapes.\n\nBut the problem does not specify the output format beyond being JSON. We can use the standard JSON escaping.\n\nHowever, to make it simple, we can write the code without newlines and use \\n. But the problem says to output the code as it would appear.\n\nBut the problem says: \"Output only the missing code\", meaning the exact lines that are missing.\n\nWe'll use the exact code with newlines, and then in the JSON we use the newline escape \\n.\n\nBut note: the problem says \"Output the missing code, NOT as markdown code.\" and then the JSON. So we are to output a JSON string that contains the code as a string with embedded newlines.\n\nSo:\n\n\"program1\": \"                v[y] = 1\\n                queue.append(y)\"\n\nBut wait, the program1 code has two lines. We must have two lines.\n\nSimilarly for the others.\n\nAlternatively, we can write the JSON without escaping the newlines? But that would break the JSON.\n\nWe must escape the newlines as \\n.\n\nBut the problem does not specify. We'll use the standard JSON.\n\nHowever, the problem says: \"Output only the missing code so that ... runs correctly.\" and then the format. We are to output the JSON.\n\nWe'll generate the JSON with the necessary escapes.\n\nBut to avoid manual escaping, we can use a dictionary and then json.dumps.\n\nBut we are writing the answer, so we must write the escaped string.\n\nAlternatively, we can write:\n\n{ \"program1\": \"                v[y] = 1\\n                queue.append(y)\", ... }\n\nBut note: the program1 code has two lines. We write the two lines with a newline in between.\n\nSimilarly, program3 has 5 lines? Actually, 5 lines? Let me count:\n\n        n_i = input_arr[pos]\n        pos += 1\n        a = input_arr[pos:pos+n_i]\n        pos += n_i\n        test_cases.append(a)\n\nThat's 5 lines. But we can write it as 5 lines in the string with \\n.\n\nBut note: the last line of program3.py's missing code does not have a trailing newline? Actually, the entire block is 5 lines.\n\nSo the JSON string for program3 will be:\n\n        n_i = input_arr[pos]\\n        pos += 1\\n        a = input_arr[pos:pos+n_i]\\n        pos += n_i\\n        test_cases.append(a)\n\nBut note: the indentation is 8 spaces per line. We are writing the same.\n\nNow, let's write the entire JSON.\n\nBut note: the program2 code is one line.\n\nFinal JSON:\n\n{\n    \"program1\": \"                v[y] = 1\\n                queue.append(y)\",\n    \"program2\": \"    return pow(x, MOD-2, MOD)\",\n    \"program3\": \"        n_i = input_arr[pos]\\n        pos += 1\\n        a = input_arr[pos:pos+n_i]\\n        pos += n_i\\n        test_cases.append(a)\"\n}\n\nBut wait, in program2, the function body is one line. We have:\n\n    return pow(x, MOD-2, MOD)\n\nBut note: the MOD is 998244353, which is defined. We don't change that.\n\nIn program3, we use the variable `a` for the array. The function `diff_ops` expects the array as `arr` and then uses `arr[0]` and so on. So the variable name `a` is acceptable.\n\nAlternatively, we can use `arr` to be consistent with the function, but it doesn't matter.\n\nNow, we output the JSON.\n\nBut note: the problem says \"Output only the missing code\", meaning we output the JSON and nothing else.\n\nSo we write:\n\n{\"program1\": \"                v[y] = 1\\n                queue.append(y)\", \"program2\": \"    return pow(x, MOD-2, MOD)\", \"program3\": \"        n_i = input_arr[pos]\\n        pos += 1\\n        a = input_arr[pos:pos+n_i]\\n        pos += n_i\\n        test_cases.append(a)\"}\n\nBut we must be cautious: the program1 code has 16 spaces at the beginning of each line? Actually, the two lines are at the same indentation level: 16 spaces (because they are inside the if and for). So the string is:\n\n\"                v[y] = 1\\n                queue.append(y)\"\n\nBut note: the length of the spaces: the for loop is at 8, the if is at 12, and then the two lines are at 16. So 16 spaces.\n\nBut in the program1 code, the TODO is at 16? Actually, the TODO is a comment at 16. We are replacing it with two lines at 16.\n\nSo the above is correct.\n\nAlternatively, we can write without the exact spaces? But we must preserve the indentation.\n\nWe have counted: the for loop is 8, the if is 12, and then the two lines are 16.\n\nBut the code in the problem uses 4-space indentation? We assume so.\n\nSo we output the JSON as above.\n\nBut note: the program3 code: the while loop is at 4 spaces, and the body we are writing is at 8. So each line of the body has 8 spaces at the beginning? Actually, the code we are writing is:\n\n        n_i = input_arr[pos]\n        pos += 1\n        a = input_arr[pos:pos+n_i]\n        pos += n_i\n        test_cases.append(a)\n\nEach line is indented 8 spaces relative to the while loop. But the while loop is at 4, so the body is at 8.\n\nSo the string for program3 is:\n\n\"        n_i = input_arr[pos]\\n        pos += 1\\n        a = input_arr[pos:pos+n_i]\\n        pos += n_i\\n        test_cases.append(a)\"\n\nBut note: the variable `test_cases` is defined as a list, and we are appending the array `a`.\n\nThis is correct.\n\nNow, we write the JSON without extra spaces to save bytes? The problem does not specify.\n\nWe'll write without extra spaces.\n\nFinal JSON string:\n\n{\"program1\":\"                v[y] = 1\\n                queue.append(y)\",\"program2\":\"    return pow(x, MOD-2, MOD)\",\"program3\":\"        n_i = input_arr[pos]\\n        pos += 1\\n        a = input_arr[pos:pos+n_i]\\n        pos += n_i\\n        test_cases.append(a)\"}\n\nBut note: the program2 code: the function body is one line, and we have 4 spaces at the beginning (because the function definition is at 0, and the body is indented 4). But the function in the code is:\n\ndef inv(x):\n    # TODO: Your code here\n\nWe are replacing the TODO with a line at 4 spaces. So we write:\n\n\"    return pow(x, MOD-2, MOD)\"\n\nThis has 4 spaces? Actually, the function body should be indented 4 spaces. The string \"    \" is 4 spaces.\n\nBut the code we wrote: \"    return pow(x, MOD-2, MOD)\" has 4 spaces at the beginning? Actually, the string we wrote is \"    return ...\", which is 4 spaces.\n\nBut note: the function body must be indented. So it's correct.\n\nWe are done."
}