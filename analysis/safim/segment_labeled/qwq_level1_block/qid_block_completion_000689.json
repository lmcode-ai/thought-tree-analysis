{
  "segments": [
    {
      "text": "Okay, I need to solve this problem where I have to determine if after any number of operations, the array can be made to have all even or all odd numbers. The operations are adding 1 to all odd indices or all even indices. Hmm, let's think about how these operations affect the elements. First, let me understand the operations. The first operation adds 1 to elements at positions 1,3,5 etc. (assuming 1-based index). The second adds 1 to 2,4,6 etc. Each operation can be done any number of times.",
      "start_char": 0,
      "end_char": 498,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "So, the order might not matter because adding multiple times is equivalent to adding a certain number of times modulo 2? Wait, because adding 1 twice is like adding 2, which doesn't change parity. Oh right! Because parity is what's important here. So maybe I can model this problem in terms of parity changes. Wait, the problem requires all elements to have the same parity. So, the key is to see if after some operations, all elements are even or all odd. Let's think in terms of parity. Each operation toggles the parity of certain elements.",
      "start_char": 499,
      "end_char": 1043,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Because adding 1 changes parity. But since you can do the operations multiple times, doing an even number of times would not change parity, odd number would. So, effectively, each operation can be considered as a toggle (since even times would cancel out). So, the number of times you perform each operation can be considered modulo 2. Because doing it an even number of times is the same as not doing it, and odd is same as doing once.",
      "start_char": 1044,
      "end_char": 1480,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "So, the problem reduces to choosing whether to perform the odd-index operation (let's call it O) and/or even-index operation (E) once each (since more would be equivalent mod 2). Then, check if after these choices, all elements have the same parity. Wait, but how do the operations affect each element's parity? Let me think for each element. Let's consider each element's position as either odd or even. For each element, the number of times it is incremented depends on how many times the corresponding operation is done. Since each operation can be done 0 or 1 times (mod 2), the total added to each element is either 0 or 1 mod 2.",
      "start_char": 1482,
      "end_char": 2118,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "For example, an element at an odd position (like position 1) is affected by O. So, if O is done once, it gets +1 (mod 2). Similarly, even positions are affected by E.\n\nSo, for each element, the total added (mod 2) is: For element at position i (1-based):\n\nif i is odd: added O (0 or 1)\nif even: added E (0 or 1) So, the parity of each element after the operations is:\n\noriginal_parity[i] + (O if i is odd else E) mod 2. We need all these to be equal, either all 0 (even) or all 1 (odd).",
      "start_char": 2120,
      "end_char": 2609,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "So, the problem reduces to finding O and E (each 0 or 1) such that for all elements, (a_i % 2) + O*(i%2) + E*(1 - (i%2)) mod 2 is the same for all elements. Wait, let me rephrase that. Let me think of O and E as binary variables (0 or 1). For each element a_i:\n\ncurrent_parity = a_i % 2. After applying O and E, the new parity is:\n\nnew_parity = (current_parity + (O if i is odd else 0) + (E if i is even else 0)) mod 2. We need all new_parity to be equal, either all 0 or all 1. Alternatively, since all must be same, the difference between any two elements' new_parity must be 0. So, for all i and j, (new_parity_i - new_parity_j) mod 2 =0.",
      "start_char": 2611,
      "end_char": 3256,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Hmm, perhaps it's easier to consider the required conditions for O and E.\n\nLet me consider the first element (position 1, odd). Its new parity is (a1_parity + O) mod 2.",
      "start_char": 3258,
      "end_char": 3426,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "The second element (even) is (a2_parity + E) mod 2.\n\nThird (odd): (a3_parity + O) mod 2.\n\nFourth (even): (a4_parity + E) mod 2, etc. So, for all elements, their new parity must be the same. Let's see:\n\nSuppose all must be even (0). Then:\n\nFor all odd positions i: (a_i_parity + O) mod 2 = 0 \u2192 O = (a_i_parity) mod 2. For all even positions j: (a_j_parity + E) mod 2 =0 \u2192 E = (a_j_parity) mod 2.\n\nSo, for all odd elements, their a_i_parity must agree on O, and all even elements must agree on E. Also, O and E must be such that O equals the required for the odd elements, and E for even, and also O must equal E? Because the parity of all elements must be the same. Wait, no. Wait, if all must be even, then the parity of the first (odd) element is (a1_p + O) mod2 =0, and the second (even) is (a2_p + E) mod2=0. So O must be a1_p, and E must be a2_p. But then, for all other elements, their parity must also be 0. For example, the third element (odd) must have (a3_p + O) mod2 =0 \u2192 O must be a3_p. So all the a_i_p for odd positions must have the same value (so that O can be set to that). Similarly, all even positions must have a_j_p the same so that E can be set to that. Also, O and E must be the same? Because the parity of all elements must be 0. Wait, no. Wait, if O is set to a1_p, then (a1_p + O) mod2 is 0.",
      "start_char": 3428,
      "end_char": 4746,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "For even elements, (a_j_p + E) mod2 must also be 0. So E must be a_j_p. But for all even elements, their a_j_p must be the same. So, the even elements must all have the same parity. Similarly, the odd elements must all have the same parity.",
      "start_char": 4747,
      "end_char": 4987,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Then, O and E must be set to their respective parities. But then, the parity of the odd elements after O is 0, and even after E is 0. So all are 0, so that's okay. So in this case, the condition is that all odd elements have the same parity, and all even elements have the same parity, and the parity of the odd elements (after O) and even (after E) must be the same (both 0 in this case).",
      "start_char": 4988,
      "end_char": 5377,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Wait, but in this scenario, the O and E are set to the original parities. So the new parity for odd elements is (original_parity + O) mod2 \u2192 (original_parity + original_parity) mod2 \u2192 0. Similarly for even. So all become 0. So that's okay. So for the all even case, the conditions are:\n\n- All odd elements have the same parity.\n\n- All even elements have the same parity.",
      "start_char": 5378,
      "end_char": 5748,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Additionally, the parity of the odd elements can be anything, but when you set O to their parity, their new parity is 0, and similarly for even. So the even and odd parities can be different, but after setting O and E, they both become 0. So the only conditions are that all odds have same parity, and all evens have same parity. Then, the O and E can be set to their original parities, leading to all 0. Alternatively, for the all odd case (parity 1), then:\n\nFor odd elements: (a_i_p + O) mod2 =1 \u2192 O = (a_i_p +1) mod2. For even elements: (a_j_p + E) mod2 =1 \u2192 E = (a_j_p +1) mod2. So similar conditions: all odd elements must have the same parity (so that O can be set to (a_i_p +1) mod2 for all of them), and all even elements must have the same parity (so E can be set to (a_j_p +1) mod2 for all of them).",
      "start_char": 5750,
      "end_char": 6561,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Additionally, the O and E must be such that when applied, the parities become 1. But in this case, the O and E are determined by the original parities. The key is that the O and E must be consistent across all elements. Wait, but for the all-odd case, the O and E must be set such that for all odds, (a_i_p + O) mod2 =1, so O must be 1 - a_i_p for all odd elements. So all the a_i_p for odd elements must have the same value.",
      "start_char": 6563,
      "end_char": 6989,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Similarly for even elements, their a_j_p must all be the same. So the conditions for all-odd are the same as for all-even, except that the O and E are set differently. But the conditions on the original array are the same: all odds have same parity, all evens have same parity.",
      "start_char": 6990,
      "end_char": 7267,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Wait, but even if those conditions are met, can we choose O and E such that all elements end up with the same parity (either all 0 or all 1)? Let me think. Suppose all odds have parity p (same for all), and evens have parity q (same for all). Then, for the all-even case, we set O = p, E = q. Then, the new parity for odds is p + p mod2 =0, and evens q + q mod2=0. So all 0. So that works. For the all-odd case, set O = 1-p, E =1 - q. Then, odds: p + (1-p) mod2 =1, evens: q + (1 - q) mod2 =1. So all 1. So in this case, the parity of the odds and evens can be anything, as long as all odds are same and evens same. Then, the question is whether the two parities (p and q) can be adjusted via O and E to make all elements same. Wait, but in this scenario, the two options (all even or all odd) can be achieved only if either:\n\nEither (p == q) \u2192 then, if we choose O and E such that O = p and E = q, then all become 0. So that's possible. Or, if p != q, then can we make all 1? Wait, let me see. Suppose p and q are different. Let's say p is 0 and q is 1. Then, for all even case: O =0, E=1. Then odds become 0+0=0, evens 1+1=0 \u2192 all 0. So that works. Wait, but in this case, the original p and q can be anything, as long as all odds are same and evens same. Because regardless of p and q, you can choose O and E to set all to 0. Wait, but in that case, the answer would always be yes if the odds and evens are each uniform. Wait, but that can't be right. Let me think of an example. Suppose the array is [1, 2]. The odds (position 1) is 1 (odd), evens (position 2) is 2 (even). So p=1, q=0. So all odds have same parity (1), evens same (0). So according to the above, we can set O and E to make all even. Let's see:\n\nSet O=1 (so O is p=1?), wait no. Wait for all even case, O is set to p (the original parity of odds). So O =1, E is set to q (0).",
      "start_char": 7269,
      "end_char": 9119,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Then:\n\nOdds (position1): 1 +1 \u2192 parity 0.\n\nEvens (position2): 0 (original) +0 \u2192 parity 0. So yes, all even. So that works. So in this case, the answer is yes. Another example: array [1,3]. The odds (1) is 1 (odd), evens (3) is 1 (odd). So p=1, q=1. So all can be set to 0 (O=1, E=1 \u2192 all 0) or 1 (O=0, E=0 \u2192 1+0=1 for odds, 1+0=1 for evens). So yes. Wait, but what if the original array has all odds same and evens same, but their parities are different. Like [1,2].",
      "start_char": 9120,
      "end_char": 9588,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Then, as above, you can set O and E to make all even. So the answer is yes. So in this case, whenever the odds and evens are each uniform, then the answer is yes. Because you can choose to set O and E to make all even, or all odd, depending on the desired parity. Wait, but what if the parities of odds and evens are different, but you want to make all odd? Let's see. Suppose odds are 0, evens are 1. To make all odd, you need O =1 (so 0+1=1 mod2), and E=0 (1+0=1 mod2). So yes, that works. So in any case, if the odds and evens are each uniform, then you can choose O and E to make all even or all odd. So the answer is yes.",
      "start_char": 9589,
      "end_char": 10216,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Wait, so the key condition is that all the elements at odd indices have the same parity, and all elements at even indices have the same parity. If that's true, then the answer is yes. Otherwise, no?\n\nWait, let me think of a case where the odds are not same. Suppose the array is [1,3,2]. The odds are positions 1 and 3: 1 (odd) and 2 (even). So their parities are 1 and 0. So the odds are not all same.",
      "start_char": 10218,
      "end_char": 10620,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Then, even if the evens (position2) is 3 (odd), but the odds have different parities, so the condition is not met. So the answer would be no. So the problem reduces to checking two things:\n\n1. All elements at odd indices have the same parity. 2. All elements at even indices have the same parity. If both are true, then answer is YES. Else, NO?\n\nWait, but let me test the sample inputs given in the problem. Sample Input 1:\n\nFirst test case: [1,2,1].",
      "start_char": 10621,
      "end_char": 11075,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "Let's see:\n\nOdds (positions 1 and 3): 1 (odd) and 1 (odd). So same parity (1). Evens (position2): 2 (even). So same. So condition holds \u2192 answer is YES. Which matches the note. Second test case: probably an array where odds or evens have different parities. Let's say like [1,2,3]. The odds are 1 and 3 (both odd \u2192 same parity). Evens (position2) is 2 (even). So all evens are same. Wait, but then why the answer is NO? Wait, maybe I'm misunderstanding the sample. Wait the note says the second test case can't be made to have same parity. Hmm, perhaps I need to think again. Wait maybe I made a mistake here. Let me think of the sample input 2. Let me see the note says the second test case's answer is NO.",
      "start_char": 11076,
      "end_char": 11786,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Let me think of an example where the conditions are met but the answer is NO. Wait, no. Wait according to my current logic, if the conditions are met, then answer is YES. So perhaps the second test case's conditions are not met. Wait maybe the second test case is like [1,2,3,4]. Let's see:\n\nOdds: positions 1 (1), 3 (3) \u2192 both odd \u2192 same parity (1).",
      "start_char": 11787,
      "end_char": 12138,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Evens: positions 2 (2) and 4 (4) \u2192 even \u2192 same parity (0). So according to my logic, answer is YES. But the note says the second test case's answer is NO. So my logic must be wrong. Hmm, so there's a problem here. So my current approach is incorrect. So I need to think again. Wait, perhaps I misunderstood the problem. Let me re-read the problem statement. The problem says that after any number of operations, can we make all elements have the same parity.",
      "start_char": 12140,
      "end_char": 12601,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The operations can be done any number of times, but each operation adds 1 to all elements in their respective indices. So the key is that each operation can be done multiple times, but since adding 1 twice is equivalent to adding 2 (so parity flips twice, which cancels). So the number of times you do each operation can be considered mod 2. So each operation can be done 0 or 1 times. So the total effect is equivalent to choosing to do O (odd operation) once or not, and E (even) once or not. Thus, the possible choices are four possibilities: (O=0,E=0), (O=1,E=0), (O=0,E=1), (O=1,E=1). For each of these four options, check if all elements have the same parity.",
      "start_char": 12602,
      "end_char": 13268,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "If any of these four options leads to all elements having same parity, then answer is YES. So perhaps my previous approach was wrong because I thought that if the odds and evens are uniform, then it's possible, but maybe there are cases where even if they are uniform, but the required O and E can't be chosen to make all same. Wait let's think of the sample input 2.",
      "start_char": 13270,
      "end_char": 13639,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Let me think of an example where the answer is NO even though the odds and evens are uniform. Suppose the array is [1,3].",
      "start_char": 13640,
      "end_char": 13761,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "The odds (position1) is 1 (odd), evens (position2) is 3 (odd). So both parities are 1. So according to my previous logic, the answer should be YES. Let's see:\n\nPossible options:\n\nOption 0: O=0, E=0 \u2192 parities remain 1 and 1 \u2192 all same \u2192 yes. So the answer is yes. So that's okay. Another example where the answer is NO: let's see the sample input 2. Let me think of the second test case's example. The note says the second test case can't be made to have same parity. Let me think of an array where the odds and evens are uniform but the answer is NO. Hmm, perhaps the array is [1,2,3]. Let's see:\n\nOdds: positions 1 and 3 \u2192 1 (odd) and 3 (odd) \u2192 same parity (1). Evens: position2 \u2192 2 (even) \u2192 parity 0. So according to my previous logic, the answer should be YES. Let's see:\n\nPossible options:\n\nOption O=1, E=0: Odds: 1+1=2 (even), 3+1=4 (even). Evens: 2+0 \u2192 2 (even). So all even \u2192 yes.\n\nSo the answer would be yes. So that's okay. Hmm, maybe the second test case in the problem is different. Let me think of another example where the answer is NO even when the odds and evens are uniform.",
      "start_char": 13763,
      "end_char": 14860,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Wait, perhaps when the parities of odds and evens are the same, but you can't choose O and E to make all same. Wait, no. Let's see:\n\nSuppose the array is [2,4]. Both even. So odds (position1) is even, evens (position2) even. So all can be kept as even (O=0, E=0). So answer is yes. Another example: array [1,1]. Both are odd. So answer is yes.",
      "start_char": 14862,
      "end_char": 15205,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Hmm, maybe my initial approach is correct, but the sample input 2 must be a case where the odds or evens are not uniform. Let me think of an example where the odds are not uniform. Suppose the array is [1,2,3]. Wait, no, odds are 1 and 3 (both odd). So uniform. So answer is yes. Hmm, perhaps the second test case in the problem is like [1,2,2].",
      "start_char": 15208,
      "end_char": 15555,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Let's see:\n\nOdds: positions 1 and 3 \u2192 1 (odd) and 2 (even). So their parities are 1 and 0 \u2192 not uniform. So the condition is not met \u2192 answer is NO. That would fit the note's second test case.",
      "start_char": 15556,
      "end_char": 15748,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Ah, okay, so my initial approach is correct. So the problem reduces to checking whether all the elements at odd indices have the same parity, and all elements at even indices have the same parity. If both are true, then answer is YES, else NO.",
      "start_char": 15750,
      "end_char": 15993,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Wait, but let me think of another case where the odds and evens are uniform but the answer is NO. Let me see. Suppose the array is [0,1].",
      "start_char": 15995,
      "end_char": 16132,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "Odds (position1) is 0 (even), evens (position2) is 1 (odd). So both groups are uniform. So according to the logic, answer is YES. Let's see:\n\nPossible options:\n\nWe can choose O and E such that all are even or all odd. To make all even:\n\nO must be 0 (so 0 +0 \u2192 even), E must be 1 (so 1+1 \u2192 even). So O=0, E=1. Then:\n\nAfter operations:\n\nposition1: 0 +0 \u2192 0 (even)\n\nposition2:1 +1 \u2192 2 (even). So yes. Alternatively, to make all odd:\n\nO must be 1 (0+1=1), E must be 0 (1+0=1). So O=1, E=0. Then:\n\nposition1: 0 +1=1 (odd), position2:1+0=1 (odd). So yes. So answer is yes. Another example where the parities of odds and evens are same. Let's say array [2,4,6]. All even. So answer is yes. Another case where odds and evens are uniform but their parities are different. Like [1,2,3]. Then, as before, can choose O and E to make all even or all odd. So answer is yes. Hmm, so the initial approach is correct. So the code needs to check for two conditions:\n\n1. All elements at odd indices have the same parity. 2. All elements at even indices have the same parity. If both are true, output YES, else NO. So how to implement this?",
      "start_char": 16134,
      "end_char": 17260,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "In code:\n\nFor each test case:\n\n- Read n and the array.\n\n- Check the parity of the first odd element (like a[0] if 0-based, but since the problem uses 1-based indices, the first element is odd, second even, etc.)",
      "start_char": 17263,
      "end_char": 17474,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Wait, in code, the array is stored as 0-based (since in C++ arrays are 0-based). So for the first element (index 0 in code, which is position 1 in problem's terms), it's an odd index. So:\n\nInitialize for odd_parity and even_parity.",
      "start_char": 17476,
      "end_char": 17707,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Check all elements at odd positions (problem's 1-based, so code's 0, 2,4 etc. for odd indices? Wait no. Wait problem's first element is position 1 (odd), so in code's 0-based, the indices for odd positions are 0,2,4,... (since 0 is first element, which is position 1). Even positions are 1,3,5 etc. (problem's 2,4,6). So for each element in the array:\n\nfor i from 0 to n-1:\n\nif i is even (0-based corresponds to odd position in problem's terms):\n\nthen it's an odd index (problem's terms). So check if all such elements have same parity.",
      "start_char": 17709,
      "end_char": 18245,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Similarly, even indices (problem's even positions) are code's indices 1,3,5 etc. So steps:\n\nInitialize:\n\nfor the first test case:\n\n- Read n, then read the array into val array (size n).\n\n- Check for all odd indices (0,2,4...) whether their parity matches the first element's parity.\n\n- Similarly for even indices (1,3,5...) whether their parity matches the first even element's parity. Wait, but what if there are no even elements (n=1?), but the problem says n >=2. So no problem. Wait n is at least 2. So for even indices, there is at least one (since n >=2). So:\n\nInitialize:\n\nbool all_odds_ok = true;\n\nint first_odd_parity = val[0] %2;\n\nfor (int i=0; i <n; i +=2) { // odd positions (0,2,4...) if (val[i]%2 != first_odd_parity) {\n\n        all_odds_ok = false;\n\n        break;\n\n    }\n\n}\n\nSimilarly for evens: bool all_evens_ok = true;\n\nint first_even_parity = val[1]%2;\n\nfor (int i=1; i <n; i +=2) {\n\n    if (val[i]%2 != first_even_parity) {\n\n        all_evens_ok = false;\n\n        break;\n\n    }\n\n} Then, if (all_odds_ok && all_evens_ok) \u2192 output YES else NO.\n\nWait, but let me test this with the sample input. Sample Input 4 from the note:\n\nFourth test case: array [1000, 0, 1000, 0, 1000]. The note says that after one O operation (add 1 to odds), all become odd. Let's see:\n\nOriginal array:\n\nelements are 1000 (even), 0 (even), 1000 (even), 0 (even), 1000 (even).",
      "start_char": 18248,
      "end_char": 19629,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Wait, but after O (adding 1 to odds):\n\nThe first (position1, code 0) becomes 1001 (odd), third (code2) 1001, fifth (code4) 1001. The evens (positions 2,4 in problem's terms, code indices 1 and 3) remain 0 and 0 \u2192 even. Wait, but the note says after O, all are odd.",
      "start_char": 19631,
      "end_char": 19895,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Wait, maybe I made a mistake here. Wait the note says:\n\n\"For the fourth test case, we can perform one operation and increase all elements at odd positions by 1, thus obtaining the array",
      "start_char": 19896,
      "end_char": 20081,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "[1001, 1, 1001, 1, 1001], and all elements become odd so the answer is YES\". Wait the original array must be [1000, 0, 1000, 0, 1000].",
      "start_char": 20082,
      "end_char": 20216,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "After adding 1 to odd indices (positions 1,3,5 \u2192 code indices 0,2,4):\n\nThe first element becomes 1001 (odd), third (code2) 1001, fifth (code4) 1001.",
      "start_char": 20218,
      "end_char": 20366,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "The even indices (positions 2,4,6 \u2192 code indices 1,3,4? Wait n is 5, so even indices are code1 and 3. So elements at code1 (0) becomes 0+0 (since even indices are not touched in O operation) \u2192 0. Wait that's even. So the note's example must have a different array. Wait maybe the original array is [999, 0, 999, 0, 999]. Then adding 1 to odds (positions 1,3,5) would make them 1000 (even?), no. Wait the note says after the operation, all are odd. So the original array must have the odd indices as even numbers, so adding 1 makes them odd, and even indices as even numbers, but adding 1 via E?",
      "start_char": 20367,
      "end_char": 20961,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Or perhaps the even indices were 0, so adding 1 via E once would make them 1. Wait the note's example says after one O operation, the array becomes [1001, 1, 1001, 1, 1001]. So the original array must have been [1000, 0, 1000, 0, 1000]. Then after O (add 1 to odds):\n\nThe first element (1000 +1 \u2192 1001 (odd)), third (1000+1 \u2192 1001), fifth (1000+1 \u2192 1001).",
      "start_char": 20962,
      "end_char": 21317,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "The even indices (positions 2 and 4 in problem's terms, code indices 1 and 3) are 0 and 0. So they remain 0. So the array would be [1001,0,1001,0,1001].",
      "start_char": 21318,
      "end_char": 21470,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Which has even elements (0 and 0). So that's not all odd. So perhaps I'm misunderstanding the note. Wait the note says \"after one operation and increase all elements at odd positions by 1, thus obtaining the array [1001, 1, 1001, 1, 1001]\". So the original array must have been [1000, 0, 1000, 0, 1000], but then the even indices (positions 2,4,6) must have been 0, but after O, they are still 0. So how do they become 1?",
      "start_char": 21471,
      "end_char": 21892,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Oh, maybe the original array was [999, 0, 999, 0, 999]. Then adding 1 to odds (positions 1,3,5) gives 1000 (even?), but the note says they become 1001. Hmm, perhaps the note's example is different.",
      "start_char": 21893,
      "end_char": 22090,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Maybe the original array is [1000, 0, 1000, 0, 1000], and then they also did an E operation once. Wait but the note says \"perform one operation (O) and increase all elements at odd positions by 1\". So the even elements remain 0. So the note's example must have a different setup.",
      "start_char": 22091,
      "end_char": 22370,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Maybe I'm missing something here, but perhaps the code approach is correct. Back to the code. So the code needs to check whether all the odd indices have the same parity, and even indices same. Thus, the code steps are:\n\nInside the loop for each test case:\n\nRead n.\n\nRead the array into val[0..n-1]. Check for all_odds_ok and all_evens_ok as above. If both are true \u2192 output YES, else NO. Wait, but let me test the sample input 2 from the note. Let's say the second test case is [1,2,3].",
      "start_char": 22371,
      "end_char": 22863,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Then:\n\nOdds (indices 0 and 2) have parities 1 and 1 \u2192 ok.\n\nEvens (index1) has parity 0 \u2192 ok. So answer is YES. But the note says the second test case's answer is NO. So there must be a mistake here.",
      "start_char": 22864,
      "end_char": 23062,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Hmm, this suggests that my approach is wrong. So I must have misunderstood the problem. Wait the note says the second test case's answer is NO. So there must be a case where the odds and evens are uniform but the answer is NO. So my approach is wrong. Hmm, so I need to think again.",
      "start_char": 23064,
      "end_char": 23348,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Alternative approach: Let's think of the problem in terms of the required conditions for all elements to have the same parity. Suppose after some operations, all elements are even. Then:\n\nFor each element at an odd position (i is odd):\n\noriginal a_i + (number of O operations) must be even. Similarly, for even positions (i even):\n\noriginal a_i + (number of E operations) must be even. Let me denote the number of O operations as x (mod 2), and E as y (mod 2). So for all odd indices i:\n\n(a_i + x) mod2 = 0 \u2192 x \u2261 (-a_i) mod2 \u2192 x \u2261 a_i mod2 (since -1 mod2 is 1, so -a_i mod2 is (2 - a_i%2) mod2 \u2192 same as (1 - a_i%2) mod2? Wait, no. Wait, (a_i +x) mod2 =0 \u2192 x \u2261 (-a_i) mod2 \u2192 since mod2, -a_i mod2 is same as (2 - a_i mod2) mod2 \u2192 which is same as (1 - a_i mod2) if a_i mod2 is 1, else 0. So x must be equal to (a_i mod2) for all odd indices. Similarly for even indices:\n\n(a_j + y) mod2 =0 \u2192 y \u2261 a_j mod2 for all even indices j.\n\nThus, for all elements to be even, the following must hold:\n\nAll a_i mod2 (for odd indices) must be the same (so that x can be set to that value). All a_j mod2 (for even indices) must be the same (so that y can be set to that value).",
      "start_char": 23350,
      "end_char": 24518,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Additionally, the x and y must be such that the parities are the same. Wait no, because in this case, all elements are even, so their parities are 0. So the x and y are set to the required values, but the parity of the elements is 0 regardless. So the only conditions are that all odds have same parity, and evens same. Similarly, for all elements to be odd:\n\n(a_i +x) mod2 =1 \u2192 x \u2261 (1 - a_i mod2) for all odd indices.\n\n(a_j + y) mod2 =1 \u2192 y \u2261 (1 - a_j mod2) for all even indices.",
      "start_char": 24520,
      "end_char": 25001,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Thus, for this to be possible, all a_i mod2 (for odds) must be the same (so that x can be set to 1 - a_i mod2 for all), and all a_j mod2 (evens) must be same (so y can be set to 1 - a_j mod2 for all). Thus, the conditions for all-odd are:\n\nall odds have same parity, and all evens have same parity.",
      "start_char": 25003,
      "end_char": 25302,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Thus, the overall conditions for either all-even or all-odd are the same: the odds must be uniform and evens must be uniform. Thus, the initial approach is correct. So why does the second test case in the note have answer NO? Ah, perhaps the second test case is not the one I thought. Let me think of an example where the odds and evens are not uniform. Suppose the array is [1, 3, 2]. The odds are positions 1 and 3 (code 0 and 2):\n\na[0] =1 (odd), a[2]=2 (even). So their parities are 1 and 0 \u2192 not uniform. Thus, the answer is NO. Which would be the second test case. Ah, so my initial approach is correct. So the code should work. Thus, the code needs to check whether all the odd indices have the same parity and even indices have the same parity. Now, implementing this in C++.",
      "start_char": 25304,
      "end_char": 26092,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "The code given has the main loop, and inside the while(t--) loop, we need to read n, then the array, then check the conditions. So inside the loop:\n\ncin >> n;\n\nthen read n elements into val array.",
      "start_char": 26094,
      "end_char": 26291,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Since the array is up to 50 elements, we can read into a vector or array. Wait the code has val[100010], which is big enough. So:\n\nfor (int i=0; i<n; i++) cin >> val[i]; Then, check the conditions. Initialize all_odds_ok and all_evens_ok as true. Check for odds:\n\nif n is at least 1 (since n >=2), so there are at least one odd index (0). first_odd_parity = val[0]%2;\n\nfor (int i=0; i <n; i +=2) {\n\n    if (val[i]%2 != first_odd_parity) {\n\n        all_odds_ok = false;\n\n        break;\n\n    }\n\n}\n\nSimilarly for evens: if n >=2, there is at least one even index (1). first_even_parity = val[1]%2;\n\nfor (int i=1; i <n; i +=2) { if (val[i]%2 != first_even_parity) {\n\n        all_evens_ok = false;\n\n        break;\n\n    }\n\n} Then, if (all_odds_ok && all_evens_ok) \u2192 output YES else NO. Thus, the missing code inside the while loop would be:\n\ncin >> n;\n\nfor (int i = 0; i < n; i++) {\n\n    cin >> val[i];\n\n}\n\nbool all_odds = true;\n\nint first_odd = val[0] % 2;\n\nfor (int i = 0; i < n; i += 2) {\n\n    if (val[i] % 2 != first_odd) {\n\n        all_odds = false;\n\n        break;\n\n    }\n\n}\n\nbool all_evens = true;\n\nint first_even = val[1] % 2;\n\nfor (int i = 1; i < n; i += 2) {\n\n    if (val[i] % 2 != first_even) {\n\n        all_evens = false;\n\n        break;\n\n    }\n\n}\n\nif (all_odds && all_evens) {\n\n    cout << \"YES\" << endl;\n\n} else {\n\n    cout << \"NO\" << endl;\n\n}\n\nWait but what if n is even? Like n=2. Then even indices go up to 1 (since 1 is even index (problem's 2nd position). So the loops are okay. Testing the sample input 2 (the second test case which is supposed to be NO):\n\nSuppose the array is [1,3,2]. Then:\n\nOdds are indices 0 and 2 \u2192 values 1 (odd) and 2 (even). So first_odd is 1. The second element (index2) is 2 mod2=0 \u2192 not equal to first_odd \u2192 all_odds becomes false. Thus, the condition is not met \u2192 output NO. Which matches the note.",
      "start_char": 26292,
      "end_char": 28149,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Another test case where the array is [1,2,3], odds are 1 and 3 (both odd \u2192 all_odds is true. Evens (index1) is 2 \u2192 even. So all_evens is true \u2192 output YES. Which is correct. Thus, the code should work.",
      "start_char": 28151,
      "end_char": 28352,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Now, the code provided in the problem has the variables val[100010], and the main loop is inside while(t--). So the missing code is as above. Thus, the code to fill in the TODO is:\n\ncin >> n;\n\nfor (int i = 0; i < n; i++) {\n\n    cin >> val[i];\n\n}\n\nbool all_odds = true;\n\nint first_odd = val[0] % 2;\n\nfor (int i = 0; i < n; i += 2) {\n\n    if (val[i] % 2 != first_odd) {\n\n        all_odds = false;\n\n        break;\n\n    }\n\n}\n\nbool all_evens = true;\n\nint first_even = val[1] % 2;\n\nfor (int i = 1; i < n; i += 2) {\n\n    if (val[i] % 2 != first_even) {\n\n        all_evens = false;\n\n        break;\n\n    }\n\n}\n\ncout << (all_odds && all_evens ? \"YES\" : \"NO\") << endl;\n\nWait, but in the code given, the variables are declared inside the loop? The val array is declared outside, but since each test case overwrites it, that's okay. Wait the code given has:\n\nlong long val[100010];\n\nBut in C++, it's okay to reuse the array for each test case. Thus, the code should be as above.",
      "start_char": 28355,
      "end_char": 29322,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    }
  ],
  "original_reasoning": "Okay, I need to solve this problem where I have to determine if after any number of operations, the array can be made to have all even or all odd numbers. The operations are adding 1 to all odd indices or all even indices. Hmm, let's think about how these operations affect the elements.\n\nFirst, let me understand the operations. The first operation adds 1 to elements at positions 1,3,5 etc. (assuming 1-based index). The second adds 1 to 2,4,6 etc. Each operation can be done any number of times. So, the order might not matter because adding multiple times is equivalent to adding a certain number of times modulo 2? Wait, because adding 1 twice is like adding 2, which doesn't change parity. Oh right! Because parity is what's important here. So maybe I can model this problem in terms of parity changes.\n\nWait, the problem requires all elements to have the same parity. So, the key is to see if after some operations, all elements are even or all odd. Let's think in terms of parity. Each operation toggles the parity of certain elements. Because adding 1 changes parity. But since you can do the operations multiple times, doing an even number of times would not change parity, odd number would. So, effectively, each operation can be considered as a toggle (since even times would cancel out). So, the number of times you perform each operation can be considered modulo 2. Because doing it an even number of times is the same as not doing it, and odd is same as doing once.\n\nSo, the problem reduces to choosing whether to perform the odd-index operation (let's call it O) and/or even-index operation (E) once each (since more would be equivalent mod 2). Then, check if after these choices, all elements have the same parity.\n\nWait, but how do the operations affect each element's parity?\n\nLet me think for each element. Let's consider each element's position as either odd or even. For each element, the number of times it is incremented depends on how many times the corresponding operation is done. Since each operation can be done 0 or 1 times (mod 2), the total added to each element is either 0 or 1 mod 2.\n\nFor example, an element at an odd position (like position 1) is affected by O. So, if O is done once, it gets +1 (mod 2). Similarly, even positions are affected by E.\n\nSo, for each element, the total added (mod 2) is:\n\nFor element at position i (1-based):\n\nif i is odd: added O (0 or 1)\nif even: added E (0 or 1)\n\nSo, the parity of each element after the operations is:\n\noriginal_parity[i] + (O if i is odd else E) mod 2.\n\nWe need all these to be equal, either all 0 (even) or all 1 (odd).\n\nSo, the problem reduces to finding O and E (each 0 or 1) such that for all elements, (a_i % 2) + O*(i%2) + E*(1 - (i%2)) mod 2 is the same for all elements.\n\nWait, let me rephrase that. Let me think of O and E as binary variables (0 or 1). For each element a_i:\n\ncurrent_parity = a_i % 2.\n\nAfter applying O and E, the new parity is:\n\nnew_parity = (current_parity + (O if i is odd else 0) + (E if i is even else 0)) mod 2.\n\nWe need all new_parity to be equal, either all 0 or all 1.\n\nAlternatively, since all must be same, the difference between any two elements' new_parity must be 0. So, for all i and j, (new_parity_i - new_parity_j) mod 2 =0.\n\nHmm, perhaps it's easier to consider the required conditions for O and E.\n\nLet me consider the first element (position 1, odd). Its new parity is (a1_parity + O) mod 2.\n\nThe second element (even) is (a2_parity + E) mod 2.\n\nThird (odd): (a3_parity + O) mod 2.\n\nFourth (even): (a4_parity + E) mod 2, etc.\n\nSo, for all elements, their new parity must be the same. Let's see:\n\nSuppose all must be even (0). Then:\n\nFor all odd positions i: (a_i_parity + O) mod 2 = 0 \u2192 O = (a_i_parity) mod 2.\n\nFor all even positions j: (a_j_parity + E) mod 2 =0 \u2192 E = (a_j_parity) mod 2.\n\nSo, for all odd elements, their a_i_parity must agree on O, and all even elements must agree on E. Also, O and E must be such that O equals the required for the odd elements, and E for even, and also O must equal E? Because the parity of all elements must be the same. Wait, no. Wait, if all must be even, then the parity of the first (odd) element is (a1_p + O) mod2 =0, and the second (even) is (a2_p + E) mod2=0. So O must be a1_p, and E must be a2_p. But then, for all other elements, their parity must also be 0. For example, the third element (odd) must have (a3_p + O) mod2 =0 \u2192 O must be a3_p. So all the a_i_p for odd positions must have the same value (so that O can be set to that). Similarly, all even positions must have a_j_p the same so that E can be set to that. Also, O and E must be the same? Because the parity of all elements must be 0. Wait, no. Wait, if O is set to a1_p, then (a1_p + O) mod2 is 0. For even elements, (a_j_p + E) mod2 must also be 0. So E must be a_j_p. But for all even elements, their a_j_p must be the same. So, the even elements must all have the same parity. Similarly, the odd elements must all have the same parity. Then, O and E must be set to their respective parities. But then, the parity of the odd elements after O is 0, and even after E is 0. So all are 0, so that's okay. So in this case, the condition is that all odd elements have the same parity, and all even elements have the same parity, and the parity of the odd elements (after O) and even (after E) must be the same (both 0 in this case). Wait, but in this scenario, the O and E are set to the original parities. So the new parity for odd elements is (original_parity + O) mod2 \u2192 (original_parity + original_parity) mod2 \u2192 0. Similarly for even. So all become 0. So that's okay. So for the all even case, the conditions are:\n\n- All odd elements have the same parity.\n\n- All even elements have the same parity.\n\nAdditionally, the parity of the odd elements can be anything, but when you set O to their parity, their new parity is 0, and similarly for even. So the even and odd parities can be different, but after setting O and E, they both become 0. So the only conditions are that all odds have same parity, and all evens have same parity. Then, the O and E can be set to their original parities, leading to all 0.\n\nAlternatively, for the all odd case (parity 1), then:\n\nFor odd elements: (a_i_p + O) mod2 =1 \u2192 O = (a_i_p +1) mod2.\n\nFor even elements: (a_j_p + E) mod2 =1 \u2192 E = (a_j_p +1) mod2.\n\nSo similar conditions: all odd elements must have the same parity (so that O can be set to (a_i_p +1) mod2 for all of them), and all even elements must have the same parity (so E can be set to (a_j_p +1) mod2 for all of them). Additionally, the O and E must be such that when applied, the parities become 1. But in this case, the O and E are determined by the original parities. The key is that the O and E must be consistent across all elements.\n\nWait, but for the all-odd case, the O and E must be set such that for all odds, (a_i_p + O) mod2 =1, so O must be 1 - a_i_p for all odd elements. So all the a_i_p for odd elements must have the same value. Similarly for even elements, their a_j_p must all be the same. So the conditions for all-odd are the same as for all-even, except that the O and E are set differently. But the conditions on the original array are the same: all odds have same parity, all evens have same parity.\n\nWait, but even if those conditions are met, can we choose O and E such that all elements end up with the same parity (either all 0 or all 1)?\n\nLet me think. Suppose all odds have parity p (same for all), and evens have parity q (same for all). Then, for the all-even case, we set O = p, E = q. Then, the new parity for odds is p + p mod2 =0, and evens q + q mod2=0. So all 0. So that works. For the all-odd case, set O = 1-p, E =1 - q. Then, odds: p + (1-p) mod2 =1, evens: q + (1 - q) mod2 =1. So all 1. So in this case, the parity of the odds and evens can be anything, as long as all odds are same and evens same. Then, the question is whether the two parities (p and q) can be adjusted via O and E to make all elements same.\n\nWait, but in this scenario, the two options (all even or all odd) can be achieved only if either:\n\nEither (p == q) \u2192 then, if we choose O and E such that O = p and E = q, then all become 0. So that's possible. Or, if p != q, then can we make all 1?\n\nWait, let me see. Suppose p and q are different. Let's say p is 0 and q is 1. Then, for all even case: O =0, E=1. Then odds become 0+0=0, evens 1+1=0 \u2192 all 0. So that works. Wait, but in this case, the original p and q can be anything, as long as all odds are same and evens same. Because regardless of p and q, you can choose O and E to set all to 0. Wait, but in that case, the answer would always be yes if the odds and evens are each uniform. Wait, but that can't be right. Let me think of an example.\n\nSuppose the array is [1, 2]. The odds (position 1) is 1 (odd), evens (position 2) is 2 (even). So p=1, q=0. So all odds have same parity (1), evens same (0). So according to the above, we can set O and E to make all even. Let's see:\n\nSet O=1 (so O is p=1?), wait no. Wait for all even case, O is set to p (the original parity of odds). So O =1, E is set to q (0). Then:\n\nOdds (position1): 1 +1 \u2192 parity 0.\n\nEvens (position2): 0 (original) +0 \u2192 parity 0. So yes, all even. So that works. So in this case, the answer is yes.\n\nAnother example: array [1,3]. The odds (1) is 1 (odd), evens (3) is 1 (odd). So p=1, q=1. So all can be set to 0 (O=1, E=1 \u2192 all 0) or 1 (O=0, E=0 \u2192 1+0=1 for odds, 1+0=1 for evens). So yes.\n\nWait, but what if the original array has all odds same and evens same, but their parities are different. Like [1,2]. Then, as above, you can set O and E to make all even. So the answer is yes. So in this case, whenever the odds and evens are each uniform, then the answer is yes. Because you can choose to set O and E to make all even, or all odd, depending on the desired parity.\n\nWait, but what if the parities of odds and evens are different, but you want to make all odd? Let's see. Suppose odds are 0, evens are 1. To make all odd, you need O =1 (so 0+1=1 mod2), and E=0 (1+0=1 mod2). So yes, that works. So in any case, if the odds and evens are each uniform, then you can choose O and E to make all even or all odd. So the answer is yes.\n\nWait, so the key condition is that all the elements at odd indices have the same parity, and all elements at even indices have the same parity. If that's true, then the answer is yes. Otherwise, no?\n\nWait, let me think of a case where the odds are not same. Suppose the array is [1,3,2]. The odds are positions 1 and 3: 1 (odd) and 2 (even). So their parities are 1 and 0. So the odds are not all same. Then, even if the evens (position2) is 3 (odd), but the odds have different parities, so the condition is not met. So the answer would be no.\n\nSo the problem reduces to checking two things:\n\n1. All elements at odd indices have the same parity.\n\n2. All elements at even indices have the same parity.\n\nIf both are true, then answer is YES. Else, NO?\n\nWait, but let me test the sample inputs given in the problem.\n\nSample Input 1:\n\nFirst test case: [1,2,1]. Let's see:\n\nOdds (positions 1 and 3): 1 (odd) and 1 (odd). So same parity (1).\n\nEvens (position2): 2 (even). So same. So condition holds \u2192 answer is YES. Which matches the note.\n\nSecond test case: probably an array where odds or evens have different parities. Let's say like [1,2,3]. The odds are 1 and 3 (both odd \u2192 same parity). Evens (position2) is 2 (even). So all evens are same. Wait, but then why the answer is NO? Wait, maybe I'm misunderstanding the sample. Wait the note says the second test case can't be made to have same parity. Hmm, perhaps I need to think again.\n\nWait maybe I made a mistake here. Let me think of the sample input 2. Let me see the note says the second test case's answer is NO. Let me think of an example where the conditions are met but the answer is NO. Wait, no. Wait according to my current logic, if the conditions are met, then answer is YES. So perhaps the second test case's conditions are not met.\n\nWait maybe the second test case is like [1,2,3,4]. Let's see:\n\nOdds: positions 1 (1), 3 (3) \u2192 both odd \u2192 same parity (1).\n\nEvens: positions 2 (2) and 4 (4) \u2192 even \u2192 same parity (0). So according to my logic, answer is YES. But the note says the second test case's answer is NO. So my logic must be wrong.\n\nHmm, so there's a problem here. So my current approach is incorrect. So I need to think again.\n\nWait, perhaps I misunderstood the problem. Let me re-read the problem statement.\n\nThe problem says that after any number of operations, can we make all elements have the same parity. The operations can be done any number of times, but each operation adds 1 to all elements in their respective indices. So the key is that each operation can be done multiple times, but since adding 1 twice is equivalent to adding 2 (so parity flips twice, which cancels). So the number of times you do each operation can be considered mod 2. So each operation can be done 0 or 1 times. So the total effect is equivalent to choosing to do O (odd operation) once or not, and E (even) once or not.\n\nThus, the possible choices are four possibilities: (O=0,E=0), (O=1,E=0), (O=0,E=1), (O=1,E=1). For each of these four options, check if all elements have the same parity.\n\nIf any of these four options leads to all elements having same parity, then answer is YES.\n\nSo perhaps my previous approach was wrong because I thought that if the odds and evens are uniform, then it's possible, but maybe there are cases where even if they are uniform, but the required O and E can't be chosen to make all same.\n\nWait let's think of the sample input 2. Let me think of an example where the answer is NO even though the odds and evens are uniform.\n\nSuppose the array is [1,3]. The odds (position1) is 1 (odd), evens (position2) is 3 (odd). So both parities are 1. So according to my previous logic, the answer should be YES. Let's see:\n\nPossible options:\n\nOption 0: O=0, E=0 \u2192 parities remain 1 and 1 \u2192 all same \u2192 yes. So the answer is yes. So that's okay.\n\nAnother example where the answer is NO: let's see the sample input 2. Let me think of the second test case's example. The note says the second test case can't be made to have same parity. Let me think of an array where the odds and evens are uniform but the answer is NO.\n\nHmm, perhaps the array is [1,2,3]. Let's see:\n\nOdds: positions 1 and 3 \u2192 1 (odd) and 3 (odd) \u2192 same parity (1).\n\nEvens: position2 \u2192 2 (even) \u2192 parity 0.\n\nSo according to my previous logic, the answer should be YES. Let's see:\n\nPossible options:\n\nOption O=1, E=0:\n\nOdds: 1+1=2 (even), 3+1=4 (even). Evens: 2+0 \u2192 2 (even). So all even \u2192 yes.\n\nSo the answer would be yes. So that's okay.\n\nHmm, maybe the second test case in the problem is different. Let me think of another example where the answer is NO even when the odds and evens are uniform.\n\nWait, perhaps when the parities of odds and evens are the same, but you can't choose O and E to make all same. Wait, no. Let's see:\n\nSuppose the array is [2,4]. Both even. So odds (position1) is even, evens (position2) even. So all can be kept as even (O=0, E=0). So answer is yes.\n\nAnother example: array [1,1]. Both are odd. So answer is yes.\n\nHmm, maybe my initial approach is correct, but the sample input 2 must be a case where the odds or evens are not uniform. Let me think of an example where the odds are not uniform.\n\nSuppose the array is [1,2,3]. Wait, no, odds are 1 and 3 (both odd). So uniform. So answer is yes.\n\nHmm, perhaps the second test case in the problem is like [1,2,2]. Let's see:\n\nOdds: positions 1 and 3 \u2192 1 (odd) and 2 (even). So their parities are 1 and 0 \u2192 not uniform. So the condition is not met \u2192 answer is NO. That would fit the note's second test case.\n\nAh, okay, so my initial approach is correct. So the problem reduces to checking whether all the elements at odd indices have the same parity, and all elements at even indices have the same parity. If both are true, then answer is YES, else NO.\n\nWait, but let me think of another case where the odds and evens are uniform but the answer is NO. Let me see.\n\nSuppose the array is [0,1]. Odds (position1) is 0 (even), evens (position2) is 1 (odd). So both groups are uniform. So according to the logic, answer is YES. Let's see:\n\nPossible options:\n\nWe can choose O and E such that all are even or all odd.\n\nTo make all even:\n\nO must be 0 (so 0 +0 \u2192 even), E must be 1 (so 1+1 \u2192 even). So O=0, E=1. Then:\n\nAfter operations:\n\nposition1: 0 +0 \u2192 0 (even)\n\nposition2:1 +1 \u2192 2 (even). So yes.\n\nAlternatively, to make all odd:\n\nO must be 1 (0+1=1), E must be 0 (1+0=1). So O=1, E=0. Then:\n\nposition1: 0+1=1 (odd), position2:1+0=1 (odd). So yes. So answer is yes.\n\nAnother example where the parities of odds and evens are same. Let's say array [2,4,6]. All even. So answer is yes.\n\nAnother case where odds and evens are uniform but their parities are different. Like [1,2,3]. Then, as before, can choose O and E to make all even or all odd. So answer is yes.\n\nHmm, so the initial approach is correct. So the code needs to check for two conditions:\n\n1. All elements at odd indices have the same parity.\n\n2. All elements at even indices have the same parity.\n\nIf both are true, output YES, else NO.\n\nSo how to implement this?\n\nIn code:\n\nFor each test case:\n\n- Read n and the array.\n\n- Check the parity of the first odd element (like a[0] if 0-based, but since the problem uses 1-based indices, the first element is odd, second even, etc.)\n\nWait, in code, the array is stored as 0-based (since in C++ arrays are 0-based). So for the first element (index 0 in code, which is position 1 in problem's terms), it's an odd index. So:\n\nInitialize for odd_parity and even_parity.\n\nCheck all elements at odd positions (problem's 1-based, so code's 0, 2,4 etc. for odd indices? Wait no. Wait problem's first element is position 1 (odd), so in code's 0-based, the indices for odd positions are 0,2,4,... (since 0 is first element, which is position 1). Even positions are 1,3,5 etc. (problem's 2,4,6).\n\nSo for each element in the array:\n\nfor i from 0 to n-1:\n\nif i is even (0-based corresponds to odd position in problem's terms):\n\nthen it's an odd index (problem's terms). So check if all such elements have same parity.\n\nSimilarly, even indices (problem's even positions) are code's indices 1,3,5 etc.\n\nSo steps:\n\nInitialize:\n\nfor the first test case:\n\n- Read n, then read the array into val array (size n).\n\n- Check for all odd indices (0,2,4...) whether their parity matches the first element's parity.\n\n- Similarly for even indices (1,3,5...) whether their parity matches the first even element's parity.\n\nWait, but what if there are no even elements (n=1?), but the problem says n >=2. So no problem.\n\nWait n is at least 2. So for even indices, there is at least one (since n >=2).\n\nSo:\n\nInitialize:\n\nbool all_odds_ok = true;\n\nint first_odd_parity = val[0] %2;\n\nfor (int i=0; i <n; i +=2) { // odd positions (0,2,4...)\n\n    if (val[i]%2 != first_odd_parity) {\n\n        all_odds_ok = false;\n\n        break;\n\n    }\n\n}\n\nSimilarly for evens:\n\nbool all_evens_ok = true;\n\nint first_even_parity = val[1]%2;\n\nfor (int i=1; i <n; i +=2) {\n\n    if (val[i]%2 != first_even_parity) {\n\n        all_evens_ok = false;\n\n        break;\n\n    }\n\n}\n\nThen, if (all_odds_ok && all_evens_ok) \u2192 output YES else NO.\n\nWait, but let me test this with the sample input.\n\nSample Input 4 from the note:\n\nFourth test case: array [1000, 0, 1000, 0, 1000]. The note says that after one O operation (add 1 to odds), all become odd. Let's see:\n\nOriginal array:\n\nelements are 1000 (even), 0 (even), 1000 (even), 0 (even), 1000 (even).\n\nWait, but after O (adding 1 to odds):\n\nThe first (position1, code 0) becomes 1001 (odd), third (code2) 1001, fifth (code4) 1001. The evens (positions 2,4 in problem's terms, code indices 1 and 3) remain 0 and 0 \u2192 even. Wait, but the note says after O, all are odd. Wait, maybe I made a mistake here. Wait the note says:\n\n\"For the fourth test case, we can perform one operation and increase all elements at odd positions by 1, thus obtaining the array [1001, 1, 1001, 1, 1001], and all elements become odd so the answer is YES\".\n\nWait the original array must be [1000, 0, 1000, 0, 1000]. After adding 1 to odd indices (positions 1,3,5 \u2192 code indices 0,2,4):\n\nThe first element becomes 1001 (odd), third (code2) 1001, fifth (code4) 1001. The even indices (positions 2,4,6 \u2192 code indices 1,3,4? Wait n is 5, so even indices are code1 and 3. So elements at code1 (0) becomes 0+0 (since even indices are not touched in O operation) \u2192 0. Wait that's even. So the note's example must have a different array. Wait maybe the original array is [999, 0, 999, 0, 999]. Then adding 1 to odds (positions 1,3,5) would make them 1000 (even?), no. Wait the note says after the operation, all are odd. So the original array must have the odd indices as even numbers, so adding 1 makes them odd, and even indices as even numbers, but adding 1 via E? Or perhaps the even indices were 0, so adding 1 via E once would make them 1. Wait the note's example says after one O operation, the array becomes [1001, 1, 1001, 1, 1001]. So the original array must have been [1000, 0, 1000, 0, 1000]. Then after O (add 1 to odds):\n\nThe first element (1000 +1 \u2192 1001 (odd)), third (1000+1 \u2192 1001), fifth (1000+1 \u2192 1001). The even indices (positions 2 and 4 in problem's terms, code indices 1 and 3) are 0 and 0. So they remain 0. So the array would be [1001,0,1001,0,1001]. Which has even elements (0 and 0). So that's not all odd. So perhaps I'm misunderstanding the note. Wait the note says \"after one operation and increase all elements at odd positions by 1, thus obtaining the array [1001, 1, 1001, 1, 1001]\". So the original array must have been [1000, 0, 1000, 0, 1000], but then the even indices (positions 2,4,6) must have been 0, but after O, they are still 0. So how do they become 1? Oh, maybe the original array was [999, 0, 999, 0, 999]. Then adding 1 to odds (positions 1,3,5) gives 1000 (even?), but the note says they become 1001. Hmm, perhaps the note's example is different. Maybe the original array is [1000, 0, 1000, 0, 1000], and then they also did an E operation once. Wait but the note says \"perform one operation (O) and increase all elements at odd positions by 1\". So the even elements remain 0. So the note's example must have a different setup. Maybe I'm missing something here, but perhaps the code approach is correct.\n\nBack to the code. So the code needs to check whether all the odd indices have the same parity, and even indices same.\n\nThus, the code steps are:\n\nInside the loop for each test case:\n\nRead n.\n\nRead the array into val[0..n-1].\n\nCheck for all_odds_ok and all_evens_ok as above.\n\nIf both are true \u2192 output YES, else NO.\n\nWait, but let me test the sample input 2 from the note. Let's say the second test case is [1,2,3]. Then:\n\nOdds (indices 0 and 2) have parities 1 and 1 \u2192 ok.\n\nEvens (index1) has parity 0 \u2192 ok. So answer is YES. But the note says the second test case's answer is NO. So there must be a mistake here.\n\nHmm, this suggests that my approach is wrong. So I must have misunderstood the problem.\n\nWait the note says the second test case's answer is NO. So there must be a case where the odds and evens are uniform but the answer is NO. So my approach is wrong.\n\nHmm, so I need to think again.\n\nAlternative approach: Let's think of the problem in terms of the required conditions for all elements to have the same parity.\n\nSuppose after some operations, all elements are even. Then:\n\nFor each element at an odd position (i is odd):\n\noriginal a_i + (number of O operations) must be even.\n\nSimilarly, for even positions (i even):\n\noriginal a_i + (number of E operations) must be even.\n\nLet me denote the number of O operations as x (mod 2), and E as y (mod 2).\n\nSo for all odd indices i:\n\n(a_i + x) mod2 = 0 \u2192 x \u2261 (-a_i) mod2 \u2192 x \u2261 a_i mod2 (since -1 mod2 is 1, so -a_i mod2 is (2 - a_i%2) mod2 \u2192 same as (1 - a_i%2) mod2? Wait, no. Wait, (a_i +x) mod2 =0 \u2192 x \u2261 (-a_i) mod2 \u2192 since mod2, -a_i mod2 is same as (2 - a_i mod2) mod2 \u2192 which is same as (1 - a_i mod2) if a_i mod2 is 1, else 0. So x must be equal to (a_i mod2) for all odd indices.\n\nSimilarly for even indices:\n\n(a_j + y) mod2 =0 \u2192 y \u2261 a_j mod2 for all even indices j.\n\nThus, for all elements to be even, the following must hold:\n\nAll a_i mod2 (for odd indices) must be the same (so that x can be set to that value).\n\nAll a_j mod2 (for even indices) must be the same (so that y can be set to that value).\n\nAdditionally, the x and y must be such that the parities are the same. Wait no, because in this case, all elements are even, so their parities are 0. So the x and y are set to the required values, but the parity of the elements is 0 regardless. So the only conditions are that all odds have same parity, and evens same.\n\nSimilarly, for all elements to be odd:\n\n(a_i +x) mod2 =1 \u2192 x \u2261 (1 - a_i mod2) for all odd indices.\n\n(a_j + y) mod2 =1 \u2192 y \u2261 (1 - a_j mod2) for all even indices.\n\nThus, for this to be possible, all a_i mod2 (for odds) must be the same (so that x can be set to 1 - a_i mod2 for all), and all a_j mod2 (evens) must be same (so y can be set to 1 - a_j mod2 for all).\n\nThus, the conditions for all-odd are:\n\nall odds have same parity, and all evens have same parity.\n\nThus, the overall conditions for either all-even or all-odd are the same: the odds must be uniform and evens must be uniform.\n\nThus, the initial approach is correct. So why does the second test case in the note have answer NO?\n\nAh, perhaps the second test case is not the one I thought. Let me think of an example where the odds and evens are not uniform.\n\nSuppose the array is [1, 3, 2]. The odds are positions 1 and 3 (code 0 and 2):\n\na[0] =1 (odd), a[2]=2 (even). So their parities are 1 and 0 \u2192 not uniform. Thus, the answer is NO. Which would be the second test case.\n\nAh, so my initial approach is correct. So the code should work.\n\nThus, the code needs to check whether all the odd indices have the same parity and even indices have the same parity.\n\nNow, implementing this in C++.\n\nThe code given has the main loop, and inside the while(t--) loop, we need to read n, then the array, then check the conditions.\n\nSo inside the loop:\n\ncin >> n;\n\nthen read n elements into val array. Since the array is up to 50 elements, we can read into a vector or array.\n\nWait the code has val[100010], which is big enough.\n\nSo:\n\nfor (int i=0; i<n; i++) cin >> val[i];\n\nThen, check the conditions.\n\nInitialize all_odds_ok and all_evens_ok as true.\n\nCheck for odds:\n\nif n is at least 1 (since n >=2), so there are at least one odd index (0).\n\nfirst_odd_parity = val[0]%2;\n\nfor (int i=0; i <n; i +=2) {\n\n    if (val[i]%2 != first_odd_parity) {\n\n        all_odds_ok = false;\n\n        break;\n\n    }\n\n}\n\nSimilarly for evens:\n\nif n >=2, there is at least one even index (1).\n\nfirst_even_parity = val[1]%2;\n\nfor (int i=1; i <n; i +=2) {\n\n    if (val[i]%2 != first_even_parity) {\n\n        all_evens_ok = false;\n\n        break;\n\n    }\n\n}\n\nThen, if (all_odds_ok && all_evens_ok) \u2192 output YES else NO.\n\nThus, the missing code inside the while loop would be:\n\ncin >> n;\n\nfor (int i = 0; i < n; i++) {\n\n    cin >> val[i];\n\n}\n\nbool all_odds = true;\n\nint first_odd = val[0] % 2;\n\nfor (int i = 0; i < n; i += 2) {\n\n    if (val[i] % 2 != first_odd) {\n\n        all_odds = false;\n\n        break;\n\n    }\n\n}\n\nbool all_evens = true;\n\nint first_even = val[1] % 2;\n\nfor (int i = 1; i < n; i += 2) {\n\n    if (val[i] % 2 != first_even) {\n\n        all_evens = false;\n\n        break;\n\n    }\n\n}\n\nif (all_odds && all_evens) {\n\n    cout << \"YES\" << endl;\n\n} else {\n\n    cout << \"NO\" << endl;\n\n}\n\nWait but what if n is even? Like n=2. Then even indices go up to 1 (since 1 is even index (problem's 2nd position). So the loops are okay.\n\nTesting the sample input 2 (the second test case which is supposed to be NO):\n\nSuppose the array is [1,3,2]. Then:\n\nOdds are indices 0 and 2 \u2192 values 1 (odd) and 2 (even). So first_odd is 1. The second element (index2) is 2 mod2=0 \u2192 not equal to first_odd \u2192 all_odds becomes false. Thus, the condition is not met \u2192 output NO. Which matches the note.\n\nAnother test case where the array is [1,2,3], odds are 1 and 3 (both odd \u2192 all_odds is true. Evens (index1) is 2 \u2192 even. So all_evens is true \u2192 output YES. Which is correct.\n\nThus, the code should work.\n\nNow, the code provided in the problem has the variables val[100010], and the main loop is inside while(t--). So the missing code is as above.\n\nThus, the code to fill in the TODO is:\n\ncin >> n;\n\nfor (int i = 0; i < n; i++) {\n\n    cin >> val[i];\n\n}\n\nbool all_odds = true;\n\nint first_odd = val[0] % 2;\n\nfor (int i = 0; i < n; i += 2) {\n\n    if (val[i] % 2 != first_odd) {\n\n        all_odds = false;\n\n        break;\n\n    }\n\n}\n\nbool all_evens = true;\n\nint first_even = val[1] % 2;\n\nfor (int i = 1; i < n; i += 2) {\n\n    if (val[i] % 2 != first_even) {\n\n        all_evens = false;\n\n        break;\n\n    }\n\n}\n\ncout << (all_odds && all_evens ? \"YES\" : \"NO\") << endl;\n\nWait, but in the code given, the variables are declared inside the loop? The val array is declared outside, but since each test case overwrites it, that's okay.\n\nWait the code given has:\n\nlong long val[100010];\n\nBut in C++, it's okay to reuse the array for each test case.\n\nThus, the code should be as above."
}