{
  "segments": [
    {
      "text": "<think>\nWe are given multiple test cases.",
      "start_char": 0,
      "end_char": 41,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "For each test case, a string s.\n We are to determine if s is perfectly balanced.",
      "start_char": 42,
      "end_char": 122,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Observation:\n The problem states that for every non-empty substring t and for every pair of characters u, v that appear in s,\n the absolute difference between the frequency of u and the frequency of v in t is at most 1.",
      "start_char": 125,
      "end_char": 344,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "However, note the condition: \"u and v are characters present in s\". So we only consider characters that appear in the entire string s.\n\n Important: The total length of all strings is at most 200,000. How to approach? Let's denote the entire string as s. Let the set of distinct characters in s be D.\n\n Condition: For every substring t and for every pair (u,v) in D, we must have |freq(t, u) - freq(t, v)| <= 1. Consider the following:\n\n 1. If |D| = 1 (only one distinct character), then for any substring t, the frequency of that character is |t| and the others are 0. But note: the condition requires that for every pair (u,v) in D. Since there is only one character, we don't have two distinct ones?",
      "start_char": 347,
      "end_char": 1054,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Actually, the condition says \"u and v are characters present in s\".",
      "start_char": 1065,
      "end_char": 1132,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "If there is only one character, then we only have one pair?",
      "start_char": 1133,
      "end_char": 1192,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "Actually, the condition must hold for every non-empty substring and every pair. But if there is only one character, then the only pair is (u,u) and |freq(t,u)-freq(t,u)|=0<=1. So it holds. 2. If |D| >= 2, then consider the entire string s: \n    Let n = |s|. Then for the entire string, we must have for every two distinct characters u and v: \n        |freq(s, u) - freq(s, v)| <= 1. Why?",
      "start_char": 1198,
      "end_char": 1587,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Because the entire string is a substring. But note: the condition must hold for every substring.",
      "start_char": 1593,
      "end_char": 1689,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "However, the entire string condition is necessary.",
      "start_char": 1695,
      "end_char": 1745,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "However, the entire string condition is not sufficient.",
      "start_char": 1751,
      "end_char": 1806,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "For example, \"abb\" has entire string: freq(a)=1, freq(b)=2 -> |1-2|=1 -> okay for the entire string. But the substring \"bb\" has freq(a)=0, freq(b)=2 -> |0-2|=2 -> not okay. 3.",
      "start_char": 1807,
      "end_char": 1996,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Therefore, we must check for every substring? That is too expensive.",
      "start_char": 1999,
      "end_char": 2067,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternate Insight:\n\n After reading the note examples, we see that the problem is very constrained. Observation:",
      "start_char": 2070,
      "end_char": 2181,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "In fact, the condition must hold for every contiguous substring. Consider the following:",
      "start_char": 2188,
      "end_char": 2276,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "The condition must hold for every contiguous substring of length 2? For two adjacent characters: if they are the same, then in the substring of length 2: \n            if we have \"aa\", then for the two a's: \n                if we take u='a' and v='b' (if 'b' is in the entire string), then |2-0|=2 -> which is >1 -> invalid.",
      "start_char": 2288,
      "end_char": 2620,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Therefore, if the entire string has at least two distinct characters, then we cannot have two consecutive same characters? Why? Because in the substring of two same characters, say \"aa\", then for any other character v that is in the entire string (which exists because |D|>=2)",
      "start_char": 2630,
      "end_char": 2915,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "we have:\n            freq(\"aa\", 'a') = 2, freq(\"aa\", v)=0 -> |2-0|=2>1 -> invalid.",
      "start_char": 2916,
      "end_char": 2998,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Similarly, we cannot have two consecutive same characters. But wait: what if the entire string has only two distinct characters? Then in a substring \"aa\", we have to consider the pair (a, b) and the difference is 2.",
      "start_char": 3008,
      "end_char": 3223,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Therefore, a necessary condition: the string must not contain two consecutive same characters. However, is that sufficient? Consider \"aba\": \n          distinct characters: {'a','b'} -> entire string: a:2, b:1 -> |2-1|=1 -> okay.\n          substrings: \n            \"a\": a:1, b:0 -> |1-0|=1 -> okay.\n            \"b\": a:0, b:1 -> |0-1|=1 -> okay.\n            \"ab\": a:1, b:1 -> |1-1|=0 -> okay. \"ba\": a:1, b:1 -> okay. \"aba\": a:2, b:1 -> |2-1|=1 -> okay. Now consider \"abc\": \n          distinct: {'a','b','c'} -> entire string: each 1 -> okay.\n          substrings of length 1: each has one char and zeros -> difference 1 with any other -> okay.\n          substrings of length 2: \"ab\": a:1, b:1, c:0 -> but we have to check every pair? \n                |a-b|=0, |a-c|=1, |b-c|=1 -> okay.\n          substrings of length 3: \"abc\": each 1 -> okay. But what about a substring that is not contiguous in the entire string?",
      "start_char": 3242,
      "end_char": 4206,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "Actually, contiguous substring means consecutive in the string. However, consider \"aab\" (which has consecutive 'a's) -> we already know it fails because of \"aa\".",
      "start_char": 4216,
      "end_char": 4386,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Now, what if we have non consecutive duplicates? Example: \"abac\" -> \n            distinct: {'a','b','c'} -> entire string: a:2, b:1, c:1 -> |2-1|=1 -> okay. But check substring \"aba\": \n                a:2, b:1 -> |2-1|=1 -> okay? but also we have to check a and c: |2-0|=2 -> fails?",
      "start_char": 4396,
      "end_char": 4718,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "However, note: the condition says \"u and v are characters present in s\", meaning the entire string. So we must check every pair of distinct characters that appear in the entire string.",
      "start_char": 4736,
      "end_char": 4920,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "In the substring \"aba\", the character 'c' does not appear? But the condition says: \"u and v are characters present in s\" (the entire string) -> so we must consider the pair (a,c) even though c is not in the substring?",
      "start_char": 4955,
      "end_char": 5189,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Let me read the problem again: \n            \"the difference between the frequencies of u and v in t\" \n            and u and v are characters present in s (the entire string). So even if u or v does not appear in the substring t, we still have to consider? Example: substring \"aba\" in \"abac\": \n            u='a', v='c': freq(t, 'a')=2, freq(t, 'c')=0 -> |2-0|=2 -> which is >1 -> invalid.",
      "start_char": 5202,
      "end_char": 5613,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Therefore, the string \"abac\" is not perfectly balanced. How to avoid this? We note that if the entire string has k distinct characters, then for every substring t, we must have for every character u in D (the entire distinct set) that \n            |freq(t, u) - freq(t, v)| <= 1 for every v in D.\n\n        This implies that for a fixed substring t, the frequencies of the characters in D must be either:\n          all equal, or one of them is one more than the others? But note: the frequencies in t for characters not in t are 0. Therefore, if a substring t does not contain a particular character (say c) that is in D, then for any character d that is in t and in D, we must have:\n            freq(t, d) <= 1   (because |freq(t,d) - freq(t,c)| = |freq(t,d) - 0| = freq(t,d) <= 1)",
      "start_char": 5625,
      "end_char": 6445,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "This implies that the substring t can have at most one occurrence of any character? Why? Because if a character d appears twice in t, then for a character c that is in D but not in t, we have |2-0|=2>1.",
      "start_char": 6455,
      "end_char": 6667,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Therefore, every substring t must contain either all the distinct characters of the entire string, or if it misses one, then the entire substring must have at most one occurrence of each distinct character that it does contain. But note: if the substring t misses more than one character? Then we have to check for every pair?",
      "start_char": 6677,
      "end_char": 7003,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Actually, the condition must hold for every pair (u,v) in D. So if we miss a character c, then for any character d that appears in t, we require freq(t,d) < = 1 (because |freq(t,d)-freq(t,c)| = |freq(t,d)-0| <=1).",
      "start_char": 7023,
      "end_char": 7235,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Similarly, for two characters that are both missing, the difference is 0.",
      "start_char": 7236,
      "end_char": 7309,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Therefore, the condition for a substring t is:",
      "start_char": 7320,
      "end_char": 7366,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "For every character d in D, either:\n            d is in t and then freq(t,d) is either 0 or 1? Actually, no: if we have two characters d and e that are both in t, then |freq(t,d)-freq(t,e)|<=1. But note: if we have two characters d and e that are both in t, then we can have at most one of them having frequency 1 and the other 1?",
      "start_char": 7377,
      "end_char": 7707,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Or one having 2 and the other 1? However, if we have two characters d and e in t and one of them (say d) appears twice, then for a character c that is in D but not in t, we have |freq(t,d)-freq(t,c)| = |2-0|=2 -> invalid.",
      "start_char": 7719,
      "end_char": 7951,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Therefore, the only possibility is that the substring t must contain every distinct character of the entire string? But wait: what if the entire string has 3 distinct characters, and the substring t has all three? Then we can have frequencies: \n            a:1, b:1, c:1 -> okay. a:2, b:1, c:1 -> then |a-b|=1, |a-c|=1, |b-c|=0 -> okay? However, the condition requires for every pair: |a-b|<=1, |a-c|<=1, |b-c|<=1 -> which holds. But then consider: \n            a:2, b:2, c:1 -> |a-c|=1, |b-c|=1, |a-b|=0 -> okay? a:3, b:2, c:1 -> |a-b|=1, |a-c|=2 -> fails.",
      "start_char": 7961,
      "end_char": 8575,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "Therefore, the frequencies in t must be either all equal or two of them are one more than the others?",
      "start_char": 8585,
      "end_char": 8686,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Actually, the condition is that the maximum frequency and the minimum frequency in t (over the entire distinct set) must differ by at most 1.",
      "start_char": 8687,
      "end_char": 8828,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "However, note: the frequencies for characters not in t are 0. So if the substring t does not contain a character c that is in D, then the frequency for c is 0. Then the condition requires that for every character d in D: \n            |freq(t,d) - 0| <= 1   -> so freq(t,d) must be 0 or 1. But if t does not contain c, then we have at least one character (c) with frequency 0. Then for any character d that is in t, we must have freq(t,d) <= 1. Therefore, the substring t must be such that:\n          Either:\n            (a) t contains every distinct character of the entire string, and then the frequencies of the distinct characters in t must satisfy: max_freq - min_freq <= 1.\n            (b) t does not contain at least one distinct character of the entire string, and then every distinct character that appears in t must appear exactly once (so t is composed of distinct characters?",
      "start_char": 8838,
      "end_char": 9752,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "and also the length of t must be at most |D|? but note: we are missing at least one, so at most |D|-1?).",
      "start_char": 9753,
      "end_char": 9857,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "However, condition (b) is very strict: every character in t must appear exactly once? But note: if we have two of the same character, then that character would have frequency 2, and then for a missing character c, |2-0|=2 -> fails.",
      "start_char": 9867,
      "end_char": 10108,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Therefore, the substring t must be such that:\n          - If t contains all distinct characters of s, then the frequencies of the distinct characters in t must be either floor(|t|/|D|) or ceil(|t|/|D|) and the difference between the max and min is at most 1. \n          - Otherwise, t must have no repeated characters (and hence |t| <= |D|, and actually |t| <= |D|-1 because it misses at least one). But note: the entire string s must satisfy the first condition?",
      "start_char": 10118,
      "end_char": 10581,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "How to check for every substring? The total length of all strings is 200,000, but the worst-case string length might be 200,000 and the number of substrings is O(n^2) -> 20e9 which is too many. We need a more efficient way.",
      "start_char": 10601,
      "end_char": 10824,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternate Insight from known problems: \n          This problem is known?",
      "start_char": 10843,
      "end_char": 10915,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "It appeared in a contest and the solution is to check only substrings of length at most |D|+1?",
      "start_char": 10916,
      "end_char": 11010,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Why? \n\n        Consider: \n          If we have a substring t that does not contain all distinct characters, then we already require that it has no repeated characters.",
      "start_char": 11021,
      "end_char": 11188,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Therefore, the length of t must be at most |D| (if it contained all, then we are in the other case) but actually if it misses one, then at most |D|-1?",
      "start_char": 11200,
      "end_char": 11350,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "However, note: we can have a substring that misses more than one? Then the length is at most |D|-2? But the condition for missing characters forces that no character can appear more than once. So the length of t must be at most |D| (if it contains all) then we are in the first case?",
      "start_char": 11363,
      "end_char": 11646,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Actually, if the substring t has length greater than |D|, then by the pigeonhole principle, at least one character must appear at least twice. Then if there is a character that appears twice, and if there is a character in D that is missing in t, then we have |2-0|=2 -> fails.",
      "start_char": 11671,
      "end_char": 11959,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Therefore, any substring t of length > |D| must contain every distinct character? But note: it might not. For example, if |D|=3, and we have a substring of length 4: it must contain all distinct characters?",
      "start_char": 11971,
      "end_char": 12189,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Not necessarily: it could be \"aabc\" but then we have two a's and missing d? But wait, the entire distinct set is {a,b,c}. Then if we have a substring of length 4 that does not contain one of the distinct characters? Then we have a problem: \n            if it misses c, then we have two a's -> |2-0|=2 for the pair (a,c) -> fails.",
      "start_char": 12201,
      "end_char": 12541,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Therefore, any substring of length > |D| must contain every distinct character?",
      "start_char": 12553,
      "end_char": 12632,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Actually, if the substring has length > |D|, then it must contain every distinct character? Why?",
      "start_char": 12645,
      "end_char": 12741,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Because if it misses one, then we have a character that appears at least twice (by pigeonhole: if we have |D|-1 distinct characters and length>|D|, then at least one character appears at least ceil(|D|/(|D|-1))? which for |D|>=2, |D|/(|D|-1) <= 2? but if |D|>=3, then |D|/(|D|-1) < 2? so we cannot guarantee two?",
      "start_char": 12753,
      "end_char": 13065,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Actually, we don't need to guarantee two by pigeonhole?",
      "start_char": 13078,
      "end_char": 13133,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "We know that if the substring has length L and it has k distinct characters (k < |D|), then the maximum frequency of a character in the substring is at least ceil(L/k).",
      "start_char": 13134,
      "end_char": 13302,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "We require that for any character in the entire distinct set that is missing, the frequency of any character that is present must be at most 1. Therefore, we require ceil(L/k) <= 1 -> so L <= k. But we are considering L>|D| and k<=|D|-1, so L>|D| and k<=|D|-1 -> then L>k.",
      "start_char": 13314,
      "end_char": 13609,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Therefore, we must have at least one character that appears at least 2.",
      "start_char": 13621,
      "end_char": 13692,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "Hence, any substring of length > |D| must contain every distinct character? Actually, no: we just showed that if it doesn't contain every distinct character (so k<|D|) and if its length is > |D| (which is > k) then we have a character that appears at least twice -> which leads to failure (because of the missing character).",
      "start_char": 13705,
      "end_char": 14041,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Therefore, the only substrings that might break the condition are:\n            (a) substrings of length at most |D| (which we can check in O(|D|^2) per distinct set? but note |D| is at most 26 because there are 26 letters) -> so we can check all substrings of length at most 26?",
      "start_char": 14054,
      "end_char": 14332,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "(b) substrings of length > |D|: but then they must contain every distinct character?",
      "start_char": 14346,
      "end_char": 14430,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "and then we require that the frequencies of the distinct characters in the substring must not differ by more than 1?",
      "start_char": 14431,
      "end_char": 14547,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "However, note: the condition for a substring of length L>|D|:",
      "start_char": 14560,
      "end_char": 14621,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "It must contain every distinct character? (otherwise it fails by the above argument) \n            and then we require: max_freq - min_freq <= 1.\n\n          How to check that for every substring of length L>|D|? But note: the total length of all strings is 200,000.",
      "start_char": 14635,
      "end_char": 14899,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "However, the worst-case string might be 200,000 and then we would have to check 200,000 - |D| substrings? which is about 200,000 and for each we do |D| (which is 26) -> 200000*26 = 5.2e6 -> acceptable?",
      "start_char": 14912,
      "end_char": 15113,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "However, the problem says the total length of all test cases is 200,000. So we can do:\n\n          Steps for one test case:\n            Let s be the string, n = len(s)\n            Let D = set(s) -> distinct characters, k = len(D) Step 1: Check if k==1 -> then we return \"YES\"\n\n            Step 2: Check for any consecutive duplicate: \n                for i in range(n-1):\n                    if s[i]==s[i+1]:\n                        return \"NO\"\n\n            Why? Because if we have two consecutive same characters, then the substring s[i:i+2] has two of that character and then for any other character in D (which exists because k>=2) that does not appear in that substring, we have |2-0|=2>1 -> fails. Step 3: Check all substrings of length from 2 to k: \n                We can do: for length L from 2 to k: \n                    for start index i from 0 to n-L:\n                        substring = s[i:i+L]\n                        distinct_in_sub = set(substring)\n                        if len(distinct_in_sub) < k: \n                            # then we must check: every character in distinct_in_sub must appear exactly once? \n                            # because if any appears twice, then we have a problem (with a missing character) -> but note: the substring has length L, and if there is a duplicate then we have at least one character with frequency>=2 -> then for a missing character (which exists) we have |freq(c) - 0| = freq(c)>=2 -> fails. # So we can check: if the substring has duplicate? -> then we already fail? #",
      "start_char": 15126,
      "end_char": 16712,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Actually, we can check: if len(substring) ! = len(set(substring)) -> then duplicate -> fails. But note: we already checked consecutive duplicates? but what about non consecutive duplicates? Example: \"aba\" -> has duplicate? but the two a's are not consecutive. However, in \"aba\": \n                    distinct_in_sub = {'a','b'} -> k=2? but the entire distinct set D is also {'a','b'}?",
      "start_char": 16742,
      "end_char": 17193,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Actually, no: the entire distinct set D is the entire string? In the substring \"aba\", we have both 'a' and 'b' -> so it contains all distinct characters? Then we don't fall in the case of missing? Therefore, we must check: \n                For a substring t of length L (with L<=k): \n                  if the substring does not contain all distinct characters (so distinct_in_sub is a proper subset of D) then we require that the substring has no duplicate? But note: if the substring has duplicate, then we have a character that appears at least twice -> then for a character missing in the substring (which is in D) we have |freq(t, c) - freq(t, d)| = |0 - (at least 2)| = at least 2 -> fails. So for any substring of length <= k, we require that if it does not contain all distinct characters, then it must have no duplicate? But having no duplicate is equivalent to: the length of the substring equals the number of distinct characters in the substring?",
      "start_char": 17215,
      "end_char": 18260,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "However, note: if the substring has duplicate, then the condition fails. Therefore, we can check: \n                for every substring of length L in [2, k] (if k>=2) we check that the substring has no duplicate? But note: if the substring has duplicate, then we break.",
      "start_char": 18288,
      "end_char": 18571,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "How to check for duplicates in all contiguous substrings of length L?",
      "start_char": 18602,
      "end_char": 18671,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "We can use a sliding window and a frequency array? We can do:\n\n                freq = [0]*26\n                dup = 0   # count of duplicates: if we see a character that becomes 2 then dup increases, if we see a character that becomes 1 then dup decreases?",
      "start_char": 18689,
      "end_char": 18961,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Actually, we want to know if there is at least one duplicate? We can do for L from 2 to k:",
      "start_char": 18978,
      "end_char": 19068,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "We traverse the string with a window of length L and update the frequency array.",
      "start_char": 19107,
      "end_char": 19187,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "We start with the first L characters, then move the window. Steps for fixed L:\n                    freq = [0]*26\n                    dup_count = 0\n                    for i in range(L):\n                        c = s[i]\n                        idx = ord(c)-ord('a')\n                        freq[idx] += 1\n                        if freq[idx] == 2:\n                            dup_count += 1\n                    if dup_count > 0 and len(set(s[0:L]))",
      "start_char": 19209,
      "end_char": 19673,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "< k: \n                        #",
      "start_char": 19674,
      "end_char": 19705,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "Actually, we don't need to check the distinct set? #",
      "start_char": 19706,
      "end_char": 19758,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "We only care if the substring does not contain all distinct characters? \n                        # But note: if it contains all distinct characters, then we don't require no duplicate? \n                        # However, we are in the case of length L<=k.",
      "start_char": 19784,
      "end_char": 20039,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "If the substring has duplicate, then even if it contains all distinct characters? \n                        # But wait: if it contains all distinct characters and has duplicate, then we have k distinct characters and length L (<=k) and duplicate -> then L>=k+1? no, because L<=k. \n                        # Actually, if we have k distinct characters and length L<=k, then if there is a duplicate, then L must be at least k+1? -> impossible. #",
      "start_char": 20040,
      "end_char": 20481,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Therefore, if the substring has k distinct characters (so it contains all) then the length L must be at least k? and if there is a duplicate then L>=k+1? -> so for L<=k, if we have k distinct characters then there is no duplicate? #",
      "start_char": 20507,
      "end_char": 20739,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Therefore, we only need to worry about substrings that do not contain all distinct characters? Actually, we can simplify: \n                        For a substring of length L (<=k) that has a duplicate -> then it fails. So we can break as soon as we find a substring of length L (<=k) that has a duplicate. Then we move the window: \n                    for i in range(L, n):\n                        # remove s[i-L]\n                        c_out = s[i-L]\n                        idx_out = ord(c_out)-ord('a')\n                        freq[idx_out] -= 1\n                        if freq[idx_out] == 1:\n                            dup_count -= 1\n                        # add s[i]\n                        c_in = s[i]\n                        idx_in = ord(c_in)-ord('a')\n                        freq[idx_in] += 1\n                        if freq[idx_in] == 2:\n                            dup_count += 1\n                        if dup_count > 0:\n                            return \"NO\"\n\n            Step 4: Check substrings of length > k:",
      "start_char": 20765,
      "end_char": 21854,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "We require that the substring must contain all distinct characters? And then the frequencies of the distinct characters must satisfy: max_freq - min_freq <= 1.\n\n                How to check?",
      "start_char": 21872,
      "end_char": 22079,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "We can use a sliding window of variable length? But note: we must check every substring of length from k+1 to n?",
      "start_char": 22101,
      "end_char": 22213,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "The total number of such substrings is O(n) per test case? and the total length of all test cases is 200,000 -> but worst-case one test case with 200,000? then the number of substrings of length>=k+1 is about 200,000?",
      "start_char": 22235,
      "end_char": 22452,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "and for each we do O(k) to check the min and max? then 200000 * 26 = 5.2e6 -> acceptable.",
      "start_char": 22453,
      "end_char": 22542,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "However, we can do:\n\n                    We want to check every contiguous substring of length L in [k+1, n]? But note: we can use a sliding window that expands until we have all distinct characters?",
      "start_char": 22560,
      "end_char": 22759,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, we can do:\n\n                    We know the window must contain all distinct characters.",
      "start_char": 22799,
      "end_char": 22902,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "We can use a two-pointer to find all minimal windows that contain all distinct characters? and then extend?",
      "start_char": 22903,
      "end_char": 23010,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Actually, we can do:\n\n                    We know that the condition for a substring t of length L>k: \n                      (a) It must contain all distinct characters? -> so we can use a frequency array and a count of distinct characters in the window. (b) Then we check: max_freq - min_freq <= 1.\n\n                    How to get min_freq and max_freq?",
      "start_char": 23029,
      "end_char": 23405,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "We can maintain the frequency array and then use a segment tree? but k is only 26, so we can compute min and max in O(26) per window. Steps for step 4:",
      "start_char": 23406,
      "end_char": 23557,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "We use a sliding window that moves the start and end to cover every minimal window that contains all distinct characters? But note: we must check every contiguous substring of length>=k+1?",
      "start_char": 23595,
      "end_char": 23804,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Actually, we can iterate with the window that has all distinct characters?",
      "start_char": 23827,
      "end_char": 23901,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "and then we extend the window to the right and then move the left? We can do:\n\n                    freq = [0]*26\n                    distinct_count = 0\n                    # We'll use two pointers: left and right, and we want to get every window that has all distinct characters? \n                    # But note: we don't need every window?",
      "start_char": 23902,
      "end_char": 24264,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "we only need to check if there is a window that has all distinct characters and max_freq - min_freq > 1. We can do:\n\n                    left = 0\n                    for right in range(n):\n                        # add s[right]\n                        idx = ord(s[right])-ord('a')\n                        freq[idx] += 1\n                        if freq[idx] == 1:\n                            distinct_count += 1\n\n                        # if we have all distinct, then we can try to shrink from the left until we break the condition? while distinct_count == k and left <= right:\n                            # Check the current window: [left, right]\n                            L = right - left + 1\n                            if L > k:   # we only care about L>k\n                                # get min and max frequency in the window for the distinct set? \n                                # But note: we only care about the distinct set D? and we have all distinct? min_f = min(freq[i] for i in range(26) if freq[i]>0)\n                                max_f = max(freq[i] for i in range(26)",
      "start_char": 24265,
      "end_char": 25435,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "if freq[i]>0)\n                                if max_f - min_f > 1:\n                                    return \"NO\"\n\n                            #",
      "start_char": 25436,
      "end_char": 25582,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Now, we try to shrink the window? # But note: we must check every window? #",
      "start_char": 25583,
      "end_char": 25658,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "However, we are going to move left and then break the window? #",
      "start_char": 25717,
      "end_char": 25780,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "Actually, we can break the window by removing s[left] and then check the condition? \n                            # But note: we are going to check every window that has all distinct? # Remove s[left]\n                            idx_left = ord(s[left])-ord('a') freq[idx_left] -= 1\n                            if freq[idx_left] == 0:\n                                distinct_count -= 1\n                            left += 1\n\n                            #",
      "start_char": 25810,
      "end_char": 26321,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "After removal, if distinct_count < k, then we break the inner while and move right again. But wait: what if we break the window",
      "start_char": 26322,
      "end_char": 26449,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "and then we don't check the window that we just had?",
      "start_char": 26471,
      "end_char": 26523,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Actually, the above while loop shrinks the window until it no longer has all distinct?",
      "start_char": 26546,
      "end_char": 26632,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "However, we want to check every window that has all distinct?",
      "start_char": 26655,
      "end_char": 26716,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "We can do:\n\n                    We maintain a window that has all distinct?",
      "start_char": 26739,
      "end_char": 26814,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "and then we move the left pointer only until the window loses one distinct? Then we check the window [left, right]",
      "start_char": 26815,
      "end_char": 26929,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "and then we also check the windows that are larger?",
      "start_char": 26952,
      "end_char": 27003,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Actually, we can do:\n\n                    We use a two-pointer to get the minimal window that has all distinct?",
      "start_char": 27026,
      "end_char": 27137,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "and then we extend the window to the right? But note: the condition must hold for every window that has all distinct?",
      "start_char": 27138,
      "end_char": 27255,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "We can do:\n\n                    We know that the minimal window (the smallest contiguous substring that contains all distinct) has length at least k. \n                    Then any window that contains the minimal window and extends arbitrarily? However, we can check:",
      "start_char": 27300,
      "end_char": 27567,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "For a fixed minimal window [l, r] (which is the first window that has all distinct",
      "start_char": 27613,
      "end_char": 27695,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "and then we shrink from the left until we break), then we can extend to the right arbitrarily?",
      "start_char": 27696,
      "end_char": 27790,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Actually, we can do:\n\n                    We can iterate over the starting index and then for each starting index, we find the minimal window that has all distinct?",
      "start_char": 27813,
      "end_char": 27977,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "and then we extend to the entire rest of the string? But that is too expensive. Alternatively, we can note:\n\n                  The condition for a window that has all distinct: \n                    max_freq - min_freq <= 1.",
      "start_char": 27978,
      "end_char": 28240,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "This condition is equivalent to: the window is \"almost uniform\" in frequency.",
      "start_char": 28260,
      "end_char": 28337,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "How many such windows are there?",
      "start_char": 28358,
      "end_char": 28390,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "However, note: the total length of the string is 200,000 and k is at most 26, so we can do:\n\n                    We iterate over the starting index? -> 200,000 * 26 -> 5.2e6 -> acceptable.",
      "start_char": 28409,
      "end_char": 28597,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Steps for step 4 (alternative):",
      "start_char": 28615,
      "end_char": 28646,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "We know that the window must contain all distinct characters.",
      "start_char": 28668,
      "end_char": 28729,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "We can precompute the next occurrence of each character? But a simpler method:",
      "start_char": 28751,
      "end_char": 28829,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "For each starting index i, we can expand until we have all distinct? Then we check the window",
      "start_char": 28875,
      "end_char": 28968,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "[i, j] for j from the minimal j that gives all distinct to n-1? But then we break when we find a violation?",
      "start_char": 28992,
      "end_char": 29099,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "However, worst-case: the entire string has no violation? then we do O(n) per starting index? -> O(n^2) - > 200000^2 = 40e9 -> too high. We need a more efficient way. Insight: \n                  The condition max_freq - min_freq <= 1 is equivalent to: Let L = j-i+1, then we must have: \n                         min_freq = floor(L/k) and max_freq = ceil(L/k) \n                    and then the total sum of frequencies is L, and we have k distinct. Then we must have: \n                         floor(L/k)*k + r = L, where r is the number of characters that have ceil(L/k) (and r = L mod k) and the rest have floor(L/k). Then the condition is automatically satisfied? But note: the frequencies are not necessarily assigned arbitrarily?",
      "start_char": 29145,
      "end_char": 29952,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "they are determined by the substring. However, we can check: Let L = j-i+1, then we require:\n                         min_freq = L // k\n                         max_freq = (L+k-1)//k   [which is ceil(L/k)]\n                         and then the total sum: (k - r)*min_freq + r*max_freq = (k - r)*(L//k) + r*((L//k)+1) = k*(L//k) + r = L.\n\n                  So the condition is equivalent to: the frequencies must be either L//k or (L//k)+1, and there are exactly r = L % k characters that have (L//k)+1.",
      "start_char": 29994,
      "end_char": 30536,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Therefore, we can check: \n                    For a window [i, j] that has all distinct characters, we require:",
      "start_char": 30556,
      "end_char": 30667,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "For each character c in D: \n                             freq(c) must be either floor(L/k) or floor(L/k)+1. And the number of characters with freq(c)=floor(L/k)+1 must be exactly r = L % k.\n\n                  How to check quickly?",
      "start_char": 30693,
      "end_char": 30948,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "We can precompute the frequency array for the window?",
      "start_char": 30969,
      "end_char": 31022,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "and then we can check in O(k). But we are iterating over O(n) windows? and k=26 -> 26*n -> 200000*26 = 5.2e6 -> acceptable. How to iterate over windows?",
      "start_char": 31023,
      "end_char": 31195,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "We can use a two-pointer that moves the start and end?",
      "start_char": 31233,
      "end_char": 31287,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "and we update the frequency array as we extend the window? We can do:\n\n                    left = 0\n                    freq = [0]*26\n                    # We'll use a variable to track the distinct count? distinct_count = 0\n                    #",
      "start_char": 31288,
      "end_char": 31575,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "We want to consider windows that have all distinct? #",
      "start_char": 31576,
      "end_char": 31629,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "We can move right pointer and then when we have all distinct, we fix the right pointer and then move left until we break?",
      "start_char": 31651,
      "end_char": 31772,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Actually, we can do:\n\n                    for left in range(n):\n                        #",
      "start_char": 31795,
      "end_char": 31884,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "We want to find the minimal right such that [left, right] has all distinct? # But we can use a pointer that we don't reset? \n                        #",
      "start_char": 31885,
      "end_char": 32035,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "We can do a two-pointer that moves the right pointer only forward? We do:\n\n                    left = 0\n                    right = -1\n                    freq = [0]*26\n                    distinct_count = 0\n                    # Precompute the distinct set D? \n                    # We know k = len(D) #",
      "start_char": 32061,
      "end_char": 32387,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "We'll move right until we have all distinct?",
      "start_char": 32409,
      "end_char": 32453,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "for left in range(n):\n                        # We need to ensure that we have all distinct? while right < n and distinct_count < k:\n                            right += 1\n                            if right == n: break\n                            c = s[right]\n                            idx = ord(c)-ord('a')\n                            freq[idx] += 1\n                            if freq[idx] == 1:\n                                distinct_count += 1\n\n                        if distinct_count < k: \n                            # then from left to the end we don't have all distinct?",
      "start_char": 32475,
      "end_char": 33086,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "and we break because we are going to move left and remove more? \n                            # But we break the inner while",
      "start_char": 33087,
      "end_char": 33210,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "and then we break the outer? \n                            #",
      "start_char": 33211,
      "end_char": 33270,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Actually, we break the outer loop?",
      "start_char": 33271,
      "end_char": 33305,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "break\n\n                        # Now [left, right] has all distinct? L = right - left + 1 if L > k:   # we only care about L>k\n                            # Check the condition: \n                            # Let base = L // k\n                            base = L // k\n                            r = L % k\n                            #",
      "start_char": 33335,
      "end_char": 33720,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "We need: \n                            #   Each frequency must be either base or base+1. # And the number of characters with frequency base+1 must be r.\n                            count_plus = 0\n                            valid = True\n                            for i in range(26):\n                                if freq[i] > 0: if freq[i] != base and freq[i] ! = base+1:\n                                        valid = False\n                                        break\n                                    if freq[i] == base+1: count_plus += 1\n                            if not valid or count_plus ! = r:\n                                # print(\"Failed at window:",
      "start_char": 33721,
      "end_char": 34494,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "[%d, %d]\" % (left, right))\n                                return \"NO\"\n\n                        # Now remove s[left] and update\n                        c_left = s[left]\n                        idx_left = ord(c_left)-ord('a') freq[idx_left] -= 1\n                        if freq[idx_left] == 0:\n                            distinct_count -= 1 Then we break out of the for loop? But note: we must check every window that has all distinct?",
      "start_char": 34495,
      "end_char": 34954,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "The above only checks the first window that has all distinct for a given left?",
      "start_char": 35013,
      "end_char": 35091,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "However, note: for a fixed left, the minimal window that has all distinct is [left, right] (the one we found). But what about windows [left, j] for j>right? We must check those too? How?",
      "start_char": 35110,
      "end_char": 35296,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "We can do: for each left, we have the minimal right (call it right0) such that [left, right0] has all distinct. Then we extend j from right0 to n-1?",
      "start_char": 35371,
      "end_char": 35519,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "and check the condition for each window [left, j]? Then the inner loop would be O(n) per left -> O(n^2) -> too slow. We need to avoid that.",
      "start_char": 35539,
      "end_char": 35696,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternate Insight: \n                  The condition for a window [left, j] (with j>=right0) is that the frequencies must be either base or base+1, and the number of base+1 must be r = (j-left+1) % k.\n\n                  But note: as we extend j, the base and r change? How? base = (j-left+1) // k\n                    r = (j-left+1) % k\n\n                  And the frequencies: we are adding one character at a time.",
      "start_char": 35731,
      "end_char": 36185,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "We can update the frequency of the added character and then check if it becomes base or base+1? But note: when we extend by one, base might increase? Actually, base = (L) // k, and when L increases by 1, base might increase by 1 if L mod k becomes 0? So we cannot update quickly.",
      "start_char": 36206,
      "end_char": 36525,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Therefore, we must check each window? But the total number of windows that have all distinct?",
      "start_char": 36563,
      "end_char": 36656,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "The condition that the window has all distinct is automatically satisfied for any window that contains the minimal window?",
      "start_char": 36694,
      "end_char": 36816,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "And the minimal window is at least k, and the total length is n, so the number of windows that have all distinct is O(n) per test case?",
      "start_char": 36836,
      "end_char": 36971,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "However, worst-case: the entire string has all distinct? then the number of windows that have all distinct is O(n^2) -> too many. We must avoid. Another Insight: \n                  The condition max_freq - min_freq <= 1 must hold for every window that has all distinct? But note: if the entire string has all distinct, then we require that the entire string has frequencies that differ by at most 1?",
      "start_char": 36990,
      "end_char": 37423,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "And also every contiguous substring that has all distinct?",
      "start_char": 37462,
      "end_char": 37520,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "However, if the entire string satisfies the condition, does every substring that has all distinct satisfy? Example: \"aabbcc\" (k=3) -> entire string: a:2, b:2, c:2 -> okay. But consider the substring \"aabbc\": \n                         a:2, b:2, c:1 -> max=2, min=1 -> 2-1=1 -> okay. How about \"aab\": \n                         a:2, b:1 -> okay. Actually, the condition for a window that has all distinct: \n                    The frequencies are forced by the length: \n                         base = L//k, r = L%k, and then we require that the frequencies are base or base+1 and exactly r of them are base+1.",
      "start_char": 37541,
      "end_char": 38228,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Therefore, we can precompute the entire frequency array for the whole string?",
      "start_char": 38248,
      "end_char": 38325,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "and then check the entire string? But what about a substring? How about: \n                    We know that the entire string must satisfy: \n                         base = n//k, r = n%k, and then the frequency of each character must be either base or base+1, and exactly r characters have base+1. But is that sufficient? Consider: \n                    s = \"aabbcc\" -> n=6, k=3: base=2, r=0 -> then we require 0 characters with base+1? and each must be 2 -> holds. Now consider a substring that has all distinct?",
      "start_char": 38326,
      "end_char": 38915,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "The entire string satisfies, but what about a substring? Example: s = \"abcabc\", k=3: \n                    entire string: each 2 -> holds. substring \"abcab\": \n                         L=5, base=5//3=1, r=2 -> we require 2 characters with 2 and one with 1? \n                         a:2, b:2, c:1 -> holds. How about \"abca\": \n                         L=4, base=1, r=1 -> we require 1 character with 2 and two with 1? \n                         a:2, b:1, c:1 -> holds. How about \"abc\": \n                         base=1, r=0 -> each 1 -> holds.",
      "start_char": 38956,
      "end_char": 39573,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "How about \"ab\": \n                         but \"ab\" does not have all distinct? so we skip.",
      "start_char": 39593,
      "end_char": 39683,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Therefore, it seems that if the entire string satisfies the condition for the entire string and also we have no consecutive duplicates? and also we have no duplicate in any substring of length<=k? then the condition holds for every substring? Why?",
      "start_char": 39703,
      "end_char": 39950,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "For a substring that does not have all distinct: we require no duplicate? -> which we already checked for length<=k? and for length>k we cannot have a duplicate without having all distinct? (because if we have a duplicate and the substring does not have all distinct, then we have a character that appears twice and a missing character -> fails) -> but we already checked that for length<=k? For a substring that has all distinct: we require that the frequencies are either base or base+1 and the count of base+1 is r = L%k? But note: the entire string satisfies the condition?",
      "start_char": 39992,
      "end_char": 40591,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "does that imply every substring that has all distinct satisfies? Counterexample? \n                    s = \"aabbcc\" -> entire string: 2,2,2 -> holds. substring \"aabbc\": \n                         a:2, b:2, c:1 -> base = 5//3=1, r=2 -> we require 2 characters with 2 and one with 1 -> holds.",
      "start_char": 40612,
      "end_char": 40940,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "How about we build the string from the entire string that satisfies the condition?",
      "start_char": 40960,
      "end_char": 41042,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Actually, the condition for a substring that has all distinct is automatically satisfied if the entire string is periodic? But we don't know.",
      "start_char": 41063,
      "end_char": 41204,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "Known solution from similar problems: \n                  We only need to check substrings of length at most k+1? Why?",
      "start_char": 41242,
      "end_char": 41359,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "Consider: \n                    If a substring t has length L>k and has all distinct characters, then the minimal window that contains all distinct is of length k? But our substring t might be larger.",
      "start_char": 41397,
      "end_char": 41596,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "However, if the entire string has no consecutive duplicates, then the string is an alternating sequence?",
      "start_char": 41638,
      "end_char": 41742,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "In fact, the string is an alternating sequence of the distinct characters? Then the frequencies in any contiguous substring that has all distinct and has length L>k must be: \n                         base = L//k, r = L%k, and then the frequency of each character is either base or base+1? Why?",
      "start_char": 41763,
      "end_char": 42076,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Because the string is a repetition of the distinct set? Example: distinct set = {'a','b','c'}, then the string is \"abcabcabc...\". Then in a substring of length L: \n                         each character appears floor(L/3) or ceil(L/3) times? But note: if the substring is contiguous and the string is periodic, then the frequencies are as required.",
      "start_char": 42118,
      "end_char": 42487,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "Therefore, if the entire string is a repetition of the distinct set? then the condition holds?",
      "start_char": 42546,
      "end_char": 42640,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "How to check if the entire string is a repetition of the distinct set?",
      "start_char": 42661,
      "end_char": 42731,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "We can check the entire string:",
      "start_char": 42753,
      "end_char": 42784,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "The frequency of each character in the entire string must be either n//k or n//k+1?",
      "start_char": 42811,
      "end_char": 42894,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "and the count of n//k+1 must be n%k?",
      "start_char": 42895,
      "end_char": 42931,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "And also the consecutive duplicates are already avoided? But note: the distinct set might not be in a fixed order?",
      "start_char": 42953,
      "end_char": 43067,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "However, the condition of no consecutive duplicates and the entire string being composed of a fixed set of k characters? Then the string is a path in a complete graph? Actually, we can check the entire string: \n                    We know the frequency condition for the entire string: \n                         base = n//k, r = n%k, and then the frequency of each character must be either base or base+1, and exactly r characters have base+1.",
      "start_char": 43108,
      "end_char": 43592,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "And then we also require that the string has no consecutive duplicates? And then we also require that there is no duplicate in any substring of length<=k? But if the entire string is a repetition of the distinct set, then in any substring of length<=k, the characters are distinct?",
      "start_char": 43612,
      "end_char": 43934,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Therefore, the conditions we have already are sufficient? Steps for one test case:\n\n                    k = len(set(s)) if k==1:\n                        print(\"YES\")\n                        continue\n\n                    # Check consecutive duplicates:\n                    for i in range(len(s)-1):\n                        if s[i]==s[i+1]:\n                            print(\"NO\")\n                            break\n                    else:   # no break\n                        # Check the entire string frequency condition? \n                        from collections import Counter\n                        cnt = Counter(s)\n                        n = len(s)\n                        base = n // k\n                        r = n % k\n                        #",
      "start_char": 43955,
      "end_char": 44749,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "The frequency of each character must be either base or base+1. # And the number of characters with frequency base+1 must be r.\n                        count_plus = 0\n                        valid = True\n                        for char, count_val in cnt.items():\n                            if count_val ! = base and count_val ! = base+1:\n                                valid = False\n                                break\n                            if count_val == base+1: count_plus += 1\n                        if not valid or count_plus ! = r:\n                            print(\"NO\")\n                        else:\n                            print(\"YES\") But wait: what if the distinct set is not contiguous in the entire string? Example: \"abcabc\" -> distinct set {'a','b','c'}, n=6, base=2, r=0 -> each must be 2 -> holds. Counterexample: \n                    s = \"abcd\" -> k=4, n=4, base=1, r=0 -> each must be 1 -> holds. and no consecutive duplicates -> holds -> YES. But what about the substring \"ab\"? It has distinct set {'a','b'} which is a subset of the entire distinct set? Then we require that it has no duplicate -> holds. What about the substring \"abc\"? \n                    distinct set {'a','b','c'} -> which is a subset? and we require no duplicate -> holds. What about the entire string? distinct set {'a','b','c','d'} -> then we require the frequencies: each 1 -> holds. But what about the pair (a,d) in the substring \"ab\"? freq(a)=1, freq(d)=0 -> |1-0|=1 -> holds. So it passes. However, consider: \n                    s = \"aabc\" -> k=3? distinct set {'a','b','c'}, n=4, base=1, r=1 -> then we require one character with 2 and two with 1? \n                    a:2, b:1, c:1 -> holds. But we have consecutive duplicates? s[0]='a', s[1]='a' -> consecutive duplicates -> we break and say \"NO\". So we don't get to the frequency check. Now consider: \n                    s = \"abac\" -> \n                      distinct set: {'a','b','c'} -> k=3, n=4, base=1, r=1 -> we require one character with 2 and two with 1? \n                      a:2, b:1, c:1 -> holds. consecutive duplicates? 'a' then 'b' -> no\n                         'b' then 'a' -> no\n                         'a' then 'c' -> no -> so we would say \"YES\". But wait: the substring \"aba\" (which is contiguous) -> \n                    distinct set of the entire string is {'a','b','c'}, so we must consider the pair (a,c): \n                         freq(a)=2, freq(c)=0 -> |2-0|=2>1 -> fails. Therefore, we must also check that there is no duplicate in any substring of length<=k? In \"abac\", the substring \"aba\" has length 3 (<=k=3) and has a duplicate (a appears twice) -> so we should have caught it in step 3? How do we check step 3?",
      "start_char": 44750,
      "end_char": 47976,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "We can do: \n                      for L in range(2, k+1): \n                         use a sliding window to check for duplicate in any window of length L? In \"abac\": \n                    L=2: \n                         \"ab\": no duplicate -> okay. \"ba\": no duplicate -> okay. \"ac\": no duplicate -> okay.\n                    L=3:\n                         \"aba\": has duplicate?",
      "start_char": 48018,
      "end_char": 48461,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "We can use a frequency array: \n                            freq = [0]*26\n                            for \"aba\": \n                                a:2, b:1 -> so we see a duplicate? How do we detect duplicate? if any frequency>=2. So we can do:\n\n                    for L in range(2, k+1):\n                        freq = [0]*26\n                        dup = 0\n                        # initialize the first window [0, L-1]\n                        for i in range(L):\n                            c = s[i]\n                            idx = ord(c)-ord('a')\n                            freq[idx] += 1\n                            if freq[idx] == 2:\n                                dup += 1\n                        if dup > 0:\n                            print(\"NO\")\n                            break\n                        for i in range(L, n): # remove s[i-L]\n                            c_out = s[i-L]\n                            idx_out = ord(c_out)-ord('a')\n                            freq[idx_out] -= 1\n                            if freq[idx_out] == 1:\n                                dup -= 1\n                            # add s[i]\n                            c_in = s[i]\n                            idx_in = ord(c_in)-ord('a')\n                            freq[idx_in] += 1\n                            if freq[idx_in] == 2:\n                                dup += 1\n                            if dup > 0:\n                                print(\"NO\")\n                                break\n                        else:",
      "start_char": 48488,
      "end_char": 50078,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "continue\n                        break\n                    else:\n                        # then we do the entire string frequency condition? \n                        # ... and then print \"YES\"\n\n                  But note: in \"abac\", when L=3, the first window \"aba\" has dup>0 -> we break and say \"NO\".",
      "start_char": 50107,
      "end_char": 50408,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "However, we did not say \"NO\" for consecutive duplicates?",
      "start_char": 50428,
      "end_char": 50484,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "\"abac\" has no consecutive duplicates? So we would do step 3 and find a window of length 3 with duplicate -> \"NO\". Therefore, the algorithm for one test case:\n\n                    k = len(set(s)) if k==1:\n                        print(\"YES\")\n                        continue\n\n                    # Check consecutive duplicates (adjacent duplicates)\n                    for i in range(len(s)-1):\n                        if s[i]==s[i+1]:\n                            print(\"NO\")\n                            break\n                    else:\n                        # Check for any duplicate in any substring of length in [2, k] (using a sliding window for each length? but note: k is at most 26)\n                        n = len(s)\n                        found = False\n                        # We can do a single sliding window for the maximum length: k? \n                        # But note: we care about any window of length in [2, k] that has a duplicate? \n                        #",
      "start_char": 50506,
      "end_char": 51546,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "We can do a sliding window that checks windows of length up to k? \n                        #",
      "start_char": 51547,
      "end_char": 51639,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "However, we can do: \n                        # We want to know: is there any window of length L (2<=L<=k) that has a duplicate? #",
      "start_char": 51640,
      "end_char": 51771,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "We can do a sliding window that expands to at most k? \n\n                        #",
      "start_char": 51799,
      "end_char": 51880,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "We'll do a window that expands from the left until we have length k, then move left? \n                        # But we can do a fixed window of length k? and then slide? \n                        # But we also need to check windows of length < k? \n\n                        # Alternatively, we can do: \n                        # We know that if there is a duplicate in a window of length L (<=k), then there is a duplicate in a window of length L0 (which is the distance between the duplicate and the next occurrence) which is at most k? \n                        # But we can simply check the last k+1 characters? \n\n                        #",
      "start_char": 51881,
      "end_char": 52522,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "We can do: \n                        #   Use a frequency array for the window [i, i+L-1] and we let L vary? #",
      "start_char": 52525,
      "end_char": 52633,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Instead, we can do a sliding window that expands to at most k? \n                        #   We'll use a fixed window that moves and we maintain the frequency array and a flag for duplicate.\n\n                        #",
      "start_char": 52660,
      "end_char": 52876,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "We'll do a window that is at most length k? \n                        #",
      "start_char": 52877,
      "end_char": 52947,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "We can do a two-pointer that expands until we either have a duplicate or the window length becomes k, then we move the left pointer? \n\n                        # But note: we only care if there is at least one duplicate in a window of length<=k? \n\n                        # We can do:\n\n                        freq = [0]*26\n                        left = 0\n                        found_dup = False\n                        for right in range(n):\n                            # add s[right]\n                            idx = ord(s[right])-ord('a')\n                            freq[idx] += 1\n                            if freq[idx] >= 2:\n                                found_dup = True\n                                break\n\n                            # if the window length (right-left+1) == k, then we remove left and move left\n                            if right - left + 1 == k:\n                                # remove s[left]\n                                idx_left = ord(s[left])-ord('a') freq[idx_left] -= 1\n                                left += 1\n\n                        if found_dup:\n                            print(\"NO\")\n                        else:\n                            # Check the entire string frequency condition? cnt = Counter(s)\n                            base = n // k\n                            r = n % k\n                            count_plus = 0\n                            valid = True\n                            for char in cnt:\n                                if cnt[char] ! = base and cnt[char] ! = base+1:\n                                    valid = False\n                                    break\n                                if cnt[char] == base+1: count_plus += 1\n                            if not valid or count_plus ! = r:\n                                print(\"NO\")\n                            else:\n                                print(\"YES\")\n\n                  But wait: the above two-pointer for duplicate in a window of length<=k? We start with left=0, and we expand right. We add s[right].",
      "start_char": 52950,
      "end_char": 55113,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "If we get a duplicate, we break and say \"NO\".",
      "start_char": 55156,
      "end_char": 55201,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "If the window length becomes k, then we remove the leftmost and move left? Why is that sufficient? We are essentially maintaining a window of length at most k. \n                    We are checking if there is a duplicate in any window of length at most k? \n\n                  Example: \"abac\": \n                    left=0, right=0: window=\"a\" -> no duplicate.\n                    right=1: window=\"ab\" -> no duplicate. right=2: window=\"aba\" -> now we add 'a': freq['a'] becomes 2 -> duplicate found -> break and say \"NO\". Therefore, it works.",
      "start_char": 55223,
      "end_char": 55824,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "However, note: the window might not be contiguous? But we are moving left only when the window length becomes k? But what if the duplicate is not in the current window of length k? Example: \"abcdefga\" -> k=7, then when we add the last 'a', the window is \"bcdefga\", which has length 7 and does not contain the first 'a'. But then we have not seen a duplicate in any window of length<=7?",
      "start_char": 55863,
      "end_char": 56331,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "However, the entire string has a duplicate? but the window that contains the duplicate is the entire string? which has length 8>7? -> we don't care? But note: the condition for a window of length>k: \n                    We require that it contains all distinct?",
      "start_char": 56353,
      "end_char": 56614,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "and then the frequency condition? But in \"abcdefga\", the entire string has distinct set of size 7, and the entire string has length 8, base=8//7=1, r=1, and then we require one character with 2 and the rest 1? \n                    'a':2, others:1 -> holds.",
      "start_char": 56635,
      "end_char": 56912,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "And the consecutive duplicates?",
      "start_char": 56932,
      "end_char": 56963,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "We already checked: no consecutive duplicates. And the window of length<=k: we did not find any duplicate? But wait: the substring \"a\" and then the substring \"a\" at the end? -> but we only care about contiguous substring? The substring \"abcdefga\" is not of length<=k? The substring that is \"a\" at the beginning and \"a\" at the end are not in the same window of length<=k?",
      "start_char": 56985,
      "end_char": 57436,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "However, the condition requires that for the substring \"a\" (at the beginning) and the substring \"a\" (at the end) separately? For the substring \"a\" (at the beginning): \n                         distinct set of the entire string is {'a','b','c','d','e','f','g'}, so we must consider the pair (a, b): \n                         freq(a)=1, freq(b)=0 -> |1-0|=1 -> holds.",
      "start_char": 57457,
      "end_char": 57843,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "For the substring \"a\" at the end: similarly holds.",
      "start_char": 57864,
      "end_char": 57914,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "And the substring \"abcdefga\" (the entire string) has all distinct?",
      "start_char": 57934,
      "end_char": 58000,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "and we checked the frequency condition? -> holds.",
      "start_char": 58001,
      "end_char": 58050,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Therefore, we would say \"YES\" for \"abcdefga\", which is correct. But what about the substring \"ag\" (which is not contiguous? but contiguous substring must be contiguous) -> \"ag\" is not contiguous in the string?",
      "start_char": 58070,
      "end_char": 58298,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "The contiguous substring that is the entire string is the only one that contains both a's? Therefore, the algorithm:\n\n                    t = int(input().strip())\n                    for _ in range(t):\n                        s = input().strip()\n                        k = len(set(s)) if k == 1:\n                            print(\"YES\")\n                            continue\n\n                        # Check consecutive duplicates\n                        consecutive_dup = False\n                        for i in range(len(s)-1): if s[i]==s[i+1]:\n                                print(\"NO\")\n                                consecutive_dup = True\n                                break\n\n                        if consecutive_dup:\n                            continue\n\n                        # Check for any duplicate in a window of length at most k\n                        freq = [0]*26\n                        left = 0\n                        found_dup = False\n                        for right in range(len(s)):\n                            idx_r = ord(s[right]) - ord('a')\n                            freq[idx_r] += 1\n                            if freq[idx_r] > 1:\n                                found_dup = True\n                                break\n\n                            # If the current window length is k, then we remove the leftmost\n                            if right - left + 1 == k:\n                                idx_l = ord(s[left]) - ord('a')\n                                freq[idx_l] -= 1\n                                left += 1\n\n                        if found_dup:\n                            print(\"NO\")\n                            continue\n\n                        # Check the entire string frequency condition\n                        from collections import Counter\n                        cnt = Counter(s)\n                        n = len(s)\n                        base = n // k\n                        r = n % k\n                        count_plus = 0\n                        valid = True\n                        # Note: k is the number of distinct, but what if k does not divide the frequencies? \n                        for char in cnt:\n                            if cnt[char] ! = base and cnt[char] ! = base+1:\n                                valid = False\n                                break\n                            if cnt[char] == base+1: count_plus += 1\n\n                        if not valid or count_plus ! = r:\n                            print(\"NO\")\n                        else:\n                            print(\"YES\")",
      "start_char": 58319,
      "end_char": 60991,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "However, note: the entire string frequency condition: We require that the frequency of each character is either base or base+1, and the number of characters with base+1 is r = n%k. But what if k does not divide n? then base = n//k, and r = n%k, and then the total sum: \n                    (k - r)*base + r*(base+1) = k*base + r = n.",
      "start_char": 61011,
      "end_char": 61384,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "And the frequencies we have sum to n? But note: the entire string has n characters.",
      "start_char": 61404,
      "end_char": 61487,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Therefore, the condition is necessary and sufficient for the entire string to be partitioned as described.",
      "start_char": 61527,
      "end_char": 61633,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "However, is it sufficient for the condition of the problem?",
      "start_char": 61653,
      "end_char": 61712,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "We have already ensured:\n                      (1) no consecutive duplicates. (2) no duplicate in any window of length<=k (which forces that any window that does not contain all distinct has no duplicate?",
      "start_char": 61734,
      "end_char": 61960,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "and then the condition holds for such window? because for a character not in the window, the frequency in the window is 0, and for a character in the window, the frequency is 1 -> so the difference is at most 1).",
      "start_char": 61961,
      "end_char": 62173,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "(3) for the entire string, the frequency condition holds?",
      "start_char": 62196,
      "end_char": 62253,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "and by the periodic structure (which is forced by the no consecutive duplicates and the entire string frequency condition) we assume that any window that has all distinct has the frequency condition? But note: we did not explicitly check every window that has all distinct?",
      "start_char": 62254,
      "end_char": 62527,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "We only checked the entire string frequency condition?",
      "start_char": 62569,
      "end_char": 62623,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "How about a window that has all distinct and is not the entire string? Example: s = \"abcabc\" -> k=3, n=6, base=2, r=0 ->",
      "start_char": 62644,
      "end_char": 62785,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "each character appears 2 times in the entire string. Consider the window \"abcab\": \n                         a:2, b:2, c:1 -> \n                         L=5, base=5//3=1, r=2 -> we require 2 characters with 2 and one with 1? -> holds.",
      "start_char": 62786,
      "end_char": 63039,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "How does the entire string frequency condition imply that for every window that has all distinct?",
      "start_char": 63059,
      "end_char": 63156,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "It doesn't directly, but the structure of the string (which is a repetition of the distinct set) might ensure that. But note: we have no consecutive duplicates and the entire string frequency condition?",
      "start_char": 63178,
      "end_char": 63380,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "The string might not be a repetition? Example: s = \"aabbcc\" (which is not a repetition of \"abc\", but we have consecutive duplicates? -> but we already checked consecutive duplicates and this has consecutive duplicates -> so we would have caught it). In our algorithm, we only get to the entire string frequency condition if there are no consecutive duplicates and no duplicate in any window of length<=k.",
      "start_char": 63421,
      "end_char": 63865,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "What is the structure of such a string?",
      "start_char": 63885,
      "end_char": 63924,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "It must be that the string is a repetition of the distinct set? Why?",
      "start_char": 63946,
      "end_char": 64014,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Because if there is no duplicate in any window of length k, then the first k characters are distinct. Then the next character must be the first character of the distinct set?",
      "start_char": 64059,
      "end_char": 64233,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "because if it were a different character, then we would have a window of length k+1 that has a duplicate? But wait: we allow windows of length>k to have duplicates? Actually, the condition we checked for duplicate is only for windows of length<=k? \n\n                  Example: \"abcdab\" -> k=4, \n                    window0: \"abcd\" -> distinct. then we remove 'a', add next 'a' -> window1: \"bcda\" -> distinct. then window2: \"cdab\" -> distinct. But we never see a duplicate in a window of length<=k? However, the entire string frequency condition: \n                    n=6, base=1, r=2 -> we require two characters with 2 and two with 1? \n                    a:2, b:2, c:1, d:1 -> holds.",
      "start_char": 64257,
      "end_char": 65064,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "And the condition for the entire string? We require that for every window that has all distinct (which in this case, every window of length 4 has all distinct) -> then we require for a window of length 4: base=4//4=1, r=0 -> so each character must appear 1 time -> holds. How about a window of length 5? \n                    \"abcda\": \n                         distinct set is {'a','b','c','d'} -> all distinct? base=5//4=1, r=1 -> we require one character with 2 and the rest 1? a:2, b:1, c:1, d:1 -> holds.",
      "start_char": 65084,
      "end_char": 65709,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "How about a window of length 6? \n                    \"abcdab\": base=6//4=1, r=2 -> we require two characters with 2 and two with 1? \n                         a:2, b:2, c:1, d:1 -> holds.",
      "start_char": 65729,
      "end_char": 65941,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Therefore, the entire string frequency condition might be sufficient for every window that has all distinct? Why?",
      "start_char": 65961,
      "end_char": 66074,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "The entire string is composed of the distinct set, and the frequency condition for the entire string ensures that the distribution is as uniform as possible.",
      "start_char": 66116,
      "end_char": 66273,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "And then any window that has all distinct will have a frequency distribution that is also as uniform as possible? We might rely on the known solution: \n                    Known solution in C++ for a similar problem (from a contest) is:\n\n                      #include <bits/stdc++.h>\n                      using namespace std;\n                      int main() {\n                          int t;\n                          cin >> t;\n                          while (t--) {\n                              string s;\n                              cin >> s;\n                              vector<int> cnt(26, 0);\n                              for (char c : s) cnt[c - 'a']++;\n                              sort(cnt.rbegin(), cnt.rend());\n                              int mx = cnt[0];\n                              int distinct = 0;\n                              for (int i = 0; i < 26; i++) if (cnt[i]) distinct++;\n                              if (distinct == 1) {\n                                  cout << \"YES\\n\";\n                                  continue;\n                              }\n                              for (int i = 1; i < s.size(); i++) {\n                                  if (s[i] == s[i-1]) {\n                                      mx = 1e9;\n                                  }\n                              }\n                              int total = s.size();\n                              if (mx <= (total + distinct - 1) / distinct) {\n                                  cout << \"YES\\n\";\n                              } else {\n                                  cout << \"NO\\n\";\n                              }\n                          }\n                      } But I'm not sure.",
      "start_char": 66295,
      "end_char": 68011,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Given the complexity of the problem and the constraints on the total length (200,000) and the fact that k is at most 26, we can try to run the following for step 4 if we want to be safe:\n\n                  We use a two-pointer to find every minimal window that has all distinct?",
      "start_char": 68048,
      "end_char": 68326,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "and then extend it to the right and check every window that has all distinct? But we already have an O(n * k) solution that might be acceptable? However, the worst-case total length of all test cases is 200,000, and k<=26, so 200000*26 = 5.2e6 -> acceptable in Pyton? So we can do:\n\n                    if consecutive_dup is False and found_dup is False:\n                        # then we check every window that has all distinct and has length>k? \n                        #",
      "start_char": 68327,
      "end_char": 68841,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "We use a two-pointer to slide and for every window that has all distinct, we check the frequency condition. left = 0\n                        right = -1\n                        freq = [0]*26\n                        distinct_count = 0\n                        n = len(s)\n                        # We'll also maintain the distinct set of the entire string: we know k\n                        for right in range(n):\n                            idx = ord(s[right])-ord('a')\n                            freq[idx] += 1\n                            if freq[idx]==1:\n                                distinct_count += 1\n\n                            while distinct_count == k and left <= right: L = right - left + 1 if L > k:   # we only care about L>k\n                                    base = L // k\n                                    r = L % k\n                                    # We need to check: \n                                    #   For each character in the distinct set of the entire string, the frequency in the window must be either base or base+1. # And the number of characters with frequency base+1 must be r.\n                                    count_plus = 0\n                                    valid_win = True\n                                    # But note: the window has all distinct? so we only care about the characters that are in the entire distinct set? \n                                    #",
      "start_char": 68862,
      "end_char": 70398,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "We can iterate over the entire distinct set? \n                                    #",
      "start_char": 70399,
      "end_char": 70482,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "However, we have the frequency array for the window? # But note: the frequency array is for the window? for i in range(26):\n                                        if freq[i] > 0:\n                                            if freq[i]!=base and freq[i]!=base+1:\n                                                valid_win = False\n                                                break\n                                            if freq[i] == base+1:\n                                                count_plus += 1\n                                        else:\n                                            #",
      "start_char": 70483,
      "end_char": 71160,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "This character is in the entire distinct set? #",
      "start_char": 71161,
      "end_char": 71208,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "We know the entire distinct set? but we don't have it stored per index? #",
      "start_char": 71254,
      "end_char": 71327,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "We can precompute the entire distinct set? \n                                            # But note: if freq[i]==0, then it might be that this character is not in the entire distinct set? \n                                            #",
      "start_char": 71373,
      "end_char": 71606,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Actually, the entire distinct set is known: we have k, but not the exact letters? \n                                            # We can precompute the set of characters that are in the entire string: \n                                            #   total_chars = set(s)\n                                            # But we are in the loop over test cases, and we did: k = len(set(s))\n                                            #   total_chars = set(s)  -> we can do that at the beginning. # But wait: the window has distinct_count = k, so it contains all distinct characters of the entire string? # Therefore, if freq[i]==0, then the character corresponding to i is not in the entire distinct set? # So we skip.",
      "start_char": 71607,
      "end_char": 72411,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "pass\n\n                                    # But note: we only care about the characters that are in the entire distinct set?",
      "start_char": 72503,
      "end_char": 72627,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "and the entire distinct set is exactly the set of characters with freq[i]>0 in the window?",
      "start_char": 72628,
      "end_char": 72718,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "#   because the window has all distinct.",
      "start_char": 72756,
      "end_char": 72796,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "if not valid_win or count_plus ! = r:\n                                        print(\"NO\")\n                                        # We break out of everything?",
      "start_char": 72834,
      "end_char": 72992,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "# We can set a flag and break out of the while and for loops. # Let's set a flag\n                                        found_bad = True\n                                        break\n                                # End if L>k\n\n                                # Remove s[left] and update\n                                idx_left = ord(s[left])-ord('a') freq[idx_left] -= 1\n                                if freq[idx_left]==0:\n                                    distinct_count -= 1\n                                left += 1\n\n                            else:\n                                # We did not have all distinct?",
      "start_char": 73034,
      "end_char": 73731,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "continue\n\n                            #",
      "start_char": 73765,
      "end_char": 73804,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "If we broke out of the while loop with found_bad, then break out of the for loop\n                            if found_bad:\n                                break\n\n                        else:\n                            # if we did not break, then all windows are valid. print(\"YES\") But this is getting very long. Given the time, and the known total length of all test cases is 200,000, and the worst-case for one test case is 200,000, and k<=26, and the inner loop is O(26) per window that has all distinct?",
      "start_char": 73805,
      "end_char": 74378,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "How many windows have all distinct?",
      "start_char": 74397,
      "end_char": 74432,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "In the worst-case, the entire string has all distinct? then the number of windows that have all distinct is n-k+1? And then we do 26*(n) = 200000*26 = 5.2e6 per test case? But the total length of all test cases is 200,000, so the worst-case is one test case of length 200,000 -> 5.2e6 -> acceptable in Python. Therefore, we can do:\n\n                  t = int(input().strip())\n                  for _ in range(t):\n                      s = input().strip()\n                      n = len(s) distinct_all = set(s)\n                      k = len(distinct_all)\n\n                      if k==1:\n                          print(\"YES\")\n                          continue\n\n                      # Check consecutive duplicates\n                      consecutive_dup = False\n                      for i in range(n-1): if s[i]==s[i+1]:\n                              print(\"NO\") consecutive_dup = True\n                              break\n                      if consecutive_dup:\n                          continue\n\n                      # Check for any duplicate in any window of length<=k\n                      freq1 = [0]*26\n                      left = 0\n                      found_dup = False\n                      for right in range(n):\n                          idx_r = ord(s[right])-ord('a')\n                          freq1[idx_r] += 1\n                          if freq1[idx_r] > 1:\n                              found_dup = True\n                              break\n                          if right - left + 1 == k:\n                              idx_l = ord(s[left])-ord('a')\n                              freq1[idx_l] -= 1\n                              left += 1\n                      if found_dup:\n                          print(\"NO\")\n                          continue\n\n                      # Now check every window that has all distinct and has length>k\n                      # We'll use a two-pointer to find all windows that have all distinct.\n                      freq2 = [0]*26\n                      distinct_count = 0\n                      left = 0\n                      valid = True\n                      for right in range(n):\n                          idx = ord(s[right])-ord('a')\n                          freq2[idx] += 1\n                          if freq2[idx] == 1:\n                              distinct_count += 1\n\n                          # Shrink the window from the left until it no longer has all distinct? while distinct_count == k and left <= right: L = right - left + 1\n                              if L > k:\n                                  base = L // k\n                                  r = L % k\n                                  count_plus = 0\n                                  # We iterate over the entire distinct_all set? but we have an array for the window, but we only care about the distinct_all set? \n                                  # But note: the window has all distinct_all, so we only care about the 26 letters that are in distinct_all? \n                                  # We can iterate over the 26 letters? # But we can also iterate over distinct_all? \n                                  #",
      "start_char": 74452,
      "end_char": 77772,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "However, we have the frequency array for the window? # But the frequency array is indexed by letter, and we don't have a direct mapping from the set distinct_all to the array? \n                                  # We can do: \n                                  #   for c in distinct_all:\n                                  #       letter = c\n                                  #       idx = ord(c)-ord('a')\n                                  #       count_val = freq2[idx]\n                                  #   but this is O(k) per window, and k<=26, and the number of windows is O(n) -> 26 * (number of windows) -> worst-case 200000*26 = 5.2e6 -> acceptable.\n                                  # But note: the while loop might run for many windows? # The total number of windows that have all distinct is O(n) (amortized by the two pointers) and then 26 per window -> 5.2e6.\n\n                                  for c in distinct_all :\n                                      count_val = freq2[ord(c)-ord('a')]\n                                      if count_val != base and count_val != base+1:\n                                          valid = False\n                                          break\n                                      if count_val == base+1:\n                                          count_plus += 1\n                                  if not valid or count_plus ! = r:\n                                      valid = False\n                                  if not valid:\n                                      break\n\n                              # Remove s[left] and update\n                              c_left = s[left]\n                              idx_left = ord(c_left)-ord('a')\n                              freq2[idx_left] -= 1\n                              if freq2[idx_left] == 0:\n                                  distinct_count -= 1\n                              left += 1\n\n                              # If we broke due to valid=False, then break the while\n                              if not valid:\n                                  break\n\n                          if not valid:\n                              break\n\n                      if not valid:\n                          print(\"NO\")\n                      else:\n                          print(\"YES\") But note: it is possible that we never have a window with all distinct? For example, if the string is \"abcd\" with k=4, then the entire string is the only window that has all distinct? and we will check it? However, the two-pointer will find it: \n                  right=0: add 'a' -> distinct_count=1\n                  right=1: add 'b' -> distinct_count=2\n                  right=2: add 'c' -> distinct_count=3\n                  right=3: add 'd' -> distinct_count=4 -> then we enter the while. L=4, which is not >k (k=4) -> so we skip the condition?",
      "start_char": 77808,
      "end_char": 80798,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "We only check windows with length>k. But the condition for the window of length=k: \n                  We require that it has no duplicate? -> which we already checked in the previous step (the window of length<=k) ->",
      "start_char": 80817,
      "end_char": 81051,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "and we know it has no duplicate? and it has all distinct? then for the condition: \n                    For a window of length=k: \n                      base = k//k = 1, r=0 -> then we require each character to appear exactly 1 time -> which it does. Therefore, we don't need to check windows of length=k? So we are safe.",
      "start_char": 81052,
      "end_char": 81427,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "However, note: the problem says \"for every substring\", and we have checked:\n                  - For every substring that does not have all distinct: we have ensured that it has no duplicate (by the window<=k check) and then the condition holds.\n                  - For every substring that has all distinct and has length=k: we have ensured no duplicate (so each appears once) -> then for any two characters: \n                         if both are in the substring: |1-1|=0\n                         if one is in and one is out: |1-0|=1 -> holds.\n                  -",
      "start_char": 81463,
      "end_char": 82027,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "For every substring that has all distinct and has length>k: we check the frequency condition.",
      "start_char": 82028,
      "end_char": 82121,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Therefore, we have checked every substring. Let's run the provided examples:\n\n                  Example 1: \"aba\" (which should be \"NO\" because of the substring \"aba\" has a duplicate and length=3<=k=2? -> wait, k=2 for \"aba\"? distinct set: {'a','b'} -> k=2. consecutive duplicates: \n                          s[0]='a', s[1]='b' -> no\n                          s[1]='b', s[2]='a' -> no -> so we pass. Check for duplicate in window of length<=2: We do a sliding window of at most 2? \n                          right0: 'a' -> freq['a']=1 -> no dup.\n                          right1: 'b' -> no dup, then window length=2 -> remove 'a' -> freq['a']=0, then left=1.\n                          right2: 'a' -> freq['a']=1 (because we removed the first 'a') -> no dup. Then we move to the two-pointer for windows with all distinct and length>2?",
      "start_char": 82139,
      "end_char": 83082,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "We never have a window with all distinct and length>2? The entire distinct set is {'a','b'}, and we have windows: [0,1]: \"ab\" -> distinct_count=2, length=2 (not>2) -> skip. [1,2]: \"ba\" -> distinct_count=2, length=2 -> skip. Then we print \"YES\" -> but expected \"NO\". Why? The substring \"aba\" has length=3>k=2, and it has all distinct? How do we catch it? In the two-pointer for windows with all distinct and length>k: \n                      We start with left=0, and we add:\n                         right0: 'a' -> distinct_count=1.\n                         right1: 'b' -> distinct_count=2 -> enter the while: \n                             window = \"ab\", length=2 (<=k) -> skip the condition. then we remove 'a' -> distinct_count becomes 1? because 'a' goes to 0? \n                         right2: 'a' -> distinct_count=2 again? window = s[1:3] = \"ba\", length=2 -> skip. We never consider the window [0,2]=\"aba\" because after we remove the first 'a', the window [0,2] is not contiguous in our two-pointer? How to consider window [0,2]?",
      "start_char": 83132,
      "end_char": 84435,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Our two-pointer is designed to find the minimal window for a given right? But we want to consider every window that has all distinct?",
      "start_char": 84473,
      "end_char": 84606,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "We can modify the two-pointer to not shrink below k? But the condition: we want to consider every window that has all distinct?",
      "start_char": 84644,
      "end_char": 84771,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Alternatively, we can do a different two-pointer: \n                  We want to expand the window until we have all distinct, and then we do not shrink below the minimal window? But then we would have to check every extension?",
      "start_char": 84809,
      "end_char": 85035,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Given the time, and the fact that the total length is 200,000 and k is small, we can do a separate check for every window that has all distinct by a different method?",
      "start_char": 85073,
      "end_char": 85239,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "How about: \n                  We iterate over every starting index left, and then we find the minimal right such that [left, right] has all distinct? Then we extend the window to the end, and for each extension, we check the condition? But that is O(n^2).",
      "start_char": 85258,
      "end_char": 85513,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, we can use the two-pointer that moves the right pointer and then for each left, we remember the last time we had all distinct? We can do:\n\n                  left = 0\n                  right = 0\n                  freq = [0]*26\n                  distinct_count = 0\n                  for right in range(n):\n                      # add s[right]\n                      # update distinct_count\n                      # while we have all distinct, we can check the condition for the current window and then we do not remove? \n                      # but we want to check every window that has all distinct?",
      "start_char": 85569,
      "end_char": 86199,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "# so for the current right, we find the minimal left such that [left, right] has all distinct? # then we know that [left, right] has all distinct, and we check it. # then we do not remove, because we want to extend to the right?",
      "start_char": 86223,
      "end_char": 86451,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "This is not the typical two-pointer.",
      "start_char": 86517,
      "end_char": 86553,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "Known efficient method: \n                  We can use a pointer that for each right, we find the minimal left such that [left, right] has all distinct?",
      "start_char": 86571,
      "end_char": 86722,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "and then we know that for this right, the windows [left, right], [left+1, right], ... ,",
      "start_char": 86742,
      "end_char": 86829,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "[right, right] might not have all distinct? but we only care about the windows that have all distinct? We can do:\n\n                    last_occurrence = {}\n                    left = 0\n                    for right in range(n):\n                        c = s[right]\n                        # update last_occurrence of c to right\n                        # and then the minimal left is max(left, last_occurrence of any char? ) -> no. This is complex. Given the complexity, and the fact that the string length is not huge (200,000) and the distinct set is small (<=26), we can simply precompute the next occurrence for each character? But note: the total length of all test cases is 200,000, so we can try to do an O(26*n) solution?",
      "start_char": 86830,
      "end_char": 87633,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "How about for each starting index left, we go right until we have collected all distinct? then we check the condition for the window [left, right] and then for [left, right+1], [left, right+2], ... until the end?",
      "start_char": 87670,
      "end_char": 87882,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "and then we break when we find a violation? But worst-case: O(n^2) -> 200000^2 = 40e9 -> too high.",
      "start_char": 87921,
      "end_char": 88037,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Therefore, we must use the two-pointer that moves the left pointer for a fixed right only to the last minimal window?",
      "start_char": 88055,
      "end_char": 88172,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "We can do as in the first two-pointer for the minimal window, but then for a fixed right, after we have the minimal left (say L0), then the window [L0, right] has all distinct, and then we extend to [L0-1, right] if available? But that is not contiguous.",
      "start_char": 88191,
      "end_char": 88445,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, we can do: \n                  Use a two-pointer to find the minimal window (the smallest window ending at right that has all distinct) for each right? then the condition must hold for that minimal window?",
      "start_char": 88481,
      "end_char": 88700,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "and also for any window that contains it? But note: the condition for a window that has all distinct and is larger than the minimal window might be automatically satisfied if the minimal window satisfies? \n                  -> not necessarily.",
      "start_char": 88739,
      "end_char": 89000,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "Given the time constraints, and since the intended solution might be simpler, let me look for known solutions online. Known solution in C++ (from a contest):\n\n                  #include <bits/stdc++.h>\n                  using namespace std;\n                  int main() {\n                      int test;\n                      cin >> test;\n                      while (test--) {\n                          string s;\n                          cin >> s;\n                          vector<int> cnt(26, 0);\n                          for (auto &c : s) {\n                              cnt[c - 'a']++;\n                          }\n                          int distinct = 0;\n                          for (int i = 0; i < 26; i++) {\n                              if (cnt[i] > 0) {\n                                  distinct++;\n                              }\n                          } if (distinct == 1) {\n                              cout << \"YES\" << endl;\n                              continue;\n                          }\n                          vector<int> cnt2(26, 0);\n                          int j = 0;\n                          bool valid = true;\n                          for (int i = 0; i < s.size(); i++) {\n                              cnt2[s[i]-'a']++;\n                              if (cnt2[s[i]-'a'] > 1) {\n                                  valid = false;\n                                  break;\n                              } if (i >= distinct-1) {\n                                  cnt2[s[j]-'a']--;\n                                  j++;\n                              }\n                          }\n                          if (valid) {\n                              cout << \"YES\" << endl;\n                          } else {\n                              cout << \"NO\" << endl;\n                          }\n                      }\n                  }\n\n                This solution only checks for duplicate in any window of length=distinct? It maintains a window of length= distinct, and then checks if any duplicate in that window? But note: the window is of fixed length = distinct. Why is that sufficient? Because if there is a duplicate in a window of length= distinct, then we have two of the same in a window of length= distinct -> which is the size of the distinct set -> so it must be that the distinct set is not covered?",
      "start_char": 89018,
      "end_char": 91509,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "or if it is covered, then one character appears twice and one is missing? But the window of length= distinct might not have all distinct? The window of length= distinct might have duplicate and also might be missing some? However, if there is a duplicate in any window of length<= distinct, then we have a duplicate in a window of length= distinct? because if there is a duplicate in a window of length L < distinct, then we can extend it to length= distinct and the duplicate remains? But extending might remove the duplicate? Example: \"aba\", distinct=2, then we check windows of length=2: \n                  \"ab\": no duplicate. \"ba\": no duplicate.\n                -> not found.",
      "start_char": 91529,
      "end_char": 92336,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Therefore, this known solution would say \"YES\" for \"aba\", but we want \"NO\". So that solution is not correct for \"aba\". Another known solution:\n\n                  #include <bits/stdc++.h>\n                  using namespace std;\n                  int main() {\n                      int test;\n                      cin >> test;\n                      while (test--) {\n                          string s;\n                          cin >> s;\n                          set<char> distinct;\n                          for (char c : s) {\n                              distinct.insert(c);\n                          }\n                          int k = distinct.size();\n                          bool ans = true;\n                          for (int i = 0; i < s.size(); i++) {\n                              set<char> distinct_window;\n                              for (int j = i; j < i+k; j++) {\n                                  if (j >= s.size()) break;\n                                  distinct_window.insert(s[j]);\n                              }\n                              if (distinct_window.size() < k) {\n                                  ans = false;\n                                  break;\n                              }\n                          }\n                          cout << (ans ? \"YES\" : \"NO\") << endl;\n                      }\n                  }\n\n                This solution checks every window of length=k. \n                  It checks that the window of length=k has exactly k distinct characters. For \"aba\", k=2, and the windows of length=2: \n                  \"ab\": distinct_window.size()=2 -> ok.\n                  \"ba\": 2 -> ok.\n                -> \"YES\", but expected \"NO\". So not correct. Another known solution (from a passed submission in C++):\n\n                  #include <bits/stdc++.h>\n                  using namespace std;\n                  int main() {\n                      int test;\n                      cin >> test;\n                      while (test--) {\n                          string s;\n                          cin >> s;\n                          int n = s.size();\n                          vector<int> cnt(256, 0);\n                          for (char c : s) cnt[c]++;\n\n                          sort(cnt.rbegin(), cnt.rend());\n                          int distinct = 0;\n                          for (int i = 0; i < 256; i++) {\n                              if (cnt[i] ) distinct++;\n                              else break;\n                          } if (distinct == 1) {\n                              cout << \"YES\\n\";\n                              continue;\n                          }\n\n                          // Check consecutive duplicates\n                          bool bad = false;\n                          for (int i = 0; i < n-1; i++) {\n                              if (s[i] == s[i+1]) {\n                                  bad = true;\n                                  break;\n                              }\n                          }\n                          if (bad) {\n                              cout << \"NO\\n\";\n                              continue;\n                          }\n\n                          // Check for duplicates in any window of length= distinct\n                          vector<int> last(256, -1);\n                          bool valid = true;\n                          for (int i = 0; i < n; i++) {\n                              if (last[s[i]] ! = -1 && i - last[s[i]] < distinct) {\n                                  valid = false;\n                                  break;\n                              }\n                              last[s[i]] = i;\n                          }\n                          if (valid) {\n                              cout << \"YES\\n\";\n                          } else {\n                              cout << \"NO\\n\";\n                          }\n                      }\n                  } This solution: \n                  - consecutive duplicates -> NO.\n                  - then for each character, if the last occurrence of s[i] is within distinct-1 positions (i - last[s[i]] < distinct), then NO. For \"aba\", distinct=2, \n                  i=0: last['a'] = 0.\n                  i=1: last['b'] = 1.\n                  i=2: last['a'] is 0, and i - last['a'] = 2, which is not < distinct=2 -> so valid.\n\n                -> \"YES\", but expected \"NO\". Therefore, I'll stick to our first solution that caught \"aba\" in the duplicate check for windows of length<=k: In \"aba\", during the duplicate check in windows of length<=k (which is<=2), we have:\n                      left=",
      "start_char": 92354,
      "end_char": 97112,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    }
  ],
  "metadata": {
    "answer": "```json\n{\"program1\": \"                s += ctr[f'{l}{b}']\", \"program2\": \"        r.append('YES' if sum(int(x) for x in i[:3]) == sum(int(x) for x in i[3:]) else 'NO')\"}\n```",
    "note": "the thinking is incomplete"
  },
  "original_reasoning": "<think>\nWe are given multiple test cases. For each test case, a string s.\n We are to determine if s is perfectly balanced.\n\n Observation:\n The problem states that for every non-empty substring t and for every pair of characters u, v that appear in s,\n the absolute difference between the frequency of u and the frequency of v in t is at most 1.\n\n However, note the condition: \"u and v are characters present in s\". So we only consider characters that appear in the entire string s.\n\n Important: The total length of all strings is at most 200,000.\n\n How to approach?\n\n Let's denote the entire string as s. Let the set of distinct characters in s be D.\n\n Condition: For every substring t and for every pair (u,v) in D, we must have |freq(t, u) - freq(t, v)| <= 1.\n\n Consider the following:\n\n 1. If |D| = 1 (only one distinct character), then for any substring t, the frequency of that character is |t| and the others are 0. \n    But note: the condition requires that for every pair (u,v) in D. Since there is only one character, we don't have two distinct ones? \n    Actually, the condition says \"u and v are characters present in s\". If there is only one character, then we only have one pair? \n    Actually, the condition must hold for every non-empty substring and every pair. But if there is only one character, then the only pair is (u,u) and |freq(t,u)-freq(t,u)|=0<=1. So it holds.\n\n 2. If |D| >= 2, then consider the entire string s: \n    Let n = |s|. Then for the entire string, we must have for every two distinct characters u and v: \n        |freq(s, u) - freq(s, v)| <= 1.\n\n    Why? Because the entire string is a substring.\n\n    But note: the condition must hold for every substring. However, the entire string condition is necessary.\n\n    However, the entire string condition is not sufficient. For example, \"abb\" has entire string: \n        freq(a)=1, freq(b)=2 -> |1-2|=1 -> okay for the entire string. \n    But the substring \"bb\" has freq(a)=0, freq(b)=2 -> |0-2|=2 -> not okay.\n\n 3. Therefore, we must check for every substring? That is too expensive.\n\n Alternate Insight:\n\n After reading the note examples, we see that the problem is very constrained.\n\n Observation: \n   In fact, the condition must hold for every contiguous substring. \n\n   Consider the following: \n     The condition must hold for every contiguous substring of length 2? \n        For two adjacent characters: if they are the same, then in the substring of length 2: \n            if we have \"aa\", then for the two a's: \n                if we take u='a' and v='b' (if 'b' is in the entire string), then |2-0|=2 -> which is >1 -> invalid.\n\n        Therefore, if the entire string has at least two distinct characters, then we cannot have two consecutive same characters? \n        Why? Because in the substring of two same characters, say \"aa\", then for any other character v that is in the entire string (which exists because |D|>=2) we have:\n            freq(\"aa\", 'a') = 2, freq(\"aa\", v)=0 -> |2-0|=2>1 -> invalid.\n\n        Similarly, we cannot have two consecutive same characters.\n\n        But wait: what if the entire string has only two distinct characters? Then in a substring \"aa\", we have to consider the pair (a, b) and the difference is 2.\n\n        Therefore, a necessary condition: the string must not contain two consecutive same characters.\n\n        However, is that sufficient? \n\n        Consider \"aba\": \n          distinct characters: {'a','b'} -> entire string: a:2, b:1 -> |2-1|=1 -> okay.\n          substrings: \n            \"a\": a:1, b:0 -> |1-0|=1 -> okay.\n            \"b\": a:0, b:1 -> |0-1|=1 -> okay.\n            \"ab\": a:1, b:1 -> |1-1|=0 -> okay.\n            \"ba\": a:1, b:1 -> okay.\n            \"aba\": a:2, b:1 -> |2-1|=1 -> okay.\n\n        Now consider \"abc\": \n          distinct: {'a','b','c'} -> entire string: each 1 -> okay.\n          substrings of length 1: each has one char and zeros -> difference 1 with any other -> okay.\n          substrings of length 2: \"ab\": a:1, b:1, c:0 -> but we have to check every pair? \n                |a-b|=0, |a-c|=1, |b-c|=1 -> okay.\n          substrings of length 3: \"abc\": each 1 -> okay.\n\n        But what about a substring that is not contiguous in the entire string? Actually, contiguous substring means consecutive in the string.\n\n        However, consider \"aab\" (which has consecutive 'a's) -> we already know it fails because of \"aa\".\n\n        Now, what if we have non consecutive duplicates? \n          Example: \"abac\" -> \n            distinct: {'a','b','c'} -> entire string: a:2, b:1, c:1 -> |2-1|=1 -> okay.\n            But check substring \"aba\": \n                a:2, b:1 -> |2-1|=1 -> okay? \n                but also we have to check a and c: |2-0|=2 -> fails? \n                However, note: the condition says \"u and v are characters present in s\", meaning the entire string. \n                So we must check every pair of distinct characters that appear in the entire string. \n                In the substring \"aba\", the character 'c' does not appear? \n                But the condition says: \"u and v are characters present in s\" (the entire string) -> so we must consider the pair (a,c) even though c is not in the substring? \n\n          Let me read the problem again: \n            \"the difference between the frequencies of u and v in t\" \n            and u and v are characters present in s (the entire string). \n\n          So even if u or v does not appear in the substring t, we still have to consider? \n\n          Example: substring \"aba\" in \"abac\": \n            u='a', v='c': freq(t, 'a')=2, freq(t, 'c')=0 -> |2-0|=2 -> which is >1 -> invalid.\n\n          Therefore, the string \"abac\" is not perfectly balanced.\n\n        How to avoid this? \n\n        We note that if the entire string has k distinct characters, then for every substring t, we must have for every character u in D (the entire distinct set) that \n            |freq(t, u) - freq(t, v)| <= 1 for every v in D.\n\n        This implies that for a fixed substring t, the frequencies of the characters in D must be either:\n          all equal, or one of them is one more than the others? \n\n        But note: the frequencies in t for characters not in t are 0. \n\n        Therefore, if a substring t does not contain a particular character (say c) that is in D, then for any character d that is in t and in D, we must have:\n            freq(t, d) <= 1   (because |freq(t,d) - freq(t,c)| = |freq(t,d) - 0| = freq(t,d) <= 1)\n\n        This implies that the substring t can have at most one occurrence of any character? \n\n        Why? Because if a character d appears twice in t, then for a character c that is in D but not in t, we have |2-0|=2>1.\n\n        Therefore, every substring t must contain either all the distinct characters of the entire string, or if it misses one, then the entire substring must have at most one occurrence of each distinct character that it does contain.\n\n        But note: if the substring t misses more than one character? Then we have to check for every pair? \n\n        Actually, the condition must hold for every pair (u,v) in D. So if we miss a character c, then for any character d that appears in t, we require freq(t,d) <= 1 (because |freq(t,d)-freq(t,c)| = |freq(t,d)-0| <=1). Similarly, for two characters that are both missing, the difference is 0. \n\n        Therefore, the condition for a substring t is:\n          For every character d in D, either:\n            d is in t and then freq(t,d) is either 0 or 1? Actually, no: if we have two characters d and e that are both in t, then |freq(t,d)-freq(t,e)|<=1. \n          But note: if we have two characters d and e that are both in t, then we can have at most one of them having frequency 1 and the other 1? Or one having 2 and the other 1? \n          However, if we have two characters d and e in t and one of them (say d) appears twice, then for a character c that is in D but not in t, we have |freq(t,d)-freq(t,c)| = |2-0|=2 -> invalid.\n\n        Therefore, the only possibility is that the substring t must contain every distinct character of the entire string? \n\n        But wait: what if the entire string has 3 distinct characters, and the substring t has all three? Then we can have frequencies: \n            a:1, b:1, c:1 -> okay.\n            a:2, b:1, c:1 -> then |a-b|=1, |a-c|=1, |b-c|=0 -> okay? \n            However, the condition requires for every pair: |a-b|<=1, |a-c|<=1, |b-c|<=1 -> which holds.\n\n        But then consider: \n            a:2, b:2, c:1 -> |a-c|=1, |b-c|=1, |a-b|=0 -> okay? \n            a:3, b:2, c:1 -> |a-b|=1, |a-c|=2 -> fails.\n\n        Therefore, the frequencies in t must be either all equal or two of them are one more than the others? Actually, the condition is that the maximum frequency and the minimum frequency in t (over the entire distinct set) must differ by at most 1.\n\n        However, note: the frequencies for characters not in t are 0. So if the substring t does not contain a character c that is in D, then the frequency for c is 0. \n        Then the condition requires that for every character d in D: \n            |freq(t,d) - 0| <= 1   -> so freq(t,d) must be 0 or 1.\n\n        But if t does not contain c, then we have at least one character (c) with frequency 0. Then for any character d that is in t, we must have freq(t,d) <= 1. \n\n        Therefore, the substring t must be such that:\n          Either:\n            (a) t contains every distinct character of the entire string, and then the frequencies of the distinct characters in t must satisfy: max_freq - min_freq <= 1.\n            (b) t does not contain at least one distinct character of the entire string, and then every distinct character that appears in t must appear exactly once (so t is composed of distinct characters? and also the length of t must be at most |D|? but note: we are missing at least one, so at most |D|-1?).\n\n        However, condition (b) is very strict: every character in t must appear exactly once? \n\n        But note: if we have two of the same character, then that character would have frequency 2, and then for a missing character c, |2-0|=2 -> fails.\n\n        Therefore, the substring t must be such that:\n          - If t contains all distinct characters of s, then the frequencies of the distinct characters in t must be either floor(|t|/|D|) or ceil(|t|/|D|) and the difference between the max and min is at most 1. \n          - Otherwise, t must have no repeated characters (and hence |t| <= |D|, and actually |t| <= |D|-1 because it misses at least one).\n\n        But note: the entire string s must satisfy the first condition? \n\n        How to check for every substring? The total length of all strings is 200,000, but the worst-case string length might be 200,000 and the number of substrings is O(n^2) -> 20e9 which is too many.\n\n        We need a more efficient way.\n\n        Alternate Insight from known problems: \n          This problem is known? It appeared in a contest and the solution is to check only substrings of length at most |D|+1? \n\n        Why? \n\n        Consider: \n          If we have a substring t that does not contain all distinct characters, then we already require that it has no repeated characters. \n          Therefore, the length of t must be at most |D| (if it contained all, then we are in the other case) but actually if it misses one, then at most |D|-1? \n\n          However, note: we can have a substring that misses more than one? Then the length is at most |D|-2? \n\n          But the condition for missing characters forces that no character can appear more than once. So the length of t must be at most |D| (if it contains all) then we are in the first case? \n\n          Actually, if the substring t has length greater than |D|, then by the pigeonhole principle, at least one character must appear at least twice. \n          Then if there is a character that appears twice, and if there is a character in D that is missing in t, then we have |2-0|=2 -> fails.\n\n          Therefore, any substring t of length > |D| must contain every distinct character? \n\n          But note: it might not. For example, if |D|=3, and we have a substring of length 4: it must contain all distinct characters? \n          Not necessarily: it could be \"aabc\" but then we have two a's and missing d? But wait, the entire distinct set is {a,b,c}. \n          Then if we have a substring of length 4 that does not contain one of the distinct characters? Then we have a problem: \n            if it misses c, then we have two a's -> |2-0|=2 for the pair (a,c) -> fails.\n\n          Therefore, any substring of length > |D| must contain every distinct character? \n\n          Actually, if the substring has length > |D|, then it must contain every distinct character? \n          Why? Because if it misses one, then we have a character that appears at least twice (by pigeonhole: if we have |D|-1 distinct characters and length>|D|, then at least one character appears at least ceil(|D|/(|D|-1))? which for |D|>=2, |D|/(|D|-1) <= 2? but if |D|>=3, then |D|/(|D|-1) < 2? so we cannot guarantee two? \n\n          Actually, we don't need to guarantee two by pigeonhole? We know that if the substring has length L and it has k distinct characters (k < |D|), then the maximum frequency of a character in the substring is at least ceil(L/k). \n          We require that for any character in the entire distinct set that is missing, the frequency of any character that is present must be at most 1. \n          Therefore, we require ceil(L/k) <= 1 -> so L <= k. \n\n          But we are considering L>|D| and k<=|D|-1, so L>|D| and k<=|D|-1 -> then L>k. \n          Therefore, we must have at least one character that appears at least 2. \n\n          Hence, any substring of length > |D| must contain every distinct character? \n\n          Actually, no: we just showed that if it doesn't contain every distinct character (so k<|D|) and if its length is > |D| (which is > k) then we have a character that appears at least twice -> which leads to failure (because of the missing character). \n\n          Therefore, the only substrings that might break the condition are:\n            (a) substrings of length at most |D| (which we can check in O(|D|^2) per distinct set? but note |D| is at most 26 because there are 26 letters) -> so we can check all substrings of length at most 26? \n            (b) substrings of length > |D|: but then they must contain every distinct character? and then we require that the frequencies of the distinct characters in the substring must not differ by more than 1? \n\n          However, note: the condition for a substring of length L>|D|: \n            It must contain every distinct character? (otherwise it fails by the above argument) \n            and then we require: max_freq - min_freq <= 1.\n\n          How to check that for every substring of length L>|D|? \n\n          But note: the total length of all strings is 200,000. However, the worst-case string might be 200,000 and then we would have to check 200,000 - |D| substrings? which is about 200,000 and for each we do |D| (which is 26) -> 200000*26 = 5.2e6 -> acceptable? \n\n          However, the problem says the total length of all test cases is 200,000. So we can do:\n\n          Steps for one test case:\n            Let s be the string, n = len(s)\n            Let D = set(s) -> distinct characters, k = len(D)\n\n            Step 1: Check if k==1 -> then we return \"YES\"\n\n            Step 2: Check for any consecutive duplicate: \n                for i in range(n-1):\n                    if s[i]==s[i+1]:\n                        return \"NO\"\n\n            Why? Because if we have two consecutive same characters, then the substring s[i:i+2] has two of that character and then for any other character in D (which exists because k>=2) that does not appear in that substring, we have |2-0|=2>1 -> fails.\n\n            Step 3: Check all substrings of length from 2 to k: \n                We can do: for length L from 2 to k: \n                    for start index i from 0 to n-L:\n                        substring = s[i:i+L]\n                        distinct_in_sub = set(substring)\n                        if len(distinct_in_sub) < k: \n                            # then we must check: every character in distinct_in_sub must appear exactly once? \n                            # because if any appears twice, then we have a problem (with a missing character) -> but note: the substring has length L, and if there is a duplicate then we have at least one character with frequency>=2 -> then for a missing character (which exists) we have |freq(c) - 0| = freq(c)>=2 -> fails.\n                            # So we can check: if the substring has duplicate? -> then we already fail? \n                            # Actually, we can check: if len(substring) != len(set(substring)) -> then duplicate -> fails.\n\n            But note: we already checked consecutive duplicates? but what about non consecutive duplicates? \n                Example: \"aba\" -> has duplicate? but the two a's are not consecutive. \n                However, in \"aba\": \n                    distinct_in_sub = {'a','b'} -> k=2? \n                    but the entire distinct set D is also {'a','b'}? \n                    Actually, no: the entire distinct set D is the entire string? \n                    In the substring \"aba\", we have both 'a' and 'b' -> so it contains all distinct characters? \n                    Then we don't fall in the case of missing? \n\n            Therefore, we must check: \n                For a substring t of length L (with L<=k): \n                  if the substring does not contain all distinct characters (so distinct_in_sub is a proper subset of D) then we require that the substring has no duplicate? \n                  But note: if the substring has duplicate, then we have a character that appears at least twice -> then for a character missing in the substring (which is in D) we have |freq(t, c) - freq(t, d)| = |0 - (at least 2)| = at least 2 -> fails.\n\n            So for any substring of length <= k, we require that if it does not contain all distinct characters, then it must have no duplicate? \n            But having no duplicate is equivalent to: the length of the substring equals the number of distinct characters in the substring? \n\n            However, note: if the substring has duplicate, then the condition fails. \n\n            Therefore, we can check: \n                for every substring of length L in [2, k] (if k>=2) we check that the substring has no duplicate? \n                But note: if the substring has duplicate, then we break.\n\n            How to check for duplicates in all contiguous substrings of length L? \n                We can use a sliding window and a frequency array? \n                We can do:\n\n                freq = [0]*26\n                dup = 0   # count of duplicates: if we see a character that becomes 2 then dup increases, if we see a character that becomes 1 then dup decreases?\n                Actually, we want to know if there is at least one duplicate? \n\n                We can do for L from 2 to k:\n                    We traverse the string with a window of length L and update the frequency array. \n                    We start with the first L characters, then move the window.\n\n                Steps for fixed L:\n                    freq = [0]*26\n                    dup_count = 0\n                    for i in range(L):\n                        c = s[i]\n                        idx = ord(c)-ord('a')\n                        freq[idx] += 1\n                        if freq[idx] == 2:\n                            dup_count += 1\n                    if dup_count > 0 and len(set(s[0:L])) < k: \n                        # Actually, we don't need to check the distinct set? \n                        # We only care if the substring does not contain all distinct characters? \n                        # But note: if it contains all distinct characters, then we don't require no duplicate? \n                        # However, we are in the case of length L<=k. If the substring has duplicate, then even if it contains all distinct characters? \n                        # But wait: if it contains all distinct characters and has duplicate, then we have k distinct characters and length L (<=k) and duplicate -> then L>=k+1? no, because L<=k. \n                        # Actually, if we have k distinct characters and length L<=k, then if there is a duplicate, then L must be at least k+1? -> impossible. \n                        # Therefore, if the substring has k distinct characters (so it contains all) then the length L must be at least k? and if there is a duplicate then L>=k+1? -> so for L<=k, if we have k distinct characters then there is no duplicate? \n                        # Therefore, we only need to worry about substrings that do not contain all distinct characters? \n\n                    Actually, we can simplify: \n                        For a substring of length L (<=k) that has a duplicate -> then it fails.\n\n                    So we can break as soon as we find a substring of length L (<=k) that has a duplicate.\n\n                Then we move the window: \n                    for i in range(L, n):\n                        # remove s[i-L]\n                        c_out = s[i-L]\n                        idx_out = ord(c_out)-ord('a')\n                        freq[idx_out] -= 1\n                        if freq[idx_out] == 1:\n                            dup_count -= 1\n                        # add s[i]\n                        c_in = s[i]\n                        idx_in = ord(c_in)-ord('a')\n                        freq[idx_in] += 1\n                        if freq[idx_in] == 2:\n                            dup_count += 1\n                        if dup_count > 0:\n                            return \"NO\"\n\n            Step 4: Check substrings of length > k: \n                We require that the substring must contain all distinct characters? \n                And then the frequencies of the distinct characters must satisfy: max_freq - min_freq <= 1.\n\n                How to check? \n                    We can use a sliding window of variable length? But note: we must check every substring of length from k+1 to n? \n                    The total number of such substrings is O(n) per test case? and the total length of all test cases is 200,000 -> but worst-case one test case with 200,000? then the number of substrings of length>=k+1 is about 200,000? and for each we do O(k) to check the min and max? then 200000 * 26 = 5.2e6 -> acceptable.\n\n                However, we can do:\n\n                    We want to check every contiguous substring of length L in [k+1, n]? \n                    But note: we can use a sliding window that expands until we have all distinct characters? \n\n                Alternatively, we can do:\n\n                    We know the window must contain all distinct characters. We can use a two-pointer to find all minimal windows that contain all distinct characters? and then extend? \n\n                Actually, we can do:\n\n                    We know that the condition for a substring t of length L>k: \n                      (a) It must contain all distinct characters? -> so we can use a frequency array and a count of distinct characters in the window.\n                      (b) Then we check: max_freq - min_freq <= 1.\n\n                    How to get min_freq and max_freq? We can maintain the frequency array and then use a segment tree? but k is only 26, so we can compute min and max in O(26) per window.\n\n                Steps for step 4:\n                    We use a sliding window that moves the start and end to cover every minimal window that contains all distinct characters? \n                    But note: we must check every contiguous substring of length>=k+1? \n\n                    Actually, we can iterate with the window that has all distinct characters? and then we extend the window to the right and then move the left? \n\n                    We can do:\n\n                    freq = [0]*26\n                    distinct_count = 0\n                    # We'll use two pointers: left and right, and we want to get every window that has all distinct characters? \n                    # But note: we don't need every window? we only need to check if there is a window that has all distinct characters and max_freq - min_freq > 1.\n\n                    We can do:\n\n                    left = 0\n                    for right in range(n):\n                        # add s[right]\n                        idx = ord(s[right])-ord('a')\n                        freq[idx] += 1\n                        if freq[idx] == 1:\n                            distinct_count += 1\n\n                        # if we have all distinct, then we can try to shrink from the left until we break the condition? \n                        while distinct_count == k and left <= right:\n                            # Check the current window: [left, right]\n                            L = right - left + 1\n                            if L > k:   # we only care about L>k\n                                # get min and max frequency in the window for the distinct set? \n                                # But note: we only care about the distinct set D? and we have all distinct? \n                                min_f = min(freq[i] for i in range(26) if freq[i]>0)\n                                max_f = max(freq[i] for i in range(26) if freq[i]>0)\n                                if max_f - min_f > 1:\n                                    return \"NO\"\n\n                            # Now, we try to shrink the window? \n                            # But note: we must check every window? \n                            # However, we are going to move left and then break the window? \n                            # Actually, we can break the window by removing s[left] and then check the condition? \n                            # But note: we are going to check every window that has all distinct? \n\n                            # Remove s[left]\n                            idx_left = ord(s[left])-ord('a')\n                            freq[idx_left] -= 1\n                            if freq[idx_left] == 0:\n                                distinct_count -= 1\n                            left += 1\n\n                            # After removal, if distinct_count < k, then we break the inner while and move right again.\n\n                    But wait: what if we break the window and then we don't check the window that we just had? \n\n                    Actually, the above while loop shrinks the window until it no longer has all distinct? \n\n                    However, we want to check every window that has all distinct? \n\n                    We can do:\n\n                    We maintain a window that has all distinct? and then we move the left pointer only until the window loses one distinct? \n\n                    Then we check the window [left, right] and then we also check the windows that are larger? \n\n                    Actually, we can do:\n\n                    We use a two-pointer to get the minimal window that has all distinct? and then we extend the window to the right? \n\n                    But note: the condition must hold for every window that has all distinct? \n\n                    We can do:\n\n                    We know that the minimal window (the smallest contiguous substring that contains all distinct) has length at least k. \n                    Then any window that contains the minimal window and extends arbitrarily? \n\n                    However, we can check: \n                      For a fixed minimal window [l, r] (which is the first window that has all distinct and then we shrink from the left until we break), then we can extend to the right arbitrarily? \n\n                    Actually, we can do:\n\n                    We can iterate over the starting index and then for each starting index, we find the minimal window that has all distinct? and then we extend to the entire rest of the string? \n\n                    But that is too expensive.\n\n                Alternatively, we can note:\n\n                  The condition for a window that has all distinct: \n                    max_freq - min_freq <= 1.\n\n                  This condition is equivalent to: the window is \"almost uniform\" in frequency. \n\n                  How many such windows are there? \n\n                However, note: the total length of the string is 200,000 and k is at most 26, so we can do:\n\n                    We iterate over the starting index? -> 200,000 * 26 -> 5.2e6 -> acceptable.\n\n                Steps for step 4 (alternative):\n\n                    We know that the window must contain all distinct characters. \n                    We can precompute the next occurrence of each character? \n\n                    But a simpler method: \n                      For each starting index i, we can expand until we have all distinct? \n                      Then we check the window [i, j] for j from the minimal j that gives all distinct to n-1? \n                      But then we break when we find a violation? \n\n                    However, worst-case: the entire string has no violation? then we do O(n) per starting index? -> O(n^2) -> 200000^2 = 40e9 -> too high.\n\n                We need a more efficient way.\n\n                Insight: \n                  The condition max_freq - min_freq <= 1 is equivalent to: \n                    Let L = j-i+1, then we must have: \n                         min_freq = floor(L/k) and max_freq = ceil(L/k) \n                    and then the total sum of frequencies is L, and we have k distinct.\n\n                    Then we must have: \n                         floor(L/k)*k + r = L, where r is the number of characters that have ceil(L/k) (and r = L mod k) and the rest have floor(L/k). \n                    Then the condition is automatically satisfied? \n\n                  But note: the frequencies are not necessarily assigned arbitrarily? they are determined by the substring.\n\n                  However, we can check: \n                    Let L = j-i+1, then we require:\n                         min_freq = L // k\n                         max_freq = (L+k-1)//k   [which is ceil(L/k)]\n                         and then the total sum: (k - r)*min_freq + r*max_freq = (k - r)*(L//k) + r*((L//k)+1) = k*(L//k) + r = L.\n\n                  So the condition is equivalent to: the frequencies must be either L//k or (L//k)+1, and there are exactly r = L % k characters that have (L//k)+1.\n\n                  Therefore, we can check: \n                    For a window [i, j] that has all distinct characters, we require:\n                         For each character c in D: \n                             freq(c) must be either floor(L/k) or floor(L/k)+1.\n                         And the number of characters with freq(c)=floor(L/k)+1 must be exactly r = L % k.\n\n                  How to check quickly? \n\n                  We can precompute the frequency array for the window? and then we can check in O(k). \n\n                  But we are iterating over O(n) windows? and k=26 -> 26*n -> 200000*26 = 5.2e6 -> acceptable.\n\n                How to iterate over windows? \n\n                  We can use a two-pointer that moves the start and end? and we update the frequency array as we extend the window? \n\n                  We can do:\n\n                    left = 0\n                    freq = [0]*26\n                    # We'll use a variable to track the distinct count? \n                    distinct_count = 0\n                    # We want to consider windows that have all distinct? \n                    # We can move right pointer and then when we have all distinct, we fix the right pointer and then move left until we break? \n\n                    Actually, we can do:\n\n                    for left in range(n):\n                        # We want to find the minimal right such that [left, right] has all distinct? \n                        # But we can use a pointer that we don't reset? \n                        # We can do a two-pointer that moves the right pointer only forward? \n\n                    We do:\n\n                    left = 0\n                    right = -1\n                    freq = [0]*26\n                    distinct_count = 0\n                    # Precompute the distinct set D? \n                    # We know k = len(D)\n\n                    # We'll move right until we have all distinct? \n                    for left in range(n):\n                        # We need to ensure that we have all distinct? \n                        while right < n and distinct_count < k:\n                            right += 1\n                            if right == n: break\n                            c = s[right]\n                            idx = ord(c)-ord('a')\n                            freq[idx] += 1\n                            if freq[idx] == 1:\n                                distinct_count += 1\n\n                        if distinct_count < k: \n                            # then from left to the end we don't have all distinct? and we break because we are going to move left and remove more? \n                            # But we break the inner while and then we break the outer? \n                            # Actually, we break the outer loop? \n                            break\n\n                        # Now [left, right] has all distinct? \n                        L = right - left + 1\n                        if L > k:   # we only care about L>k\n                            # Check the condition: \n                            # Let base = L // k\n                            base = L // k\n                            r = L % k\n                            # We need: \n                            #   Each frequency must be either base or base+1.\n                            #   And the number of characters with frequency base+1 must be r.\n                            count_plus = 0\n                            valid = True\n                            for i in range(26):\n                                if freq[i] > 0:\n                                    if freq[i] != base and freq[i] != base+1:\n                                        valid = False\n                                        break\n                                    if freq[i] == base+1:\n                                        count_plus += 1\n                            if not valid or count_plus != r:\n                                # print(\"Failed at window: [%d, %d]\" % (left, right))\n                                return \"NO\"\n\n                        # Now remove s[left] and update\n                        c_left = s[left]\n                        idx_left = ord(c_left)-ord('a')\n                        freq[idx_left] -= 1\n                        if freq[idx_left] == 0:\n                            distinct_count -= 1\n\n                    Then we break out of the for loop? \n\n                But note: we must check every window that has all distinct? \n                  The above only checks the first window that has all distinct for a given left? \n\n                However, note: for a fixed left, the minimal window that has all distinct is [left, right] (the one we found). \n                But what about windows [left, j] for j>right? \n                  We must check those too? \n\n                How? \n\n                  We can do: for each left, we have the minimal right (call it right0) such that [left, right0] has all distinct. \n                  Then we extend j from right0 to n-1? and check the condition for each window [left, j]? \n\n                Then the inner loop would be O(n) per left -> O(n^2) -> too slow.\n\n                We need to avoid that.\n\n                Alternate Insight: \n                  The condition for a window [left, j] (with j>=right0) is that the frequencies must be either base or base+1, and the number of base+1 must be r = (j-left+1) % k.\n\n                  But note: as we extend j, the base and r change? \n\n                  How? \n                    base = (j-left+1) // k\n                    r = (j-left+1) % k\n\n                  And the frequencies: we are adding one character at a time. \n\n                  We can update the frequency of the added character and then check if it becomes base or base+1? \n\n                  But note: when we extend by one, base might increase? \n\n                  Actually, base = (L) // k, and when L increases by 1, base might increase by 1 if L mod k becomes 0? \n\n                  So we cannot update quickly.\n\n                Therefore, we must check each window? \n\n                But the total number of windows that have all distinct? \n                  The condition that the window has all distinct is automatically satisfied for any window that contains the minimal window? \n                  And the minimal window is at least k, and the total length is n, so the number of windows that have all distinct is O(n) per test case? \n\n                However, worst-case: the entire string has all distinct? then the number of windows that have all distinct is O(n^2) -> too many.\n\n                We must avoid.\n\n                Another Insight: \n                  The condition max_freq - min_freq <= 1 must hold for every window that has all distinct? \n                  But note: if the entire string has all distinct, then we require that the entire string has frequencies that differ by at most 1? \n                  And also every contiguous substring that has all distinct? \n\n                  However, if the entire string satisfies the condition, does every substring that has all distinct satisfy? \n                    Example: \"aabbcc\" (k=3) -> entire string: a:2, b:2, c:2 -> okay.\n                    But consider the substring \"aabbc\": \n                         a:2, b:2, c:1 -> max=2, min=1 -> 2-1=1 -> okay.\n                    How about \"aab\": \n                         a:2, b:1 -> okay.\n\n                  Actually, the condition for a window that has all distinct: \n                    The frequencies are forced by the length: \n                         base = L//k, r = L%k, and then we require that the frequencies are base or base+1 and exactly r of them are base+1.\n\n                  Therefore, we can precompute the entire frequency array for the whole string? and then check the entire string? \n                  But what about a substring? \n\n                  How about: \n                    We know that the entire string must satisfy: \n                         base = n//k, r = n%k, and then the frequency of each character must be either base or base+1, and exactly r characters have base+1.\n\n                  But is that sufficient? \n\n                  Consider: \n                    s = \"aabbcc\" -> n=6, k=3: base=2, r=0 -> then we require 0 characters with base+1? and each must be 2 -> holds.\n\n                  Now consider a substring that has all distinct? \n                    The entire string satisfies, but what about a substring? \n\n                  Example: s = \"abcabc\", k=3: \n                    entire string: each 2 -> holds.\n                    substring \"abcab\": \n                         L=5, base=5//3=1, r=2 -> we require 2 characters with 2 and one with 1? \n                         a:2, b:2, c:1 -> holds.\n\n                  How about \"abca\": \n                         L=4, base=1, r=1 -> we require 1 character with 2 and two with 1? \n                         a:2, b:1, c:1 -> holds.\n\n                  How about \"abc\": \n                         base=1, r=0 -> each 1 -> holds.\n\n                  How about \"ab\": \n                         but \"ab\" does not have all distinct? so we skip.\n\n                  Therefore, it seems that if the entire string satisfies the condition for the entire string and also we have no consecutive duplicates? and also we have no duplicate in any substring of length<=k? then the condition holds for every substring? \n\n                  Why? \n                    For a substring that does not have all distinct: we require no duplicate? -> which we already checked for length<=k? and for length>k we cannot have a duplicate without having all distinct? (because if we have a duplicate and the substring does not have all distinct, then we have a character that appears twice and a missing character -> fails) -> but we already checked that for length<=k? \n\n                    For a substring that has all distinct: we require that the frequencies are either base or base+1 and the count of base+1 is r = L%k? \n\n                  But note: the entire string satisfies the condition? does that imply every substring that has all distinct satisfies? \n\n                  Counterexample? \n                    s = \"aabbcc\" -> entire string: 2,2,2 -> holds.\n                    substring \"aabbc\": \n                         a:2, b:2, c:1 -> base = 5//3=1, r=2 -> we require 2 characters with 2 and one with 1 -> holds.\n\n                  How about we build the string from the entire string that satisfies the condition? \n\n                  Actually, the condition for a substring that has all distinct is automatically satisfied if the entire string is periodic? \n\n                  But we don't know.\n\n                Known solution from similar problems: \n                  We only need to check substrings of length at most k+1? \n\n                Why? \n                  Consider: \n                    If a substring t has length L>k and has all distinct characters, then the minimal window that contains all distinct is of length k? \n                    But our substring t might be larger. \n\n                  However, if the entire string has no consecutive duplicates, then the string is an alternating sequence? \n\n                  In fact, the string is an alternating sequence of the distinct characters? \n\n                  Then the frequencies in any contiguous substring that has all distinct and has length L>k must be: \n                         base = L//k, r = L%k, and then the frequency of each character is either base or base+1? \n\n                  Why? \n                    Because the string is a repetition of the distinct set? \n\n                  Example: distinct set = {'a','b','c'}, then the string is \"abcabcabc...\". \n                  Then in a substring of length L: \n                         each character appears floor(L/3) or ceil(L/3) times? \n\n                  But note: if the substring is contiguous and the string is periodic, then the frequencies are as required.\n\n                  Therefore, if the entire string is a repetition of the distinct set? then the condition holds? \n\n                  How to check if the entire string is a repetition of the distinct set? \n                    We can check the entire string: \n                         The frequency of each character in the entire string must be either n//k or n//k+1? and the count of n//k+1 must be n%k? \n                    And also the consecutive duplicates are already avoided? \n\n                  But note: the distinct set might not be in a fixed order? \n\n                  However, the condition of no consecutive duplicates and the entire string being composed of a fixed set of k characters? \n                    Then the string is a path in a complete graph? \n\n                  Actually, we can check the entire string: \n                    We know the frequency condition for the entire string: \n                         base = n//k, r = n%k, and then the frequency of each character must be either base or base+1, and exactly r characters have base+1.\n\n                  And then we also require that the string has no consecutive duplicates? \n\n                  And then we also require that there is no duplicate in any substring of length<=k? \n                    But if the entire string is a repetition of the distinct set, then in any substring of length<=k, the characters are distinct? \n\n                  Therefore, the conditions we have already are sufficient? \n\n                  Steps for one test case:\n\n                    k = len(set(s))\n\n                    if k==1:\n                        print(\"YES\")\n                        continue\n\n                    # Check consecutive duplicates:\n                    for i in range(len(s)-1):\n                        if s[i]==s[i+1]:\n                            print(\"NO\")\n                            break\n                    else:   # no break\n                        # Check the entire string frequency condition? \n                        from collections import Counter\n                        cnt = Counter(s)\n                        n = len(s)\n                        base = n // k\n                        r = n % k\n                        # The frequency of each character must be either base or base+1.\n                        # And the number of characters with frequency base+1 must be r.\n                        count_plus = 0\n                        valid = True\n                        for char, count_val in cnt.items():\n                            if count_val != base and count_val != base+1:\n                                valid = False\n                                break\n                            if count_val == base+1:\n                                count_plus += 1\n                        if not valid or count_plus != r:\n                            print(\"NO\")\n                        else:\n                            print(\"YES\")\n\n                  But wait: what if the distinct set is not contiguous in the entire string? \n                    Example: \"abcabc\" -> distinct set {'a','b','c'}, n=6, base=2, r=0 -> each must be 2 -> holds.\n\n                  Counterexample: \n                    s = \"abcd\" -> k=4, n=4, base=1, r=0 -> each must be 1 -> holds.\n                    and no consecutive duplicates -> holds -> YES.\n\n                  But what about the substring \"ab\"? \n                    It has distinct set {'a','b'} which is a subset of the entire distinct set? \n                    Then we require that it has no duplicate -> holds.\n\n                  What about the substring \"abc\"? \n                    distinct set {'a','b','c'} -> which is a subset? and we require no duplicate -> holds.\n\n                  What about the entire string? \n                    distinct set {'a','b','c','d'} -> then we require the frequencies: each 1 -> holds.\n\n                  But what about the pair (a,d) in the substring \"ab\"? \n                    freq(a)=1, freq(d)=0 -> |1-0|=1 -> holds.\n\n                  So it passes.\n\n                  However, consider: \n                    s = \"aabc\" -> k=3? distinct set {'a','b','c'}, n=4, base=1, r=1 -> then we require one character with 2 and two with 1? \n                    a:2, b:1, c:1 -> holds.\n\n                  But we have consecutive duplicates? \n                    s[0]='a', s[1]='a' -> consecutive duplicates -> we break and say \"NO\".\n\n                  So we don't get to the frequency check.\n\n                  Now consider: \n                    s = \"abac\" -> \n                      distinct set: {'a','b','c'} -> k=3, n=4, base=1, r=1 -> we require one character with 2 and two with 1? \n                      a:2, b:1, c:1 -> holds.\n                      consecutive duplicates? \n                         'a' then 'b' -> no\n                         'b' then 'a' -> no\n                         'a' then 'c' -> no -> so we would say \"YES\".\n\n                  But wait: the substring \"aba\" (which is contiguous) -> \n                    distinct set of the entire string is {'a','b','c'}, so we must consider the pair (a,c): \n                         freq(a)=2, freq(c)=0 -> |2-0|=2>1 -> fails.\n\n                  Therefore, we must also check that there is no duplicate in any substring of length<=k? \n                    In \"abac\", the substring \"aba\" has length 3 (<=k=3) and has a duplicate (a appears twice) -> so we should have caught it in step 3? \n\n                  How do we check step 3? \n                    We can do: \n                      for L in range(2, k+1): \n                         use a sliding window to check for duplicate in any window of length L? \n\n                  In \"abac\": \n                    L=2: \n                         \"ab\": no duplicate -> okay.\n                         \"ba\": no duplicate -> okay.\n                         \"ac\": no duplicate -> okay.\n                    L=3:\n                         \"aba\": has duplicate? \n                         We can use a frequency array: \n                            freq = [0]*26\n                            for \"aba\": \n                                a:2, b:1 -> so we see a duplicate? \n                         How do we detect duplicate? if any frequency>=2.\n\n                  So we can do:\n\n                    for L in range(2, k+1):\n                        freq = [0]*26\n                        dup = 0\n                        # initialize the first window [0, L-1]\n                        for i in range(L):\n                            c = s[i]\n                            idx = ord(c)-ord('a')\n                            freq[idx] += 1\n                            if freq[idx] == 2:\n                                dup += 1\n                        if dup > 0:\n                            print(\"NO\")\n                            break\n                        for i in range(L, n):\n                            # remove s[i-L]\n                            c_out = s[i-L]\n                            idx_out = ord(c_out)-ord('a')\n                            freq[idx_out] -= 1\n                            if freq[idx_out] == 1:\n                                dup -= 1\n                            # add s[i]\n                            c_in = s[i]\n                            idx_in = ord(c_in)-ord('a')\n                            freq[idx_in] += 1\n                            if freq[idx_in] == 2:\n                                dup += 1\n                            if dup > 0:\n                                print(\"NO\")\n                                break\n                        else:\n                            continue\n                        break\n                    else:\n                        # then we do the entire string frequency condition? \n                        # ... and then print \"YES\"\n\n                  But note: in \"abac\", when L=3, the first window \"aba\" has dup>0 -> we break and say \"NO\".\n\n                  However, we did not say \"NO\" for consecutive duplicates? \n                    \"abac\" has no consecutive duplicates? \n\n                  So we would do step 3 and find a window of length 3 with duplicate -> \"NO\".\n\n                  Therefore, the algorithm for one test case:\n\n                    k = len(set(s))\n\n                    if k==1:\n                        print(\"YES\")\n                        continue\n\n                    # Check consecutive duplicates (adjacent duplicates)\n                    for i in range(len(s)-1):\n                        if s[i]==s[i+1]:\n                            print(\"NO\")\n                            break\n                    else:\n                        # Check for any duplicate in any substring of length in [2, k] (using a sliding window for each length? but note: k is at most 26)\n                        n = len(s)\n                        found = False\n                        # We can do a single sliding window for the maximum length: k? \n                        # But note: we care about any window of length in [2, k] that has a duplicate? \n                        # We can do a sliding window that checks windows of length up to k? \n                        # However, we can do: \n                        #   We want to know: is there any window of length L (2<=L<=k) that has a duplicate? \n                        #   We can do a sliding window that expands to at most k? \n\n                        # We'll do a window that expands from the left until we have length k, then move left? \n                        # But we can do a fixed window of length k? and then slide? \n                        # But we also need to check windows of length < k? \n\n                        # Alternatively, we can do: \n                        #   We know that if there is a duplicate in a window of length L (<=k), then there is a duplicate in a window of length L0 (which is the distance between the duplicate and the next occurrence) which is at most k? \n                        #   But we can simply check the last k+1 characters? \n\n                        # We can do: \n                        #   Use a frequency array for the window [i, i+L-1] and we let L vary? \n\n                        # Instead, we can do a sliding window that expands to at most k? \n                        #   We'll use a fixed window that moves and we maintain the frequency array and a flag for duplicate.\n\n                        # We'll do a window that is at most length k? \n                        #   We can do a two-pointer that expands until we either have a duplicate or the window length becomes k, then we move the left pointer? \n\n                        # But note: we only care if there is at least one duplicate in a window of length<=k? \n\n                        # We can do:\n\n                        freq = [0]*26\n                        left = 0\n                        found_dup = False\n                        for right in range(n):\n                            # add s[right]\n                            idx = ord(s[right])-ord('a')\n                            freq[idx] += 1\n                            if freq[idx] >= 2:\n                                found_dup = True\n                                break\n\n                            # if the window length (right-left+1) == k, then we remove left and move left\n                            if right - left + 1 == k:\n                                # remove s[left]\n                                idx_left = ord(s[left])-ord('a')\n                                freq[idx_left] -= 1\n                                left += 1\n\n                        if found_dup:\n                            print(\"NO\")\n                        else:\n                            # Check the entire string frequency condition? \n                            cnt = Counter(s)\n                            base = n // k\n                            r = n % k\n                            count_plus = 0\n                            valid = True\n                            for char in cnt:\n                                if cnt[char] != base and cnt[char] != base+1:\n                                    valid = False\n                                    break\n                                if cnt[char] == base+1:\n                                    count_plus += 1\n                            if not valid or count_plus != r:\n                                print(\"NO\")\n                            else:\n                                print(\"YES\")\n\n                  But wait: the above two-pointer for duplicate in a window of length<=k? \n                    We start with left=0, and we expand right. \n                    We add s[right]. \n                    If we get a duplicate, we break and say \"NO\". \n                    If the window length becomes k, then we remove the leftmost and move left? \n\n                  Why is that sufficient? \n                    We are essentially maintaining a window of length at most k. \n                    We are checking if there is a duplicate in any window of length at most k? \n\n                  Example: \"abac\": \n                    left=0, right=0: window=\"a\" -> no duplicate.\n                    right=1: window=\"ab\" -> no duplicate.\n                    right=2: window=\"aba\" -> now we add 'a': freq['a'] becomes 2 -> duplicate found -> break and say \"NO\".\n\n                  Therefore, it works.\n\n                  However, note: the window might not be contiguous? \n                    But we are moving left only when the window length becomes k? \n\n                  But what if the duplicate is not in the current window of length k? \n                    Example: \"abcdefga\" -> k=7, then when we add the last 'a', the window is \"bcdefga\", which has length 7 and does not contain the first 'a'. \n                    But then we have not seen a duplicate in any window of length<=7? \n                    However, the entire string has a duplicate? but the window that contains the duplicate is the entire string? which has length 8>7? -> we don't care? \n\n                  But note: the condition for a window of length>k: \n                    We require that it contains all distinct? and then the frequency condition? \n                    But in \"abcdefga\", the entire string has distinct set of size 7, and the entire string has length 8, base=8//7=1, r=1, and then we require one character with 2 and the rest 1? \n                    'a':2, others:1 -> holds.\n\n                  And the consecutive duplicates? \n                    We already checked: no consecutive duplicates.\n\n                  And the window of length<=k: we did not find any duplicate? \n\n                  But wait: the substring \"a\" and then the substring \"a\" at the end? -> but we only care about contiguous substring? \n                    The substring \"abcdefga\" is not of length<=k? \n                    The substring that is \"a\" at the beginning and \"a\" at the end are not in the same window of length<=k? \n\n                  However, the condition requires that for the substring \"a\" (at the beginning) and the substring \"a\" (at the end) separately? \n                    For the substring \"a\" (at the beginning): \n                         distinct set of the entire string is {'a','b','c','d','e','f','g'}, so we must consider the pair (a, b): \n                         freq(a)=1, freq(b)=0 -> |1-0|=1 -> holds.\n                    For the substring \"a\" at the end: similarly holds.\n\n                  And the substring \"abcdefga\" (the entire string) has all distinct? and we checked the frequency condition? -> holds.\n\n                  Therefore, we would say \"YES\" for \"abcdefga\", which is correct.\n\n                  But what about the substring \"ag\" (which is not contiguous? but contiguous substring must be contiguous) -> \"ag\" is not contiguous in the string? \n\n                  The contiguous substring that is the entire string is the only one that contains both a's? \n\n                  Therefore, the algorithm:\n\n                    t = int(input().strip())\n                    for _ in range(t):\n                        s = input().strip()\n                        k = len(set(s))\n                        if k == 1:\n                            print(\"YES\")\n                            continue\n\n                        # Check consecutive duplicates\n                        consecutive_dup = False\n                        for i in range(len(s)-1):\n                            if s[i]==s[i+1]:\n                                print(\"NO\")\n                                consecutive_dup = True\n                                break\n\n                        if consecutive_dup:\n                            continue\n\n                        # Check for any duplicate in a window of length at most k\n                        freq = [0]*26\n                        left = 0\n                        found_dup = False\n                        for right in range(len(s)):\n                            idx_r = ord(s[right]) - ord('a')\n                            freq[idx_r] += 1\n                            if freq[idx_r] > 1:\n                                found_dup = True\n                                break\n\n                            # If the current window length is k, then we remove the leftmost\n                            if right - left + 1 == k:\n                                idx_l = ord(s[left]) - ord('a')\n                                freq[idx_l] -= 1\n                                left += 1\n\n                        if found_dup:\n                            print(\"NO\")\n                            continue\n\n                        # Check the entire string frequency condition\n                        from collections import Counter\n                        cnt = Counter(s)\n                        n = len(s)\n                        base = n // k\n                        r = n % k\n                        count_plus = 0\n                        valid = True\n                        # Note: k is the number of distinct, but what if k does not divide the frequencies? \n                        for char in cnt:\n                            if cnt[char] != base and cnt[char] != base+1:\n                                valid = False\n                                break\n                            if cnt[char] == base+1:\n                                count_plus += 1\n\n                        if not valid or count_plus != r:\n                            print(\"NO\")\n                        else:\n                            print(\"YES\")\n\n                  However, note: the entire string frequency condition: \n                    We require that the frequency of each character is either base or base+1, and the number of characters with base+1 is r = n%k.\n\n                  But what if k does not divide n? then base = n//k, and r = n%k, and then the total sum: \n                    (k - r)*base + r*(base+1) = k*base + r = n.\n\n                  And the frequencies we have sum to n? \n\n                  But note: the entire string has n characters.\n\n                  Therefore, the condition is necessary and sufficient for the entire string to be partitioned as described.\n\n                  However, is it sufficient for the condition of the problem? \n                    We have already ensured:\n                      (1) no consecutive duplicates.\n                      (2) no duplicate in any window of length<=k (which forces that any window that does not contain all distinct has no duplicate? and then the condition holds for such window? because for a character not in the window, the frequency in the window is 0, and for a character in the window, the frequency is 1 -> so the difference is at most 1).\n                      (3) for the entire string, the frequency condition holds? and by the periodic structure (which is forced by the no consecutive duplicates and the entire string frequency condition) we assume that any window that has all distinct has the frequency condition? \n\n                  But note: we did not explicitly check every window that has all distinct? \n                    We only checked the entire string frequency condition? \n\n                  How about a window that has all distinct and is not the entire string? \n                    Example: s = \"abcabc\" -> k=3, n=6, base=2, r=0 -> each character appears 2 times in the entire string.\n\n                    Consider the window \"abcab\": \n                         a:2, b:2, c:1 -> \n                         L=5, base=5//3=1, r=2 -> we require 2 characters with 2 and one with 1? -> holds.\n\n                  How does the entire string frequency condition imply that for every window that has all distinct? \n                    It doesn't directly, but the structure of the string (which is a repetition of the distinct set) might ensure that.\n\n                  But note: we have no consecutive duplicates and the entire string frequency condition? \n                    The string might not be a repetition? \n                    Example: s = \"aabbcc\" (which is not a repetition of \"abc\", but we have consecutive duplicates? -> but we already checked consecutive duplicates and this has consecutive duplicates -> so we would have caught it).\n\n                  In our algorithm, we only get to the entire string frequency condition if there are no consecutive duplicates and no duplicate in any window of length<=k.\n\n                  What is the structure of such a string? \n                    It must be that the string is a repetition of the distinct set? \n                    Why? \n                      Because if there is no duplicate in any window of length k, then the first k characters are distinct. \n                      Then the next character must be the first character of the distinct set? because if it were a different character, then we would have a window of length k+1 that has a duplicate? \n                      But wait: we allow windows of length>k to have duplicates? \n\n                  Actually, the condition we checked for duplicate is only for windows of length<=k? \n\n                  Example: \"abcdab\" -> k=4, \n                    window0: \"abcd\" -> distinct.\n                    then we remove 'a', add next 'a' -> window1: \"bcda\" -> distinct.\n                    then window2: \"cdab\" -> distinct.\n\n                  But we never see a duplicate in a window of length<=k? \n\n                  However, the entire string frequency condition: \n                    n=6, base=1, r=2 -> we require two characters with 2 and two with 1? \n                    a:2, b:2, c:1, d:1 -> holds.\n\n                  And the condition for the entire string? \n                    We require that for every window that has all distinct (which in this case, every window of length 4 has all distinct) -> then we require for a window of length 4: \n                         base=4//4=1, r=0 -> so each character must appear 1 time -> holds.\n\n                  How about a window of length 5? \n                    \"abcda\": \n                         distinct set is {'a','b','c','d'} -> all distinct? \n                         base=5//4=1, r=1 -> we require one character with 2 and the rest 1? \n                         a:2, b:1, c:1, d:1 -> holds.\n\n                  How about a window of length 6? \n                    \"abcdab\": \n                         base=6//4=1, r=2 -> we require two characters with 2 and two with 1? \n                         a:2, b:2, c:1, d:1 -> holds.\n\n                  Therefore, the entire string frequency condition might be sufficient for every window that has all distinct? \n\n                  Why? \n                    The entire string is composed of the distinct set, and the frequency condition for the entire string ensures that the distribution is as uniform as possible. \n                    And then any window that has all distinct will have a frequency distribution that is also as uniform as possible? \n\n                  We might rely on the known solution: \n                    Known solution in C++ for a similar problem (from a contest) is:\n\n                      #include <bits/stdc++.h>\n                      using namespace std;\n                      int main() {\n                          int t;\n                          cin >> t;\n                          while (t--) {\n                              string s;\n                              cin >> s;\n                              vector<int> cnt(26, 0);\n                              for (char c : s) cnt[c - 'a']++;\n                              sort(cnt.rbegin(), cnt.rend());\n                              int mx = cnt[0];\n                              int distinct = 0;\n                              for (int i = 0; i < 26; i++) if (cnt[i]) distinct++;\n                              if (distinct == 1) {\n                                  cout << \"YES\\n\";\n                                  continue;\n                              }\n                              for (int i = 1; i < s.size(); i++) {\n                                  if (s[i] == s[i-1]) {\n                                      mx = 1e9;\n                                  }\n                              }\n                              int total = s.size();\n                              if (mx <= (total + distinct - 1) / distinct) {\n                                  cout << \"YES\\n\";\n                              } else {\n                                  cout << \"NO\\n\";\n                              }\n                          }\n                      }\n\n                  But I'm not sure.\n\n                Given the complexity of the problem and the constraints on the total length (200,000) and the fact that k is at most 26, we can try to run the following for step 4 if we want to be safe:\n\n                  We use a two-pointer to find every minimal window that has all distinct? and then extend it to the right and check every window that has all distinct? \n\n                  But we already have an O(n * k) solution that might be acceptable? \n\n                  However, the worst-case total length of all test cases is 200,000, and k<=26, so 200000*26 = 5.2e6 -> acceptable in Pyton? \n\n                  So we can do:\n\n                    if consecutive_dup is False and found_dup is False:\n                        # then we check every window that has all distinct and has length>k? \n                        # We use a two-pointer to slide and for every window that has all distinct, we check the frequency condition.\n\n                        left = 0\n                        right = -1\n                        freq = [0]*26\n                        distinct_count = 0\n                        n = len(s)\n                        # We'll also maintain the distinct set of the entire string: we know k\n                        for right in range(n):\n                            idx = ord(s[right])-ord('a')\n                            freq[idx] += 1\n                            if freq[idx]==1:\n                                distinct_count += 1\n\n                            while distinct_count == k and left <= right:\n                                L = right - left + 1\n                                if L > k:   # we only care about L>k\n                                    base = L // k\n                                    r = L % k\n                                    # We need to check: \n                                    #   For each character in the distinct set of the entire string, the frequency in the window must be either base or base+1.\n                                    #   And the number of characters with frequency base+1 must be r.\n                                    count_plus = 0\n                                    valid_win = True\n                                    # But note: the window has all distinct? so we only care about the characters that are in the entire distinct set? \n                                    # We can iterate over the entire distinct set? \n                                    # However, we have the frequency array for the window? \n                                    # But note: the frequency array is for the window? \n                                    for i in range(26):\n                                        if freq[i] > 0:\n                                            if freq[i]!=base and freq[i]!=base+1:\n                                                valid_win = False\n                                                break\n                                            if freq[i] == base+1:\n                                                count_plus += 1\n                                        else:\n                                            # This character is in the entire distinct set? \n                                            # We know the entire distinct set? but we don't have it stored per index? \n                                            # We can precompute the entire distinct set? \n                                            # But note: if freq[i]==0, then it might be that this character is not in the entire distinct set? \n                                            # Actually, the entire distinct set is known: we have k, but not the exact letters? \n                                            # We can precompute the set of characters that are in the entire string: \n                                            #   total_chars = set(s)\n                                            # But we are in the loop over test cases, and we did: k = len(set(s))\n                                            #   total_chars = set(s)  -> we can do that at the beginning.\n\n                                            # But wait: the window has distinct_count = k, so it contains all distinct characters of the entire string? \n                                            #   Therefore, if freq[i]==0, then the character corresponding to i is not in the entire distinct set? \n                                            #   So we skip.\n                                            pass\n\n                                    # But note: we only care about the characters that are in the entire distinct set? and the entire distinct set is exactly the set of characters with freq[i]>0 in the window? \n                                    #   because the window has all distinct. \n                                    if not valid_win or count_plus != r:\n                                        print(\"NO\")\n                                        # We break out of everything? \n                                        # We can set a flag and break out of the while and for loops.\n                                        # Let's set a flag\n                                        found_bad = True\n                                        break\n                                # End if L>k\n\n                                # Remove s[left] and update\n                                idx_left = ord(s[left])-ord('a')\n                                freq[idx_left] -= 1\n                                if freq[idx_left]==0:\n                                    distinct_count -= 1\n                                left += 1\n\n                            else:\n                                # We did not have all distinct? \n                                continue\n\n                            # If we broke out of the while loop with found_bad, then break out of the for loop\n                            if found_bad:\n                                break\n\n                        else:\n                            # if we did not break, then all windows are valid.\n                            print(\"YES\")\n\n                  But this is getting very long.\n\n                Given the time, and the known total length of all test cases is 200,000, and the worst-case for one test case is 200,000, and k<=26, and the inner loop is O(26) per window that has all distinct? \n\n                How many windows have all distinct? \n                  In the worst-case, the entire string has all distinct? then the number of windows that have all distinct is n-k+1? \n                  And then we do 26*(n) = 200000*26 = 5.2e6 per test case? \n                But the total length of all test cases is 200,000, so the worst-case is one test case of length 200,000 -> 5.2e6 -> acceptable in Python.\n\n                Therefore, we can do:\n\n                  t = int(input().strip())\n                  for _ in range(t):\n                      s = input().strip()\n                      n = len(s)\n                      distinct_all = set(s)\n                      k = len(distinct_all)\n\n                      if k==1:\n                          print(\"YES\")\n                          continue\n\n                      # Check consecutive duplicates\n                      consecutive_dup = False\n                      for i in range(n-1):\n                          if s[i]==s[i+1]:\n                              print(\"NO\")\n                              consecutive_dup = True\n                              break\n                      if consecutive_dup:\n                          continue\n\n                      # Check for any duplicate in any window of length<=k\n                      freq1 = [0]*26\n                      left = 0\n                      found_dup = False\n                      for right in range(n):\n                          idx_r = ord(s[right])-ord('a')\n                          freq1[idx_r] += 1\n                          if freq1[idx_r] > 1:\n                              found_dup = True\n                              break\n                          if right - left + 1 == k:\n                              idx_l = ord(s[left])-ord('a')\n                              freq1[idx_l] -= 1\n                              left += 1\n                      if found_dup:\n                          print(\"NO\")\n                          continue\n\n                      # Now check every window that has all distinct and has length>k\n                      # We'll use a two-pointer to find all windows that have all distinct.\n                      freq2 = [0]*26\n                      distinct_count = 0\n                      left = 0\n                      valid = True\n                      for right in range(n):\n                          idx = ord(s[right])-ord('a')\n                          freq2[idx] += 1\n                          if freq2[idx] == 1:\n                              distinct_count += 1\n\n                          # Shrink the window from the left until it no longer has all distinct?\n                          while distinct_count == k and left <= right:\n                              L = right - left + 1\n                              if L > k:\n                                  base = L // k\n                                  r = L % k\n                                  count_plus = 0\n                                  # We iterate over the entire distinct_all set? but we have an array for the window, but we only care about the distinct_all set? \n                                  # But note: the window has all distinct_all, so we only care about the 26 letters that are in distinct_all? \n                                  # We can iterate over the 26 letters? \n                                  # But we can also iterate over distinct_all? \n                                  # However, we have the frequency array for the window? \n                                  # But the frequency array is indexed by letter, and we don't have a direct mapping from the set distinct_all to the array? \n                                  # We can do: \n                                  #   for c in distinct_all:\n                                  #       letter = c\n                                  #       idx = ord(c)-ord('a')\n                                  #       count_val = freq2[idx]\n                                  #   but this is O(k) per window, and k<=26, and the number of windows is O(n) -> 26 * (number of windows) -> worst-case 200000*26 = 5.2e6 -> acceptable.\n                                  # But note: the while loop might run for many windows? \n                                  #   The total number of windows that have all distinct is O(n) (amortized by the two pointers) and then 26 per window -> 5.2e6.\n\n                                  for c in distinct_all:\n                                      count_val = freq2[ord(c)-ord('a')]\n                                      if count_val != base and count_val != base+1:\n                                          valid = False\n                                          break\n                                      if count_val == base+1:\n                                          count_plus += 1\n                                  if not valid or count_plus != r:\n                                      valid = False\n                                  if not valid:\n                                      break\n\n                              # Remove s[left] and update\n                              c_left = s[left]\n                              idx_left = ord(c_left)-ord('a')\n                              freq2[idx_left] -= 1\n                              if freq2[idx_left] == 0:\n                                  distinct_count -= 1\n                              left += 1\n\n                              # If we broke due to valid=False, then break the while\n                              if not valid:\n                                  break\n\n                          if not valid:\n                              break\n\n                      if not valid:\n                          print(\"NO\")\n                      else:\n                          print(\"YES\")\n\n                But note: it is possible that we never have a window with all distinct? \n                  For example, if the string is \"abcd\" with k=4, then the entire string is the only window that has all distinct? \n                  and we will check it? \n\n                However, the two-pointer will find it: \n                  right=0: add 'a' -> distinct_count=1\n                  right=1: add 'b' -> distinct_count=2\n                  right=2: add 'c' -> distinct_count=3\n                  right=3: add 'd' -> distinct_count=4 -> then we enter the while.\n\n                  L=4, which is not >k (k=4) -> so we skip the condition? \n\n                We only check windows with length>k. \n\n                But the condition for the window of length=k: \n                  We require that it has no duplicate? -> which we already checked in the previous step (the window of length<=k) -> and we know it has no duplicate? \n                  and it has all distinct? \n                  then for the condition: \n                    For a window of length=k: \n                      base = k//k = 1, r=0 -> then we require each character to appear exactly 1 time -> which it does.\n\n                Therefore, we don't need to check windows of length=k? \n\n                So we are safe.\n\n                However, note: the problem says \"for every substring\", and we have checked:\n                  - For every substring that does not have all distinct: we have ensured that it has no duplicate (by the window<=k check) and then the condition holds.\n                  - For every substring that has all distinct and has length=k: we have ensured no duplicate (so each appears once) -> then for any two characters: \n                         if both are in the substring: |1-1|=0\n                         if one is in and one is out: |1-0|=1 -> holds.\n                  - For every substring that has all distinct and has length>k: we check the frequency condition.\n\n                Therefore, we have checked every substring.\n\n                Let's run the provided examples:\n\n                  Example 1: \"aba\" (which should be \"NO\" because of the substring \"aba\" has a duplicate and length=3<=k=2? -> wait, k=2 for \"aba\"? \n                      distinct set: {'a','b'} -> k=2.\n                      consecutive duplicates: \n                          s[0]='a', s[1]='b' -> no\n                          s[1]='b', s[2]='a' -> no -> so we pass.\n                      Check for duplicate in window of length<=2: \n                          We do a sliding window of at most 2? \n                          right0: 'a' -> freq['a']=1 -> no dup.\n                          right1: 'b' -> no dup, then window length=2 -> remove 'a' -> freq['a']=0, then left=1.\n                          right2: 'a' -> freq['a']=1 (because we removed the first 'a') -> no dup.\n                      Then we move to the two-pointer for windows with all distinct and length>2? \n                          We never have a window with all distinct and length>2? \n                          The entire distinct set is {'a','b'}, and we have windows:\n                              [0,1]: \"ab\" -> distinct_count=2, length=2 (not>2) -> skip.\n                              [1,2]: \"ba\" -> distinct_count=2, length=2 -> skip.\n                          Then we print \"YES\" -> but expected \"NO\".\n\n                Why? \n                  The substring \"aba\" has length=3>k=2, and it has all distinct? \n                  How do we catch it? \n                    In the two-pointer for windows with all distinct and length>k: \n                      We start with left=0, and we add:\n                         right0: 'a' -> distinct_count=1.\n                         right1: 'b' -> distinct_count=2 -> enter the while: \n                             window = \"ab\", length=2 (<=k) -> skip the condition.\n                             then we remove 'a' -> distinct_count becomes 1? because 'a' goes to 0? \n                         right2: 'a' -> distinct_count=2 again? \n                             window = s[1:3] = \"ba\", length=2 -> skip.\n\n                    We never consider the window [0,2]=\"aba\" because after we remove the first 'a', the window [0,2] is not contiguous in our two-pointer? \n\n                How to consider window [0,2]? \n                  Our two-pointer is designed to find the minimal window for a given right? \n                  But we want to consider every window that has all distinct? \n\n                We can modify the two-pointer to not shrink below k? \n                  But the condition: we want to consider every window that has all distinct? \n\n                Alternatively, we can do a different two-pointer: \n                  We want to expand the window until we have all distinct, and then we do not shrink below the minimal window? \n                  But then we would have to check every extension? \n\n                Given the time, and the fact that the total length is 200,000 and k is small, we can do a separate check for every window that has all distinct by a different method? \n\n                How about: \n                  We iterate over every starting index left, and then we find the minimal right such that [left, right] has all distinct? \n                  Then we extend the window to the end, and for each extension, we check the condition? \n                  But that is O(n^2).\n\n                Alternatively, we can use the two-pointer that moves the right pointer and then for each left, we remember the last time we had all distinct? \n\n                We can do:\n\n                  left = 0\n                  right = 0\n                  freq = [0]*26\n                  distinct_count = 0\n                  for right in range(n):\n                      # add s[right]\n                      # update distinct_count\n                      # while we have all distinct, we can check the condition for the current window and then we do not remove? \n                      # but we want to check every window that has all distinct? \n                      # so for the current right, we find the minimal left such that [left, right] has all distinct? \n                      # then we know that [left, right] has all distinct, and we check it.\n                      # then we do not remove, because we want to extend to the right? \n\n                  This is not the typical two-pointer.\n\n                Known efficient method: \n                  We can use a pointer that for each right, we find the minimal left such that [left, right] has all distinct? \n                  and then we know that for this right, the windows [left, right], [left+1, right], ... , [right, right] might not have all distinct? \n                  but we only care about the windows that have all distinct? \n\n                  We can do:\n\n                    last_occurrence = {}\n                    left = 0\n                    for right in range(n):\n                        c = s[right]\n                        # update last_occurrence of c to right\n                        # and then the minimal left is max(left, last_occurrence of any char? ) -> no.\n\n                  This is complex.\n\n                Given the complexity, and the fact that the string length is not huge (200,000) and the distinct set is small (<=26), we can simply precompute the next occurrence for each character? \n\n                But note: the total length of all test cases is 200,000, so we can try to do an O(26*n) solution? \n\n                How about for each starting index left, we go right until we have collected all distinct? \n                  then we check the condition for the window [left, right] and then for [left, right+1], [left, right+2], ... until the end? \n                  and then we break when we find a violation? \n\n                But worst-case: O(n^2) -> 200000^2 = 40e9 -> too high.\n\n                Therefore, we must use the two-pointer that moves the left pointer for a fixed right only to the last minimal window? \n\n                We can do as in the first two-pointer for the minimal window, but then for a fixed right, after we have the minimal left (say L0), then the window [L0, right] has all distinct, and then we extend to [L0-1, right] if available? \n\n                But that is not contiguous.\n\n                Alternatively, we can do: \n                  Use a two-pointer to find the minimal window (the smallest window ending at right that has all distinct) for each right? \n                  then the condition must hold for that minimal window? \n                  and also for any window that contains it? \n\n                But note: the condition for a window that has all distinct and is larger than the minimal window might be automatically satisfied if the minimal window satisfies? \n                  -> not necessarily.\n\n                Given the time constraints, and since the intended solution might be simpler, let me look for known solutions online.\n\n                Known solution in C++ (from a contest):\n\n                  #include <bits/stdc++.h>\n                  using namespace std;\n                  int main() {\n                      int test;\n                      cin >> test;\n                      while (test--) {\n                          string s;\n                          cin >> s;\n                          vector<int> cnt(26, 0);\n                          for (auto &c : s) {\n                              cnt[c - 'a']++;\n                          }\n                          int distinct = 0;\n                          for (int i = 0; i < 26; i++) {\n                              if (cnt[i] > 0) {\n                                  distinct++;\n                              }\n                          }\n                          if (distinct == 1) {\n                              cout << \"YES\" << endl;\n                              continue;\n                          }\n                          vector<int> cnt2(26, 0);\n                          int j = 0;\n                          bool valid = true;\n                          for (int i = 0; i < s.size(); i++) {\n                              cnt2[s[i]-'a']++;\n                              if (cnt2[s[i]-'a'] > 1) {\n                                  valid = false;\n                                  break;\n                              }\n                              if (i >= distinct-1) {\n                                  cnt2[s[j]-'a']--;\n                                  j++;\n                              }\n                          }\n                          if (valid) {\n                              cout << \"YES\" << endl;\n                          } else {\n                              cout << \"NO\" << endl;\n                          }\n                      }\n                  }\n\n                This solution only checks for duplicate in any window of length=distinct? \n                  It maintains a window of length= distinct, and then checks if any duplicate in that window? \n\n                But note: the window is of fixed length = distinct. \n\n                Why is that sufficient? \n                  Because if there is a duplicate in a window of length= distinct, then we have two of the same in a window of length= distinct -> which is the size of the distinct set -> so it must be that the distinct set is not covered? \n                  or if it is covered, then one character appears twice and one is missing? \n\n                But the window of length= distinct might not have all distinct? \n                  The window of length= distinct might have duplicate and also might be missing some? \n\n                However, if there is a duplicate in any window of length<= distinct, then we have a duplicate in a window of length= distinct? \n                  because if there is a duplicate in a window of length L < distinct, then we can extend it to length= distinct and the duplicate remains? \n\n                But extending might remove the duplicate? \n\n                Example: \"aba\", distinct=2, then we check windows of length=2: \n                  \"ab\": no duplicate.\n                  \"ba\": no duplicate.\n                -> not found.\n\n                Therefore, this known solution would say \"YES\" for \"aba\", but we want \"NO\".\n\n                So that solution is not correct for \"aba\".\n\n                Another known solution:\n\n                  #include <bits/stdc++.h>\n                  using namespace std;\n                  int main() {\n                      int test;\n                      cin >> test;\n                      while (test--) {\n                          string s;\n                          cin >> s;\n                          set<char> distinct;\n                          for (char c : s) {\n                              distinct.insert(c);\n                          }\n                          int k = distinct.size();\n                          bool ans = true;\n                          for (int i = 0; i < s.size(); i++) {\n                              set<char> distinct_window;\n                              for (int j = i; j < i+k; j++) {\n                                  if (j >= s.size()) break;\n                                  distinct_window.insert(s[j]);\n                              }\n                              if (distinct_window.size() < k) {\n                                  ans = false;\n                                  break;\n                              }\n                          }\n                          cout << (ans ? \"YES\" : \"NO\") << endl;\n                      }\n                  }\n\n                This solution checks every window of length=k. \n                  It checks that the window of length=k has exactly k distinct characters.\n\n                For \"aba\", k=2, and the windows of length=2: \n                  \"ab\": distinct_window.size()=2 -> ok.\n                  \"ba\": 2 -> ok.\n                -> \"YES\", but expected \"NO\".\n\n                So not correct.\n\n                Another known solution (from a passed submission in C++):\n\n                  #include <bits/stdc++.h>\n                  using namespace std;\n                  int main() {\n                      int test;\n                      cin >> test;\n                      while (test--) {\n                          string s;\n                          cin >> s;\n                          int n = s.size();\n                          vector<int> cnt(256, 0);\n                          for (char c : s) cnt[c]++;\n\n                          sort(cnt.rbegin(), cnt.rend());\n                          int distinct = 0;\n                          for (int i = 0; i < 256; i++) {\n                              if (cnt[i]) distinct++;\n                              else break;\n                          }\n\n                          if (distinct == 1) {\n                              cout << \"YES\\n\";\n                              continue;\n                          }\n\n                          // Check consecutive duplicates\n                          bool bad = false;\n                          for (int i = 0; i < n-1; i++) {\n                              if (s[i] == s[i+1]) {\n                                  bad = true;\n                                  break;\n                              }\n                          }\n                          if (bad) {\n                              cout << \"NO\\n\";\n                              continue;\n                          }\n\n                          // Check for duplicates in any window of length= distinct\n                          vector<int> last(256, -1);\n                          bool valid = true;\n                          for (int i = 0; i < n; i++) {\n                              if (last[s[i]] != -1 && i - last[s[i]] < distinct) {\n                                  valid = false;\n                                  break;\n                              }\n                              last[s[i]] = i;\n                          }\n                          if (valid) {\n                              cout << \"YES\\n\";\n                          } else {\n                              cout << \"NO\\n\";\n                          }\n                      }\n                  }\n\n                This solution: \n                  - consecutive duplicates -> NO.\n                  - then for each character, if the last occurrence of s[i] is within distinct-1 positions (i - last[s[i]] < distinct), then NO.\n\n                For \"aba\", distinct=2, \n                  i=0: last['a'] = 0.\n                  i=1: last['b'] = 1.\n                  i=2: last['a'] is 0, and i - last['a'] = 2, which is not < distinct=2 -> so valid.\n\n                -> \"YES\", but expected \"NO\".\n\n                Therefore, I'll stick to our first solution that caught \"aba\" in the duplicate check for windows of length<=k: \n                  In \"aba\", during the duplicate check in windows of length<=k (which is<=2), we have:\n                      left="
}