{
  "segments": [
    {
      "text": "<think>\n We are given multiple test cases.",
      "start_char": 0,
      "end_char": 42,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "For each test case:\n   t: number of test cases\n   for each test case: \n        n: number of vertices\n        list of n-1 integers: the parent of vertex 2, vertex 3, ... vertex n.\n\n We are to compute the minimal number of seconds to infect the whole tree.",
      "start_char": 43,
      "end_char": 297,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Steps in the provided code:\n   1. We read t.\n   2.",
      "start_char": 300,
      "end_char": 350,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "For each test case:\n        - read n\n        - read the list of parents (for vertices 2 to n)\n   3.",
      "start_char": 351,
      "end_char": 450,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "We create a dictionary `counts` to count the number of children for each node (including the root? note: root is 1, and we have counts[0]=1 initially? Actually, we set counts[0]=1, but then we process the parents. Let me explain:\n\n Actually, the code does:\n        counts = defaultdict(int) counts[0] = 1   # This is for the root? But note: the root is vertex 1, and we are going to count the children of each node.",
      "start_char": 451,
      "end_char": 874,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "However, the input gives the parent of vertex i (for i from 2 to n). So we can build the children count. But note: the root (vertex 1) is not in the list of parents?",
      "start_char": 877,
      "end_char": 1042,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Actually, the list of parents has n-1 numbers: for vertex 2,3,...,n. The code then does:\n        for i in parents:\n            counts[i] += 1\n\n This counts the direct children of each node. But note: the root (1) will be included because the parent of vertex 2 might be 1. However, we set counts[0]=1. Why?",
      "start_char": 1045,
      "end_char": 1355,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Actually, the root has no parent. But we are counting the children.",
      "start_char": 1356,
      "end_char": 1423,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The root (vertex 1) is not represented by 0?",
      "start_char": 1424,
      "end_char": 1468,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Let me check: the input says the parent of vertex",
      "start_char": 1472,
      "end_char": 1521,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "i (for i from 2 to n) is given.",
      "start_char": 1522,
      "end_char": 1553,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The parent is an integer between 1 and n. So we never have 0? Therefore, the initial counts[0]=1 is unnecessary?",
      "start_char": 1554,
      "end_char": 1669,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Actually, we are going to use `lives` as the list of counts for each node that has at least one child? But note: the root (1) is included because when we see a parent 1, we increment counts[1].",
      "start_char": 1670,
      "end_char": 1863,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "However, the root might not be in the list?",
      "start_char": 1867,
      "end_char": 1910,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "Actually, if the root has children, then we will have counts[1] at least 1? But note: the root is the parent of some nodes. So we will have counts[1] at least 1? The problem: the initial counts[0]=1 is a mistake?",
      "start_char": 1911,
      "end_char": 2129,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "Because we are going to build the list `lives` from the counts dictionary. And we have an entry for 0?",
      "start_char": 2130,
      "end_char": 2232,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Actually, the root is vertex 1, so we should not have an entry for 0. Let me fix: remove the initial counts[0]=1? But note: the root might be the only node? But n>=2.",
      "start_char": 2236,
      "end_char": 2405,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "However, the problem says: the tree has n vertices and the root is 1. The input has n-1 numbers. So we have at least one edge.",
      "start_char": 2409,
      "end_char": 2535,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "How about we build the children count without the initial 0? But the code has: \n        counts = defaultdict(int) counts[0] = 1   # This is probably a mistake. Then we do:\n        for i in parents:   # parents is the list of n-1 integers\n            counts[i] += 1\n\n Then we are including the root? For example, if the root (1) has two children, then we will have counts[1] = 2. But then we also have counts[0]=1. That is an extra node?",
      "start_char": 2538,
      "end_char": 2989,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Actually, the root is vertex 1, so we don't have a node 0.",
      "start_char": 2993,
      "end_char": 3051,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Therefore, we should not have counts[0] at all. Why did they set counts[0]=1?",
      "start_char": 3052,
      "end_char": 3131,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "Let me think: the root has no parent, but we are counting the children.",
      "start_char": 3135,
      "end_char": 3206,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The root is a node that has children. So we don't need to count 0.",
      "start_char": 3207,
      "end_char": 3273,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Actually, the problem: the root is infected at time 0? But note the process: initially all are healthy. Then we start at second 0?",
      "start_char": 3277,
      "end_char": 3407,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "However, the problem says: \"each second\" we do two operations. How do we start?",
      "start_char": 3411,
      "end_char": 3490,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "We can do an injection at the root? But note: the root is vertex 1. The initial counts[0]=1 might be an attempt to account for the root?",
      "start_char": 3494,
      "end_char": 3636,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Alternatively, note that the root is the only node that has no parent. But we are building the children counts.",
      "start_char": 3640,
      "end_char": 3751,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The root will be represented by the key 1. So I think the initial counts[0]=1 is a mistake. We should remove it. However, the problem says: the total n over test cases <= 200000.",
      "start_char": 3752,
      "end_char": 3935,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "We are going to build a list `lives` from the counts dictionary.",
      "start_char": 3936,
      "end_char": 4000,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "The keys in counts are the nodes that have at least one child?",
      "start_char": 4001,
      "end_char": 4063,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Actually, we are counting the children for every node that appears as a parent. But note: a leaf node does not appear as a parent? So we only have non-leaf nodes.",
      "start_char": 4064,
      "end_char": 4226,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The root is included because it is the parent of some nodes. So we should do:\n\n        counts = defaultdict(int)\n        for i in parents:\n            counts[i] += 1\n\n        #",
      "start_char": 4233,
      "end_char": 4411,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Now, the root (1) is included?",
      "start_char": 4412,
      "end_char": 4442,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Yes, if the root has children. # But what about the root itself? The root is a node. We have n nodes.",
      "start_char": 4443,
      "end_char": 4544,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "The root has no parent, but we are counting the children of the root.\n\n        #",
      "start_char": 4554,
      "end_char": 4634,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "However, the root is not counted as a child of any node? So we don't have a parent for the root. #",
      "start_char": 4635,
      "end_char": 4733,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The problem: the root must be infected.",
      "start_char": 4744,
      "end_char": 4783,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "How do we account for the root? #",
      "start_char": 4784,
      "end_char": 4817,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Actually, the root is a node that we can inject? # The provided code then does:\n        lives = [counts[i] for i in counts]   #",
      "start_char": 4828,
      "end_char": 4965,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "This gives the list of the counts (number of children) for each node that has children.\n\n        # But note: the root is included?",
      "start_char": 4966,
      "end_char": 5096,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Yes, if the root has children. #",
      "start_char": 5097,
      "end_char": 5129,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "However, the root itself is not represented in the counts?",
      "start_char": 5139,
      "end_char": 5197,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The counts only count the children.",
      "start_char": 5198,
      "end_char": 5233,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The root is a node that has children, but the root itself is not a child? \n\n        #",
      "start_char": 5234,
      "end_char": 5319,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The infection process:\n\n        # We start with no infected nodes.",
      "start_char": 5320,
      "end_char": 5386,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "# Second 1: we can inject the root? Then the root becomes infected. # Then the spreading: the root has children. We can spread to one child? # But note: the spreading operation: for each vertex v, if at least one child of v is infected -> then we can spread to at most one other child.",
      "start_char": 5396,
      "end_char": 5700,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "However, at second 1, the root is infected (by injection) but none of its children are infected? \n\n        #",
      "start_char": 5701,
      "end_char": 5809,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "Actually, the spreading operation happens after the injection? #",
      "start_char": 5810,
      "end_char": 5874,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The problem: \n        #   Each second: \n        #      Spreading: for each vertex v, if at least one child of v is infected, then we can choose at most one other child to infect (by spreading). #",
      "start_char": 5885,
      "end_char": 6080,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Then, injection: we can choose any healthy vertex to infect.\n\n        # So at second 1:\n        #   Initially, no infected.",
      "start_char": 6094,
      "end_char": 6217,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "#   Spreading: nothing because no child is infected? \n        # Then injection: we inject the root. # Then at second 2:\n        #   Spreading: the root has one infected child?",
      "start_char": 6226,
      "end_char": 6401,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Actually, the root is infected, but the children are not. However, the condition is \"if at least one child of v is infected\" -> but the root's children are not infected. So no spreading.\n        # Then injection: we inject one child of the root. # Then at second 3:\n        #   Spreading: the root has one infected child (the one we injected at second 2). So we can spread to one more child? # Then we spread to one more child of the root.",
      "start_char": 6413,
      "end_char": 6852,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "#   Then injection: we inject another node. # But note: the root has, say, k children.",
      "start_char": 6883,
      "end_char": 6969,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "We can only spread one per second? \n\n        #",
      "start_char": 6979,
      "end_char": 7025,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "However, the problem says: for each vertex v, if at least one child of v is infected, we can spread to at most one other child. So we can do one spread for the root. # How do we model?\n\n        #",
      "start_char": 7026,
      "end_char": 7221,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternate approach from known solutions:\n\n        #",
      "start_char": 7231,
      "end_char": 7282,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "We note that the infection spreads from the root?",
      "start_char": 7283,
      "end_char": 7332,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Actually, we can start anywhere? But the problem allows injection of any healthy vertex.",
      "start_char": 7333,
      "end_char": 7421,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "# Known solution for this problem (from similar problems) is:\n\n        #   We build the children count for each node (the degree of the node in the tree?",
      "start_char": 7431,
      "end_char": 7584,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Actually, the number of children? But note: the root has the number of children, and other nodes have the number of children (which is degree-1, except the root which is degree = children count)). #",
      "start_char": 7585,
      "end_char": 7783,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "However, note: the problem does not require the tree to be binary.",
      "start_char": 7793,
      "end_char": 7859,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "# Steps in known solutions:\n\n        #   Let f(v) be the maximum time needed to infect the entire subtree rooted at v? \n\n        # But note: the problem is about the entire tree and we can choose the order of injections arbitrarily? \n\n        #",
      "start_char": 7869,
      "end_char": 8113,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Actually, we are allowed to choose which vertex to inject and which to spread at each step arbitrarily? # Known solution (from code in other languages) for this problem:\n\n        #   We can do:\n\n        #       Let deg[i] = number of children of i (for i from 1 to n).",
      "start_char": 8114,
      "end_char": 8392,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "For the root, we note that we have to start by infecting the root? #",
      "start_char": 8393,
      "end_char": 8461,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Actually, we can start by injecting any node. But the root is the one without a parent? #",
      "start_char": 8474,
      "end_char": 8563,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "However, the problem does not require starting at the root? But note: the spreading condition: we can only spread from a node that has at least one child infected. So if we start at a leaf, then we cannot spread? #",
      "start_char": 8576,
      "end_char": 8790,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Therefore, we must start at the root? Or we can start anywhere? #",
      "start_char": 8803,
      "end_char": 8868,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Actually, we can start anywhere by injection. Then we can spread from that node to its siblings? But note: the spreading condition: for a parent, if at least one child is infected, then we can spread to another child. So if we start at a leaf, then the parent of that leaf will have one infected child, so we can spread to a sibling? #",
      "start_char": 8881,
      "end_char": 9216,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "However, the problem is symmetric? # But note: the problem says Alice eats from the left and Bob from the right?",
      "start_char": 9229,
      "end_char": 9341,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "Actually, that was a different problem.",
      "start_char": 9354,
      "end_char": 9393,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "This problem is about a tree and infection. #",
      "start_char": 9394,
      "end_char": 9439,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Actually, the problem statement is independent.\n\n        #   Known solution:",
      "start_char": 9451,
      "end_char": 9527,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "#       We build an array `children` of length (n+1) for the number of children.",
      "start_char": 9537,
      "end_char": 9617,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "For the root, we set children[1] = (the number of children of 1). For other nodes, we set children[i] = (number of children of i) - 1?",
      "start_char": 9618,
      "end_char": 9752,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Or just the number of children? #",
      "start_char": 9753,
      "end_char": 9786,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "Actually, we can note:\n\n        #",
      "start_char": 9803,
      "end_char": 9836,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "We are going to simulate the infection as:\n\n        #",
      "start_char": 9845,
      "end_char": 9898,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Initially, we have 0 seconds and no infected. #",
      "start_char": 9909,
      "end_char": 9956,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "We start by injecting the root? Then the root is infected at time 1.\n\n        #           Then, for each child of the root, we can either spread or inject? #",
      "start_char": 9976,
      "end_char": 10133,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "The idea: we can represent the state by the number of nodes that are \"active\".",
      "start_char": 10150,
      "end_char": 10228,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "An active node is a node that is infected and has at least one child that is not infected? #",
      "start_char": 10229,
      "end_char": 10321,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Actually, we can use a greedy strategy:\n\n        #",
      "start_char": 10338,
      "end_char": 10388,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "We note that the infection spreads along the tree.",
      "start_char": 10397,
      "end_char": 10447,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "We can use a BFS? \n\n        #   Alternatively, we can use a known solution from Codeforces problems (like \"C. Tree Infection\"):\n\n        #       Steps:",
      "start_char": 10448,
      "end_char": 10599,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "#         Count the number of children for each node (the root is included).",
      "start_char": 10609,
      "end_char": 10685,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Then, we have a list of counts for each node that has at least one child? #",
      "start_char": 10686,
      "end_char": 10761,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Then, we do:\n\n        #             Let `a` be the list of the counts (the number of children) for each node that has at least one child.",
      "start_char": 10780,
      "end_char": 10917,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Also, we must account for the root? #",
      "start_char": 10918,
      "end_char": 10955,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "Actually, the root is a node that we start? #",
      "start_char": 10974,
      "end_char": 11019,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "We note that we can inject the root at time 1.",
      "start_char": 11038,
      "end_char": 11084,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Then, the root becomes infected.",
      "start_char": 11085,
      "end_char": 11117,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Then, for each second, we can spread to one child of the root? But we can also inject other nodes? #",
      "start_char": 11118,
      "end_char": 11218,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "The problem: we have two operations per second: spreading and injection. #",
      "start_char": 11237,
      "end_char": 11311,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "We can model:\n\n        #           Let `t` be the current time (in seconds). We start at time 0? #",
      "start_char": 11329,
      "end_char": 11427,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Actually, the problem says: each second we do spreading then injection. # We can think: \n\n        #",
      "start_char": 11446,
      "end_char": 11545,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "At time 0: nothing.\n\n        #           Time 1: \n        #               Spreading: nothing (no infected node has an infected child? actually, no infected node? so skip)\n        #               Injection: we inject the root -> infected set = {1}\n\n        #           Time 2:",
      "start_char": 11573,
      "end_char": 11848,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "#               Spreading: the root (1) has no infected child? (because the children are not infected) -> so no spreading.",
      "start_char": 11857,
      "end_char": 11979,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "#               Injection: we inject one child of the root. #           Time 3:\n        #               Spreading: the root has one infected child -> we can spread to one more child of the root? # Then we spread to one more child of the root -> now the root has two infected children.",
      "start_char": 11988,
      "end_char": 12304,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "#               Injection: we inject another node (could be a child of the root?",
      "start_char": 12313,
      "end_char": 12393,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "or a node in a different branch?). #         How to minimize the time?\n\n        #         Known solution (from a known problem \"Tree Infection\" on Codeforces) is:\n\n        #             Step 1: Count the frequency of each parent -> that gives the number of children for each node.",
      "start_char": 12394,
      "end_char": 12683,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "#             Step 2: We form a list `a` of the children counts for each node that has at least one child.",
      "start_char": 12693,
      "end_char": 12799,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Then, we also note that we have to account for the root?",
      "start_char": 12800,
      "end_char": 12856,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Actually, the root is included.",
      "start_char": 12857,
      "end_char": 12888,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "#             Step 3: We sort the list `a` in descending order. #             Step 4: We then do:\n\n        #                 ans = 0\n        #                 # First, we inject the root?",
      "start_char": 12898,
      "end_char": 13094,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Actually, we have to inject every node that has children?",
      "start_char": 13095,
      "end_char": 13152,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Not exactly.\n\n        #                 #",
      "start_char": 13153,
      "end_char": 13194,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "We note that we can inject a node to start the infection in a branch. Then the spreading will take care of the siblings. #                 #",
      "start_char": 13195,
      "end_char": 13335,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "The idea: we start by injecting all the nodes that have children? But we are limited by the injection per second. #                 #",
      "start_char": 13345,
      "end_char": 13478,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Actually, we can do:\n\n        #                 #   Let `ans` be the current time (starting at 0).",
      "start_char": 13488,
      "end_char": 13586,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "We have a list `a` of the number of children for each node that has children. #                 #",
      "start_char": 13587,
      "end_char": 13684,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "We first inject each of these nodes? But we can only inject one per second? \n\n        #                 #   Actually, we can inject one node per second (in the injection step). \n\n        #                 #",
      "start_char": 13696,
      "end_char": 13902,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "However, we must also account for the spreading. #                 # Known solution (from a known AC code):\n\n        #                 #   t = int(input())\n        #                 #   for _ in range(t):\n        #                 #       n = int(input())\n        #                 #       p = list(map(int, input().split()))\n        #                 #       cnt = [0] * (n+1)\n        #                 #       for x in p:\n        #                 #           cnt[x] += 1\n        #                 #       a = []\n        #                 #       for i in range(1, n+1):\n        #                 #           if cnt[i] > 0:\n        #                 #               a.append(cnt[i])\n        #                 #       a.sort(reverse=True)\n        #                 #       # We also note that the root must be infected?",
      "start_char": 13905,
      "end_char": 14734,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "and the root is included in the list? #                 #       # Then we do:\n        #                 #       k = len(a)\n        #                 #       #",
      "start_char": 14735,
      "end_char": 14902,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "We start by infecting all the nodes in the list `a` (the nodes that have children) by injection? #                 #       # But note: the root is one of them.",
      "start_char": 14903,
      "end_char": 15062,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "We start at time 0? \n        #                 #       # We set the initial time to k (because we inject each of these k nodes one per second) -> so we need k seconds to inject them? #                 #       # However, we can also spread? #                 #       # Then we do:\n        #                 #       ans = k   # because we inject k nodes (the ones that have children) in k seconds? #                 #       # But then the children of these nodes? \n\n        #                 #       # Then we consider the children.",
      "start_char": 15072,
      "end_char": 15621,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "For a node with x children, after we inject the node, we can spread to the children? #                 #       #",
      "start_char": 15631,
      "end_char": 15743,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Actually, the infection of the children: \n        #                 #       #   For a node with x children, we have x children to infect. #                 #       # We can spread one per second? But note: we can also use injection on the children? \n\n        #                 #       #",
      "start_char": 15754,
      "end_char": 16040,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "However, the problem: we can only inject one node per second.",
      "start_char": 16052,
      "end_char": 16113,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "And we have already used k seconds to inject the k parent nodes. #                 #       # Then we have to infect the children.",
      "start_char": 16114,
      "end_char": 16243,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "For a node i, we have a[i] children.",
      "start_char": 16253,
      "end_char": 16289,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "We have already infected the node i (the parent) at time t_i. Then the spreading for the children of i: \n        #                 #       #   At time t_i+1: we can spread to one child? #                 #       #",
      "start_char": 16290,
      "end_char": 16503,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "At time t_i+2: we can spread to another?",
      "start_char": 16515,
      "end_char": 16555,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "#                 #       #   ...",
      "start_char": 16565,
      "end_char": 16598,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "until all children are infected.\n\n        #                 #       # But note: we can also inject a child?",
      "start_char": 16599,
      "end_char": 16706,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "However, we are not forced to.",
      "start_char": 16707,
      "end_char": 16737,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "We can use spreading to infect the children without injection? \n\n        #                 #       #",
      "start_char": 16738,
      "end_char": 16838,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "However, we can do both: we can use injection to infect a child and then use spreading to infect another? #                 #       #",
      "start_char": 16839,
      "end_char": 16972,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "Actually, the problem: we have one injection per second and one spreading per node that has at least one infected child? #                 #       # But note: the spreading operation: for each node that has at least one infected child, we can spread to one more child. So we can spread to multiple children in one second (one per node). #                 #       #",
      "start_char": 16983,
      "end_char": 17347,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Therefore, the spreading operation can infect as many children as there are nodes that have at least one infected child? #                 #       # So the process:\n\n        #                 #       #   Let T be the current time.",
      "start_char": 17368,
      "end_char": 17598,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "We have injected k nodes (the ones that have children) by time k.\n\n        #                 #       #   Then, at time k, we have k nodes that are infected and each of these nodes has at least one child?",
      "start_char": 17609,
      "end_char": 17812,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Actually, they have children (because we included only nodes with at least one child). #                 #       # Then, at time k+1: \n        #                 #       #        Spreading: we can spread to one child for each of the k nodes -> so we infect k children? #                 #       # Then injection: we inject one more node (which could be a child? or a leaf? but we are focusing on the children of these k nodes) \n\n        #                 #       # But note: we have to infect all the children.",
      "start_char": 17813,
      "end_char": 18334,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "The total number of children is sum(a). #                 #       #",
      "start_char": 18353,
      "end_char": 18420,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "However, we can also use injection on the children? #                 #       #",
      "start_char": 18433,
      "end_char": 18512,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Actually, we can use injection on any healthy node. So we can use injection to speed up the infection of the children?",
      "start_char": 18525,
      "end_char": 18643,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "#                 #       #   How to compute the minimal time? \n\n        #                 #       #   We can use a greedy: \n\n        #                 #       #",
      "start_char": 18654,
      "end_char": 18815,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "We have k injections (for the k parent nodes)",
      "start_char": 18822,
      "end_char": 18867,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "and then we have a list of the remaining children to infect. #                 #       #",
      "start_char": 18868,
      "end_char": 18956,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "We can simulate: \n        #                 #       # Let b = sorted(a, reverse=True)   # the list of children counts for each parent node. #                 #       # We start at time = k (we have injected the k parent nodes by time k). #                 #       #",
      "start_char": 18973,
      "end_char": 19266,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Then, for each parent node i, we have a[i] children.",
      "start_char": 19285,
      "end_char": 19337,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "We can spread to one child per second per parent node? #                 #       # But note: we can also inject a child? #                 #       #",
      "start_char": 19338,
      "end_char": 19486,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "Actually, we have one injection per second and multiple spreads per second (one per infected parent that still has uninfected children).\n\n        #                 #       #",
      "start_char": 19527,
      "end_char": 19700,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "We can model the infection of the children of a parent node i as: \n        #                 #       # The parent node i is infected at time t0 (which is <= k). \n        #                 #       #               Then, the children of i can be infected by spreading: one per second (starting at time t0+1) and also we can use injection to infect a child at any second? \n\n        #                 #       #",
      "start_char": 19711,
      "end_char": 20130,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "However, we are free to choose the order.",
      "start_char": 20141,
      "end_char": 20182,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "#                 #       #   Alternate known solution:\n\n        #                 #       # We do:\n\n        #                 #       #         ans = k   # k = number of parent nodes (with at least one child)\n        #                 #       #         # Then we create an array `rem` for the remaining children for each parent node?",
      "start_char": 20193,
      "end_char": 20533,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "#                 #       #         #",
      "start_char": 20543,
      "end_char": 20580,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "We subtract the time that has passed? \n\n        #                 #       #         #",
      "start_char": 20581,
      "end_char": 20666,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Actually, we can do:\n\n        #                 #       #         # We have k parent nodes.",
      "start_char": 20667,
      "end_char": 20758,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "We have injected them by time k.",
      "start_char": 20761,
      "end_char": 20793,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "Then, for each parent node i, we have a[i] children.",
      "start_char": 20794,
      "end_char": 20846,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "#                 #       #         #   The spreading for node i starts at time (the time when the parent node was injected) and then we can spread one per second?",
      "start_char": 20856,
      "end_char": 21019,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "#                 #       #         # But note: we can also use injection to infect a child?",
      "start_char": 21030,
      "end_char": 21122,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "#                 #       #         #   How many seconds after time k do we need?",
      "start_char": 21135,
      "end_char": 21216,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "#                 #       #         #",
      "start_char": 21227,
      "end_char": 21264,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "We can use a priority queue: we want to assign the injections and spreads optimally.",
      "start_char": 21267,
      "end_char": 21351,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "#                 #       #         # Actually, we can use a greedy: \n\n        #                 #       #         #       Let time = k. \n        #                 #       #         # We have an array `rem` = a (the children counts for each parent node).",
      "start_char": 21361,
      "end_char": 21623,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "#                 #       #         #",
      "start_char": 21633,
      "end_char": 21670,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "We also have a variable `injections` that we can use after time k: one per second.",
      "start_char": 21677,
      "end_char": 21759,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "#                 #       #         # But note: we can also spread one per parent node per second?",
      "start_char": 21769,
      "end_char": 21867,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "#                 #       #         #",
      "start_char": 21884,
      "end_char": 21921,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "Actually, the spreading operation: at each second, for every parent node that has at least one infected child and still has uninfected children, we can spread to one child.",
      "start_char": 21928,
      "end_char": 22100,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "#                 #       #         # So the number of spreads per second is the number of parent nodes that are \"active\" (have at least one uninfected child and at least one infected child).",
      "start_char": 22111,
      "end_char": 22302,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "#                 #       #         # We start at time k: all parent nodes are infected and have uninfected children -> so we have k spreads at the next second?",
      "start_char": 22319,
      "end_char": 22485,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "#                 #       #         # Then at time k+1: we do spreading: we reduce each `rem[i]` by 1? But wait, we can only spread one per parent?",
      "start_char": 22496,
      "end_char": 22643,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Actually, we can spread to one child per parent?",
      "start_char": 22650,
      "end_char": 22698,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "#                 #       #         # However, the problem says: \"for each vertex v, ... you can spread at most one\" -> so we can do one spread per parent? \n\n        #                 #       #         # So at time k+1: we do k spreads? Then we reduce each `rem[i]` by 1? \n\n        #                 #       #         # But that would be too fast? \n\n        #                 #       #         #",
      "start_char": 22709,
      "end_char": 23110,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Actually, we are allowed to choose which child to spread? But we don't have to spread to every parent?",
      "start_char": 23129,
      "end_char": 23231,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "#                 #       #         #",
      "start_char": 23242,
      "end_char": 23279,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "The problem: we can spread at most one per parent. So we can choose to spread to one child for parent i and not for parent j? \n\n        #                 #       #         # But we want to minimize the time, so we would spread to every parent that has uninfected children?",
      "start_char": 23286,
      "end_char": 23558,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "#                 #       #         #",
      "start_char": 23575,
      "end_char": 23612,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "Therefore, at each second after k, we can reduce the remaining children of every active parent by 1? \n\n        #                 #       #         #",
      "start_char": 23619,
      "end_char": 23767,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "However, we also have an injection per second.",
      "start_char": 23774,
      "end_char": 23820,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "We can use that injection to reduce the largest remaining group?",
      "start_char": 23821,
      "end_char": 23885,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "#                 #       #         # So:\n\n        #                 #       #         #           Let time = k.\n        #                 #       #         # We have an array `rem` = [a0, a1, ...]",
      "start_char": 23896,
      "end_char": 24109,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "(the children counts for each parent node, and we have k nodes).",
      "start_char": 24110,
      "end_char": 24174,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "#                 #       #         #",
      "start_char": 24183,
      "end_char": 24220,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "We sort `rem` in descending order.",
      "start_char": 24231,
      "end_char": 24265,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "#                 #       #         # Then, we simulate from time = k onward.",
      "start_char": 24275,
      "end_char": 24362,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "At each second, we do:\n        #                 #       #         #               Spreading: we reduce every positive `rem[i]` by 1? \n        #                 #       #         #",
      "start_char": 24363,
      "end_char": 24543,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Then, we can use an injection: we choose the parent node that has the largest remaining children and reduce it by 1? \n\n        #                 #       #         #           But note: the injection can be used on a child? So we can use it to reduce the largest remaining group?",
      "start_char": 24558,
      "end_char": 24836,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "#                 #       #         #",
      "start_char": 24847,
      "end_char": 24884,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "However, the injection can be used on any healthy node. So we can use it on a child of a parent node?",
      "start_char": 24895,
      "end_char": 24996,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "#                 #       #         # Therefore, we can simulate:\n\n        #                 #       #         #               time = k\n        #                 #       #         #               rem = sorted(a, reverse=True)   # but note: we have k elements?",
      "start_char": 25007,
      "end_char": 25276,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "#                 #       #         # Then, we let time pass until all rem are <=0.\n\n        #                 #       #         #               How? \n        #                 #       #         # We start with time = k.\n        #                 #       #         # Then, we let t = 0 (additional seconds after k)\n        #                 #       #         # We want to know the minimal t such that for every i, we have:\n        #                 #       #         #                         rem[i] <= t + (number of injections we have done to this group) \n        #                 #       #         #                   But note: we have one injection per second",
      "start_char": 25286,
      "end_char": 26018,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "and we can assign it arbitrarily.",
      "start_char": 26019,
      "end_char": 26052,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "#                 #       #         #",
      "start_char": 26062,
      "end_char": 26099,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "Actually, we can do:\n\n        #                 #       #         # We have t additional seconds.",
      "start_char": 26110,
      "end_char": 26207,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "In these t seconds:\n        #                 #       #         #                 - We do spreading: which reduces every active group by 1 per second?",
      "start_char": 26222,
      "end_char": 26372,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "#                 #       #         #                 - We do injection: we can use t injections (one per second) to reduce the remaining children of any group by 1 per injection.\n\n        #                 #       #         # So the total reduction for group i is: t (from spreading) + x_i (from injections, where x_i is the number of injections we use on that group) and we require:\n        #                 #       #         #                         a[i] <= t + x_i\n        #                 #       #         #               and the sum of x_i <= t   (because we have t injections) \n\n        #                 #       #         # But note: we can also use the injections on the children?",
      "start_char": 26382,
      "end_char": 27089,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "#                 #       #         #",
      "start_char": 27114,
      "end_char": 27151,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "Alternatively, we can use a greedy: \n\n        #                 #       #         # We start at time = k. Then we have an array `rem` = a.\n        #                 #       #         #",
      "start_char": 27162,
      "end_char": 27360,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "We sort `rem` in descending order.",
      "start_char": 27375,
      "end_char": 27409,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "#                 #       #         # Then, we let t = 0.\n        #                 #       #         #               while there is any rem[i] > 0:\n        #                 #       #         #                   t += 1\n        #                 #       #         #                   # Spreading: reduce every rem[i] by 1? But we can only reduce if we have an active parent?",
      "start_char": 27419,
      "end_char": 27807,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "#                 #       #         #                   #",
      "start_char": 27817,
      "end_char": 27874,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "Actually, we can reduce every rem[i] that is positive by 1? \n        #                 #       #         #                   # But note: the spreading operation: we can only spread to one child per parent per second?",
      "start_char": 27875,
      "end_char": 28091,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "#                 #       #         #                   # So we do: \n        #                 #       #         #                   for i in range(len(rem)):\n        #                 #       #         # if rem[i] > 0:\n        #                 #       #         #                           rem[i] -= 1\n        #                 #       #         #                   #",
      "start_char": 28101,
      "end_char": 28492,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Then, we use the injection: we choose the largest rem[i] and reduce it by 1? \n        #                 #       #         #                   # But note: we can only do one injection per second. #                 #       #         #                   rem.sort(reverse=True)\n        #                 #       #         # if rem[0] > 0:\n        #                 #       #         #                       rem[0] -= 1\n\n        #                 #       #         #               Then the total time = k + t.\n\n        #                 #       #         #",
      "start_char": 28493,
      "end_char": 29070,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "However, k can be up to 200000 and t might be large? \n\n        #                 #       #         # We need a more efficient way.",
      "start_char": 29081,
      "end_char": 29211,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "#                 #       #         #   Known efficient solution:\n\n        #                 #       #         # We do:\n\n        #                 #       #         #         ans = k   # k = len(a)\n        #                 #       #         #         #",
      "start_char": 29231,
      "end_char": 29490,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "Then, we create an array `rem` and we want to know the minimal additional time t such that:\n        #                 #       #         #         # For each i, we have: a[i] <= (t - i)   ???",
      "start_char": 29491,
      "end_char": 29683,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "#                 #       #         #         #",
      "start_char": 29694,
      "end_char": 29741,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "Actually, we can sort a in descending order, and then we require:\n        #                 #       #         #         #         a[i] - (t - i) < = 0   for every i? \n\n        #                 #       #         #         # But note: the spreading reduces every active group by 1 per second, and we can use the injection to reduce the largest group? \n\n        #                 #       #         #         #   Alternatively, we can do:\n\n        #                 #       #         #         # Let t = 0\n        #                 #       #         #         #         while True:\n        #                 #       #         #         #             if we can cover all groups with additional time t: break\n        #                 #       #         #         #             else: t++\n\n        #                 #       #         #         #   How to check for a given t?\n        #                 #       #         #         # We have k groups.",
      "start_char": 29744,
      "end_char": 30695,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "The reduction for group i from spreading is t (because every second we reduce by 1) and we have t injections that we can assign arbitrarily.",
      "start_char": 30704,
      "end_char": 30844,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "#                 #       #         #         # So we require: \n        #                 #       #         #         #             a[i] <= t + x_i   and sum_i x_i <= t\n        #                 #       #         #         #",
      "start_char": 30854,
      "end_char": 31086,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "This is equivalent to: \n        #                 #       #         #         #             sum_i max(0, a[i] - t) <= t\n        #                 #       #         #         #         Why? \n        #                 #       #         #         #",
      "start_char": 31095,
      "end_char": 31340,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "For group i, we need at least (a[i] - t) injections?",
      "start_char": 31353,
      "end_char": 31405,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "#                 #       #         #         # But note: the spreading reduces every group by t (if we wait t seconds)",
      "start_char": 31415,
      "end_char": 31534,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "and then we need to cover the remaining by injections.",
      "start_char": 31543,
      "end_char": 31597,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "The total injections needed is sum_i max(0, a[i]-t). And we have t injections.",
      "start_char": 31598,
      "end_char": 31676,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "#                 #       #         #         # So we can do:\n\n        #                 #       #         #         #             t = 0\n        #                 #       #         #         #             while True:\n        #                 #       #         #         #                 s = 0\n        #                 #       #         #         #                 for i in range(k):\n        #                 #       #         #         # if a[i] > t:\n        #                 #       #         #         #                         s += a[i] - t\n        #                 #       #         #         #                     else:\n        #                 #       #         #         #                         break\n        #                 #       #         #         #                 if s <= t:\n        #                 #       #         #         #                     break\n        #                 #       #         #         #                 t += 1\n\n        #                 #       #         #         #         Then total time = k + t.\n\n        #                 #       #         #         #   But note: we sorted a in descending order? Actually, we break early if a[i] <= t? \n\n        #                 #       #         #         #   However, we can break early because a is sorted in descending order?",
      "start_char": 31686,
      "end_char": 33034,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "#                 #       #         #         # But note: we have to check all groups?",
      "start_char": 33045,
      "end_char": 33131,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "#                 #       #         #         # Actually, we can break when a[i] <= t? because then the rest are <= t? \n\n        #                 #       #         #         # So we can do:\n\n        #                 #       #         #         #         a.sort(reverse=True)\n        #                 #       #         #         #         t = 0\n        #                 #       #         #         #         while True:\n        #                 #       #         #         #             s = 0\n        #                 #       #         #         #             for i in range(k):\n        #                 #       #         #         # if a[i] > t:\n        #                 #       #         #         #                     s += a[i] - t\n        #                 #       #         #         #                 else:\n        #                 #       #         #         #                     break\n        #                 #       #         #         # if s <= t:\n        #                 #       #         #         #                 break\n        #                 #       #         #         #             t += 1\n\n        #                 #       #         #         #         ans = k + t\n\n        #                 #       #         #         #   However, the total n is 200000, and the sum of n over test cases is 200000, but the while loop might run up to max(a) which is 200000? and the inner loop is k (which is <= n, but the sum of k over test cases is <= 200000?",
      "start_char": 33144,
      "end_char": 34656,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "note: the total n over test cases is 200000, so the total k over test cases is at most 200000? but the while loop might be heavy).",
      "start_char": 34657,
      "end_char": 34787,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "#                 #       #         #         #",
      "start_char": 34797,
      "end_char": 34844,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "We can optimize by binary search on t?",
      "start_char": 34847,
      "end_char": 34885,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "#                 #       #         #         # But note: the constraints say the total n over test cases is 200000, but the total k over test cases is the total number of nodes that have children?",
      "start_char": 34896,
      "end_char": 35093,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "and the sum of n is 200000, so the total k is at most 200000? \n\n        #                 #       #         #         #",
      "start_char": 35096,
      "end_char": 35215,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "However, the while loop for t might run up to max(a) which is 200000? and then the inner loop over k (which is 200000) would be 200000*200000 = 40e9, which is too slow.\n\n        #                 #       #         #         # We need a more efficient way.",
      "start_char": 35218,
      "end_char": 35473,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "#                 #       #         #         #",
      "start_char": 35485,
      "end_char": 35532,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "Alternatively, we can compute:\n\n        #                 #       #         #         # We want the minimal t such that: \n        #                 #       #         #         #             sum_{i} max(0, a[i] - t) <= t\n\n        #                 #       #         #         #         We can do a binary search on t?",
      "start_char": 35535,
      "end_char": 35859,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "#                 #       #         #         #         Let f(t) = sum_{i} max(0, a[i]-t)\n        #                 #       #         #         # We want the smallest t such that f(t) <= t.\n\n        #                 #       #         #         #         How to compute f(t) quickly? \n        #                 #       #         #         #",
      "start_char": 35870,
      "end_char": 36218,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "We have a sorted in descending order?",
      "start_char": 36231,
      "end_char": 36268,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Actually, we can sort in ascending order?",
      "start_char": 36269,
      "end_char": 36310,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "#                 #       #         #         # Actually, we can sort in descending order and then we can break when a[i] <= t.\n\n        #                 #       #         #         #         But note: the total k over test cases is at most 200000, and the maximum t we need to check is at most max(a) (which is <= 200000).",
      "start_char": 36320,
      "end_char": 36656,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "#                 #       #         #         #",
      "start_char": 36667,
      "end_char": 36714,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "However, we cannot iterate over t from 0 to max(a) for each test case?",
      "start_char": 36723,
      "end_char": 36793,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "because the sum of max(a) over test cases might be large.\n\n        #                 #       #         #         #         But note: the total n over test cases is 200000, so the maximum a[i] in any test case is at most 200000, and the number of test cases t is up to 10000? but the sum of n is 200000, so the number of test cases is at most 10000, but the sum of n is 200000, so the maximum test case has n=200000, but the number of test cases is about 1?",
      "start_char": 36794,
      "end_char": 37250,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "because 200000 is the total n? \n\n        #                 #       #         #         #         Actually, the problem says: \"the sum of n over all test cases does not exceed 200000\". So we have at most 10000 test cases, but the total n is 200000, so the maximum n in a test case can be 200000, but the number of test cases is about 1? Actually, 200000 is the total, so if one test case has n=200000, then t=1.",
      "start_char": 37251,
      "end_char": 37661,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "If there are many test cases, each n is small.",
      "start_char": 37662,
      "end_char": 37708,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "#                 #       #         #         #",
      "start_char": 37718,
      "end_char": 37765,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "Therefore, we can do a linear scan for t?",
      "start_char": 37774,
      "end_char": 37815,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "#                 #       #         #         # But worst-case, if we have one test case with n=200000, and the tree is a chain? then k = 1 (only the root has children, and the root has 199999 children). Then we need to find t such that:\n        #                 #       #         #         #             f(t) = max(0, 199999 - t) <= t\n        #                 #       #         #         # So we need t such that 199999 - t <= t  -> t>= 100000. So we would iterate t from 0 to 100000? and for each t we do a loop over k (which is 1) -> that's 100000 iterations, which is acceptable? \n\n        #                 #       #         #         # But worst-case, we might have many test cases? but the total n is 200000, so the total k is at most 200000?",
      "start_char": 37826,
      "end_char": 38593,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "and the total work over all test cases for the while loop would be the sum over test cases of (max(a_i) for that test case).",
      "start_char": 38602,
      "end_char": 38726,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "#                 #       #         #         #",
      "start_char": 38737,
      "end_char": 38784,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "However, the sum of n is 200000, but the max(a_i) for a test case can be 200000, and we have one test case, so we do 100000 iterations?",
      "start_char": 38793,
      "end_char": 38928,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "which is acceptable.\n\n        #                 #       #         #         # But worst-case, we might have 10000 test cases? but the total n is 200000, so the maximum n per test case is 20? then k is at most 20, and max(a_i) is at most 20, so the while loop runs at most 20 seconds per test case -> 10000*20 = 200000, which is acceptable.\n\n        #                 #       #         #         # So we can do:\n\n        #                 #       #         #         #             a.sort(reverse=True)\n        #                 #       #         #         #             k = len(a)\n        #                 #       #         #         #             t = 0\n        #                 #       #         #         #             while True:\n        #                 #       #         #         #                 s = 0\n        #                 #       #         #         #                 for i in range(k):\n        #                 #       #         #         # if a[i] > t:\n        #                 #       #         #         #                         s += a[i] - t\n        #                 #       #         #         #                     else:\n        #                 #       #         #         #                         break\n        #                 #       #         #         #                 if s <= t:\n        #                 #       #         #         #                     break\n        #                 #       #         #         #                 t += 1\n        #                 #       #         #         #             ans = k + t\n\n        #                 #       #         #         # But note: we have to account for the root?",
      "start_char": 38929,
      "end_char": 40622,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "#                 #       #         #         #",
      "start_char": 40635,
      "end_char": 40682,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "Actually, we have already accounted for the root: the root is one of the nodes in the list a? \n\n        #                 #       #         #         #   However, wait: the root is infected at time 1, but we counted it in the k injections?",
      "start_char": 40685,
      "end_char": 40924,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "#                 #       #         #         # But note: the root is a node that has children, so it is in the list a.",
      "start_char": 40935,
      "end_char": 41054,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "We inject it at one of the first k seconds? \n\n        #                 #       #         #         #   Then the children of the root are infected by spreading and injection? \n\n        #                 #       #         #         # So the total time is k (to inject the k parent nodes) plus t (the additional seconds).",
      "start_char": 41057,
      "end_char": 41376,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "#                 #       #         #         #",
      "start_char": 41388,
      "end_char": 41435,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "However, is that the entire tree?",
      "start_char": 41438,
      "end_char": 41471,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "#                 #       #         #         #   What about the parent nodes themselves?",
      "start_char": 41482,
      "end_char": 41571,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "We have infected them by injection? \n\n        #                 #       #         #         #   But note: the parent nodes are the ones that have children. We have k parent nodes.",
      "start_char": 41572,
      "end_char": 41751,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "We have infected them in the first k seconds. Then we only need to infect the children?",
      "start_char": 41752,
      "end_char": 41839,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "#                 #       #         #         #   The total nodes: \n        #                 #       #         #         #         k (the parent nodes) + sum(a) (the children) \n        #                 #       #         #         #   But note: the root is counted in k? and the root is also a node?",
      "start_char": 41850,
      "end_char": 42150,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "#                 #       #         #         #",
      "start_char": 42161,
      "end_char": 42208,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "Actually, the tree has n nodes.",
      "start_char": 42211,
      "end_char": 42242,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The parent nodes are the ones that have at least one child.",
      "start_char": 42243,
      "end_char": 42302,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The children counts a[i] are the number of children of that parent.",
      "start_char": 42303,
      "end_char": 42370,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The sum of a[i] is the total number of edges?",
      "start_char": 42371,
      "end_char": 42416,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "because each edge is from a parent to a child? and there are n-1 edges.",
      "start_char": 42417,
      "end_char": 42488,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "#                 #       #         #         # But note: the root is not a child of anyone. So the total nodes = 1 (the root) + sum(a) = 1 + (n-1) = n? \n\n        #                 #       #         #         #",
      "start_char": 42499,
      "end_char": 42711,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "However, the parent nodes are included in the count? The root is a parent node?",
      "start_char": 42714,
      "end_char": 42793,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "and the other parent nodes are also nodes?",
      "start_char": 42794,
      "end_char": 42836,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "#                 #       #         #         #",
      "start_char": 42847,
      "end_char": 42894,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "Actually, the parent nodes are the nodes that have children. The root is one of them.",
      "start_char": 42897,
      "end_char": 42982,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The list a has the children counts for each parent node.",
      "start_char": 42983,
      "end_char": 43039,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The total number of nodes is: \n        #                 #       #         #         #         the parent nodes (k) + the leaf nodes (which are the children that are not parents) \n        #                 #       #         #         #   But note: a parent node might be the child of another parent node?",
      "start_char": 43040,
      "end_char": 43344,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "#                 #       #         #         #",
      "start_char": 43355,
      "end_char": 43402,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "Actually, the tree has n nodes.",
      "start_char": 43405,
      "end_char": 43436,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The parent nodes are the non-leaf nodes.",
      "start_char": 43437,
      "end_char": 43477,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The leaf nodes are the ones that have no children.",
      "start_char": 43478,
      "end_char": 43528,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The list a has the children counts for the non-leaf nodes. The total number of leaf nodes = n - k.\n\n        #                 #       #         #         #   But note: the children counts a[i] for the non-leaf nodes: the sum of a[i] is the total number of edges?",
      "start_char": 43529,
      "end_char": 43791,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "and also the total number of children?",
      "start_char": 43792,
      "end_char": 43830,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "which is n-1? \n\n        #                 #       #         #         # So the total nodes = k (non-leaf) + (n-1) (children) ??? -> that would be k + (n-1) which is not n.\n\n        #                 #       #         #         #",
      "start_char": 43831,
      "end_char": 44061,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Actually, the children counts a[i] are the out-degrees. The sum of a[i] is the total number of edges = n-1.",
      "start_char": 44064,
      "end_char": 44171,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "#                 #       #         #         # Therefore, the total nodes is n = k + (number of leaf nodes) = k + (n - k) = n? \n\n        #                 #       #         #         #   But note: the non-leaf nodes are k, and the leaf nodes are n - k. \n\n        #                 #       #         #         #",
      "start_char": 44181,
      "end_char": 44494,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "We have infected the non-leaf nodes (k) in the first k seconds. Then we need to infect the leaf nodes (n-k).",
      "start_char": 44497,
      "end_char": 44605,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "#                 #       #         #         # But wait, the leaf nodes are the children of the parent nodes. So they are accounted for in the a[i]'s.",
      "start_char": 44616,
      "end_char": 44767,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "#                 #       #         #         # Therefore, the total time = k + t, where t is the additional seconds to infect the leaf nodes.",
      "start_char": 44780,
      "end_char": 44924,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "#                 #       #         #         # But note: the leaf nodes are infected by spreading or injection?",
      "start_char": 44934,
      "end_char": 45046,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "#                 #       #         #         #",
      "start_char": 45059,
      "end_char": 45106,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "The leaf nodes have no children, so they cannot be spread from?",
      "start_char": 45109,
      "end_char": 45172,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "They can only be infected by injection or by spreading from their parent?",
      "start_char": 45173,
      "end_char": 45246,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "#                 #       #         #         #",
      "start_char": 45257,
      "end_char": 45304,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "Actually, the spreading operation: the parent of a leaf node can spread to that leaf node?",
      "start_char": 45307,
      "end_char": 45397,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "#                 #       #         #         # So the leaf nodes are the children of the parent nodes.",
      "start_char": 45408,
      "end_char": 45511,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "#                 #       #         #         #",
      "start_char": 45524,
      "end_char": 45571,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "Therefore, the above method is correct.",
      "start_char": 45574,
      "end_char": 45613,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "#                 #       #         # However, the known solution in the provided code does something different:\n\n        #                 #       #         #         lives = [counts[i] for i in counts]   # but we have the initial counts[0]=1? which is a mistake. #                 #       #         #         lives.sort(reverse=True)\n\n        #                 #       #         #         for i in range(len(lives)):\n        #                 #       #         #             lives[i] -= len(lives)-i\n\n        #                 #       #         #         answer = len(lives)\n\n        #                 #       #         #         while max(lives) > 0:\n        #                 #       #         #             current_max = -1\n        #                 #       #         #             max_index = -1\n        #                 #       #         #             for i in range(len(lives)):\n        #                 #       #         #                 lives[i] -= 1\n        #                 #       #         #                 if lives[i] > current_max:\n        #                 #       #         #                     current_max = lives[i]\n        #                 #       #         #                     max_index = i\n        #                 #       #         #             lives[max_index] -= 1\n        #                 #       #         #             answer += 1\n\n        #                 #       #         # This is a different approach. #                 #       #         #   Let me explain:\n\n        #                 #       #         #       Step 1: build lives = list of children counts for each parent node (including the root). #                 #       #         #       Step 2: sort in descending order.\n        #                 #       #         #       Step 3: for i in range(len(lives)):\n        #                 #       #         #               lives[i] = lives[i] - (len(lives)-i) [subtract (k - i) where k = len(lives)]\n        #                 #       #         #       Step 4: answer = k   (the number of parent nodes)\n        #                 #       #         #       Step 5: while max(lives)>0:\n        #                 #       #         #               We subtract 1 from every live (which represents one second passing: spreading reduces every active parent's remaining children by 1) \n        #                 #       #         # Then we find the parent with the maximum remaining children and subtract one more (which represents using the injection on that parent's child) \n        #                 #       #         # Then we do answer += 1.\n\n        #                 #       #         #",
      "start_char": 45623,
      "end_char": 48317,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "This is simulating:\n\n        #                 #       #         # We have k parent nodes.",
      "start_char": 48320,
      "end_char": 48410,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "We inject them in the first k seconds? \n\n        #                 #       #         #",
      "start_char": 48417,
      "end_char": 48503,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Then, we account for the fact that during the first k seconds, we also have spreading?",
      "start_char": 48510,
      "end_char": 48596,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "#                 #       #         #       How? \n\n        #                 #       #         #",
      "start_char": 48607,
      "end_char": 48703,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "In the first k seconds, we are injecting the k parent nodes. But during these k seconds, we also have spreading? \n\n        #                 #       #         #",
      "start_char": 48712,
      "end_char": 48872,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "At second i (from 1 to k):\n        #                 #       #         #             Spreading: for every parent node that is already infected and has at least one infected child, we can spread to one more child?",
      "start_char": 48881,
      "end_char": 49093,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "#                 #       #         # But note: at second i, we have i parent nodes infected. So we can spread to i children?",
      "start_char": 49103,
      "end_char": 49228,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "#                 #       #         #             Injection: we inject one parent node.\n\n        #                 #       #         #         However, the spreading in the first k seconds: \n        #                 #       #         #             At second 1: \n        #                 #       #         #                 Spreading: nothing (no parent node has an infected child?",
      "start_char": 49254,
      "end_char": 49636,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "because we haven't injected any child) \n        #                 #       #         #                 Injection: inject parent node 1.\n        #                 #       #         #             At second 2",
      "start_char": 49637,
      "end_char": 49841,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": ":\n        #                 #       #         #                 Spreading: parent node 1 has no infected child? -> nothing.",
      "start_char": 49841,
      "end_char": 49964,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "#                 #       #         #                 Injection: inject parent node 2.\n        #                 #       #         #             ... until second k.\n\n        #                 #       #         # So in the first k seconds, we only do injections?",
      "start_char": 49973,
      "end_char": 50234,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "#                 #       #         # Then why subtract (len(lives)-i? \n\n        #                 #       #         # The subtraction: \n        #                 #       #         #             for i in range(k):\n        #                 #       #         #                 lives[i] = lives[i] - (k - i)\n\n        #                 #       #         #         This seems to be subtracting (k-i) from the i-th largest group.\n\n        #                 #       #         #         Example: k=2, lives = [3,1] (sorted descending)\n        #                 #       #         #             i=0: lives[0] = 3 - (2-0) = 1\n        #                 #       #         #             i=1: lives[1] = 1 - (2-1) = 0\n        #                 #       #         #         Then answer = 2, then we enter the while loop: \n        #                 #       #         # current_max = -1, max_index=-1\n        #                 #       #         #             for i in range(2):\n        #                 #       #         #                 lives[0] = 1-1 = 0\n        #                 #       #         #                 lives[1] = 0-1 = -1\n        #                 #       #         # then we find the max: at i=0, lives[0]=0 -> current_max=0, max_index=0? \n        #                 #       #         #             then lives[0] becomes 0-1 = -1.\n        #                 #       #         #             answer becomes 3.\n        #                 #       #         # But the expected answer for a tree with root having 3 children and one of the children having one child? \n        #                 #       #         #         Total nodes = 5? \n        #                 #       #         #         How many seconds? \n        #                 #       #         #             Second 1: inject the root -> infected: { 1}\n        #                 #       #         #             Second 2: \n        #                 #       #         #                 Spreading: the root has no infected child? -> skip. #                 #       #         #                 Injection: inject one child of the root (say A) -> infected: {1, A}\n        #                 #       #         #             Second 3:\n        #                 #       #         #                 Spreading: the root has one infected child (A) -> we can spread to one more child (say B) -> infected: {1, A, B}\n        #                 #       #         #                 Injection: inject the child of A (say C) -> infected: {1, A, B, C}\n        #                 #       #         #             Second 4: #                 #       #         #                 Spreading: the root has two infected children (A,B) -> we can spread to one more child (D) -> infected: {1, A, B, C, D}\n        #                 #       #         #                 Injection: none needed? \n        #                 #       #         # So total time=4.\n\n        #                 #       #         # But our simulation got 3? \n\n        #                 #       #         #         Alternatively, we might inject differently:\n\n        #                 #       #         #             Second 1: inject root -> {1}\n        #                 #       #         #             Second 2: inject the child A -> {1, A}\n        #                 #       #         #             Second 3: \n        #                 #       #         #                 Spreading: root has one infected child -> spread to B; and also the node A has a child? -> we can spread to C? \n        #                 #       #         #                 But note: the spreading operation: for each vertex v, if at least one child of v is infected, we can spread to at most one other child.",
      "start_char": 50253,
      "end_char": 54014,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "#                 #       #         # So for the root: we can spread to B.\n        #                 #       #         #                 For the node A: we can spread to C.\n        #                 #       #         # Then we infect B and C in one second?",
      "start_char": 54024,
      "end_char": 54280,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "#                 #       #         # Then injection: we can inject D? \n        #                 #       #         #                 -> infected: {1, A, B, C, D} in 3 seconds?",
      "start_char": 54322,
      "end_char": 54514,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "#                 #       #         # But the problem: the spreading operation: we can only spread to at most one other child per vertex. So we can do both the root and A in the same second?",
      "start_char": 54525,
      "end_char": 54715,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "#                 #       #         # Yes! So we can spread to B (from the root) and to C (from A) in the same spreading phase.",
      "start_char": 54734,
      "end_char": 54861,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "#                 #       #         # Then at second 3: \n        #                 #       #         #             Spreading: infect B and C.\n        #                 #       #         #             Injection: inject D.\n        #                 #       #         # Then we are done in 3 seconds?",
      "start_char": 54879,
      "end_char": 55176,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "#                 #       #         # But wait, at second 3, after spreading we have infected B and C, then we inject D. So at the end of second 3, we have infected {1, A, B, C, D}.",
      "start_char": 55203,
      "end_char": 55392,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "#                 #       #         # So the minimal time is 3.\n\n        #                 #       #         #",
      "start_char": 55403,
      "end_char": 55513,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "Therefore, the provided code might be correct.",
      "start_char": 55530,
      "end_char": 55576,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "#                 #       #         #",
      "start_char": 55586,
      "end_char": 55623,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "How does the provided code work for this example?\n\n        #                 #       #         # We have a tree: \n        #                 #       #         #             root (1) has children: [2,3,4]  -> so counts[1]=3.\n        #                 #       #         #             node 2 has child 5 -> counts[2]=1.\n        #                 #       #         # So lives = [3,1] -> sorted descending: [3,1]\n\n        #                 #       #         #         Step: for i in range(2):\n        #                 #       #         #             i=0: lives[0] = 3 - (2-0) = 1\n        #                 #       #         #             i=1: lives[1] = 1 - (2-1) = 0\n        #                 #       #         #         Then answer = 2.\n        #                 #       #         #         Then while max(lives)>0: max(lives)=1>0 -> enter loop. #                 #       #         #             current_max = -1, max_index=-1\n        #                 #       #         #             for i in range(2):\n        #                 #       #         #                 lives[0] = 1-1 = 0\n        #                 #       #         #                 lives[1] = 0-1 = -1\n        #                 #       #         # then we compare: \n        #                 #       #         #                     i=0: 0 > -1 -> current_max=0, max_index=0.\n        #                 #       #         #                     i=1: -1 is not greater than 0 -> skip. #                 #       #         #             then lives[0] = 0-1 = -1.\n        #                 #       #         #             answer becomes 3.\n        #                 #       #         #         Then max(lives) = max(-1,-1) = -1 -> break.",
      "start_char": 55626,
      "end_char": 57365,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "#                 #       #         # So answer=3.\n\n        #                 #       #         #",
      "start_char": 57375,
      "end_char": 57480,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Therefore, the provided code is correct for the example.",
      "start_char": 57483,
      "end_char": 57539,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "#                 #       #         # But why subtract (len(lives)-i? \n\n        #                 #       #         #",
      "start_char": 57549,
      "end_char": 57666,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "The idea: during the first k seconds, we are injecting the k parent nodes. But in the same time, we can also spread?",
      "start_char": 57677,
      "end_char": 57793,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "#                 #       #         #",
      "start_char": 57804,
      "end_char": 57841,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "Specifically, at the i-th second (0-indexed), we are injecting the i-th parent node. But at the same time, we have i parent nodes that are already infected (from the previous i seconds) and each of them can spread to one child?",
      "start_char": 57850,
      "end_char": 58077,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "#                 #       #         #",
      "start_char": 58088,
      "end_char": 58125,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "However, the spreading happens after the injection?",
      "start_char": 58134,
      "end_char": 58185,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "#                 #       #         #",
      "start_char": 58196,
      "end_char": 58233,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "The problem: each second: spreading then injection.\n\n        #                 #       #         # So in the first i seconds, we have injected i parent nodes. Then at the spreading phase of the (i+1)-th second, we can spread to i children?",
      "start_char": 58242,
      "end_char": 58481,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "#                 #       #         # But note: the injection of the parent node happens after the spreading? \n\n        #                 #       #         # So at the start of second i+1:\n        #                 #       #         #             We have i infected parent nodes. #                 #       #         #             Spreading: we can spread to i children (one per infected parent node) -> so we reduce the remaining children of each parent node by 1? \n        #                 #       #         # Then we inject the (i+1)-th parent node.\n\n        #                 #       #         #         Therefore, by the time we inject the i-th parent node (at the injection step of the i-th second), we have already done i-1 spreading steps? \n\n        #                 #       #         #         Actually, let's do:\n\n        #                 #       #         #             Second 1:\n        #                 #       #         #                 Spreading: 0 (because no parent node is infected at the start of second 1)\n        #                 #       #         #                 Injection: inject parent node 1 -> now we have 1 infected parent node. #                 #       #         #             Second 2:\n        #                 #       #         #                 Spreading: we have 1 infected parent node -> we can spread to one child of node 1.\n        #                 #       #         #                 Injection: inject parent node 2.\n\n        #                 #       #         # So after second 2, the remaining children for node 1 is a[0]-1, and for node 2 is a[1] (because we haven't spread for node 2 yet? we only spread for node 1).",
      "start_char": 58500,
      "end_char": 60212,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "#                 #       #         # Then at second 3:\n        #                 #       #         #                 Spreading: we have 2 infected parent nodes -> we can spread to two children: one for node 1 and one for node 2.\n        #                 #       #         #                 Injection: inject parent node 3.\n\n        #                 #       #         # So by the time we finish the injection of the last parent node (at second k), we have done:\n        #                 #       #         # For the first parent node: it was injected at second 1, then it was spread for in seconds 2,3,...,k -> (k-1) spreads.",
      "start_char": 60230,
      "end_char": 60885,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "#                 #       #         # For the second parent node: injected at second 2, then spread for in seconds 3,...,k -> (k-2) spreads.",
      "start_char": 60894,
      "end_char": 61046,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "#                 #       #         #             ...\n        #                 #       #         #",
      "start_char": 61055,
      "end_char": 61154,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "For the last parent node: injected at second k, then no spread in the same second?",
      "start_char": 61167,
      "end_char": 61249,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "#                 #       #         #",
      "start_char": 61260,
      "end_char": 61297,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "Actually, after injecting the last parent node, we haven't done any spreading for it in the same second?",
      "start_char": 61306,
      "end_char": 61410,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "#                 #       #         #",
      "start_char": 61421,
      "end_char": 61458,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "Therefore, the total spreads for the i-th parent node (0-indexed) is (k - i - 1) ?",
      "start_char": 61467,
      "end_char": 61549,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "#                 #       #         # But the code does: \n        #                 #       #         #             lives[i] = lives[i] - (k - i)\n\n        #                 #       #         #         Why (k-i) and not (k-i-1)?",
      "start_char": 61560,
      "end_char": 61795,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "#                 #       #         #         Let me reindex: the parent nodes are sorted in descending order by the number of children.\n\n        #                 #       #         #",
      "start_char": 61806,
      "end_char": 61989,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "For the parent node at index i (0-indexed), it is injected at second i+1.\n        #                 #       #         #         Then, from second i+2 to second k: that's (k - (i+1)) = k-i-1 seconds in which it can be spread from? \n\n        #                 #       #         # But also, at the spreading phase of second i+1: we haven't injected it yet? so it doesn't get a spread in second i+1.\n\n        #                 #       #         # So total spreads for node i = k - i - 1.\n\n        #                 #       #         #",
      "start_char": 61998,
      "end_char": 62544,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "However, the code subtracts (k-i).",
      "start_char": 62553,
      "end_char": 62587,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "#                 #       #         # This suggests that the code is accounting for one extra spread? \n\n        #                 #       #         #         Let me see the example: k=2, i=0: subtract 2, i=1: subtract 1.\n\n        #                 #       #         # For the first parent node (i=0): we subtract 2 -> but we only had 1 spread (at second 2) -> so we over-subtracted by 1.\n\n        #                 #       #         # For the second parent node (i=1): we subtract 1 -> but we had 0 spreads -> over-subtracted by 1.\n\n        #                 #       #         # Then the while loop then adds back by doing extra seconds? \n\n        #                 #       #         #         In the example, after subtraction: [3-2=1, 1-1=0]. Then we do one extra second: \n        #                 #       #         #             we subtract 1 from every live (so [0, -1]) and then we do an extra injection on the first node (making it -1) -> total time = 2 (initial) + 1 = 3.\n\n        #                 #       #         #",
      "start_char": 62598,
      "end_char": 63656,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "This extra second: \n        #                 #       #         # In that second, we do:",
      "start_char": 63665,
      "end_char": 63753,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "#                 #       #         #                 Spreading: we spread to two children?",
      "start_char": 63774,
      "end_char": 63865,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "(because we have two parent nodes that are infected and have children? but one has 0 remaining and one has 1) -> but after the subtraction in the for-loop, the first node became 1, then we subtract 1 in the while loop to get 0, and then we do an extra injection on the first node? \n        #                 #       #         #                 Injection: we inject a child of the first node.",
      "start_char": 63866,
      "end_char": 64257,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "#                 #       #         #",
      "start_char": 64267,
      "end_char": 64304,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "This matches the second scenario we described.",
      "start_char": 64313,
      "end_char": 64359,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "#                 #       #         # But why subtract (k-i) initially?",
      "start_char": 64369,
      "end_char": 64440,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "#                 #       #         #",
      "start_char": 64459,
      "end_char": 64496,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "The initial subtraction might be accounting for the fact that we will eventually do (k-i) spreads for the node i? but we haven't done them yet?",
      "start_char": 64505,
      "end_char": 64648,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "#                 #       #         #",
      "start_char": 64659,
      "end_char": 64696,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "Actually, the initial subtraction is to account for the spreads that happen during the first k seconds? but we overcounted and then we fix in the while loop.",
      "start_char": 64705,
      "end_char": 64862,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "#                 #       #         #",
      "start_char": 64872,
      "end_char": 64909,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "Alternatively, we can think: the initial subtraction is to account for the maximum possible spreads that could have been done for that node by the time we finish the k seconds?",
      "start_char": 64918,
      "end_char": 65094,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "#                 #       #         # But the example shows we over-subtract.",
      "start_char": 65105,
      "end_char": 65182,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "#                 #       #         #",
      "start_char": 65200,
      "end_char": 65237,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "The while loop then simulates the additional seconds: \n        #                 #       #         #             In each additional second:\n        #                 #       #         #                 We do spreading: which reduces every parent node's remaining children by 1.\n        #                 #       #         #                 Then we do an injection: we choose the parent node with the largest remaining children and reduce it by 1 (by injecting one of its children).\n\n        #                 #       #         #",
      "start_char": 65246,
      "end_char": 65774,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "This is equivalent to: \n        #                 #       #         #",
      "start_char": 65783,
      "end_char": 65852,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "In the additional seconds, we can do one spread per parent node (if they have remaining children) and then one extra injection (which we use on the worst-off parent node).",
      "start_char": 65865,
      "end_char": 66036,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "#                 #       #         # But note: the spreading in the additional seconds: we can spread to one child per parent node that still has children?",
      "start_char": 66046,
      "end_char": 66202,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "#                 #       #         #",
      "start_char": 66221,
      "end_char": 66258,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "Therefore, the while loop: \n        #                 #       #         # We subtract 1 from every parent node (simulating the spread for every active parent) -> this is the spreading phase.",
      "start_char": 66267,
      "end_char": 66469,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "#                 #       #         # Then we find the parent node with the largest remaining children and subtract 1 (simulating an injection on a child of that parent) -> this is the injection phase.",
      "start_char": 66478,
      "end_char": 66691,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "#                 #       #         #",
      "start_char": 66701,
      "end_char": 66738,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "And we count one second for this.",
      "start_char": 66747,
      "end_char": 66780,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "#                 #       #         #",
      "start_char": 66790,
      "end_char": 66827,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "We do this until no parent node has positive remaining children.",
      "start_char": 66836,
      "end_char": 66900,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "#                 #       #         #",
      "start_char": 66910,
      "end_char": 66947,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "The initial subtraction (k-i) for the i-th parent node: \n        #                 #       #         #",
      "start_char": 66956,
      "end_char": 67058,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "This accounts for the fact that during the first k seconds, the node i is injected at second i+1, and then from second i+1 to the end of the k seconds, there are (k - i - 1) seconds in which the node i could have been spread from? \n        #                 #       #         # But the code subtracts (k-i), which is one more.\n\n        #                 #       #         # Why one more? \n\n        #                 #       #         #         Let me see the first parent node (i=0): \n        #                 #       #         # It is injected at second 1. Then, in the spreading phase of seconds 2,3,...,k: that's k-1 seconds -> we would spread to k-1 children?",
      "start_char": 67071,
      "end_char": 67767,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "#                 #       #         # But the code subtracts k (because k-i = k-0 = k) -> so it subtracts one extra.\n\n        #                 #       #         #",
      "start_char": 67777,
      "end_char": 67952,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "This extra subtraction might be accounting for the injection of the parent node itself?",
      "start_char": 67961,
      "end_char": 68048,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "#                 #       #         #",
      "start_char": 68059,
      "end_char": 68096,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "Actually, the parent node is infected by injection, but that doesn't reduce the number of its children.",
      "start_char": 68105,
      "end_char": 68208,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "#                 #       #         #",
      "start_char": 68219,
      "end_char": 68256,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "I think the initial subtraction is not correct. But the example worked because the while loop compensated.\n\n        #                 #       #         #",
      "start_char": 68265,
      "end_char": 68418,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "However, the known solution in the provided code is used and we must complete it.",
      "start_char": 68427,
      "end_char": 68508,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "#                 #       #         #",
      "start_char": 68518,
      "end_char": 68555,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "Therefore, we will complete the provided code. #                 #       #         #   The provided code has:\n\n        #                 #       #         #       for i in range(len(lives)):\n        #                 #       #         #           lives[i] -= len(lives)-i\n\n        #                 #       #         #       answer = len(lives)\n\n        #                 #       #         #       while max(lives) > 0:\n        #                 #       #         #           current_max = -1\n        #                 #       #         #           max_index = -1\n        #                 #       #         #           for i in range(len(lives)):\n        #                 #       #         #               lives[i] -= 1\n        #                 #       #         #               if lives[i] > current_max:\n        #                 #       #         #                   current_max = lives[i]\n        #                 #       #         #                   max_index = i\n        #                 #       #         #           lives[max_index] -= 1\n        #                 #       #         #           answer += 1\n\n        #                 #       #         #",
      "start_char": 68558,
      "end_char": 69733,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "We are to complete the if condition: we are iterating i in the for-loop, and we update lives[i] by subtracting 1, and then we check if the updated lives[i] is greater than current_max.\n\n        #                 #       #         #   We also need to update current_max and max_index.\n\n        #                 #       #         # The code inside the if block is:\n\n        #                 #       #         #         current_max = lives[i]\n        #                 #       #         #         max_index = i\n\n        #                 #       #         #   But note: we are subtracting 1 from every lives[i] in the for-loop. Then we compare the updated value.",
      "start_char": 69736,
      "end_char": 70399,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "#                 #       #         # We want to find the index",
      "start_char": 70409,
      "end_char": 70472,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "i that has the maximum lives[i] after the subtraction of 1.\n\n        #                 #       #         # So we do:\n\n        #                 #       #         #         if lives[i] > current_max:\n        #                 #       #         #             current_max = lives[i]\n        #                 #       #         #             max_index = i\n\n        #                 #       #         # But note: we are iterating in order, and we want the maximum and its index.",
      "start_char": 70475,
      "end_char": 70951,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "#                 #       #         # This is correct. # However, the initial counts[0]=1 is a mistake. We should remove it. #   How to fix the initial counts?\n\n        #       We are given: \n        #           n = number of vertices\n        #           parents = list of n-1 integers: the parent of vertex 2, vertex 3, ... vertex n.\n\n        #",
      "start_char": 70963,
      "end_char": 71330,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "We want to count the number of children for each node. # We should do:\n\n        #           counts = defaultdict(int)\n        #           for i in parents:\n        #               counts[i] += 1\n\n        #       But note: the root (vertex 1) might not appear in the list? # The parent of vertex 2: if the parent is 1, then we will have counts[1] += 1. # So the root will be included. #",
      "start_char": 71337,
      "end_char": 71756,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "However, the root has no parent, but we are counting its children. # Therefore, we remove the line: counts[0]=1. # But wait: the provided code has:\n\n        #         counts = defaultdict(int)\n        #         counts[0] = 1   # we remove this line. # Then we do:\n\n        #         for i in parents:\n        #             counts[i] += 1\n\n        #   Then we form lives = [counts[i] for i in counts]   -> this will include the root (if it has children) and any other node that has children. # But note: what if a node does not have children? Then it won't be in counts? #",
      "start_char": 71787,
      "end_char": 72395,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "That's okay because we only care about nodes that have children. #",
      "start_char": 72419,
      "end_char": 72485,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "However, the root might not have children? then the tree has only one node? but n>=2. # But the input has n-1 numbers, so the tree has at least one edge. So the root must have at least one child. # Therefore, we remove the line counts[0]=1. # But note: the sample test case: \n        #         t=1, n=2, parents = [1] \n        # Then counts: \n        #             counts[1] = 1\n        #         lives = [1] \n        # Then: for i in range(1): \n        #                 lives[0] = 1 - (1-0) = 0\n        # Then answer = 1, then while max(lives)>0 -> false, so answer=1.\n        # But the tree has 2 nodes.",
      "start_char": 72497,
      "end_char": 73160,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "How do we infect?\n        #             Second 1: #                 Spreading: nothing -> then inject the root? # Then we have infected the root. But we need to infect the child.",
      "start_char": 73169,
      "end_char": 73356,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "#             Second 2:\n        #                 Spreading: the root has one child? and the child is not infected -> but the condition: \"if at least one child of v is infected\" -> the root has no infected child?",
      "start_char": 73386,
      "end_char": 73598,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "because the child is not infected. # Then we inject the child. # So total seconds=2.\n\n        # But our answer is 1? \n\n        #",
      "start_char": 73599,
      "end_char": 73772,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "What went wrong?\n\n        #   The problem: the root is a parent node?",
      "start_char": 73783,
      "end_char": 73852,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "and we are only infecting the parent nodes in the first k seconds? but the child is not a parent node? so we haven't infected the child.",
      "start_char": 73853,
      "end_char": 73989,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "#   The list `lives` only includes the parent nodes.",
      "start_char": 73999,
      "end_char": 74051,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The child (vertex 2) is not a parent node? so it is not in `lives`. #",
      "start_char": 74052,
      "end_char": 74121,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "How do we account for the children that are not parents?",
      "start_char": 74134,
      "end_char": 74190,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "#   The initial counts: we only count the children of a node.",
      "start_char": 74201,
      "end_char": 74262,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "The child (vertex 2) has no children, so it is not in the counts dictionary. # But the child is a node that must be infected.",
      "start_char": 74263,
      "end_char": 74388,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "#   The method: we only consider the parent nodes and then the children are accounted for in the children counts?",
      "start_char": 74410,
      "end_char": 74523,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "#   In the example: \n        # The root has one child. So in the list `lives` we have [1] for the root. # Then we subtract (1-0)=1 -> becomes 0.\n        # Then we don't enter the while loop -> answer=1. # But we need 2 seconds. #",
      "start_char": 74534,
      "end_char": 74795,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Therefore, we must account for the child.",
      "start_char": 74818,
      "end_char": 74859,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "#   How does the known solution account for the child? #",
      "start_char": 74869,
      "end_char": 74925,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The known solution in the while loop: \n        #",
      "start_char": 74938,
      "end_char": 74986,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "We are only processing the parent nodes.",
      "start_char": 74995,
      "end_char": 75035,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The child is not a parent node, so it is not in the list.",
      "start_char": 75036,
      "end_char": 75093,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "#   But note: the child is infected by injection?",
      "start_char": 75104,
      "end_char": 75153,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "in the second second.\n\n        #   The initial k seconds: we inject the parent nodes.",
      "start_char": 75154,
      "end_char": 75239,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "The child is not a parent node, so we don't inject it in the first k seconds. # Then the while loop: we are only reducing the children counts of the parent nodes.",
      "start_char": 75240,
      "end_char": 75402,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The child is a child of the root.",
      "start_char": 75414,
      "end_char": 75447,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "The root's children count was 1, and we subtracted 1 initially, so it became 0. Then we don't do anything for the child. #",
      "start_char": 75448,
      "end_char": 75570,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "We must account for the child in the while loop?",
      "start_char": 75582,
      "end_char": 75630,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "#   Alternatively, we must include the leaf nodes that are not parents? # But the problem: the leaf nodes are not parent nodes, so they are not in the list. # The known solution for the sample n=2: \n        # We have one parent node (the root) -> k=1. # Then we do: \n        #             lives = [1] \n        #             for i in range(1): lives[0] = 1 - (1-0) = 0.\n        #             answer = 1.\n        # Then while max(lives)>0 -> false, so answer=1.\n\n        #   But expected 2.\n\n        #   Therefore, the known solution might be missing the leaf nodes. #   How to fix? #",
      "start_char": 75641,
      "end_char": 76278,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "We note that the total number of nodes is n. We have infected the parent nodes (k) in the first k seconds. Then we need to infect the leaf nodes (n-k). # But the leaf nodes are the children of the parent nodes.",
      "start_char": 76300,
      "end_char": 76510,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "The children counts a[i] are the number of children of the parent node i.",
      "start_char": 76523,
      "end_char": 76596,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The sum of a[i] is n-1 (the number of edges).",
      "start_char": 76597,
      "end_char": 76642,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "#   The initial subtraction: we subtract (k-i) from a[i] for the i-th parent node. Then we get the remaining children that are not infected by the spreading during the first k seconds. # Then the while loop infects the remaining children by spreading and injection. # But in the example: \n        #         k=1, a[0]=1 -> after subtraction: 1 - (1-0)=0 -> so the root has no remaining children. # But the child is not infected?",
      "start_char": 76653,
      "end_char": 77102,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "#   Why is the child not infected? #",
      "start_char": 77130,
      "end_char": 77166,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "The child is infected by spreading? # At second 1: \n        # We inject the root -> infected: {1}\n        #",
      "start_char": 77179,
      "end_char": 77315,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "At second 2:\n        #             Spreading: the root has one child? and the child is not infected -> but the condition: \"if at least one child of v is infected\" -> the root has no infected child? # So we cannot spread. # Then we inject the child. # So the child is infected by injection.",
      "start_char": 77324,
      "end_char": 77613,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "#   How is that accounted for in the while loop?",
      "start_char": 77675,
      "end_char": 77723,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "#   The while loop is only for the parent nodes.",
      "start_char": 77734,
      "end_char": 77782,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The child is not a parent node, so it is not in the list. #",
      "start_char": 77783,
      "end_char": 77842,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Therefore, we must account for the injection of the child in the while loop? # But the while loop only does: \n        #         for each parent node: reduce the remaining children by 1 (spreading) \n        #         then we inject one child (of the parent node that has the most remaining children) -> this injection is counted.",
      "start_char": 77855,
      "end_char": 78195,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "#   In the example, after the initial subtraction, the root has 0 remaining children. So we don't enter the while loop. # But we still have one node (the child) to infect. #",
      "start_char": 78205,
      "end_char": 78378,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Therefore, we must account for the leaf nodes that are not infected by spreading.",
      "start_char": 78402,
      "end_char": 78483,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "#   The known solution might be incomplete. #   Let me check a known AC solution for this problem (from Codeforces): \n\n        #         #include <bits/stdc++.h>\n        #         using namespace std;\n        #         int main() {\n        #             int t;\n        #             cin >> t;\n        #             while (t--) {\n        #                 int n;\n        #                 cin >> n;\n        #                 vector<int> p(n);\n        #                 for (int i = 1; i < n; i++) {\n        #                     cin >> p[i];\n        #                 }\n        #                 vector<int> deg(n+1, 0);\n        #                 for (int i = 1; i < n; i++) {\n        #                     deg[p[i]]++;\n        #                 }\n        #                 vector<int> v = {1};   // we start with 1 for the root? #                 for (int i = 1; i <= n; i++) {\n        #                     if (deg[i] > 0) {\n        #                         v.push_back(deg[i]);\n        #                     }\n        #                 }\n        #                 sort(v.rbegin(), v.rend());\n        #                 int k = v.size();\n        #                 for (int i = 0; i < k; i++) {\n        #                     v[i] = v[i] - (k - i);\n        #                 }\n        #                 int ans = k;\n        #                 while (true) {\n        #                     int mx = -1e9, pos = -1;\n        #                     for (int i = 0; i < k; i++) {\n        #                         if (v[i] > mx) {\n        #                             mx = v[i];\n        #                             pos = i;\n        #                         }\n        #                     }\n        #                     if (mx <= 0) break;\n        #                     v[pos]--;\n        #                     ans++;\n        #                 }\n        #                 cout << ans << '\\n';\n        #             }\n        #         }\n\n        #   This solution starts with v = {1}. Why?\n\n        #   In the sample n=2: \n        #         deg[1] = 1, so v = [1, 1]  (because they push 1 initially and then push deg[i] for i that has deg[i]>0, and deg[1]=1>0)\n        #         Then sort: [1,1] (descending: still [1,1])\n        #         Then for i=0: v[0]=1 - (2-0) = -1\n        #                i=1: v[1]=1 - (2-1) = 0\n        #         Then ans = 2.\n        # Then while: mx = max(-1,0)=0 -> break. # So answer=2.\n\n        #   Why push 1 initially?",
      "start_char": 78493,
      "end_char": 80983,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "#   The comment says: \"we start with 1 for the root\". # But the root is already included in the deg array?",
      "start_char": 80994,
      "end_char": 81100,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "#   The initial 1 might account for the root being infected at time 0? #",
      "start_char": 81123,
      "end_char": 81195,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Or it might account for the root as a node that we start with.",
      "start_char": 81208,
      "end_char": 81270,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "#   The known solution in the provided code does not have this.",
      "start_char": 81280,
      "end_char": 81343,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "#   How about we modify our solution to include the root as a node that we start with? # We can do: \n        #         lives =",
      "start_char": 81353,
      "end_char": 81491,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "[1]   # for the root, we consider it as a node that we start with? #         then for every node",
      "start_char": 81492,
      "end_char": 81588,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "i that has at least one child, we append counts[i] (the number of children)\n\n        # But then for the root, if it has children, we will have two entries: one for the initial 1 and one for the children count? #   Alternatively, the known AC solution does: \n        #         v = {1}\n        #         for i in range(1, n+1):\n        #             if deg[i] > 0:\n        #                 v.push_back(deg[i])\n\n        #   This means: \n        #",
      "start_char": 81598,
      "end_char": 82054,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The initial 1 might represent the root being infected at time 0? \n\n        # But the problem: initially, all vertices are healthy.",
      "start_char": 82063,
      "end_char": 82193,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "#   The known AC solution might be accounting for the fact that we must infect the root, and the root is not injected in the first second? #   Let me simulate the known AC solution for n=2:\n\n        #         v = [1, 1]  -> two nodes: the root and the child? # But wait, the child is not a parent node, so it is not appended.",
      "start_char": 82205,
      "end_char": 82540,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "#         Why is there a 1 for the child? # The initial 1 might be for the root, and then the deg[1]=1 (the child) is appended. # Then we have two nodes: the root and the child of the root. # Then we do: \n        #             k=2. #             for i=0: v[0]=1 - (2-0) = -1\n        #             for i=1: v[1]=1 - (2-1) = 0\n        #             ans=2. #         This matches. #   How about a chain of 3: \n        #         n=3, parents = [1,1]   -> the root has two children.\n        #         deg[1]=2, so v = [1, 2] -> sorted descending: [2,1]\n        #         k=2. #         i=0: 2 - (2-0) = 0\n        #         i=1: 1 - (2-1) = 0\n        #         ans=2. # But we need 3 seconds?",
      "start_char": 82569,
      "end_char": 83341,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "#             Second 1: inject root.",
      "start_char": 83367,
      "end_char": 83403,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "#             Second 2: \n        #                 spreading: the root has two children? but none is infected -> skip. #                 injection: inject child A.\n        #             Second 3:\n        #                 spreading: the root has one infected child (A) -> spread to child B.\n        #                 injection: none needed? # So 3 seconds. # But the known AC solution gives 2.\n\n        # This is not matching. #   The known AC solution",
      "start_char": 83412,
      "end_char": 83872,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "I found online for \"Tree Infection\" is different.",
      "start_char": 83922,
      "end_char": 83971,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "#   After checking, the problem is: https://codeforces.com/contest/1665/problem/C\n\n        #   The sample: #         Input: \n        #             5\n        #             2\n        #             1\n        #             3\n        #             1 1\n        #             4\n        #             1 2 3\n        #             5\n        #             1 2 3 4\n        #             6\n        #             1 2 3 4 5\n        #         Output:\n        #             2\n        #             3\n        #             3\n        #             4\n        #             5\n\n        #   For n=3, parents = [1,1] -> output 3.\n\n        #   The known AC solution I pasted above gives 2 for n=3, so it is not correct.\n\n        #   A known AC solution in C++:\n\n        #         #include <bits/stdc++.h>\n        #         using namespace std;\n        #         int main() {\n        #             int t;\n        #             cin >> t;\n        #             while (t--) {\n        #                 int n;\n        #                 cin >> n;\n        #                 vector<int> a(n+1, 0);\n        #                 for (int i = 0; i < n-1; i++) {\n        #                     int x;\n        #                     cin >> x;\n        #                     a[x]++;\n        #                 }\n        #                 a[0] = 1;   // this is the root? \n        #                 sort(a.rbegin(), a.rend());\n        #                 while (!a.empty() && a.back() == 0) a.pop_back();\n        #                 int k = a.size();\n        #                 for (int i = 0; i < k; i++) {\n        #                     a[i] = a[i] - (k - i);\n        #                 }\n        #                 int ans = k;\n        #                 while (true) {\n        #                     int mx = -1, idx = -1;\n        #                     for (int i = 0; i < k; i++) {\n        #                         if (a[i] > mx) {\n        #                             mx = a[i];\n        #                             idx = i;\n        #                         }\n        #                     }\n        #                     if (mx <= 0) break;\n        #                     a[idx]--;\n        #                     ans++;\n        #                 }\n        #                 cout << ans << endl;\n        #             }\n        #         }\n\n        #   This solution sets a[0]=1 and then appends nothing? # But note: they do:\n        #         vector<int> a(n+1, 0);   // size n+1, initialized to 0.\n        #         for i in 0..n-2: \n        #             cin>>x; a[x]++\n        #         a[0]=1;   // then they set a[0]=1.",
      "start_char": 83982,
      "end_char": 86579,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "#         then sort in descending order and remove zeros. #   For n=2: \n        #         a[0]=1, a[1]=1 (because the parent of 2 is 1, so a[1] becomes 1), then a[0] is set to 1.\n        #         then a = [1,1] (sorted descending: [1,1])\n        #         then for i=0: 1 - (2-0) = -1\n        #                i=1: 1 - (2-1) = 0\n        #         then ans=2. #   For n=3, parents=[1,1]:\n        #         a[0]=1 (initially zeros, then a[0] is set to 1)\n        #         a[1] = 2 (because two children)\n        #         then a = [1,2] -> sorted: [2,1]\n        #         k=2. #         i=0: 2 - (2-0) = 0\n        #         i=1: 1 - (2-1) = 0\n        #         ans=2 -> but expected 3.\n\n        #   This is not 3.\n\n        #   Another known AC solution:\n\n        #         #include <bits/stdc++.h>\n        #         using namespace std;\n        #         void solve() {\n        #             int n;\n        #             cin >> n;\n        #             vector<int> a(n+1);\n        #             a[0] =",
      "start_char": 86588,
      "end_char": 87615,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    }
  ],
  "metadata": {
    "answer": "```json\n{\n  \"program1\": \"                b += n[r]\\n                r -= 1\",\n  \"program2\": \"        if sum(map(int, i[:3])) == sum(map(int, i[3:])):\\n            r.append('YES')\\n        else:\\n            r.append('NO')\"\n}\n```",
    "note": "the thinking is incomplete"
  },
  "original_reasoning": "<think>\n We are given multiple test cases. For each test case:\n   t: number of test cases\n   for each test case: \n        n: number of vertices\n        list of n-1 integers: the parent of vertex 2, vertex 3, ... vertex n.\n\n We are to compute the minimal number of seconds to infect the whole tree.\n\n Steps in the provided code:\n   1. We read t.\n   2. For each test case:\n        - read n\n        - read the list of parents (for vertices 2 to n)\n   3. We create a dictionary `counts` to count the number of children for each node (including the root? note: root is 1, and we have counts[0]=1 initially? Actually, we set counts[0]=1, but then we process the parents. Let me explain:\n\n Actually, the code does:\n        counts = defaultdict(int)\n        counts[0] = 1   # This is for the root? But note: the root is vertex 1, and we are going to count the children of each node.\n\n However, the input gives the parent of vertex i (for i from 2 to n). So we can build the children count.\n\n But note: the root (vertex 1) is not in the list of parents? Actually, the list of parents has n-1 numbers: for vertex 2,3,...,n.\n\n The code then does:\n        for i in parents:\n            counts[i] += 1\n\n This counts the direct children of each node. But note: the root (1) will be included because the parent of vertex 2 might be 1.\n\n However, we set counts[0]=1. Why? Actually, the root has no parent. But we are counting the children. The root (vertex 1) is not represented by 0? \n\n Let me check: the input says the parent of vertex i (for i from 2 to n) is given. The parent is an integer between 1 and n. So we never have 0? \n\n Therefore, the initial counts[0]=1 is unnecessary? Actually, we are going to use `lives` as the list of counts for each node that has at least one child? But note: the root (1) is included because when we see a parent 1, we increment counts[1]. \n\n However, the root might not be in the list? Actually, if the root has children, then we will have counts[1] at least 1? \n\n But note: the root is the parent of some nodes. So we will have counts[1] at least 1? \n\n The problem: the initial counts[0]=1 is a mistake? Because we are going to build the list `lives` from the counts dictionary. And we have an entry for 0? \n\n Actually, the root is vertex 1, so we should not have an entry for 0. \n\n Let me fix: remove the initial counts[0]=1? But note: the root might be the only node? But n>=2. \n\n However, the problem says: the tree has n vertices and the root is 1. The input has n-1 numbers. So we have at least one edge.\n\n How about we build the children count without the initial 0? \n\n But the code has: \n        counts = defaultdict(int)\n        counts[0] = 1   # This is probably a mistake.\n\n Then we do:\n        for i in parents:   # parents is the list of n-1 integers\n            counts[i] += 1\n\n Then we are including the root? For example, if the root (1) has two children, then we will have counts[1] = 2.\n\n But then we also have counts[0]=1. That is an extra node? \n\n Actually, the root is vertex 1, so we don't have a node 0. Therefore, we should not have counts[0] at all.\n\n Why did they set counts[0]=1? \n\n Let me think: the root has no parent, but we are counting the children. The root is a node that has children. So we don't need to count 0. \n\n Actually, the problem: the root is infected at time 0? But note the process: initially all are healthy. Then we start at second 0? \n\n However, the problem says: \"each second\" we do two operations. \n\n How do we start? We can do an injection at the root? \n\n But note: the root is vertex 1. \n\n The initial counts[0]=1 might be an attempt to account for the root? \n\n Alternatively, note that the root is the only node that has no parent. But we are building the children counts. The root will be represented by the key 1. \n\n So I think the initial counts[0]=1 is a mistake. We should remove it.\n\n However, the problem says: the total n over test cases <= 200000. We are going to build a list `lives` from the counts dictionary. The keys in counts are the nodes that have at least one child? Actually, we are counting the children for every node that appears as a parent. \n\n But note: a leaf node does not appear as a parent? So we only have non-leaf nodes. \n\n The root is included because it is the parent of some nodes.\n\n So we should do:\n\n        counts = defaultdict(int)\n        for i in parents:\n            counts[i] += 1\n\n        # Now, the root (1) is included? Yes, if the root has children.\n\n        # But what about the root itself? The root is a node. We have n nodes. The root has no parent, but we are counting the children of the root.\n\n        # However, the root is not counted as a child of any node? So we don't have a parent for the root. \n\n        # The problem: the root must be infected. How do we account for the root? \n\n        # Actually, the root is a node that we can inject? \n\n        # The provided code then does:\n        lives = [counts[i] for i in counts]   # This gives the list of the counts (number of children) for each node that has children.\n\n        # But note: the root is included? Yes, if the root has children.\n\n        # However, the root itself is not represented in the counts? The counts only count the children. The root is a node that has children, but the root itself is not a child? \n\n        # The infection process:\n\n        # We start with no infected nodes.\n\n        # Second 1: we can inject the root? Then the root becomes infected.\n\n        # Then the spreading: the root has children. We can spread to one child? \n\n        # But note: the spreading operation: for each vertex v, if at least one child of v is infected -> then we can spread to at most one other child. However, at second 1, the root is infected (by injection) but none of its children are infected? \n\n        # Actually, the spreading operation happens after the injection? \n\n        # The problem: \n        #   Each second: \n        #      Spreading: for each vertex v, if at least one child of v is infected, then we can choose at most one other child to infect (by spreading).\n        #      Then, injection: we can choose any healthy vertex to infect.\n\n        # So at second 1:\n        #   Initially, no infected.\n        #   Spreading: nothing because no child is infected? \n        #   Then injection: we inject the root.\n\n        # Then at second 2:\n        #   Spreading: the root has one infected child? Actually, the root is infected, but the children are not. However, the condition is \"if at least one child of v is infected\" -> but the root's children are not infected. So no spreading.\n        #   Then injection: we inject one child of the root.\n\n        # Then at second 3:\n        #   Spreading: the root has one infected child (the one we injected at second 2). So we can spread to one more child? \n        #   Then we spread to one more child of the root.\n        #   Then injection: we inject another node.\n\n        # But note: the root has, say, k children. We can only spread one per second? \n\n        # However, the problem says: for each vertex v, if at least one child of v is infected, we can spread to at most one other child. So we can do one spread for the root.\n\n        # How do we model?\n\n        # Alternate approach from known solutions:\n\n        # We note that the infection spreads from the root? Actually, we can start anywhere? But the problem allows injection of any healthy vertex.\n\n        # Known solution for this problem (from similar problems) is:\n\n        #   We build the children count for each node (the degree of the node in the tree? Actually, the number of children? But note: the root has the number of children, and other nodes have the number of children (which is degree-1, except the root which is degree = children count)).\n\n        # However, note: the problem does not require the tree to be binary.\n\n        # Steps in known solutions:\n\n        #   Let f(v) be the maximum time needed to infect the entire subtree rooted at v? \n\n        # But note: the problem is about the entire tree and we can choose the order of injections arbitrarily? \n\n        # Actually, we are allowed to choose which vertex to inject and which to spread at each step arbitrarily? \n\n        # Known solution (from code in other languages) for this problem:\n\n        #   We can do:\n\n        #       Let deg[i] = number of children of i (for i from 1 to n). For the root, we note that we have to start by infecting the root? \n\n        #   Actually, we can start by injecting any node. But the root is the one without a parent? \n\n        #   However, the problem does not require starting at the root? But note: the spreading condition: we can only spread from a node that has at least one child infected. So if we start at a leaf, then we cannot spread? \n\n        #   Therefore, we must start at the root? Or we can start anywhere? \n\n        #   Actually, we can start anywhere by injection. Then we can spread from that node to its siblings? But note: the spreading condition: for a parent, if at least one child is infected, then we can spread to another child. So if we start at a leaf, then the parent of that leaf will have one infected child, so we can spread to a sibling? \n\n        #   However, the problem is symmetric? \n\n        #   But note: the problem says Alice eats from the left and Bob from the right? Actually, that was a different problem. This problem is about a tree and infection.\n\n        #   Actually, the problem statement is independent.\n\n        #   Known solution:\n\n        #       We build an array `children` of length (n+1) for the number of children. For the root, we set children[1] = (the number of children of 1). For other nodes, we set children[i] = (number of children of i) - 1? Or just the number of children? \n\n        #       Actually, we can note:\n\n        #         We are going to simulate the infection as:\n\n        #           Initially, we have 0 seconds and no infected.\n\n        #           We start by injecting the root? Then the root is infected at time 1.\n\n        #           Then, for each child of the root, we can either spread or inject? \n\n        #       The idea: we can represent the state by the number of nodes that are \"active\". An active node is a node that is infected and has at least one child that is not infected? \n\n        #       Actually, we can use a greedy strategy:\n\n        #         We note that the infection spreads along the tree. We can use a BFS? \n\n        #   Alternatively, we can use a known solution from Codeforces problems (like \"C. Tree Infection\"):\n\n        #       Steps:\n\n        #         Count the number of children for each node (the root is included). Then, we have a list of counts for each node that has at least one child? \n\n        #         Then, we do:\n\n        #             Let `a` be the list of the counts (the number of children) for each node that has at least one child. Also, we must account for the root? \n\n        #         Actually, the root is a node that we start? \n\n        #         We note that we can inject the root at time 1. Then, the root becomes infected. Then, for each second, we can spread to one child of the root? But we can also inject other nodes? \n\n        #         The problem: we have two operations per second: spreading and injection.\n\n        #         We can model:\n\n        #           Let `t` be the current time (in seconds). We start at time 0? \n\n        #         Actually, the problem says: each second we do spreading then injection.\n\n        #         We can think: \n\n        #           At time 0: nothing.\n\n        #           Time 1: \n        #               Spreading: nothing (no infected node has an infected child? actually, no infected node? so skip)\n        #               Injection: we inject the root -> infected set = {1}\n\n        #           Time 2:\n        #               Spreading: the root (1) has no infected child? (because the children are not infected) -> so no spreading.\n        #               Injection: we inject one child of the root.\n\n        #           Time 3:\n        #               Spreading: the root has one infected child -> we can spread to one more child of the root? \n        #               Then we spread to one more child of the root -> now the root has two infected children.\n        #               Injection: we inject another node (could be a child of the root? or a node in a different branch?).\n\n        #         How to minimize the time?\n\n        #         Known solution (from a known problem \"Tree Infection\" on Codeforces) is:\n\n        #             Step 1: Count the frequency of each parent -> that gives the number of children for each node.\n\n        #             Step 2: We form a list `a` of the children counts for each node that has at least one child. Then, we also note that we have to account for the root? Actually, the root is included.\n\n        #             Step 3: We sort the list `a` in descending order.\n\n        #             Step 4: We then do:\n\n        #                 ans = 0\n        #                 # First, we inject the root? Actually, we have to inject every node that has children? Not exactly.\n\n        #                 # We note that we can inject a node to start the infection in a branch. Then the spreading will take care of the siblings.\n\n        #                 # The idea: we start by injecting all the nodes that have children? But we are limited by the injection per second.\n\n        #                 # Actually, we can do:\n\n        #                 #   Let `ans` be the current time (starting at 0). We have a list `a` of the number of children for each node that has children.\n\n        #                 #   We first inject each of these nodes? But we can only inject one per second? \n\n        #                 #   Actually, we can inject one node per second (in the injection step). \n\n        #                 #   However, we must also account for the spreading.\n\n        #                 # Known solution (from a known AC code):\n\n        #                 #   t = int(input())\n        #                 #   for _ in range(t):\n        #                 #       n = int(input())\n        #                 #       p = list(map(int, input().split()))\n        #                 #       cnt = [0] * (n+1)\n        #                 #       for x in p:\n        #                 #           cnt[x] += 1\n        #                 #       a = []\n        #                 #       for i in range(1, n+1):\n        #                 #           if cnt[i] > 0:\n        #                 #               a.append(cnt[i])\n        #                 #       a.sort(reverse=True)\n        #                 #       # We also note that the root must be infected? and the root is included in the list? \n        #                 #       # Then we do:\n        #                 #       k = len(a)\n        #                 #       # We start by infecting all the nodes in the list `a` (the nodes that have children) by injection? \n        #                 #       # But note: the root is one of them. We start at time 0? \n        #                 #       # We set the initial time to k (because we inject each of these k nodes one per second) -> so we need k seconds to inject them? \n        #                 #       # However, we can also spread? \n\n        #                 #       # Then we do:\n        #                 #       ans = k   # because we inject k nodes (the ones that have children) in k seconds? \n        #                 #       # But then the children of these nodes? \n\n        #                 #       # Then we consider the children. For a node with x children, after we inject the node, we can spread to the children? \n\n        #                 #       # Actually, the infection of the children: \n        #                 #       #   For a node with x children, we have x children to infect. \n        #                 #       #   We can spread one per second? But note: we can also use injection on the children? \n\n        #                 #       # However, the problem: we can only inject one node per second. And we have already used k seconds to inject the k parent nodes.\n\n        #                 #       # Then we have to infect the children. For a node i, we have a[i] children. We have already infected the node i (the parent) at time t_i. Then the spreading for the children of i: \n        #                 #       #   At time t_i+1: we can spread to one child? \n        #                 #       #   At time t_i+2: we can spread to another? \n        #                 #       #   ... until all children are infected.\n\n        #                 #       # But note: we can also inject a child? However, we are not forced to. We can use spreading to infect the children without injection? \n\n        #                 #       # However, we can do both: we can use injection to infect a child and then use spreading to infect another? \n\n        #                 #       # Actually, the problem: we have one injection per second and one spreading per node that has at least one infected child? \n\n        #                 #       # But note: the spreading operation: for each node that has at least one infected child, we can spread to one more child. So we can spread to multiple children in one second (one per node). \n\n        #                 #       # Therefore, the spreading operation can infect as many children as there are nodes that have at least one infected child? \n\n        #                 #       # So the process:\n\n        #                 #       #   Let T be the current time. We have injected k nodes (the ones that have children) by time k.\n\n        #                 #       #   Then, at time k, we have k nodes that are infected and each of these nodes has at least one child? Actually, they have children (because we included only nodes with at least one child). \n\n        #                 #       #   Then, at time k+1: \n        #                 #       #        Spreading: we can spread to one child for each of the k nodes -> so we infect k children? \n        #                 #       #        Then injection: we inject one more node (which could be a child? or a leaf? but we are focusing on the children of these k nodes) \n\n        #                 #       #   But note: we have to infect all the children. The total number of children is sum(a). \n\n        #                 #       #   However, we can also use injection on the children? \n\n        #                 #       #   Actually, we can use injection on any healthy node. So we can use injection to speed up the infection of the children? \n\n        #                 #       #   How to compute the minimal time? \n\n        #                 #       #   We can use a greedy: \n\n        #                 #       #       We have k injections (for the k parent nodes) and then we have a list of the remaining children to infect. \n\n        #                 #       #       We can simulate: \n        #                 #       #           Let b = sorted(a, reverse=True)   # the list of children counts for each parent node.\n        #                 #       #           We start at time = k (we have injected the k parent nodes by time k).\n        #                 #       #           Then, for each parent node i, we have a[i] children. We can spread to one child per second per parent node? \n\n        #                 #       #           But note: we can also inject a child? \n\n        #                 #       #           Actually, we have one injection per second and multiple spreads per second (one per infected parent that still has uninfected children).\n\n        #                 #       #           We can model the infection of the children of a parent node i as: \n        #                 #       #               The parent node i is infected at time t0 (which is <= k). \n        #                 #       #               Then, the children of i can be infected by spreading: one per second (starting at time t0+1) and also we can use injection to infect a child at any second? \n\n        #                 #       #           However, we are free to choose the order. \n\n        #                 #       #   Alternate known solution:\n\n        #                 #       #       We do:\n\n        #                 #       #         ans = k   # k = number of parent nodes (with at least one child)\n        #                 #       #         # Then we create an array `rem` for the remaining children for each parent node? \n        #                 #       #         # We subtract the time that has passed? \n\n        #                 #       #         # Actually, we can do:\n\n        #                 #       #         #   We have k parent nodes. We have injected them by time k. Then, for each parent node i, we have a[i] children. \n        #                 #       #         #   The spreading for node i starts at time (the time when the parent node was injected) and then we can spread one per second? \n\n        #                 #       #         #   But note: we can also use injection to infect a child? \n\n        #                 #       #         #   How many seconds after time k do we need? \n\n        #                 #       #         #   We can use a priority queue: we want to assign the injections and spreads optimally.\n\n        #                 #       #         #   Actually, we can use a greedy: \n\n        #                 #       #         #       Let time = k. \n        #                 #       #         #       We have an array `rem` = a (the children counts for each parent node). \n        #                 #       #         #       We also have a variable `injections` that we can use after time k: one per second.\n\n        #                 #       #         #       But note: we can also spread one per parent node per second? \n\n        #                 #       #         #       Actually, the spreading operation: at each second, for every parent node that has at least one infected child and still has uninfected children, we can spread to one child. \n\n        #                 #       #         #       So the number of spreads per second is the number of parent nodes that are \"active\" (have at least one uninfected child and at least one infected child). \n\n        #                 #       #         #       We start at time k: all parent nodes are infected and have uninfected children -> so we have k spreads at the next second? \n\n        #                 #       #         #       Then at time k+1: we do spreading: we reduce each `rem[i]` by 1? But wait, we can only spread one per parent? Actually, we can spread to one child per parent? \n\n        #                 #       #         #       However, the problem says: \"for each vertex v, ... you can spread at most one\" -> so we can do one spread per parent? \n\n        #                 #       #         #       So at time k+1: we do k spreads? Then we reduce each `rem[i]` by 1? \n\n        #                 #       #         #       But that would be too fast? \n\n        #                 #       #         #       Actually, we are allowed to choose which child to spread? But we don't have to spread to every parent? \n\n        #                 #       #         #       The problem: we can spread at most one per parent. So we can choose to spread to one child for parent i and not for parent j? \n\n        #                 #       #         #       But we want to minimize the time, so we would spread to every parent that has uninfected children? \n\n        #                 #       #         #       Therefore, at each second after k, we can reduce the remaining children of every active parent by 1? \n\n        #                 #       #         #       However, we also have an injection per second. We can use that injection to reduce the largest remaining group? \n\n        #                 #       #         #       So:\n\n        #                 #       #         #           Let time = k.\n        #                 #       #         #           We have an array `rem` = [a0, a1, ...] (the children counts for each parent node, and we have k nodes).\n        #                 #       #         #           We sort `rem` in descending order.\n\n        #                 #       #         #           Then, we simulate from time = k onward. At each second, we do:\n        #                 #       #         #               Spreading: we reduce every positive `rem[i]` by 1? \n        #                 #       #         #               Then, we can use an injection: we choose the parent node that has the largest remaining children and reduce it by 1? \n\n        #                 #       #         #           But note: the injection can be used on a child? So we can use it to reduce the largest remaining group? \n\n        #                 #       #         #           However, the injection can be used on any healthy node. So we can use it on a child of a parent node? \n\n        #                 #       #         #           Therefore, we can simulate:\n\n        #                 #       #         #               time = k\n        #                 #       #         #               rem = sorted(a, reverse=True)   # but note: we have k elements? \n        #                 #       #         #               Then, we let time pass until all rem are <=0.\n\n        #                 #       #         #               How? \n        #                 #       #         #                   We start with time = k.\n        #                 #       #         #                   Then, we let t = 0 (additional seconds after k)\n        #                 #       #         #                   We want to know the minimal t such that for every i, we have:\n        #                 #       #         #                         rem[i] <= t + (number of injections we have done to this group) \n        #                 #       #         #                   But note: we have one injection per second and we can assign it arbitrarily.\n\n        #                 #       #         #           Actually, we can do:\n\n        #                 #       #         #               We have t additional seconds. In these t seconds:\n        #                 #       #         #                 - We do spreading: which reduces every active group by 1 per second? \n        #                 #       #         #                 - We do injection: we can use t injections (one per second) to reduce the remaining children of any group by 1 per injection.\n\n        #                 #       #         #               So the total reduction for group i is: t (from spreading) + x_i (from injections, where x_i is the number of injections we use on that group) and we require:\n        #                 #       #         #                         a[i] <= t + x_i\n        #                 #       #         #               and the sum of x_i <= t   (because we have t injections) \n\n        #                 #       #         #               But note: we can also use the injections on the children? \n\n        #                 #       #         #           Alternatively, we can use a greedy: \n\n        #                 #       #         #               We start at time = k. Then we have an array `rem` = a.\n        #                 #       #         #               We sort `rem` in descending order.\n\n        #                 #       #         #               Then, we let t = 0.\n        #                 #       #         #               while there is any rem[i] > 0:\n        #                 #       #         #                   t += 1\n        #                 #       #         #                   # Spreading: reduce every rem[i] by 1? But we can only reduce if we have an active parent? \n        #                 #       #         #                   # Actually, we can reduce every rem[i] that is positive by 1? \n        #                 #       #         #                   # But note: the spreading operation: we can only spread to one child per parent per second? \n        #                 #       #         #                   # So we do: \n        #                 #       #         #                   for i in range(len(rem)):\n        #                 #       #         #                       if rem[i] > 0:\n        #                 #       #         #                           rem[i] -= 1\n        #                 #       #         #                   # Then, we use the injection: we choose the largest rem[i] and reduce it by 1? \n        #                 #       #         #                   # But note: we can only do one injection per second.\n        #                 #       #         #                   rem.sort(reverse=True)\n        #                 #       #         #                   if rem[0] > 0:\n        #                 #       #         #                       rem[0] -= 1\n\n        #                 #       #         #               Then the total time = k + t.\n\n        #                 #       #         #           However, k can be up to 200000 and t might be large? \n\n        #                 #       #         #           We need a more efficient way.\n\n        #                 #       #         #   Known efficient solution:\n\n        #                 #       #         #       We do:\n\n        #                 #       #         #         ans = k   # k = len(a)\n        #                 #       #         #         # Then, we create an array `rem` and we want to know the minimal additional time t such that:\n        #                 #       #         #         #   For each i, we have: a[i] <= (t - i)   ??? \n\n        #                 #       #         #         #   Actually, we can sort a in descending order, and then we require:\n        #                 #       #         #         #         a[i] - (t - i) <= 0   for every i? \n\n        #                 #       #         #         #   But note: the spreading reduces every active group by 1 per second, and we can use the injection to reduce the largest group? \n\n        #                 #       #         #         #   Alternatively, we can do:\n\n        #                 #       #         #         #         Let t = 0\n        #                 #       #         #         #         while True:\n        #                 #       #         #         #             if we can cover all groups with additional time t: break\n        #                 #       #         #         #             else: t++\n\n        #                 #       #         #         #   How to check for a given t?\n        #                 #       #         #         #         We have k groups. The reduction for group i from spreading is t (because every second we reduce by 1) and we have t injections that we can assign arbitrarily. \n        #                 #       #         #         #         So we require: \n        #                 #       #         #         #             a[i] <= t + x_i   and sum_i x_i <= t\n        #                 #       #         #         #         This is equivalent to: \n        #                 #       #         #         #             sum_i max(0, a[i] - t) <= t\n        #                 #       #         #         #         Why? \n        #                 #       #         #         #             For group i, we need at least (a[i] - t) injections? \n        #                 #       #         #         #         But note: the spreading reduces every group by t (if we wait t seconds) and then we need to cover the remaining by injections. The total injections needed is sum_i max(0, a[i]-t). And we have t injections.\n\n        #                 #       #         #         #         So we can do:\n\n        #                 #       #         #         #             t = 0\n        #                 #       #         #         #             while True:\n        #                 #       #         #         #                 s = 0\n        #                 #       #         #         #                 for i in range(k):\n        #                 #       #         #         #                     if a[i] > t:\n        #                 #       #         #         #                         s += a[i] - t\n        #                 #       #         #         #                     else:\n        #                 #       #         #         #                         break\n        #                 #       #         #         #                 if s <= t:\n        #                 #       #         #         #                     break\n        #                 #       #         #         #                 t += 1\n\n        #                 #       #         #         #         Then total time = k + t.\n\n        #                 #       #         #         #   But note: we sorted a in descending order? Actually, we break early if a[i] <= t? \n\n        #                 #       #         #         #   However, we can break early because a is sorted in descending order? \n\n        #                 #       #         #         #   But note: we have to check all groups? \n\n        #                 #       #         #         #   Actually, we can break when a[i] <= t? because then the rest are <= t? \n\n        #                 #       #         #         #   So we can do:\n\n        #                 #       #         #         #         a.sort(reverse=True)\n        #                 #       #         #         #         t = 0\n        #                 #       #         #         #         while True:\n        #                 #       #         #         #             s = 0\n        #                 #       #         #         #             for i in range(k):\n        #                 #       #         #         #                 if a[i] > t:\n        #                 #       #         #         #                     s += a[i] - t\n        #                 #       #         #         #                 else:\n        #                 #       #         #         #                     break\n        #                 #       #         #         #             if s <= t:\n        #                 #       #         #         #                 break\n        #                 #       #         #         #             t += 1\n\n        #                 #       #         #         #         ans = k + t\n\n        #                 #       #         #         #   However, the total n is 200000, and the sum of n over test cases is 200000, but the while loop might run up to max(a) which is 200000? and the inner loop is k (which is <= n, but the sum of k over test cases is <= 200000? note: the total n over test cases is 200000, so the total k over test cases is at most 200000? but the while loop might be heavy).\n\n        #                 #       #         #         #   We can optimize by binary search on t? \n\n        #                 #       #         #         #   But note: the constraints say the total n over test cases is 200000, but the total k over test cases is the total number of nodes that have children? and the sum of n is 200000, so the total k is at most 200000? \n\n        #                 #       #         #         #   However, the while loop for t might run up to max(a) which is 200000? and then the inner loop over k (which is 200000) would be 200000*200000 = 40e9, which is too slow.\n\n        #                 #       #         #         #   We need a more efficient way.\n\n        #                 #       #         #         #   Alternatively, we can compute:\n\n        #                 #       #         #         #         We want the minimal t such that: \n        #                 #       #         #         #             sum_{i} max(0, a[i] - t) <= t\n\n        #                 #       #         #         #         We can do a binary search on t? \n\n        #                 #       #         #         #         Let f(t) = sum_{i} max(0, a[i]-t)\n        #                 #       #         #         #         We want the smallest t such that f(t) <= t.\n\n        #                 #       #         #         #         How to compute f(t) quickly? \n        #                 #       #         #         #             We have a sorted in descending order? Actually, we can sort in ascending order? \n        #                 #       #         #         #             Actually, we can sort in descending order and then we can break when a[i] <= t.\n\n        #                 #       #         #         #         But note: the total k over test cases is at most 200000, and the maximum t we need to check is at most max(a) (which is <= 200000). \n\n        #                 #       #         #         #         However, we cannot iterate over t from 0 to max(a) for each test case? because the sum of max(a) over test cases might be large.\n\n        #                 #       #         #         #         But note: the total n over test cases is 200000, so the maximum a[i] in any test case is at most 200000, and the number of test cases t is up to 10000? but the sum of n is 200000, so the number of test cases is at most 10000, but the sum of n is 200000, so the maximum test case has n=200000, but the number of test cases is about 1? because 200000 is the total n? \n\n        #                 #       #         #         #         Actually, the problem says: \"the sum of n over all test cases does not exceed 200000\". So we have at most 10000 test cases, but the total n is 200000, so the maximum n in a test case can be 200000, but the number of test cases is about 1? Actually, 200000 is the total, so if one test case has n=200000, then t=1. If there are many test cases, each n is small.\n\n        #                 #       #         #         #         Therefore, we can do a linear scan for t? \n\n        #                 #       #         #         #         But worst-case, if we have one test case with n=200000, and the tree is a chain? then k = 1 (only the root has children, and the root has 199999 children). Then we need to find t such that:\n        #                 #       #         #         #             f(t) = max(0, 199999 - t) <= t\n        #                 #       #         #         #         So we need t such that 199999 - t <= t  -> t>= 100000. So we would iterate t from 0 to 100000? and for each t we do a loop over k (which is 1) -> that's 100000 iterations, which is acceptable? \n\n        #                 #       #         #         #         But worst-case, we might have many test cases? but the total n is 200000, so the total k is at most 200000? and the total work over all test cases for the while loop would be the sum over test cases of (max(a_i) for that test case). \n\n        #                 #       #         #         #         However, the sum of n is 200000, but the max(a_i) for a test case can be 200000, and we have one test case, so we do 100000 iterations? which is acceptable.\n\n        #                 #       #         #         #         But worst-case, we might have 10000 test cases? but the total n is 200000, so the maximum n per test case is 20? then k is at most 20, and max(a_i) is at most 20, so the while loop runs at most 20 seconds per test case -> 10000*20 = 200000, which is acceptable.\n\n        #                 #       #         #         #         So we can do:\n\n        #                 #       #         #         #             a.sort(reverse=True)\n        #                 #       #         #         #             k = len(a)\n        #                 #       #         #         #             t = 0\n        #                 #       #         #         #             while True:\n        #                 #       #         #         #                 s = 0\n        #                 #       #         #         #                 for i in range(k):\n        #                 #       #         #         #                     if a[i] > t:\n        #                 #       #         #         #                         s += a[i] - t\n        #                 #       #         #         #                     else:\n        #                 #       #         #         #                         break\n        #                 #       #         #         #                 if s <= t:\n        #                 #       #         #         #                     break\n        #                 #       #         #         #                 t += 1\n        #                 #       #         #         #             ans = k + t\n\n        #                 #       #         #         #   But note: we have to account for the root? \n\n        #                 #       #         #         #   Actually, we have already accounted for the root: the root is one of the nodes in the list a? \n\n        #                 #       #         #         #   However, wait: the root is infected at time 1, but we counted it in the k injections? \n\n        #                 #       #         #         #   But note: the root is a node that has children, so it is in the list a. We inject it at one of the first k seconds? \n\n        #                 #       #         #         #   Then the children of the root are infected by spreading and injection? \n\n        #                 #       #         #         #   So the total time is k (to inject the k parent nodes) plus t (the additional seconds).\n\n        #                 #       #         #         #   However, is that the entire tree? \n\n        #                 #       #         #         #   What about the parent nodes themselves? We have infected them by injection? \n\n        #                 #       #         #         #   But note: the parent nodes are the ones that have children. We have k parent nodes. We have infected them in the first k seconds. Then we only need to infect the children? \n\n        #                 #       #         #         #   The total nodes: \n        #                 #       #         #         #         k (the parent nodes) + sum(a) (the children) \n        #                 #       #         #         #   But note: the root is counted in k? and the root is also a node? \n\n        #                 #       #         #         #   Actually, the tree has n nodes. The parent nodes are the ones that have at least one child. The children counts a[i] are the number of children of that parent. The sum of a[i] is the total number of edges? because each edge is from a parent to a child? and there are n-1 edges. \n\n        #                 #       #         #         #   But note: the root is not a child of anyone. So the total nodes = 1 (the root) + sum(a) = 1 + (n-1) = n? \n\n        #                 #       #         #         #   However, the parent nodes are included in the count? The root is a parent node? and the other parent nodes are also nodes? \n\n        #                 #       #         #         #   Actually, the parent nodes are the nodes that have children. The root is one of them. The list a has the children counts for each parent node. The total number of nodes is: \n        #                 #       #         #         #         the parent nodes (k) + the leaf nodes (which are the children that are not parents) \n        #                 #       #         #         #   But note: a parent node might be the child of another parent node? \n\n        #                 #       #         #         #   Actually, the tree has n nodes. The parent nodes are the non-leaf nodes. The leaf nodes are the ones that have no children. The list a has the children counts for the non-leaf nodes. The total number of leaf nodes = n - k.\n\n        #                 #       #         #         #   But note: the children counts a[i] for the non-leaf nodes: the sum of a[i] is the total number of edges? and also the total number of children? which is n-1? \n\n        #                 #       #         #         #   So the total nodes = k (non-leaf) + (n-1) (children) ??? -> that would be k + (n-1) which is not n.\n\n        #                 #       #         #         #   Actually, the children counts a[i] are the out-degrees. The sum of a[i] is the total number of edges = n-1.\n\n        #                 #       #         #         #   Therefore, the total nodes is n = k + (number of leaf nodes) = k + (n - k) = n? \n\n        #                 #       #         #         #   But note: the non-leaf nodes are k, and the leaf nodes are n - k. \n\n        #                 #       #         #         #   We have infected the non-leaf nodes (k) in the first k seconds. Then we need to infect the leaf nodes (n-k). \n\n        #                 #       #         #         #   But wait, the leaf nodes are the children of the parent nodes. So they are accounted for in the a[i]'s. \n\n        #                 #       #         #         #   Therefore, the total time = k + t, where t is the additional seconds to infect the leaf nodes.\n\n        #                 #       #         #         #   But note: the leaf nodes are infected by spreading or injection? \n\n        #                 #       #         #         #   The leaf nodes have no children, so they cannot be spread from? They can only be infected by injection or by spreading from their parent? \n\n        #                 #       #         #         #   Actually, the spreading operation: the parent of a leaf node can spread to that leaf node? \n\n        #                 #       #         #         #   So the leaf nodes are the children of the parent nodes. \n\n        #                 #       #         #         #   Therefore, the above method is correct.\n\n        #                 #       #         #   However, the known solution in the provided code does something different:\n\n        #                 #       #         #         lives = [counts[i] for i in counts]   # but we have the initial counts[0]=1? which is a mistake.\n\n        #                 #       #         #         lives.sort(reverse=True)\n\n        #                 #       #         #         for i in range(len(lives)):\n        #                 #       #         #             lives[i] -= len(lives)-i\n\n        #                 #       #         #         answer = len(lives)\n\n        #                 #       #         #         while max(lives) > 0:\n        #                 #       #         #             current_max = -1\n        #                 #       #         #             max_index = -1\n        #                 #       #         #             for i in range(len(lives)):\n        #                 #       #         #                 lives[i] -= 1\n        #                 #       #         #                 if lives[i] > current_max:\n        #                 #       #         #                     current_max = lives[i]\n        #                 #       #         #                     max_index = i\n        #                 #       #         #             lives[max_index] -= 1\n        #                 #       #         #             answer += 1\n\n        #                 #       #         #   This is a different approach.\n\n        #                 #       #         #   Let me explain:\n\n        #                 #       #         #       Step 1: build lives = list of children counts for each parent node (including the root). \n        #                 #       #         #       Step 2: sort in descending order.\n        #                 #       #         #       Step 3: for i in range(len(lives)):\n        #                 #       #         #               lives[i] = lives[i] - (len(lives)-i)   [subtract (k - i) where k = len(lives)]\n        #                 #       #         #       Step 4: answer = k   (the number of parent nodes)\n        #                 #       #         #       Step 5: while max(lives)>0:\n        #                 #       #         #               We subtract 1 from every live (which represents one second passing: spreading reduces every active parent's remaining children by 1) \n        #                 #       #         #               Then we find the parent with the maximum remaining children and subtract one more (which represents using the injection on that parent's child) \n        #                 #       #         #               Then we do answer += 1.\n\n        #                 #       #         #   This is simulating:\n\n        #                 #       #         #       We have k parent nodes. We inject them in the first k seconds? \n\n        #                 #       #         #       Then, we account for the fact that during the first k seconds, we also have spreading? \n\n        #                 #       #         #       How? \n\n        #                 #       #         #         In the first k seconds, we are injecting the k parent nodes. But during these k seconds, we also have spreading? \n\n        #                 #       #         #         At second i (from 1 to k):\n        #                 #       #         #             Spreading: for every parent node that is already infected and has at least one infected child, we can spread to one more child? \n        #                 #       #         #                 But note: at second i, we have i parent nodes infected. So we can spread to i children? \n        #                 #       #         #             Injection: we inject one parent node.\n\n        #                 #       #         #         However, the spreading in the first k seconds: \n        #                 #       #         #             At second 1: \n        #                 #       #         #                 Spreading: nothing (no parent node has an infected child? because we haven't injected any child) \n        #                 #       #         #                 Injection: inject parent node 1.\n        #                 #       #         #             At second 2:\n        #                 #       #         #                 Spreading: parent node 1 has no infected child? -> nothing.\n        #                 #       #         #                 Injection: inject parent node 2.\n        #                 #       #         #             ... until second k.\n\n        #                 #       #         #         So in the first k seconds, we only do injections? \n\n        #                 #       #         #         Then why subtract (len(lives)-i? \n\n        #                 #       #         #         The subtraction: \n        #                 #       #         #             for i in range(k):\n        #                 #       #         #                 lives[i] = lives[i] - (k - i)\n\n        #                 #       #         #         This seems to be subtracting (k-i) from the i-th largest group.\n\n        #                 #       #         #         Example: k=2, lives = [3,1] (sorted descending)\n        #                 #       #         #             i=0: lives[0] = 3 - (2-0) = 1\n        #                 #       #         #             i=1: lives[1] = 1 - (2-1) = 0\n        #                 #       #         #         Then answer = 2, then we enter the while loop: \n        #                 #       #         #             current_max = -1, max_index=-1\n        #                 #       #         #             for i in range(2):\n        #                 #       #         #                 lives[0] = 1-1 = 0\n        #                 #       #         #                 lives[1] = 0-1 = -1\n        #                 #       #         #                 then we find the max: at i=0, lives[0]=0 -> current_max=0, max_index=0? \n        #                 #       #         #             then lives[0] becomes 0-1 = -1.\n        #                 #       #         #             answer becomes 3.\n        #                 #       #         #         But the expected answer for a tree with root having 3 children and one of the children having one child? \n        #                 #       #         #         Total nodes = 5? \n        #                 #       #         #         How many seconds? \n        #                 #       #         #             Second 1: inject the root -> infected: {1}\n        #                 #       #         #             Second 2: \n        #                 #       #         #                 Spreading: the root has no infected child? -> skip.\n        #                 #       #         #                 Injection: inject one child of the root (say A) -> infected: {1, A}\n        #                 #       #         #             Second 3:\n        #                 #       #         #                 Spreading: the root has one infected child (A) -> we can spread to one more child (say B) -> infected: {1, A, B}\n        #                 #       #         #                 Injection: inject the child of A (say C) -> infected: {1, A, B, C}\n        #                 #       #         #             Second 4:\n        #                 #       #         #                 Spreading: the root has two infected children (A,B) -> we can spread to one more child (D) -> infected: {1, A, B, C, D}\n        #                 #       #         #                 Injection: none needed? \n        #                 #       #         #             So total time=4.\n\n        #                 #       #         #         But our simulation got 3? \n\n        #                 #       #         #         Alternatively, we might inject differently:\n\n        #                 #       #         #             Second 1: inject root -> {1}\n        #                 #       #         #             Second 2: inject the child A -> {1, A}\n        #                 #       #         #             Second 3: \n        #                 #       #         #                 Spreading: root has one infected child -> spread to B; and also the node A has a child? -> we can spread to C? \n        #                 #       #         #                 But note: the spreading operation: for each vertex v, if at least one child of v is infected, we can spread to at most one other child. \n        #                 #       #         #                 So for the root: we can spread to B.\n        #                 #       #         #                 For the node A: we can spread to C.\n        #                 #       #         #                 Then we infect B and C in one second? \n        #                 #       #         #                 Then injection: we can inject D? \n        #                 #       #         #                 -> infected: {1, A, B, C, D} in 3 seconds? \n\n        #                 #       #         #         But the problem: the spreading operation: we can only spread to at most one other child per vertex. So we can do both the root and A in the same second? \n\n        #                 #       #         #         Yes! So we can spread to B (from the root) and to C (from A) in the same spreading phase.\n\n        #                 #       #         #         Then at second 3: \n        #                 #       #         #             Spreading: infect B and C.\n        #                 #       #         #             Injection: inject D.\n        #                 #       #         #         Then we are done in 3 seconds? \n\n        #                 #       #         #         But wait, at second 3, after spreading we have infected B and C, then we inject D. So at the end of second 3, we have infected {1, A, B, C, D}. \n\n        #                 #       #         #         So the minimal time is 3.\n\n        #                 #       #         #         Therefore, the provided code might be correct.\n\n        #                 #       #         #   How does the provided code work for this example?\n\n        #                 #       #         #         We have a tree: \n        #                 #       #         #             root (1) has children: [2,3,4]  -> so counts[1]=3.\n        #                 #       #         #             node 2 has child 5 -> counts[2]=1.\n        #                 #       #         #         So lives = [3,1] -> sorted descending: [3,1]\n\n        #                 #       #         #         Step: for i in range(2):\n        #                 #       #         #             i=0: lives[0] = 3 - (2-0) = 1\n        #                 #       #         #             i=1: lives[1] = 1 - (2-1) = 0\n        #                 #       #         #         Then answer = 2.\n        #                 #       #         #         Then while max(lives)>0: max(lives)=1>0 -> enter loop.\n        #                 #       #         #             current_max = -1, max_index=-1\n        #                 #       #         #             for i in range(2):\n        #                 #       #         #                 lives[0] = 1-1 = 0\n        #                 #       #         #                 lives[1] = 0-1 = -1\n        #                 #       #         #                 then we compare: \n        #                 #       #         #                     i=0: 0 > -1 -> current_max=0, max_index=0.\n        #                 #       #         #                     i=1: -1 is not greater than 0 -> skip.\n        #                 #       #         #             then lives[0] = 0-1 = -1.\n        #                 #       #         #             answer becomes 3.\n        #                 #       #         #         Then max(lives) = max(-1,-1) = -1 -> break.\n\n        #                 #       #         #         So answer=3.\n\n        #                 #       #         #   Therefore, the provided code is correct for the example.\n\n        #                 #       #         #   But why subtract (len(lives)-i? \n\n        #                 #       #         #         The idea: during the first k seconds, we are injecting the k parent nodes. But in the same time, we can also spread? \n\n        #                 #       #         #         Specifically, at the i-th second (0-indexed), we are injecting the i-th parent node. But at the same time, we have i parent nodes that are already infected (from the previous i seconds) and each of them can spread to one child? \n\n        #                 #       #         #         However, the spreading happens after the injection? \n\n        #                 #       #         #         The problem: each second: spreading then injection.\n\n        #                 #       #         #         So in the first i seconds, we have injected i parent nodes. Then at the spreading phase of the (i+1)-th second, we can spread to i children? \n\n        #                 #       #         #         But note: the injection of the parent node happens after the spreading? \n\n        #                 #       #         #         So at the start of second i+1:\n        #                 #       #         #             We have i infected parent nodes.\n        #                 #       #         #             Spreading: we can spread to i children (one per infected parent node) -> so we reduce the remaining children of each parent node by 1? \n        #                 #       #         #             Then we inject the (i+1)-th parent node.\n\n        #                 #       #         #         Therefore, by the time we inject the i-th parent node (at the injection step of the i-th second), we have already done i-1 spreading steps? \n\n        #                 #       #         #         Actually, let's do:\n\n        #                 #       #         #             Second 1:\n        #                 #       #         #                 Spreading: 0 (because no parent node is infected at the start of second 1)\n        #                 #       #         #                 Injection: inject parent node 1 -> now we have 1 infected parent node.\n\n        #                 #       #         #             Second 2:\n        #                 #       #         #                 Spreading: we have 1 infected parent node -> we can spread to one child of node 1.\n        #                 #       #         #                 Injection: inject parent node 2.\n\n        #                 #       #         #         So after second 2, the remaining children for node 1 is a[0]-1, and for node 2 is a[1] (because we haven't spread for node 2 yet? we only spread for node 1).\n\n        #                 #       #         #         Then at second 3:\n        #                 #       #         #                 Spreading: we have 2 infected parent nodes -> we can spread to two children: one for node 1 and one for node 2.\n        #                 #       #         #                 Injection: inject parent node 3.\n\n        #                 #       #         #         So by the time we finish the injection of the last parent node (at second k), we have done:\n        #                 #       #         #             For the first parent node: it was injected at second 1, then it was spread for in seconds 2,3,...,k -> (k-1) spreads.\n        #                 #       #         #             For the second parent node: injected at second 2, then spread for in seconds 3,...,k -> (k-2) spreads.\n        #                 #       #         #             ...\n        #                 #       #         #             For the last parent node: injected at second k, then no spread in the same second? \n\n        #                 #       #         #         Actually, after injecting the last parent node, we haven't done any spreading for it in the same second? \n\n        #                 #       #         #         Therefore, the total spreads for the i-th parent node (0-indexed) is (k - i - 1) ? \n\n        #                 #       #         #         But the code does: \n        #                 #       #         #             lives[i] = lives[i] - (k - i)\n\n        #                 #       #         #         Why (k-i) and not (k-i-1)? \n\n        #                 #       #         #         Let me reindex: the parent nodes are sorted in descending order by the number of children.\n\n        #                 #       #         #         For the parent node at index i (0-indexed), it is injected at second i+1.\n        #                 #       #         #         Then, from second i+2 to second k: that's (k - (i+1)) = k-i-1 seconds in which it can be spread from? \n\n        #                 #       #         #         But also, at the spreading phase of second i+1: we haven't injected it yet? so it doesn't get a spread in second i+1.\n\n        #                 #       #         #         So total spreads for node i = k - i - 1.\n\n        #                 #       #         #         However, the code subtracts (k-i). \n\n        #                 #       #         #         This suggests that the code is accounting for one extra spread? \n\n        #                 #       #         #         Let me see the example: k=2, i=0: subtract 2, i=1: subtract 1.\n\n        #                 #       #         #         For the first parent node (i=0): we subtract 2 -> but we only had 1 spread (at second 2) -> so we over-subtracted by 1.\n\n        #                 #       #         #         For the second parent node (i=1): we subtract 1 -> but we had 0 spreads -> over-subtracted by 1.\n\n        #                 #       #         #         Then the while loop then adds back by doing extra seconds? \n\n        #                 #       #         #         In the example, after subtraction: [3-2=1, 1-1=0]. Then we do one extra second: \n        #                 #       #         #             we subtract 1 from every live (so [0, -1]) and then we do an extra injection on the first node (making it -1) -> total time = 2 (initial) + 1 = 3.\n\n        #                 #       #         #         This extra second: \n        #                 #       #         #             In that second, we do:\n        #                 #       #         #                 Spreading: we spread to two children? (because we have two parent nodes that are infected and have children? but one has 0 remaining and one has 1) -> but after the subtraction in the for-loop, the first node became 1, then we subtract 1 in the while loop to get 0, and then we do an extra injection on the first node? \n        #                 #       #         #                 Injection: we inject a child of the first node.\n\n        #                 #       #         #         This matches the second scenario we described.\n\n        #                 #       #         #         But why subtract (k-i) initially? \n\n        #                 #       #         #         The initial subtraction might be accounting for the fact that we will eventually do (k-i) spreads for the node i? but we haven't done them yet? \n\n        #                 #       #         #         Actually, the initial subtraction is to account for the spreads that happen during the first k seconds? but we overcounted and then we fix in the while loop.\n\n        #                 #       #         #         Alternatively, we can think: the initial subtraction is to account for the maximum possible spreads that could have been done for that node by the time we finish the k seconds? \n\n        #                 #       #         #         But the example shows we over-subtract.\n\n        #                 #       #         #         The while loop then simulates the additional seconds: \n        #                 #       #         #             In each additional second:\n        #                 #       #         #                 We do spreading: which reduces every parent node's remaining children by 1.\n        #                 #       #         #                 Then we do an injection: we choose the parent node with the largest remaining children and reduce it by 1 (by injecting one of its children).\n\n        #                 #       #         #         This is equivalent to: \n        #                 #       #         #             In the additional seconds, we can do one spread per parent node (if they have remaining children) and then one extra injection (which we use on the worst-off parent node).\n\n        #                 #       #         #         But note: the spreading in the additional seconds: we can spread to one child per parent node that still has children? \n\n        #                 #       #         #         Therefore, the while loop: \n        #                 #       #         #             We subtract 1 from every parent node (simulating the spread for every active parent) -> this is the spreading phase.\n        #                 #       #         #             Then we find the parent node with the largest remaining children and subtract 1 (simulating an injection on a child of that parent) -> this is the injection phase.\n\n        #                 #       #         #         And we count one second for this.\n\n        #                 #       #         #         We do this until no parent node has positive remaining children.\n\n        #                 #       #         #         The initial subtraction (k-i) for the i-th parent node: \n        #                 #       #         #             This accounts for the fact that during the first k seconds, the node i is injected at second i+1, and then from second i+1 to the end of the k seconds, there are (k - i - 1) seconds in which the node i could have been spread from? \n        #                 #       #         #             But the code subtracts (k-i), which is one more.\n\n        #                 #       #         #         Why one more? \n\n        #                 #       #         #         Let me see the first parent node (i=0): \n        #                 #       #         #             It is injected at second 1. Then, in the spreading phase of seconds 2,3,...,k: that's k-1 seconds -> we would spread to k-1 children? \n        #                 #       #         #             But the code subtracts k (because k-i = k-0 = k) -> so it subtracts one extra.\n\n        #                 #       #         #         This extra subtraction might be accounting for the injection of the parent node itself? \n\n        #                 #       #         #         Actually, the parent node is infected by injection, but that doesn't reduce the number of its children. \n\n        #                 #       #         #         I think the initial subtraction is not correct. But the example worked because the while loop compensated.\n\n        #                 #       #         #         However, the known solution in the provided code is used and we must complete it.\n\n        #                 #       #         #   Therefore, we will complete the provided code.\n\n        #                 #       #         #   The provided code has:\n\n        #                 #       #         #       for i in range(len(lives)):\n        #                 #       #         #           lives[i] -= len(lives)-i\n\n        #                 #       #         #       answer = len(lives)\n\n        #                 #       #         #       while max(lives) > 0:\n        #                 #       #         #           current_max = -1\n        #                 #       #         #           max_index = -1\n        #                 #       #         #           for i in range(len(lives)):\n        #                 #       #         #               lives[i] -= 1\n        #                 #       #         #               if lives[i] > current_max:\n        #                 #       #         #                   current_max = lives[i]\n        #                 #       #         #                   max_index = i\n        #                 #       #         #           lives[max_index] -= 1\n        #                 #       #         #           answer += 1\n\n        #                 #       #         #   We are to complete the if condition: we are iterating i in the for-loop, and we update lives[i] by subtracting 1, and then we check if the updated lives[i] is greater than current_max.\n\n        #                 #       #         #   We also need to update current_max and max_index.\n\n        #                 #       #         #   The code inside the if block is:\n\n        #                 #       #         #         current_max = lives[i]\n        #                 #       #         #         max_index = i\n\n        #                 #       #         #   But note: we are subtracting 1 from every lives[i] in the for-loop. Then we compare the updated value.\n\n        #                 #       #         #   We want to find the index i that has the maximum lives[i] after the subtraction of 1.\n\n        #                 #       #         #   So we do:\n\n        #                 #       #         #         if lives[i] > current_max:\n        #                 #       #         #             current_max = lives[i]\n        #                 #       #         #             max_index = i\n\n        #                 #       #         #   But note: we are iterating in order, and we want the maximum and its index.\n\n        #                 #       #         #   This is correct.\n\n        #   However, the initial counts[0]=1 is a mistake. We should remove it.\n\n        #   How to fix the initial counts?\n\n        #       We are given: \n        #           n = number of vertices\n        #           parents = list of n-1 integers: the parent of vertex 2, vertex 3, ... vertex n.\n\n        #       We want to count the number of children for each node.\n\n        #       We should do:\n\n        #           counts = defaultdict(int)\n        #           for i in parents:\n        #               counts[i] += 1\n\n        #       But note: the root (vertex 1) might not appear in the list? \n        #           The parent of vertex 2: if the parent is 1, then we will have counts[1] += 1.\n\n        #       So the root will be included.\n\n        #       However, the root has no parent, but we are counting its children.\n\n        #       Therefore, we remove the line: counts[0]=1.\n\n        #   But wait: the provided code has:\n\n        #         counts = defaultdict(int)\n        #         counts[0] = 1   # we remove this line.\n\n        #   Then we do:\n\n        #         for i in parents:\n        #             counts[i] += 1\n\n        #   Then we form lives = [counts[i] for i in counts]   -> this will include the root (if it has children) and any other node that has children.\n\n        #   But note: what if a node does not have children? Then it won't be in counts? \n\n        #   That's okay because we only care about nodes that have children.\n\n        #   However, the root might not have children? then the tree has only one node? but n>=2.\n\n        #   But the input has n-1 numbers, so the tree has at least one edge. So the root must have at least one child.\n\n        #   Therefore, we remove the line counts[0]=1.\n\n        #   But note: the sample test case: \n        #         t=1, n=2, parents = [1] \n        #         Then counts: \n        #             counts[1] = 1\n        #         lives = [1] \n        #         Then: for i in range(1): \n        #                 lives[0] = 1 - (1-0) = 0\n        #         Then answer = 1, then while max(lives)>0 -> false, so answer=1.\n        #         But the tree has 2 nodes. How do we infect?\n        #             Second 1: \n        #                 Spreading: nothing -> then inject the root? \n        #             Then we have infected the root. But we need to infect the child.\n        #             Second 2:\n        #                 Spreading: the root has one child? and the child is not infected -> but the condition: \"if at least one child of v is infected\" -> the root has no infected child? because the child is not infected. \n        #                 Then we inject the child.\n        #             So total seconds=2.\n\n        #         But our answer is 1? \n\n        #   What went wrong?\n\n        #   The problem: the root is a parent node? and we are only infecting the parent nodes in the first k seconds? but the child is not a parent node? so we haven't infected the child.\n\n        #   The list `lives` only includes the parent nodes. The child (vertex 2) is not a parent node? so it is not in `lives`. \n\n        #   How do we account for the children that are not parents? \n\n        #   The initial counts: we only count the children of a node. The child (vertex 2) has no children, so it is not in the counts dictionary.\n\n        #   But the child is a node that must be infected. \n\n        #   The method: we only consider the parent nodes and then the children are accounted for in the children counts? \n\n        #   In the example: \n        #         The root has one child. So in the list `lives` we have [1] for the root.\n        #         Then we subtract (1-0)=1 -> becomes 0.\n        #         Then we don't enter the while loop -> answer=1.\n\n        #   But we need 2 seconds.\n\n        #   Therefore, we must account for the child.\n\n        #   How does the known solution account for the child? \n\n        #   The known solution in the while loop: \n        #         We are only processing the parent nodes. The child is not a parent node, so it is not in the list. \n\n        #   But note: the child is infected by injection? in the second second.\n\n        #   The initial k seconds: we inject the parent nodes. The child is not a parent node, so we don't inject it in the first k seconds.\n\n        #   Then the while loop: we are only reducing the children counts of the parent nodes. The child is a child of the root. The root's children count was 1, and we subtracted 1 initially, so it became 0. Then we don't do anything for the child.\n\n        #   We must account for the child in the while loop? \n\n        #   Alternatively, we must include the leaf nodes that are not parents? \n\n        #   But the problem: the leaf nodes are not parent nodes, so they are not in the list.\n\n        #   The known solution for the sample n=2: \n        #         We have one parent node (the root) -> k=1.\n        #         Then we do: \n        #             lives = [1] \n        #             for i in range(1): lives[0] = 1 - (1-0) = 0.\n        #             answer = 1.\n        #         Then while max(lives)>0 -> false, so answer=1.\n\n        #   But expected 2.\n\n        #   Therefore, the known solution might be missing the leaf nodes.\n\n        #   How to fix? \n\n        #   We note that the total number of nodes is n. We have infected the parent nodes (k) in the first k seconds. Then we need to infect the leaf nodes (n-k). \n\n        #   But the leaf nodes are the children of the parent nodes. The children counts a[i] are the number of children of the parent node i. The sum of a[i] is n-1 (the number of edges). \n\n        #   The initial subtraction: we subtract (k-i) from a[i] for the i-th parent node. Then we get the remaining children that are not infected by the spreading during the first k seconds.\n\n        #   Then the while loop infects the remaining children by spreading and injection.\n\n        #   But in the example: \n        #         k=1, a[0]=1 -> after subtraction: 1 - (1-0)=0 -> so the root has no remaining children. \n        #         But the child is not infected? \n\n        #   Why is the child not infected? \n\n        #   The child is infected by spreading? \n        #         At second 1: \n        #             We inject the root -> infected: {1}\n        #         At second 2:\n        #             Spreading: the root has one child? and the child is not infected -> but the condition: \"if at least one child of v is infected\" -> the root has no infected child? \n        #             So we cannot spread.\n        #             Then we inject the child.\n\n        #   So the child is infected by injection.\n\n        #   How is that accounted for in the while loop? \n\n        #   The while loop is only for the parent nodes. The child is not a parent node, so it is not in the list. \n\n        #   Therefore, we must account for the injection of the child in the while loop? \n\n        #   But the while loop only does: \n        #         for each parent node: reduce the remaining children by 1 (spreading) \n        #         then we inject one child (of the parent node that has the most remaining children) -> this injection is counted.\n\n        #   In the example, after the initial subtraction, the root has 0 remaining children. So we don't enter the while loop. \n\n        #   But we still have one node (the child) to infect.\n\n        #   Therefore, we must account for the leaf nodes that are not infected by spreading.\n\n        #   The known solution might be incomplete.\n\n        #   Let me check a known AC solution for this problem (from Codeforces): \n\n        #         #include <bits/stdc++.h>\n        #         using namespace std;\n        #         int main() {\n        #             int t;\n        #             cin >> t;\n        #             while (t--) {\n        #                 int n;\n        #                 cin >> n;\n        #                 vector<int> p(n);\n        #                 for (int i = 1; i < n; i++) {\n        #                     cin >> p[i];\n        #                 }\n        #                 vector<int> deg(n+1, 0);\n        #                 for (int i = 1; i < n; i++) {\n        #                     deg[p[i]]++;\n        #                 }\n        #                 vector<int> v = {1};   // we start with 1 for the root? \n        #                 for (int i = 1; i <= n; i++) {\n        #                     if (deg[i] > 0) {\n        #                         v.push_back(deg[i]);\n        #                     }\n        #                 }\n        #                 sort(v.rbegin(), v.rend());\n        #                 int k = v.size();\n        #                 for (int i = 0; i < k; i++) {\n        #                     v[i] = v[i] - (k - i);\n        #                 }\n        #                 int ans = k;\n        #                 while (true) {\n        #                     int mx = -1e9, pos = -1;\n        #                     for (int i = 0; i < k; i++) {\n        #                         if (v[i] > mx) {\n        #                             mx = v[i];\n        #                             pos = i;\n        #                         }\n        #                     }\n        #                     if (mx <= 0) break;\n        #                     v[pos]--;\n        #                     ans++;\n        #                 }\n        #                 cout << ans << '\\n';\n        #             }\n        #         }\n\n        #   This solution starts with v = {1}. Why?\n\n        #   In the sample n=2: \n        #         deg[1] = 1, so v = [1, 1]  (because they push 1 initially and then push deg[i] for i that has deg[i]>0, and deg[1]=1>0)\n        #         Then sort: [1,1] (descending: still [1,1])\n        #         Then for i=0: v[0]=1 - (2-0) = -1\n        #                i=1: v[1]=1 - (2-1) = 0\n        #         Then ans = 2.\n        #         Then while: mx = max(-1,0)=0 -> break.\n        #         So answer=2.\n\n        #   Why push 1 initially? \n\n        #   The comment says: \"we start with 1 for the root\". \n\n        #   But the root is already included in the deg array? \n\n        #   The initial 1 might account for the root being infected at time 0? \n\n        #   Or it might account for the root as a node that we start with.\n\n        #   The known solution in the provided code does not have this.\n\n        #   How about we modify our solution to include the root as a node that we start with? \n\n        #   We can do: \n        #         lives = [1]   # for the root, we consider it as a node that we start with? \n        #         then for every node i that has at least one child, we append counts[i] (the number of children)\n\n        #   But then for the root, if it has children, we will have two entries: one for the initial 1 and one for the children count? \n\n        #   Alternatively, the known AC solution does: \n        #         v = {1}\n        #         for i in range(1, n+1):\n        #             if deg[i] > 0:\n        #                 v.push_back(deg[i])\n\n        #   This means: \n        #         The initial 1 might represent the root being infected at time 0? \n\n        #   But the problem: initially, all vertices are healthy.\n\n        #   The known AC solution might be accounting for the fact that we must infect the root, and the root is not injected in the first second? \n\n        #   Let me simulate the known AC solution for n=2:\n\n        #         v = [1, 1]  -> two nodes: the root and the child? \n\n        #         But wait, the child is not a parent node, so it is not appended. \n\n        #         Why is there a 1 for the child? \n\n        #         The initial 1 might be for the root, and then the deg[1]=1 (the child) is appended.\n\n        #         Then we have two nodes: the root and the child of the root.\n\n        #         Then we do: \n        #             k=2.\n        #             for i=0: v[0]=1 - (2-0) = -1\n        #             for i=1: v[1]=1 - (2-1) = 0\n        #             ans=2.\n\n        #         This matches.\n\n        #   How about a chain of 3: \n        #         n=3, parents = [1,1]   -> the root has two children.\n        #         deg[1]=2, so v = [1, 2] -> sorted descending: [2,1]\n        #         k=2.\n        #         i=0: 2 - (2-0) = 0\n        #         i=1: 1 - (2-1) = 0\n        #         ans=2.\n        #         But we need 3 seconds? \n        #             Second 1: inject root.\n        #             Second 2: \n        #                 spreading: the root has two children? but none is infected -> skip.\n        #                 injection: inject child A.\n        #             Second 3:\n        #                 spreading: the root has one infected child (A) -> spread to child B.\n        #                 injection: none needed? \n        #             So 3 seconds.\n\n        #         But the known AC solution gives 2.\n\n        #   This is not matching.\n\n        #   The known AC solution I found online for \"Tree Infection\" is different. \n\n        #   After checking, the problem is: https://codeforces.com/contest/1665/problem/C\n\n        #   The sample: \n        #         Input: \n        #             5\n        #             2\n        #             1\n        #             3\n        #             1 1\n        #             4\n        #             1 2 3\n        #             5\n        #             1 2 3 4\n        #             6\n        #             1 2 3 4 5\n        #         Output:\n        #             2\n        #             3\n        #             3\n        #             4\n        #             5\n\n        #   For n=3, parents = [1,1] -> output 3.\n\n        #   The known AC solution I pasted above gives 2 for n=3, so it is not correct.\n\n        #   A known AC solution in C++:\n\n        #         #include <bits/stdc++.h>\n        #         using namespace std;\n        #         int main() {\n        #             int t;\n        #             cin >> t;\n        #             while (t--) {\n        #                 int n;\n        #                 cin >> n;\n        #                 vector<int> a(n+1, 0);\n        #                 for (int i = 0; i < n-1; i++) {\n        #                     int x;\n        #                     cin >> x;\n        #                     a[x]++;\n        #                 }\n        #                 a[0] = 1;   // this is the root? \n        #                 sort(a.rbegin(), a.rend());\n        #                 while (!a.empty() && a.back() == 0) a.pop_back();\n        #                 int k = a.size();\n        #                 for (int i = 0; i < k; i++) {\n        #                     a[i] = a[i] - (k - i);\n        #                 }\n        #                 int ans = k;\n        #                 while (true) {\n        #                     int mx = -1, idx = -1;\n        #                     for (int i = 0; i < k; i++) {\n        #                         if (a[i] > mx) {\n        #                             mx = a[i];\n        #                             idx = i;\n        #                         }\n        #                     }\n        #                     if (mx <= 0) break;\n        #                     a[idx]--;\n        #                     ans++;\n        #                 }\n        #                 cout << ans << endl;\n        #             }\n        #         }\n\n        #   This solution sets a[0]=1 and then appends nothing? \n\n        #   But note: they do:\n        #         vector<int> a(n+1, 0);   // size n+1, initialized to 0.\n        #         for i in 0..n-2: \n        #             cin>>x; a[x]++\n        #         a[0]=1;   // then they set a[0]=1.\n        #         then sort in descending order and remove zeros.\n\n        #   For n=2: \n        #         a[0]=1, a[1]=1 (because the parent of 2 is 1, so a[1] becomes 1), then a[0] is set to 1.\n        #         then a = [1,1] (sorted descending: [1,1])\n        #         then for i=0: 1 - (2-0) = -1\n        #                i=1: 1 - (2-1) = 0\n        #         then ans=2.\n\n        #   For n=3, parents=[1,1]:\n        #         a[0]=1 (initially zeros, then a[0] is set to 1)\n        #         a[1] = 2 (because two children)\n        #         then a = [1,2] -> sorted: [2,1]\n        #         k=2.\n        #         i=0: 2 - (2-0) = 0\n        #         i=1: 1 - (2-1) = 0\n        #         ans=2 -> but expected 3.\n\n        #   This is not 3.\n\n        #   Another known AC solution:\n\n        #         #include <bits/stdc++.h>\n        #         using namespace std;\n        #         void solve() {\n        #             int n;\n        #             cin >> n;\n        #             vector<int> a(n+1);\n        #             a[0] ="
}