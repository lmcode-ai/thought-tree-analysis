{
  "segments": [
    {
      "text": "<think>\nWe are guaranteed that the total length of all strings is <= 200,000. The problem: Check that for every substring t of s, and for every two characters u and v that appear in s, \n            |freq(u in t) - freq(v in t)| <= 1.",
      "start_char": 0,
      "end_char": 234,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "However, note the note: the examples and the condition must hold for any triplet (t, u, v) where u and v are characters present in s.\n\n Important observation: The condition must hold for every substring t and for every pair of characters (u, v) that are in the entire string s.\n\n But note: the problem says \"for all possible triplets (t, u, v) such that t is a non-empty substring of s and u and v are characters present in s\"\n\n However, note the constraints: the total length of s over test cases is <= 200,000. But if we try to check every substring, that would be O(n^2) which is too slow.",
      "start_char": 237,
      "end_char": 831,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternate Insight:\n\n After reading the note and examples, we see that the problem is actually easier.",
      "start_char": 834,
      "end_char": 935,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Observation 1: The condition must hold for every contiguous substring.",
      "start_char": 938,
      "end_char": 1008,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "In particular, consider a substring of length 1: \n      For a single character c, then for any two distinct characters u and v, if u ! = c and v ! = c, then both frequencies are 0 -> okay. But if one of them is c, say u = c and v is another, then |1-0| = 1 -> okay.",
      "start_char": 1009,
      "end_char": 1278,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "However, if we have two consecutive same characters? Example: \"aa\" -> in the substring \"aa\", if we take u='a' and v='b' (if 'b' is present in the entire string s) then |2-0| = 2 -> violates. But note: the condition says \"u and v are characters present in s\". So if the entire string s has only 'a', then we don't consider v='b' because 'b' is not present in s.",
      "start_char": 1285,
      "end_char": 1650,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "Therefore, we only need to consider the characters that appear in the entire string.",
      "start_char": 1653,
      "end_char": 1737,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "However, the problem becomes: for every substring t, and for every pair of distinct characters (u, v) that are in the entire string s, we require |freq(u in t) - freq(v in t)| <= 1.\n\n But note: if the entire string s has only one distinct character, then we don't have two distinct characters?",
      "start_char": 1740,
      "end_char": 2033,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "Actually, the condition must hold for every pair of characters that are present.",
      "start_char": 2034,
      "end_char": 2114,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "If there is only one, then there is no pair? So condition holds.",
      "start_char": 2115,
      "end_char": 2179,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "However, what if the entire string has two distinct characters? Then we have to check for every substring that the counts of the two characters differ by at most 1.",
      "start_char": 2182,
      "end_char": 2346,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "How about three distinct characters? Then we have to check for every substring and every pair of the three. This seems very heavy.",
      "start_char": 2349,
      "end_char": 2479,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "Alternate Insight from known problems: \n There is a known problem: if a string is called balanced if for every two distinct characters the counts in any substring differ by at most 1? Actually, note the examples: \n   \"aba\" -> balanced, \"abc\" -> balanced, \"abb\" -> not balanced.",
      "start_char": 2484,
      "end_char": 2763,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "How can we check this without iterating over all substrings?",
      "start_char": 2766,
      "end_char": 2826,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Observation 2: \n The condition is violated if there exists a substring t and two distinct characters u and v such that |freq(u in t) - freq(v in t)| >= 2.",
      "start_char": 2829,
      "end_char": 2983,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Since the condition is very strict, we can look for minimal violations.",
      "start_char": 2986,
      "end_char": 3057,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "Consider: \n   The violation must occur in a relatively short substring? In fact, note that if we have two consecutive same characters, say \"aa\", then in the substring \"aa\", if there is another character (say 'b') that appears in the entire string, then |freq('a') - freq('b')| = 2 - 0 = 2 -> violation. But what if the entire string does not contain 'b'? Then we don't care about 'b'. So we only care about the characters that are in the entire string.",
      "start_char": 3060,
      "end_char": 3515,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "However, note: the condition requires that for every pair of characters that are present in the entire string. So if the entire string has only 'a', then no problem. But if the entire string has at least two distinct characters, then we must check for every substring and every pair. But note: the example \"abb\": \n   Entire string has two distinct characters: 'a' and 'b'. The substring \"bb\" has 0 a's and 2 b's -> |0-2| = 2 -> violation. Similarly, if we have \"aab\", then the substring \"aa\" has 2 a's and 0 b's -> |2-0|=2 -> violation.",
      "start_char": 3520,
      "end_char": 4064,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Therefore, we can deduce that if there is any substring of length 2 that has two of the same character, and if the entire string has at least two distinct characters, then that substring by itself (if it has two same characters) is a violation?",
      "start_char": 4067,
      "end_char": 4311,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "However, what if the entire string has two distinct characters, but the substring of two same characters is the entire string? Then we have to check: For the substring \"aa\", if the entire string has both 'a' and 'b', then we must consider the pair (a,b) and in the substring \"aa\", we have 2 a's and 0 b's -> violation. But what if the entire string does not have any other character? Then we don't have to check?",
      "start_char": 4315,
      "end_char": 4731,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "Therefore, the violation can only occur if we have two consecutive same characters? However, consider a substring of three: \"aab\" -> the substring \"aa\" is of length 2 and has two a's and 0 b's -> violation. But note: the entire string \"aab\" has two distinct characters: 'a' and 'b'. So the substring \"aa\" (which is contiguous) is a violation. What about non consecutive? Consider \"aba\": \n        substring \"aba\": a:2, b:1 -> |2-1|=1 -> okay. substring \"ab\": a:1, b:1 -> okay.\n        substring \"ba\": same. Consider \"abab\": \n        substring \"aba\": a:2, b:1 -> okay. substring \"abab\": a:2, b:2 -> okay. But what about \"aaba\": \n        substring \"aa\": a:2, b:0 -> violation. So the violation occurs if we have two consecutive same characters?",
      "start_char": 4737,
      "end_char": 5513,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "However, what if we have three distinct characters? Example: \"aabc\" -> substring \"aa\": \n        for pair (a,b): |2-0|=2 -> violation.\n        for pair (a,c): |2-0|=2 -> violation. So again, two consecutive same characters cause a violation. But what if we have a longer gap? \n   Example: \"abac\": \n        substring \"aba\": a:2, b:1 -> okay for (a,b) and (a,c) and (b,c) in the entire string? But note: the entire string has a, b, c. Now consider the substring \"aba\": \n            a:2, b:1, c:0 -> \n                |a-b| = 1 -> okay\n                |a-c| = 2 -> violation. So the substring \"aba\" has a violation for the pair (a,c).",
      "start_char": 5519,
      "end_char": 6176,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "Therefore, we must also consider that if a character is missing in a substring and the entire string has that character, then the difference can be as large as the maximum frequency of a character that is present.",
      "start_char": 6184,
      "end_char": 6397,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "How to avoid checking all substrings?\n\n We can try to look for minimal violations. The condition is violated if there exists a substring t and two distinct characters u and v such that |freq(u in t) - freq(v in t)| >= 2. Note that if we have a substring t that violates, then there must be two characters u and v and an integer k>=2 such that either:\n   freq(u in t) = k and freq(v in t) = k-2, or \n   freq(u in t) = k and freq(v in t) = k+2?",
      "start_char": 6400,
      "end_char": 6844,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Actually, the absolute difference is at least 2. But note: the minimal violation is when the difference is exactly 2.",
      "start_char": 6845,
      "end_char": 6962,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "And we can look for the smallest substring that has a violation. Observation 3:",
      "start_char": 6965,
      "end_char": 7044,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "In fact, it is known from similar problems (e.g., CodeForces problems on balanced strings) that the only possible violations occur in substrings of length 2 or 3. Why?\n   Consider: \n     If we have a violation in a substring t, then there are two characters u and v such that |freq(u)-freq(v)|>=2. Without loss of generality, assume freq(u) = a and freq(v)=b, and a>=b+2.",
      "start_char": 7051,
      "end_char": 7429,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "We can try to shrink the substring from the left and right until the violation still holds. If we remove a character that is not u or v, then the difference remains the same (a-b) -> still violation. If we remove a character that is u, then we get (a-1, b) -> difference a-1-b = (a-b)-1. Since a-b>=2, then (a-b)-1>=1 -> but we require at least 2? Then we might break the violation? Similarly, if we remove a character that is v, then we get (a, b-1) -> difference a - (b-1) = a-b+1 -> which is even larger. So we want to remove characters that are not u or v?",
      "start_char": 7436,
      "end_char": 8022,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Alternatively, we can note that the minimal violation must occur in a substring that has at most 4 characters?",
      "start_char": 8036,
      "end_char": 8146,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "Actually, known fact: the condition is equivalent to the string being \"balanced\" in the sense that the only allowed substrings of two same characters are when the entire string has only one distinct character? But we have a counterexample: \"aaba\" -> the violation is in \"aa\", which is of length 2. What about a violation in a substring of length 3? \n        Example: \"aab\" -> the substring \"aa\" (length=2) is a violation? But wait, the entire string \"aab\" has two distinct characters? Then the substring \"aa\" (which is of length 2) is a violation. How about a violation that requires 3? \n        Consider: \"aabc\" -> the substring \"aa\" (length=2) is a violation. How about: \"abac\" -> the substring \"aba\" (length=3) is a violation? In \"aba\": \n            a:2, b:1, c:0 -> so for the pair (a,c): |2-0|=2 -> violation. So we have violations in substrings of length 2 and 3.",
      "start_char": 8152,
      "end_char": 9047,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "Therefore, we can check every substring of length 2 and 3? But note: the total length of all strings is 200,000. The number of substrings of length 2 and 3 in one string of length n is (n-1) + (n-2) = 2n-3. And the total n over test cases is 200,000 -> so total substrings to check is about 2*(200,000) = 400,000?",
      "start_char": 9056,
      "end_char": 9383,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "However, the problem says: the sum of |s| over all test cases does not exceed 200,000. So we can do:\n\n        total_n = 0\n        for each test case: \n            n = len(s)\n            total_n += n\n\n        and total_n <= 200,000.",
      "start_char": 9389,
      "end_char": 9620,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Therefore, we can iterate over every test case and for each string, we can check every substring of length 2 and 3? Steps for one test case:\n        Let d = distinct characters in s. If d==1: then we don't have two distinct characters -> condition holds? Actually, no pair to compare -> so condition holds -> YES. Else:",
      "start_char": 9625,
      "end_char": 9957,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Check every substring of length 2: \n                if we find any substring of length 2 that has two same characters, then we have a violation? Why? because in that substring, the two same characters (say 'a') and any other distinct character (say 'b') that exists in the entire string (and note d>=2 so there is at least one other) will cause: \n                         freq(a)=2, freq(b)=0 -> |2-0|=2 -> violation.",
      "start_char": 9979,
      "end_char": 10417,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Check every substring of length 3:\n                We need to check for every contiguous triple (i, i+1, i+2) and for every pair of distinct characters (u, v) that are in the entire string? But note: we don't have to check every pair?",
      "start_char": 10431,
      "end_char": 10665,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Because the entire string might have many distinct characters, but the triple only has a few.",
      "start_char": 10683,
      "end_char": 10776,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Actually, we can do: \n                    For a triple, we can count the frequency of each character in that triple. Then for any two distinct characters u and v that are in the entire string, we check |freq(u)-freq(v)|?",
      "start_char": 10794,
      "end_char": 11014,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "However, the entire string might have 26 distinct characters, but the triple only has at most 3. So we can check the distinct characters that appear in the entire string and also appear in the triple? But note: if a character does not appear in the triple, then its frequency is 0. So we have to consider all distinct characters in the entire string?",
      "start_char": 11032,
      "end_char": 11382,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "However, the entire string might have 26 distinct characters, and we have to check 26*25 pairs for each triple? That would be 26*25*(n-2) which is about 650*(n) -> 650 * 200,000 = 130,000,000 per test case? But the total n over test cases is 200,000 -> so worst-case one test case with n=200,000 -> 130e6 which is acceptable in Pyton?",
      "start_char": 11419,
      "end_char": 11770,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Maybe in C++ but in Python it might be borderline.",
      "start_char": 11771,
      "end_char": 11821,
      "label": "language_mapping",
      "label_info": {
        "type": "language_mapping"
      }
    },
    {
      "text": "Alternatively, we can note: \n                    The condition in the triple is violated if there exists a character that appears at least twice and another character that does not appear at all? Why?",
      "start_char": 11839,
      "end_char": 12039,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "because then the difference between the one that appears twice and the one that does not appear is 2.",
      "start_char": 12061,
      "end_char": 12162,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Also, if a character appears three times and another appears once? Then |3-1|=2 -> violation? Or if a character appears three times and another does not appear: |3-0|=3 -> violation.",
      "start_char": 12180,
      "end_char": 12379,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Actually, the condition is violated in a triple if the maximum frequency of any character in the triple is at least 2 and the minimum frequency (among the distinct characters of the entire string) is 0? But note: the entire string has multiple distinct characters.",
      "start_char": 12397,
      "end_char": 12661,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "However, the triple might not contain all the distinct characters. Specifically, for a triple t, let M = max{ f(c) for c in entire_string }? But note: for a character c that is in the entire string but not in the triple, f(c)=0. So the condition for the triple is violated if:\n                    max_freq = max( frequency in the triple of any character that is in the entire_string? ) \n                    min_freq = min( frequency in the triple of any character that is in the entire_string? ) \n                    and max_freq - min_freq >= 2.",
      "start_char": 12679,
      "end_char": 13277,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "However, note: the min_freq for a character that is in the entire string but not in the triple is 0. So if there is at least one character in the entire string that is missing in the triple, then min_freq=0. Then if max_freq>=2, we have violation. But what if the triple contains all the distinct characters? Then min_freq might be at least 1? Example: \"abc\": max_freq=1, min_freq=1 -> okay. Example: \"aba\": distinct in entire string is {'a','b'}. The triple \"aba\": \n                         a:2, b:1 -> min_freq=1, max_freq=2 -> difference=1 -> okay? But wait: the entire string might have a third character?",
      "start_char": 13295,
      "end_char": 13979,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Actually, the triple \"aba\" only has two characters. But the entire string might have a third character? Then we have to consider that third character?",
      "start_char": 14022,
      "end_char": 14172,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "In the triple, the frequency of the third character is 0. So min_freq=0, max_freq=2 -> violation.",
      "start_char": 14194,
      "end_char": 14291,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Therefore, we don't need to know which distinct characters are in the triple.",
      "start_char": 14309,
      "end_char": 14386,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "We know the entire string has d distinct characters.",
      "start_char": 14387,
      "end_char": 14439,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "In the triple, we can only have at most 3 distinct characters.",
      "start_char": 14457,
      "end_char": 14519,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "The rest (d-3) are missing (so frequency 0). So condition for the triple: \n                    Let M = max( frequency of characters in the triple ) Then the min frequency is 0 (if d>3, then there is at least one missing character) OR if d<=3, then the min frequency is the minimum over the characters that are in the entire string? Actually, we can compute:\n                    Let freq = [0]*26\n                    For the triple s[i:i+3], we count the frequency of each letter in the triple? Then we know that for any character c in the entire string that is not in the triple, freq(c)=0. Then the maximum frequency in the triple (over the 26 letters) is M, and the minimum frequency (over the entire_string's distinct set) is min( {freq(c) for c in set(s)} ) But note: for a character c in set(s) that is not in the triple, we have freq(c)=0. So the min_freq = min( min(freq(c) for c in set(s) that appears in the triple), 0 )? Actually, if there is at least one character in set(s) that is not in the triple, then min_freq=0.\n\n                Therefore, we can do:\n                    Let M = max(freq)   # over the 26 letters? but we only care about the ones that appear? but we can take the max over the entire 26? But note: the triple only has 3 characters, so we can compute the frequency for the entire_string? Alternatively, we can note: \n                    The condition is violated if M>=2 and there exists at least one distinct character in the entire string that is missing in the triple? But how do we know if there is a distinct character missing?",
      "start_char": 14520,
      "end_char": 16285,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "We can precompute the distinct set for the entire string. Then for the triple, we can check: Let present = set of characters in the triple. If the entire string has a distinct character not in present -> then min_freq=0 -> if M>=2 -> violation.",
      "start_char": 16325,
      "end_char": 16626,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Also, what if the triple contains all distinct characters? Then we have to check the min_freq in the triple? min_freq = min( frequency of each distinct character in the triple ) Then if M - min_freq >= 2, then violation. Example: \n                    s = \"aba\", distinct = {'a','b'}, triple=\"aba\": \n                         present = {'a','b'} -> no missing. frequencies: a:2, b:1 -> M=2, min_freq=1 -> 2-1=1 -> okay. s = \"aab\", distinct = {'a','b'}, triple=\"aab\": \n                         present = {'a','b'} -> no missing. frequencies: a:2, b:1 -> M=2, min_freq=1 -> 1 -> okay? But wait, the substring \"aab\" is of length 3, but we already found a violation in the substring \"aa\" (length=2). So we don't need to rely on the triple?",
      "start_char": 16644,
      "end_char": 17528,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Actually, we already check length2: so the triple check might be redundant for the case of two same consecutive? However, consider: \n                    s = \"abac\", distinct = {'a','b','c'}, and consider the triple \"aba\": \n                         present = {'a','b'} -> missing 'c' -> min_freq=0, M=2 -> violation. So we need to check both. Therefore, algorithm for one test case:\n\n        distinct = set(s) d = len(distinct)\n\n        # If there is only one distinct character, then condition holds -> YES. if d == 1:\n            print(\"YES\")\n            continue\n\n        n = len(s)\n        # Check all substrings of length 2\n        for i in range(n-1):\n            if s[i] == s[i+1]:\n                print(\"NO\")\n                break\n        else: \n            # Check all substrings of length 3\n            found = False\n            for i in range(n-2):\n                # Consider substring s[i:i+3]\n                triple = s[i:i+3]\n                # Count frequency in the triple for the 26 letters?",
      "start_char": 17547,
      "end_char": 18608,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "We don't need 26, we can use a dict for the triple and then check the distinct set of the entire string. freq = {}\n                for char in triple:\n                    freq[char] = freq.get(char,0)+1\n                M = max(freq.values())\n                # Now, if there is any character in the entire string (distinct) that is not in the triple, then min_freq=0 -> if M>=2, violation.\n                # If all distinct characters are in the triple, then min_freq = min(freq[c] for c in distinct) \n                # But note: the triple might not have all distinct? missing = False\n                for c in distinct:\n                    if c not in freq:\n                        missing = True\n                        break\n\n                if missing:\n                    if M>=2:\n                        print(\"NO\")\n                        found = True\n                        break\n                else:\n                    min_freq = min(freq[c] for c in distinct)\n                    if M - min_freq >= 2:\n                        print(\"NO\")\n                        found = True\n                        break\n\n            if not found:\n                print(\"YES\")",
      "start_char": 18609,
      "end_char": 19814,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "However, note: what if the entire string has 4 distinct characters? Example: \"abcd\" -> \n            Check length2: no consecutive same -> so we go to length3. Check triple \"abc\": \n                distinct = {'a','b','c','d'} -> missing 'd' -> min_freq=0, M=1 -> 1<2 -> no violation. Then triple \"bcd\": same -> no violation. Then we say YES. But is \"abcd\" balanced? Consider the substring \"abcd\": \n                a:1, b:1, c:1, d:1 -> differences are 0 -> okay.",
      "start_char": 19819,
      "end_char": 20346,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "Consider any substring of length 1: okay. Consider any substring of length 2: two different -> okay. Consider any substring of length 3: e.g., \"abc\": \n                a:1, b:1, c:1, d:0 -> then for the pair (a,d): |1-0|=1 -> okay? But wait, the condition says: for every pair of characters in the entire string. So we must check (a,d): |1-0|=1 -> okay. (b,d): |1-0|=1 -> okay. (c,d): |1-0|=1 -> okay. So \"abcd\" is balanced. But what about \"aabc\" (with distinct = {'a','b','c'})? We already break at the first substring of length2: \"aa\" -> we print \"NO\". What about \"abac\" (distinct={'a','b','c'}): \n        Check length2: \n            \"ab\": a!=b -> okay\n            \"ba\": b!=a -> okay\n            \"ac\": a!=c -> okay\n        Then check length3: \"aba\": \n                freq: a:2, b:1 -> distinct has 'a','b','c'. missing: 'c' -> so min_freq=0, M=2 -> violation -> print \"NO\". What about \"abcb\": \n        distinct = {'a','b','c'}\n        length2: \n            \"ab\": a!=b -> ok\n            \"bc\": b!=c -> ok\n            \"cb\": c!=b -> ok -> so no break. length3: \"abc\": \n                freq: a:1, b:1, c:1 -> no missing? no, distinct has a,b,c -> all present -> min_freq=1, M=1 -> no violation. \"bcb\": \n                freq: b:2, c:1 -> distinct: a,b,c -> missing 'a' -> min_freq=0, M=2 -> violation -> \"NO\". But is \"abcb\" balanced? Consider the substring \"bcb\": \n            a:0, b:2, c:1 -> \n                |a-b|=2 -> violation. So it works. However, note: the problem says the total length of all test cases is <=200,000. We are iterating for each test case: \n            For the length2: n-1 iterations per test case -> total over test cases: 200,000 (since total n<=200,000) -> that's acceptable. For the length3: n-2 iterations per test case -> total over test cases: 200,000 - 2*(number of test cases) -> but the total n is 200,000, so worst-case 200,000 iterations? But note: the total n over test cases is 200,000. So the total work for length2 and length3 is O(total_n) which is 200,000. However, in the inner loop of the triple check, we do:\n        for each triple: \n            we build a frequency dictionary for 3 characters -> O(1)\n            we compute M = max(freq.values()) -> O(3) -> O(1)\n            we check for missing: we iterate over distinct until we find one missing? worst-case distinct size 26 -> O(26) per triple -> worst-case 26*(n-2) per test case. But the total n over test cases is 200,000 -> worst-case 26 * 200,000 = 5,200,000 -> acceptable. But note: the distinct set for the entire string is fixed per test case. We can precompute it.",
      "start_char": 20359,
      "end_char": 23179,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "And the distinct set size is at most 26. So we can do:\n\n        distinct = set(s) d = len(distinct)\n\n        if d==1:\n            print(\"YES\")\n            continue\n\n        n = len(s)\n        # Check for consecutive same in length2\n        for i in range(n-1):\n            if s[i]==s[i+1]:\n                print(\"NO\")\n                break\n        else:\n            # Now check every triple\n            for i in range(n-2):\n                triple = s[i:i+3]\n                # Count frequency in the triple\n                freq = {}\n                for c in triple:\n                    freq[c] = freq.get(c,0)+1\n                M = max(freq.values())",
      "start_char": 23184,
      "end_char": 23845,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "# Check if there's any character in distinct missing in the triple?\n                # We can do: \n                #   if len(freq) < d:  # then there is at least one distinct character missing -> min_freq=0\n                if len(freq) < d:\n                    if M>=2:\n                        print(\"NO\")\n                        break\n                else:\n                    # All distinct characters are in the triple\n                    min_freq = min(freq[c] for c in distinct)   # but note: distinct is the set of the entire string, and we have all of them in the triple -> so we can compute min_freq from the freq dictionary? #",
      "start_char": 23862,
      "end_char": 24497,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "However, note: the distinct set might have 26 characters? But we know the triple only has 3, so if d>3 then we wouldn't be in the else branch? # Actually, the else branch is only taken if len(freq) == d? \n                    # But wait: if the distinct set has 3, and the triple has 3 distinct, then len(freq)=3=d -> we enter else. # But if distinct set has 4, then we would have len(freq) <= 3 < 4 -> we enter the if branch (missing) -> so the else branch only runs when d<=3 and the triple has exactly d distinct characters.\n\n                    # So d is at most 3 -> so we can do min_freq = min(freq.values())? # But note: the distinct set is the entire string, and we are iterating over distinct -> but the keys in freq are exactly the distinct set? \n                    #",
      "start_char": 24519,
      "end_char": 25358,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Actually, no: the distinct set might be a subset of the keys? #",
      "start_char": 25359,
      "end_char": 25422,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "We built freq only for the triple.",
      "start_char": 25444,
      "end_char": 25478,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The keys in freq are the distinct characters in the triple. # But we are in the branch where the distinct set is a subset of the keys?",
      "start_char": 25479,
      "end_char": 25613,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Actually, no: we are in the branch where the distinct set has the same size as the keys? #",
      "start_char": 25635,
      "end_char": 25725,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Actually, we are in the branch: len(freq) < d -> then we do the if. Otherwise, we do the else. # But note: it is possible that the distinct set has 3, and the triple has 3 distinct, so we do the else. # But the distinct set might be {'a','b','c'} and the triple might have {'a','b','d'}? -> but wait, the distinct set is the entire string, so the triple cannot have a character not in the distinct set? #",
      "start_char": 25747,
      "end_char": 26193,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Actually, the triple is a substring of s, so every character in the triple is in the distinct set. #",
      "start_char": 26215,
      "end_char": 26315,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Therefore, the distinct set is a superset of the keys of freq? # So in the else branch: we have that the distinct set is exactly the keys of freq? \n                    #",
      "start_char": 26337,
      "end_char": 26506,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Actually, no: the distinct set might be larger? But we are in the else branch only if the distinct set is contained in the keys? # We did: if len(freq) < d -> then there is a distinct character missing. # So the else branch: len(freq) >= d? \n                    # But note: the distinct set has d elements, and the triple has at most 3 distinct, and d can be at most 26. #",
      "start_char": 26528,
      "end_char": 26942,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Actually, the distinct set is the entire string, and the triple is a substring, so the distinct set of the triple is a subset of the distinct set of the entire string. #",
      "start_char": 26964,
      "end_char": 27133,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Therefore, the distinct set of the entire string has d elements, and the triple has len(freq) distinct. # We are in the else branch when len(freq) >= d? -> but that can only happen if len(freq)==d? \n                    # But note: the distinct set of the entire string has d elements, and the triple has at most d distinct? \n                    #",
      "start_char": 27155,
      "end_char": 27522,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Actually, the triple cannot have more distinct than the entire string. # So the condition for the else branch: we have that the distinct set of the entire string is exactly the distinct set of the triple? \n                    #",
      "start_char": 27523,
      "end_char": 27750,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "That is, the triple contains all distinct characters of the entire string? # Therefore, we can compute min_freq = min(freq.values())   # because we are taking the min over the distinct set of the entire string, but since the triple has all distinct, then the min over the distinct set is the min of the freq values for the keys that are the distinct set -> which is the same as min(freq.values())? # But note: the distinct set is the keys of freq? \n                    #",
      "start_char": 27772,
      "end_char": 28264,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Actually, the distinct set is the set of characters that appear in the entire string, and the triple has exactly those? \n                    # Then the distinct set is the keys of freq. min_freq = min(freq.values())\n                    if M - min_freq >= 2:\n                        print(\"NO\")\n                        break\n            else:\n                print(\"YES\")",
      "start_char": 28286,
      "end_char": 28677,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "However, note: what if the entire string has 4 distinct characters? Then we never enter the else branch? We only check the triple for missing: if there is a missing character (which there is, because the triple has at most 3) then we check M>=2. But if the triple has M=1 (like \"abc\") then we don't break. Then we move to the next triple. Then if we never break, we print \"YES\". This matches our example \"abcd\": \n        distinct = {'a','b','c','d'} -> d=4. Check length2: no consecutive same -> then check triples:\n            \"abc\": len(freq)=3 < 4 -> missing -> M=1 -> no break. \"bcd\": same -> no break. Then print \"YES\". But what if we have a string with 4 distinct and a triple that has two same? Example: \"aabcde\" (distinct = {'a','b','c','d','e'}) -> \n            Check length2: \"aa\" -> consecutive same -> break and print \"NO\". Example: \"abacd\" (distinct = {'a','b','c','d'}) -> \n            length2: \n                \"ab\": ok\n                \"ba\": ok\n                \"ac\": ok\n                \"cd\": ok -> no break.\n            length3: \"aba\": \n                    freq: a:2, b:1 -> distinct has 4 -> missing -> M=2 -> break and print \"NO\". Therefore, the code for one test case:\n\n        s = input().strip()\n        distinct = set(s)\n        n = len(s)\n        if len(distinct) == 1:\n            print(\"YES\")\n        else:\n            found = False\n            for i in range(n-1):\n                if s[i] == s[i+1]:\n                    print(\"NO\")\n                    found = True\n                    break\n            if not found:\n                for i in range(n-2):\n                    # take substring s[i:i+3]\n                    t = s[i:i+3]\n                    freq = {}\n                    for c in t:\n                        freq[c] = freq.get(c,0)+1\n                    M = max(freq.values()) if len(freq) < len(distinct):\n                        if M>=2:\n                            print(\"NO\")\n                            found = True\n                            break\n                    else:\n                        # then the triple has all distinct characters\n                        min_freq = min(freq.values())\n                        if M - min_freq >= 2:\n                            print(\"NO\")\n                            found = True\n                            break\n                if not found:\n                    print(\"YES\")\n\n   But note: the problem says the total length of s over test cases <= 200,000.",
      "start_char": 28682,
      "end_char": 31274,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "The inner loop for triples: worst-case we do (n-2) iterations per test case. The total n over test cases is 200,000 -> so worst-case 200,000 iterations for the triples?",
      "start_char": 31284,
      "end_char": 31461,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "However, note: if we break early, we don't do all. However, the problem says: the total length of all test cases is <=200,000. But note: the input says \"the sum of |s| over all test cases does not exceed 200000\", so we are safe. But note: the problem says \"the sum of n over all test cases does not exceed 200000\", meaning the total length of all strings is <=200000. Therefore, we can do:\n\n        t = int(input().strip())\n        for _ in range(t):\n            s = input().strip()\n            distinct = set(s)\n            n = len(s)\n            if len(distinct) == 1:\n                print(\"YES\")\n            else:\n                # Check for consecutive duplicates in adjacent\n                if any(s[i] == s[i+1] for i in range(n-1)):\n                    print(\"NO\")\n                else:\n                    # Check for triples\n                    found = False\n                    for i in range(n-2):\n                        t = s[i:i+3]\n                        #",
      "start_char": 31471,
      "end_char": 32465,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "We only care if the triple has at least one duplicate? \n                        # But we already know no consecutive duplicates, so the triple has no consecutive duplicates? \n                        # But we can have non consecutive duplicates: e.g., \"aba\"\n                        freq = {}\n                        for c in t:\n                            freq[c] = freq.get(c,0)+1\n                        M = max(freq.values()) if len(freq) < len(distinct):\n                            if M>=2:\n                                print(\"NO\")\n                                found = True\n                                break\n                        else:\n                            min_freq = min(freq.values())\n                            if M - min_freq >= 2:\n                                print(\"NO\")\n                                found = True\n                                break\n                    if not found:\n                        print(\"YES\")",
      "start_char": 32466,
      "end_char": 33447,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "However, note: the triple might have non consecutive duplicates? But we already checked adjacent duplicates, so the triple cannot have two consecutive same. But it can have the same at the ends: \"aba\" -> that's allowed? But note: we break in the adjacent check only if we find two consecutive same. So if we get to the triple check, we know that there are no two consecutive same.",
      "start_char": 33452,
      "end_char": 33841,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Therefore, the triple must be of the form: \n            abc, aba, abbc? -> but wait, we don't have consecutive same, so the triple cannot have \"aa\" in the first two or last two? So the triple can be: \n                abc: all distinct -> then M=1 -> no problem. aba: then the first and last are same -> then M=2 -> and we have to check. So the triple \"aba\" is the only one that can have M=2. Therefore, we can optimize: We only need to check triples that have the form: \n            s[i] == s[i+2] and s[i]!=s[i+1] -> then we have \"aba\" pattern. Then we can do:\n\n            for i in range(n-2):\n                if s[i] == s[i+2]:\n                    # then we have \"aba\" pattern -> then M=2 for the triple? \n                    #",
      "start_char": 33856,
      "end_char": 34641,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Now, we have to check: \n                    #   if the entire string has a distinct character that is not in the triple?",
      "start_char": 34642,
      "end_char": 34762,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "#   or if the entire string has all distinct in the triple? \n                    # But note: the triple has two distinct: s[i] and s[i+1]. # So if the entire string has a third distinct character, then we have a missing -> and M=2 -> violation. # If the entire string has exactly these two distinct, then we have to check the min_freq: \n                    #        freq: s[i]:2, s[i+1]:1 -> min_freq=1 -> 2-1=1 -> no violation. # But wait: what if the entire string has more than two? # Then we have a missing -> violation. if len(distinct) > 2:\n                        print(\"NO\")\n                        found = True\n                        break\n                    # else: if distinct has exactly 2, then no violation? \n            else:\n                print(\"YES\")\n\n        But note: what if the entire string has 4 distinct? Then we break at the first \"aba\" pattern? Example: \"abac\": \n            distinct = {'a','b','c'} -> len=3>2 -> so we break at the first triple \"aba\" and print \"NO\". Example: \"abab\": \n            distinct = {'a','b'} -> len=2 -> then we don't break? Then we check the next triple: \"bab\": \n                s[1]=='b', s[3]=='b' -> \"bab\": same pattern -> distinct=2 -> no break. Then we print \"YES\". But is \"abab\" balanced? The entire string: \n                distinct = {'a','b'}\n            Check every substring? length1: ok.\n                length2: \"ab\": a:1,b:1 -> |1-1|=0 -> ok; \"ba\": same; \"ab\": same.\n                length3: \"aba\": a:2, b:1 -> |2-1|=1 -> ok? \n                    \"bab\": b:2, a:1 -> |2-1|=1 -> ok.\n                length4: \n                    \"abab\": a:2, b:2 -> |2-2|=0 -> ok. So \"abab\" is balanced. Therefore, we can do:\n\n            for i in range(n-2):\n                if s[i] == s[i+2] and s[i]!=s[i+1]:\n                    if len(distinct) > 2:\n                        print(\"NO\")\n                        found = True\n                        break\n            if not found:\n                print(\"YES\") This is more efficient. But note: what if the triple has three distinct? Example: \"abc\" -> no \"aba\" pattern -> skip. Example: \"aab\" -> but we already broke at the adjacent duplicate. So the only triple we need to check is the \"aba\" pattern? However, what about \"aaba\"?",
      "start_char": 34784,
      "end_char": 37295,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "We broke at the adjacent duplicate \"aa\", so we never get to the triple. What about \"abca\": \n            distinct = {'a','b','c'} -> len=3>2 -> \n            Check triples:\n                \"abc\": no pattern -> skip.\n                \"bca\": no pattern -> skip. Then we print \"YES\". But is \"abca\" balanced? Consider the substring \"abca\": \n                a:2, b:1, c:1 -> \n                    |a-b|=1, |a-c|=1, |b-c|=0 -> okay. Consider the substring \"a\" (any single) -> okay.",
      "start_char": 37328,
      "end_char": 37853,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Consider the substring \"aa\": not contiguous?",
      "start_char": 37866,
      "end_char": 37910,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The substring \"aa\" is not contiguous?",
      "start_char": 37928,
      "end_char": 37965,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Actually, the substring \"aa\" would be two a's that are not consecutive? But the string is \"a b c a\" -> the two a's are not consecutive. How about the substring from the first a to the last a? \"abca\" -> which we already checked. But note: the condition is for contiguous substring.",
      "start_char": 37966,
      "end_char": 38280,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "The contiguous substring that is \"aa\" does not exist because they are not consecutive.",
      "start_char": 38311,
      "end_char": 38397,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "However, what about the substring \"a\" (the first a) and then the last a? They are not contiguous. So the only contiguous substrings are: \n                \"a\", \"ab\", \"abc\", \"abca\", \"b\", \"bc\", \"bca\", \"c\", \"ca\", \"a\"\n\n            Now, check the substring \"a\" (first) and the substring \"a\" (last) are both length1 -> okay. The substring \"ca\": c:1, a:1 -> okay. The substring \"bca\": b:1, c:1, a:1 -> okay. So \"abca\" is balanced. But what about \"abac\": \n            distinct = {'a','b','c'} -> \n            Check adjacent: \n                \"ab\": ok\n                \"ba\": ok\n                \"ac\": ok -> no break. Check triples:\n                \"aba\": pattern -> s[0]=='a', s[2]=='a' -> and distinct has 3>2 -> break and print \"NO\". So we have:\n\n            t = int(input().strip())\n            for _ in range(t):\n                s = input().strip()\n                distinct = set(s)\n                n = len(s) if len(distinct)==1:\n                    print(\"YES\")\n                else:\n                    # Check adjacent duplicates\n                    flag = False\n                    for i in range(n-1): if s[i]==s[i+1]:\n                            print(\"NO\")\n                            flag = True\n                            break\n                    if flag:\n                        continue\n\n                    # Now check for triples of the form \"aba\"\n                    for i in range(n-2):\n                        if s[i]==s[i+2] and s[i]!=s[i+1]: if len(distinct)>2:\n                                print(\"NO\")\n                                flag = True\n                                break\n                    if not flag:\n                        print(\"YES\")",
      "start_char": 38412,
      "end_char": 40233,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "However, what if the entire string has two distinct characters and we have an \"aba\" pattern? Example: \"aba\": \n            distinct = {'a','b'} -> len=2 -> we don't break in the triple check -> then print \"YES\". But we know \"aba\" is balanced? The entire string: \n                substrings: \n                    \"a\": a:1, b:0 -> |1-0|=1 -> okay? \n                    \"ab\": a:1, b:1 -> okay. \"aba\": a:2, b:1 -> |2-1|=1 -> okay. \"b\": 0,1 -> okay. \"ba\": 1,1 -> okay. So it is balanced. Therefore, the code becomes:\n\n        t = int(input().strip())\n        for _ in range(t):\n            s = input().strip()\n            distinct = set(s)\n            n = len(s)\n            if len(distinct)==1:\n                print(\"YES\")\n                continue\n\n            # Check for consecutive duplicates\n            if any(s[i]==s[i+1] for i in range(n-1)):\n                print(\"NO\")\n                continue\n\n            # Check for any triple of the form \"aba\" (with the same at the ends) and if the distinct count is more than 2\n            found = False\n            for i in range(n-2):\n                if s[i]==s[i+2] and s[i]!=s[i+1]:\n                    if len(distinct)>2:\n                        print(\"NO\")\n                        found = True\n                        break\n            if not found:\n                print(\"YES\")\n\n   But note: what if the triple is \"aaa\"? But we already checked adjacent duplicates: so \"aaa\" would have been caught by the adjacent check? Because the first two are 'a' and 'a' -> adjacent duplicate -> break and print \"NO\". Therefore, we are safe.",
      "start_char": 40238,
      "end_char": 41942,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "However, what if the triple is \"abc\" and the distinct set has 3? We don't break -> then we print \"YES\". But that is correct. Let's test with the examples from the problem:\n\n        Example 1: \"aba\" -> \n            distinct = {'a','b'} -> \n            adjacent: \n                a and b -> ok\n                b and a -> ok -> no break. then check triples: \n                i=0: \"aba\": s[0]=='a', s[2]=='a' -> and distinct has 2 -> so we don't break -> then print \"YES\". Example 2: \"abb\": \n            adjacent: \n                a and b -> ok\n                b and b -> break -> print \"NO\". Example 3: \"abc\": \n            distinct = {'a','b','c'} -> \n            adjacent: \n                a and b -> ok\n                b and c -> ok -> no break. check triples: \n                i=0: \"abc\": not of the form \"aba\" -> skip. then print \"YES\". Example 4: \"aaba\" (from above) -> \n            adjacent: \n                first two: 'a' and 'a' -> break -> \"NO\". Example 5: \"abac\": \n            adjacent: \n                \"ab\": ok, \"ba\": ok, \"ac\": ok -> no break. check triples:\n                i=0: \"aba\": form -> and distinct has 3>2 -> print \"NO\". Example 6: \"abcb\": \n            adjacent: \n                \"ab\": ok, \"bc\": ok, \"cb\": ok -> no break. check triples:\n                i=0: \"abc\": skip.\n                i=1: \"bcb\": form -> distinct has 3>2 -> print \"NO\". Example 7: \"abab\": \n            distinct = {'a','b'} -> \n            adjacent: \n                \"ab\": ok, \"ba\": ok, \"ab\": ok -> no break. check triples:\n                i=0: \"aba\": form -> but distinct has 2 -> skip.\n                i=1: \"bab\": form -> distinct has 2 -> skip. then print \"YES\". This matches.",
      "start_char": 41951,
      "end_char": 43761,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Therefore, we can write the code accordingly. But note: the problem says the total length of s over test cases <=200000, so we are safe. However, the adjacent check: we do any(s[i]==s[i+1] for i in range(n-1)) -> which is O(n). And the triple check: we do at most n-2 iterations -> O(n). And the total n over test cases is 200000 -> so worst-case 200000*2 = 400000 iterations -> acceptable. Code:\n\n        t = int(input().strip())\n        for _ in range(t):\n            s = input().strip()\n            distinct = set(s)\n            n = len(s)\n            if len(distinct) == 1:\n                print(\"YES\")\n                continue\n\n            # Check adjacent duplicates\n            duplicate_found = False\n            for i in range(n-1):\n                if s[i] == s[i+1]:\n                    duplicate_found = True\n                    break\n\n            if duplicate_found:\n                print(\"NO\")\n                continue\n\n            # Check for any triple (i, i+1, i+2) such that s[i] == s[i+2] and s[i] ! = s[i+1]\n            triple_found = False\n            for i in range(n-2):\n                if s[i] == s[i+2] and s[i] ! = s[i+1]:\n                    if len(distinct) > 2:\n                        triple_found = True\n                        break\n\n            print(\"NO\" if triple_found else \"YES\") But note: the problem says the total length of s over test cases <=200000, so we are safe.",
      "start_char": 43782,
      "end_char": 45220,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "However, we can optimize the adjacent duplicate check with:\n\n        for i in range(n-1): if s[i]==s[i+1]:\n                ...\n\n   This is O(n) per test case, and total n is 200000 -> acceptable.\n\n   But note: the problem says the total length of s over test cases is 200000, so worst-case one test case with n=200000 -> then the adjacent duplicate check is 200000 iterations -> acceptable. Therefore, we output:\n\n        t = int(input().strip())\n        for _ in range(t):\n            s = input().strip()\n            distinct = set(s)\n            n = len(s)\n            if len(distinct) == 1:\n                print(\"YES\") continue\n\n            dup = False\n            for i in range(n-1):\n                if s[i] == s[i+1]:\n                    dup = True\n                    break\n\n            if dup:\n                print(\"NO\")\n                continue\n\n            triple = False\n            for i in range(n-2):\n                if s[i] == s[i+2]:  # and s[i]!=s[i+1] is not needed? because if s[i]==s[i+2] and we have no adjacent duplicates, then s[i]!=s[i+1] automatically? \n                    # Because if s[i]==s[i+1] we already broke, and if s[i+1]==s[i+2] we broke? \n                    # But note: we broke at the first adjacent duplicate. #",
      "start_char": 45225,
      "end_char": 46510,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "However, we are at index i and i+2: we don't know about i+1 and i+2? \n                    # But we have already checked the entire string for adjacent duplicates, so we know that s[i+1]!=s[i+2] and s[i]!=s[i+1]. # Therefore, we don't need to check s[i]!=s[i+1]? # But what if s[i]==s[i+2] and s[i]==s[i+1]? -> that would be three same -> but we already broke at the adjacent duplicate at i and i+1? # So we can skip the check for s[i]!=s[i+1]? \n                    #",
      "start_char": 46532,
      "end_char": 47061,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "However, what if the adjacent duplicate was not at i and i+1 but at a later position? # But we break at the first adjacent duplicate. So if we are in the triple loop, we know there are no adjacent duplicates anywhere. # Therefore, we know s[i]!=s[i+1] and s[i+1]!=s[i+2]. # So we can just check s[i]==s[i+2]. if len(distinct) > 2:\n                        triple = True\n                        break\n\n            print(\"NO\" if triple else \"YES\")\n\n   But note: the triple condition: we break only if the distinct count is more than 2?",
      "start_char": 47062,
      "end_char": 47678,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "However, what if the distinct count is 2? Then we don't break -> which is correct. Therefore, we can remove the s[i]!=s[i+1] condition. Final code:\n\n        t = int(input().strip())\n        for _ in range(t):\n            s = input().strip()\n            distinct = set(s)\n            n = len(s)\n            if len(distinct) == 1:\n                print(\"YES\")\n                continue\n\n            # Check for any adjacent duplicate\n            has_dup = False\n            for i in range(n-1):\n                if s[i] == s[i+1]:\n                    has_dup = True\n                    break\n\n            if has_dup:\n                print(\"NO\")\n                continue\n\n            # Check for any triple with s[i] == s[i+2] and distinct count > 2\n            found = False\n            for i in range(n-2):\n                if s[i] == s[i+2]:\n                    if len(distinct) > 2:\n                        found = True\n                        break\n\n            print(\"NO\" if found else \"YES \")\n\n   Let's test with \"aba\": \n        distinct = {'a','b'} -> \n        no adjacent duplicate -> \n        then i=0: s[0]=='a', s[2]=='a' -> but distinct=2 -> not >2 -> so we don't break -> then print \"YES\". With \"abc\": \n        distinct=3 -> \n        no adjacent duplicate -> \n        then check: \n            i=0: s[0]=='a', s[2]=='c' -> not equal -> skip. then print \"YES\". With \"abac\": \n        distinct=3 -> \n        i=0: s[0]=='a', s[2]=='a' -> equal -> and distinct>2 -> break -> print \"NO\". With \"abab\": \n        distinct=2 -> \n        i=0: s[0]=='a', s[2]=='a' -> but distinct=2 -> skip. i=1: s[1]=='b', s[3]=='b' -> skip. then print \"YES\". This matches.",
      "start_char": 47684,
      "end_char": 49372,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "However, note: what if the triple is \"aaa\"? But we already break at the adjacent duplicate: the first two 'a's -> so we never get to the triple. Therefore, we are done. But note: the problem says the total length of s over test cases <=200000, so we are safe. However, the problem says: the total length of s over test cases <=200000, so worst-case one test case with n=200000 -> then the adjacent duplicate loop is 200000 iterations and the triple loop is 200000 iterations -> 400000 iterations -> acceptable. But note: the problem says the total length of s over test cases is 200000, meaning the sum of n for all test cases is 200000. So worst-case: 200000 test cases each of length 1 -> then the adjacent duplicate loop: 0 iterations per test case -> total 0. Then the triple loop: 0 iterations per test case -> total 0.\n\n        Or worst-case: one test case of length 200000 -> then adjacent duplicate: 199999 iterations, triple: 199998 iterations -> total about 400000 -> acceptable.",
      "start_char": 49389,
      "end_char": 50421,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Therefore, we output the code accordingly. But note: the original code template was:\n\n        t = int(input()) while(t):\n            s = input()\n            d = len(set(s))\n            for i in range(d, len(s)):\n                if(s[i] ! = s[i - d]):\n                    # TODO: Your code here\n            else:\n                print(\"Yes\")\n            t -= 1\n\n   However, our solution does not use this pattern. We must output the missing code in the format:\n\n        {\"program1\": \"completion\", \"program2\": \"completion\"}\n\n   But note: the problem has two programs?",
      "start_char": 50426,
      "end_char": 51007,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Actually, the problem says: \"You will be given program1.py and program2.py with missing lines or blocks\"\n\n   But we only see one program: program1.py?",
      "start_char": 51013,
      "end_char": 51163,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "And the problem says: \"Output only the missing code so that \"python3 program1.py | program2.py\" runs correctly.\" And the example output format: \n        {\u201cprogram1\u201d: \u201ccompletion\u201d, \u201cprogram2\u201d: \u201ccompletion\u201d} But we are only given one program?",
      "start_char": 51169,
      "end_char": 51413,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Let me re-read: \n        \"You will be given program1.py and program2.py\" But in the problem statement, we are only shown program1.py?",
      "start_char": 51423,
      "end_char": 51556,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "And the problem says: \"Output only the missing code\"\n\n   And the example:",
      "start_char": 51566,
      "end_char": 51639,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "For the first test case, ... \n\n   But the problem has two programs?",
      "start_char": 51649,
      "end_char": 51716,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "Actually, the problem says: \"python3 program1.py | program2.py\"\n\n   So program1.py and program2.py are two separate programs that are piped together.",
      "start_char": 51722,
      "end_char": 51871,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "We are only given the code for program1.py? But the problem says: \"You will be given program1.py and program2.py with missing lines or blocks\"\n\n   And then we are shown:\n\n        # program1.py\n        ... \n\n        # program2.py\n        ... But in the problem statement, we see:\n\n        # program1.py\n        ...",
      "start_char": 51876,
      "end_char": 52189,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "and then:\n\n        # program2.py\n        ... But in the provided input, we only see one program?",
      "start_char": 52210,
      "end_char": 52306,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Actually, the problem has two parts: \n\n        program1.py: t = int(input())\n            while(t):\n                s = input()\n                d = len(set(s))\n                for i in range(d, len(s)):\n                    if(s[i] ! = s[i - d]):\n                        # TODO: Your code here\n                else:\n                    print(\"Yes\")\n                t -= 1\n\n        program2.py: \n            ... (not provided) But the problem says: \"Output only the missing code so that \"python3 program1.py | program2.py\" runs correctly.\"",
      "start_char": 52317,
      "end_char": 52865,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "And we are to output a json with two keys: \"program1\" and \"program2\".",
      "start_char": 52874,
      "end_char": 52943,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "However, the problem only provided one program?",
      "start_char": 52948,
      "end_char": 52995,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "Let me check the problem statement again: \n\n        \"You will be given program1.py and program2.py with missing lines or blocks that you must fill in.",
      "start_char": 53001,
      "end_char": 53151,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "\"\n\n   But in the description, we only see one code block for program1.py and then a separate code block for program2.py?",
      "start_char": 53151,
      "end_char": 53271,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Actually, the problem has two separate programs. But in the problem statement, we are only shown the code for program1.py?",
      "start_char": 53277,
      "end_char": 53399,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "And then the next part says:\n\n        # program2.py\n        ... But the code for program2.py is not provided?",
      "start_char": 53410,
      "end_char": 53519,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Actually, the problem says: \n\n        # program1.py\n        ...",
      "start_char": 53530,
      "end_char": 53593,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "(the code above)\n\n        # program2.py\n        ... (we don't see it) But then the problem says: \n\n        \"Complete the code in python to solve this programming problem:\"\n\n   and then the description.",
      "start_char": 53594,
      "end_char": 53795,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "And then the code for program1.py is given with a TODO.",
      "start_char": 53804,
      "end_char": 53859,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "And then the code for program2.py is given with a TODO? But in the problem statement, we only see one TODO in program1.py? And then the next part is:\n\n        # program2.py\n        t = int(input()) while(t):\r\n            s = input()\r\n            d = len(set(s))\r\n            for i in range(d, len(s)):\r\n                if(s[i] ! = s[i - d]):\r\n                    # TODO: Your code here\r\n            else:\r\n                print(\"Yes\")\r\n            t -= 1\n\n   Wait, that's the same as program1.py?",
      "start_char": 53864,
      "end_char": 54378,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Actually, the problem has two programs? But the problem says: \"python3 program1.py | program2.py\" And we are to complete both.",
      "start_char": 54384,
      "end_char": 54510,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "However, the problem statement only describes one problem?",
      "start_char": 54524,
      "end_char": 54582,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "And the example input/output is for the candy problem? But the program1.py and program2.py provided in the template are for a different problem?",
      "start_char": 54588,
      "end_char": 54732,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The template for program1.py and program2.py is the same?",
      "start_char": 54743,
      "end_char": 54800,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "And it is about a string and set(s) and a loop from d to len(s) and checking s[i] vs s[i-d]?",
      "start_char": 54806,
      "end_char": 54898,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "This looks like a problem about string periodicity. But the problem we solved is about balanced strings. There is a disconnect.",
      "start_char": 54904,
      "end_char": 55031,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "Let me re-read the problem: \n\n        \"Complete the code in python to solve this programming problem:\"\n\n        Description: ... (the candy problem)\n\n   Then it shows:\n\n        # program1.py\n        ... (code for the candy problem? but the code shown does not match the candy problem) Actually, the code shown for program1.py is:\n\n        t = int(input()) while(t):\n            s = input()\n            d = len(set(s))\n            for i in range(d, len(s)):\n                if(s[i] ! = s[i - d]):\n                    # TODO: Your code here\n            else:\n                print(\"Yes\")\n            t -= 1\n\n   This is not the candy problem.",
      "start_char": 55044,
      "end_char": 55694,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "And then it says:\n\n        # program2.py\n        ... (same as above) But the problem says: \"You will be given program1.py and program2.py\"\n\n   And then the example: \"python3 program1.py | program2.py\"\n\n   This suggests that program1.py and program2.py are two parts of a solution. But the candy problem is one problem. How can we have two programs?",
      "start_char": 55699,
      "end_char": 56047,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "The problem says: \"Output only the missing code so that \"python3 program1.py | program2.py\" runs correctly.\"",
      "start_char": 56065,
      "end_char": 56173,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "And the output format is a json with two keys.",
      "start_char": 56178,
      "end_char": 56224,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Therefore, we must complete both program1.py and program2.py. But the problem description is for the candy problem, and the provided code for program1.py and program2.py is for a string periodicity problem. This is confusing.",
      "start_char": 56229,
      "end_char": 56454,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Let me read the problem again: \n\n        \"Complete the code in python to solve this programming problem:\"\n\n        Then the description of the candy problem. Then it shows:\n\n            # program1.py\n            ... (code with TODO)",
      "start_char": 56467,
      "end_char": 56699,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Then:\n\n            # program2.py\n            ... (code with TODO) But the code in program1.py and program2.py is the same?",
      "start_char": 56718,
      "end_char": 56840,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "And it is not the candy problem. There might be a mistake.",
      "start_char": 56850,
      "end_char": 56908,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "Alternatively, the problem might be:",
      "start_char": 56917,
      "end_char": 56953,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "We are given two programs that are part of a solution to the candy problem. But the provided code in program1.py and program2.py does not resemble the candy problem we solved.",
      "start_char": 56964,
      "end_char": 57139,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "How can we output the missing code for program1.py and program2.py for the candy problem if the provided templates are for a different problem?",
      "start_char": 57148,
      "end_char": 57291,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "We must follow the provided templates.",
      "start_char": 57296,
      "end_char": 57334,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "Let me re-read the problem statement: \n\n        \"You will be given program1.py and program2.py with missing lines or blocks that you must fill in.",
      "start_char": 57339,
      "end_char": 57485,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "\"\n\n   And then it shows two code blocks, one for program1.py and one for program2.py. But in the provided message, we only see one code block for program1.py and then a separate code block for program2.py that is identical. And the TODO is in both. But the candy problem is not about string periodicity.",
      "start_char": 57485,
      "end_char": 57788,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Unless... \n\n   There is a known solution for the balanced string problem that uses periodicity?",
      "start_char": 57805,
      "end_char": 57900,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "Let me think: \n\n        We deduced that the string is balanced if:\n            (1) It has no two consecutive identical characters.",
      "start_char": 57906,
      "end_char": 58036,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "(2) If it has more than 2 distinct characters, then it has no triple of the form \"aba\" (which is a period of 2). But note: the triple \"aba\" has a period of 2? The provided template in program1.py and program2.py is:\n\n            t = int(input()) while(t):\n                s = input()\n                d = len(set(s))",
      "start_char": 58049,
      "end_char": 58395,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "for i in range(d, len(s)):\n                    if(s[i] ! = s[i - d]):\n                        # TODO: Your code here\n                else:\n                    print(\"Yes\")\n                t -= 1\n\n        This checks for a string being periodic with period d (the number of distinct characters).",
      "start_char": 58412,
      "end_char": 58705,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Specifically, it checks for i from d to len(s)-1: if s[i] ! = s[i-d] then ...",
      "start_char": 58716,
      "end_char": 58792,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "If it never breaks, it prints \"Yes\".",
      "start_char": 58803,
      "end_char": 58839,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "This is checking if the string is periodic with period d.",
      "start_char": 58849,
      "end_char": 58906,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "How is that related to the balanced string problem?",
      "start_char": 58916,
      "end_char": 58967,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "Consider: \n            If the string is periodic with period d, then what? Example: \n            s = \"abcabc\", d = 3. Then for i=3: s[3]='a', s[0]='a' -> equal. i=4: s[4]='b', s[1]='b' -> equal. i=5: s[5]='c', s[2]='c' -> equal. Then it prints \"Yes\". Is \"abcabc\" balanced? \n            distinct = {'a','b','c'} -> d=3. Check adjacent: \n                a!=b, b!=c, c!=a, a!=b, b!=c -> no adjacent duplicate. Check triples: \n                \"abc\": not \"aba\" -> skip. \"bca\": not -> skip. \"cab\": not -> skip. \"abc\": skip. \"bc\": ... But also check longer substrings?",
      "start_char": 58977,
      "end_char": 59660,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "However, we also have to check for missing characters in short substrings? Consider the substring \"abca\": \n                    a:2, b:1, c:1 -> then for the entire string distinct={'a','b','c'}, and in this substring, we have all distinct? min_freq=1, max_freq=2 -> difference=1 -> okay. Consider \"abcab\": \n                    a:2, b:2, c:1 -> differences: max-min=1 -> okay. Consider \"abcabc\": \n                    a:2, b:2, c:2 -> okay. But consider the substring \"aa\": does it appear?",
      "start_char": 59723,
      "end_char": 60280,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "The string is \"abcabc\", there is no \"aa\". So it is balanced. Example: \"aba\", distinct=2, d=2. i from 2 to 2: \n                i=2: s[2]='a', s[0]='a' -> equal -> then print \"Yes\". Example: \"abac\", distinct=3, d=3. i=3: s[3]='c', s[0]='a' -> not equal -> then we break out of the for loop? But the template has an else for the for loop?",
      "start_char": 60311,
      "end_char": 60702,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "The else clause of a for loop is executed if the loop did not break. So if we break, we do not execute the else. In this case, we break at i=3, so we do not print \"Yes\". But then what?",
      "start_char": 60733,
      "end_char": 60942,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "The TODO is in the break branch.",
      "start_char": 60956,
      "end_char": 60988,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "The template for program1.py and program2.py is the same.",
      "start_char": 60998,
      "end_char": 61055,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "How can we use this to solve the balanced string problem?",
      "start_char": 61066,
      "end_char": 61123,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "We want to print \"Yes\" for balanced and \"No\" for not balanced.",
      "start_char": 61133,
      "end_char": 61195,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "In the template, if the for loop completes without breaking, we print \"Yes\".",
      "start_char": 61205,
      "end_char": 61281,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "If we break, we have the TODO.",
      "start_char": 61291,
      "end_char": 61321,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "In the break, we should print \"No\" and then break the while for this test case? But note: the template has:\n\n            for i in range(d, len(s)):\n                if(s[i] ! = s[i - d]):\n                    # TODO:",
      "start_char": 61331,
      "end_char": 61554,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "Your code here\n            else:\n                print(\"Yes\")\n\n        If we break in the TODO, we break the for loop and then what? The else is not executed. Then the program continues to t-=1. But we want to print \"No\" for this test case. So in the TODO, we should print \"No\" and then break out of the for loop? But then the while loop continues.",
      "start_char": 61555,
      "end_char": 61903,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Actually, we can do:\n\n            if(s[i] ! = s[i - d]):\n                print(\"No\")\n                break\n\n        Then for the test case, if we break, we print \"No\", and then we do t-=1. But what if we don't break? then we print \"Yes\" in the else.",
      "start_char": 61931,
      "end_char": 62179,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Therefore, for one test case, we either print \"No\" in the for loop break, or \"Yes\" in the else.",
      "start_char": 62198,
      "end_char": 62293,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Now, is this condition sufficient for the balanced string problem? We need:",
      "start_char": 62303,
      "end_char": 62378,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "The string is balanced if and only if the for loop does not break.",
      "start_char": 62401,
      "end_char": 62467,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "What does the condition s[i] ! = s[i-d] mean?",
      "start_char": 62477,
      "end_char": 62521,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "We are checking for a period of d. But we know that the balanced condition requires:\n            (1) no adjacent duplicates -> which is not checked here.",
      "start_char": 62531,
      "end_char": 62694,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "(2) if distinct>2, then no \"aba\" pattern.",
      "start_char": 62707,
      "end_char": 62748,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "How is the periodic condition related?",
      "start_char": 62758,
      "end_char": 62796,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Claim: The string is balanced if and only if it is periodic with period d (distinct count) and has no adjacent duplicates. But wait, \"aba\" has d=2 and is periodic with period 2: \n            s0 = 'a', s1='b', s2='a' -> s2 should equal s0 -> it does. \"abc\" has d=3, and is periodic with period 3? It is, because we only check i>=3, and len(s)=3, so i from 3 to 2 -> the for loop is empty -> then we print \"Yes\". \"abac\" has d=3, and we check i=3: \n            s[3] = 'c', s[0]='a' -> not equal -> break and print \"No\". \"abab\" has d=2, and we check:\n            i=2: s[2]='a', s[0]='a' -> equal. i=3: s[3]='b', s[1]='b' -> equal. then print \"Yes\". \"abb\" (which is not balanced) has d=2, and we check:\n            i=2: s[2]='b', s[0]='a' -> not equal -> break and print \"No\". \"aab\" (not balanced) has d=2, and we check:\n            i=2: s[2]='b', s[0]='a' -> not equal -> break and print \"No\". \"aa\" (not balanced) has d=1, then the for loop: i from 1 to 1: \n            s[1]='a', s[0]='a' -> equal -> then print \"Yes\" -> but wait, \"aa\" is not balanced. So we see the periodic condition alone is not sufficient: we also need to check adjacent duplicates.",
      "start_char": 62806,
      "end_char": 64055,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "How to incorporate the adjacent duplicate check?",
      "start_char": 64074,
      "end_char": 64122,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "In the template, we are not given a separate check for adjacent duplicates.",
      "start_char": 64132,
      "end_char": 64207,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "We must do it within the provided structure.",
      "start_char": 64217,
      "end_char": 64261,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "We can do:\n\n            for i in range(d, len(s)):\n                if s[i] ! = s[i-d] or (i>=1 and s[i]==s[i-1]): \n                    ... But wait, the template only has one condition: s[i]!=s[i-d].",
      "start_char": 64271,
      "end_char": 64479,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "We are not allowed to change the condition?",
      "start_char": 64490,
      "end_char": 64533,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Or in the TODO, we can do additional checks.",
      "start_char": 64544,
      "end_char": 64588,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "In the TODO, we have:\n\n            if(s[i] ! = s[i - d]):\n                # TODO:",
      "start_char": 64598,
      "end_char": 64678,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "Your code here\n\n        We can do:\n\n            if(s[i] ! = s[i - d]):\n                print(\"No\")\n                break But this does not catch adjacent duplicates.",
      "start_char": 64679,
      "end_char": 64843,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "How about we check for adjacent duplicates in the for loop? We can do:\n\n            for i in range(d, len(s)):\n                if s[i] == s[i-1]:",
      "start_char": 64862,
      "end_char": 65017,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "# adjacent duplicate\n                    print(\"No\")\n                    break\n                if s[i] ! = s[i-d]:\n                    print(\"No\")\n                    break\n            else:\n                print(\"Yes\") But the range is from d to len(s)-1. This checks adjacent duplicates only for i>=d.",
      "start_char": 65020,
      "end_char": 65344,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "We also need to check for adjacent duplicates in the first d characters. So we must check the first d characters for adjacent duplicates as well.",
      "start_char": 65358,
      "end_char": 65503,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "We can do before the for loop: # Check the first d characters for adjacent duplicates?\n            for i in range(1, d):\n                if s[i] == s[i-1]:\n                    print(\"No\")\n                    break\n            else:\n                # then do the for loop for i in range(d, len(s)) with the checks above\n                ... But the template does not allow us to add a for loop before.",
      "start_char": 65522,
      "end_char": 65934,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, we can extend the for loop to start from 1? But the template says: for i in range(d, len(s)):\n\n        We are not allowed to change the for loop range.",
      "start_char": 65953,
      "end_char": 66119,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "How about we check the adjacent duplicates in the TODO for indices < d? \n\n        We can do in the TODO:\n\n            if i < d: \n                # but i starts at d, so we never have i<d. So we cannot.",
      "start_char": 66139,
      "end_char": 66340,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Another idea: \n\n            We can check the entire string for adjacent duplicates in a separate loop before the provided for loop, but within the while(t) loop.",
      "start_char": 66359,
      "end_char": 66520,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "The template does not forbid adding code before the for loop.",
      "start_char": 66530,
      "end_char": 66591,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "The TODO is only in the if block. So we can do:\n\n            t = int(input()) while(t):\n                s = input()\n                d = len(set(s)) # Check for adjacent duplicates in the entire string\n                flag = False\n                for i in range(1, len(s)):\n                    if s[i] == s[i-1]:\n                        print(\"No\")\n                        flag = True\n                        break\n                if flag:\n                    t -= 1\n                    continue\n\n                for i in range(d, len(s)):\n                    if(s[i] ! = s[i - d]):\n                        print(\"No\")\n                        break\n                else:\n                    print(\"Yes\")\n                t -= 1",
      "start_char": 66601,
      "end_char": 67362,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "This will work for the adjacent duplicates. But note: the problem says the total length of s over test cases <=200000, and we are doing an extra O(n) per test case -> total O(200000) -> acceptable. Let's test:\n\n            \"aa\": d=1. Check adjacent: i=1: s[1]=='a', s[0]=='a' -> print \"No\", then continue. \"aba\": d=2. Check adjacent: \n                    i=1: 'b' vs 'a' -> not equal.\n                    i=2: 'a' vs 'b' -> not equal. Then for i in range(2,3): i=2: s[2]=='a', s[0]=='a' -> equal -> then for loop finishes -> else: print \"Yes\". \"abb\": d=2. Check adjacent: \n                    i=1: 'b' vs 'a' -> not equal. i=2: 'b' vs 'b' -> equal -> print \"No\". \"abac\": d=3. Check adjacent: \n                    i=1: 'b' vs 'a' -> not.\n                    i=2: 'a' vs 'b' -> not. i=3: 'c' vs 'a' -> not. Then for i in range(3,4): i=3: s[3]=='c', s[0]=='a' -> not equal -> print \"No\". \"abc\": d=3. Check adjacent: \n                    i=1: 'b' vs 'a' -> not.\n                    i=2: 'c' vs 'b' -> not. Then for i in range(3,3) -> empty -> else: print \"Yes\". \"abab\": d=2. Check adjacent: \n                    i=1: 'b' vs 'a' -> not.\n                    i=2: 'a' vs 'b' -> not. i=3: 'b' vs 'a' -> not. Then for i in range(2,4): \n                    i=2: s[2]=='a', s[0]=='a' -> equal. i=3: s[3]=='b', s[1]=='b' -> equal. then print \"Yes\". This matches. But note: the condition for the triple \"aba\" in a string with distinct>2 is caught by the periodicity check? In \"abac\", distinct=3, and we check s[3] (='c') against s[0] (='a') -> not equal -> break. Why is that?",
      "start_char": 67372,
      "end_char": 69301,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "In a periodic string with period d, the character at position i must equal the character at position i mod d. For \"abac\": \n                positions: \n                    0: 'a'\n                    1: 'b'\n                    2: 'a'\n                    3: 'c'\n                We expect: \n                    position 3 should be the same as position 3 mod 3 = 0 -> 'a', but we have 'c' -> not periodic.",
      "start_char": 69324,
      "end_char": 69737,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "In a balanced string with distinct characters d, is it necessarily periodic with period d?",
      "start_char": 69747,
      "end_char": 69837,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "Consider \"abc\": \n            periodic with period 3: \n                positions: 0:'a', 1:'b', 2:'c', 3:? (none) -> it is periodic. Consider \"abcd\": \n            distinct=4, \n            positions: 0:'a',1:'b',2:'c',3:'d' -> periodic? i=4: not present. so it is periodic. Consider \"abcabc\": \n            distinct=3, \n            periodic with period 3.\n\n        Consider \"aba\": \n            distinct=2, \n            periodic with period 2: \n                position0: 'a'\n                position1: 'b'\n                position2: 'a' -> should be the same as position0 -> 'a' -> matches.",
      "start_char": 69848,
      "end_char": 70486,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Consider \"abac\" is not periodic with period 3. But is every balanced string periodic with period d? We have to be cautious.",
      "start_char": 70496,
      "end_char": 70619,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "Claim: If a string has distinct set of size d and is balanced, then it is periodic with period d.\n\n        Proof sketch:",
      "start_char": 70648,
      "end_char": 70768,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "By the balanced condition, we know there are no adjacent duplicates, and for any two characters the difference in any substring is at most 1.",
      "start_char": 70782,
      "end_char": 70923,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "In particular, consider the first d characters: they must be all distinct? Because if there is a duplicate in the first d characters, then we have two of the same within a substring of length d, and then if there is a character missing in that substring (which there is, because we have d distinct and one duplicate -> then one distinct is missing in the substring) -> then the max frequency is 2 and min is 0 -> difference 2 -> violation.",
      "start_char": 70937,
      "end_char": 71393,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Therefore, the first d characters are distinct.",
      "start_char": 71406,
      "end_char": 71453,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Now, consider the next character at position d.",
      "start_char": 71467,
      "end_char": 71514,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "It must be the same as the first character? Why?",
      "start_char": 71532,
      "end_char": 71580,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Consider the substring s[0:d+1].",
      "start_char": 71615,
      "end_char": 71647,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "This substring has length d+1. The distinct set of the entire string is d, so there is at least one character that appears at least ceil((d+1)/d)=2 times? But wait, we want to show it is periodic.",
      "start_char": 71665,
      "end_char": 71878,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Alternatively, we can use the fact that the balanced condition forces a very regular structure. But note: the example \"abab\" has distinct=2 and is periodic with period 2. However, consider a string with distinct=3: \"abcabc\" -> periodic. Consider a string with distinct=3: \"abc\" -> periodic.\n\n        Consider a string with distinct=3: \"acb\" -> not the same as the first three? But is \"acb\" balanced?",
      "start_char": 71909,
      "end_char": 72335,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "Check adjacent: no duplicates. Check triples: \n                \"acb\": distinct=3 -> in this substring, we have one of each -> min=1, max=1 -> okay. But the entire string is \"acb\", so no longer substring. So it is balanced.",
      "start_char": 72359,
      "end_char": 72593,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Is \"acb\" periodic with period 3? We only have three characters -> the for loop is empty -> so it is considered periodic. Now consider a string with distinct=3: \"acbacb\" -> periodic.\n\n        Consider a string with distinct=3: \"acbbac\" -> \n            Check adjacent: \n                a-c, c-b, b-b -> duplicate at b-b -> not balanced. How about \"acbca\" (distinct=3): \n            adjacent: a-c, c-b, b-c, c-a -> no adjacent duplicate. Check substring \"cbc\": \n                distinct: 'c','b' -> but the entire string has 'a','b','c'. In \"cbc\": a:0, b:1, c:2 -> |c-a|=2 -> violation. So it is not balanced. Now, is \"acbca\" periodic with period 3? \n            d=3. i=3: s[3]='c', s[0]='a' -> not equal -> not periodic.",
      "start_char": 72631,
      "end_char": 73443,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Therefore, it seems that the balanced condition is equivalent to:\n            (1) no adjacent duplicates, and\n            (2) the string is periodic with period d.",
      "start_char": 73453,
      "end_char": 73616,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "We have to check: \n            If a string has no adjacent duplicates and is periodic with period d (distinct count), is it balanced?",
      "start_char": 73626,
      "end_char": 73759,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "Consider any substring t. \n            We can write t as a contiguous substring of the periodic string. The periodic string has the form: \n                s = p0, p1, p2, ..., p_{d-1}, p0, p1, ... \n                where the first d characters are distinct.",
      "start_char": 73769,
      "end_char": 74037,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "In any contiguous substring, the frequency of a character c is floor((i1-i0+1)/d) or floor((i1-i0+1)/d)+1, and it is almost uniform.",
      "start_char": 74051,
      "end_char": 74183,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Specifically, the frequency of a character in a substring of length L is either floor(L/d) or floor(L/d)+1.",
      "start_char": 74197,
      "end_char": 74304,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Therefore, the difference between any two characters is at most 1. So it is balanced.",
      "start_char": 74318,
      "end_char": 74403,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Therefore, the condition is necessary and sufficient. So we can use:\n\n            t = int(input()) while(t):\n                s = input()\n                d = len(set(s))\n                # First, check for adjacent duplicates in the entire string\n                has_dup = False\n                for i in range(1, len(s)):\n                    if s[i] == s[i-1]:\n                        has_dup = True\n                        break\n                if has_dup:\n                    print(\"No\")\n                    t -= 1\n                    continue\n\n                # Then check periodicity with period d\n                periodic = True\n                for i in range(d, len(s)):\n                    if s[i] ! = s[i-d]:\n                        periodic = False\n                        break\n\n                print(\"Yes\" if periodic else \"No\")\n                t -= 1\n\n        But note: the template has the for loop and then an else for the for loop.",
      "start_char": 74426,
      "end_char": 75390,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "We can also do:\n\n            for i in range(d, len(s)):\n                if s[i] ! = s[i-d]:\n                    print(\"No\")\n                    break\n            else:\n                print(\"Yes\")",
      "start_char": 75401,
      "end_char": 75596,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "And we already did the adjacent duplicate check before. So the code for program1.py and program2.py might be the same? But the problem says: \"python3 program1.py | program2.py\"\n\n        This means the output of program1.py is piped to program2.py.",
      "start_char": 75606,
      "end_char": 75853,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Therefore, program1.py and program2.py are two separate programs that communicate via pipe. We must complete both.",
      "start_char": 75882,
      "end_char": 75996,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "How should we split the solution?",
      "start_char": 76015,
      "end_char": 76048,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "The overall solution has two parts: \n            (1) Read t test cases.",
      "start_char": 76058,
      "end_char": 76129,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "(2) For each test case, read s, then:\n                 a. Check adjacent duplicates. b. Check periodicity. But if we split, then program1.py might do part of the work and program2.py the other part.",
      "start_char": 76142,
      "end_char": 76340,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "The problem does not specify how to split.",
      "start_char": 76376,
      "end_char": 76418,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "Common practice in pipe: \n            program1.py reads the input and does some processing and writes to stdout.",
      "start_char": 76428,
      "end_char": 76540,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "program2.py reads from stdin (which is the stdout of program1.py) and does the rest.",
      "start_char": 76553,
      "end_char": 76637,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "We have to decide what to do in program1.py and what in program2.py.",
      "start_char": 76647,
      "end_char": 76715,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "We can do:\n\n            program1.py: \n                Read t. For each test case:\n                    read s.\n                    Check adjacent duplicates -> if found, output something to indicate failure for this test case.",
      "start_char": 76725,
      "end_char": 76966,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Otherwise, output the string s and its distinct count d? \n\n            program2.py:\n                Read the output of program1.py.",
      "start_char": 76987,
      "end_char": 77118,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "For each test case, it gets a string s and d. Then it checks periodicity and outputs \"Yes\" or \"No\". But then program1.py must output in a format that program2.py understands. Alternatively, we can do:\n\n            program1.py: \n                t = int(input())\n                print(t)   # so that program2.py knows how many test cases\n                for each test case:\n                    s = input().strip()\n                    d = len(set(s))\n                    # Check adjacent duplicates\n                    if any(s[i]==s[i+1] for i in range(len(s)-1)):\n                        # if there is an adjacent duplicate, we output a marker and then the string? # But program2.py needs the string to compute d? \n                        #",
      "start_char": 77135,
      "end_char": 77908,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Alternatively, we can output a flag and the string.\n                        print(\"0\")  # flag for not good\n                        print(s)\n                    else:\n                        print(\"1\")  # flag for good\n                        print(s)\n                        # and also output d? program2.py:\n                t = int(input())\n                for _ in range(t):\n                    flag = input().strip()\n                    s = input().strip()\n                    if flag==\"0\":\n                        print(\"No\")\n                    else:\n                        d = len(set(s))",
      "start_char": 77934,
      "end_char": 78544,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "# we can recompute, or we can pass it? \n                        # But program1.py did not pass d.\n                        # So we recompute. d = len(set(s))\n                        periodic = True\n                        for i in range(d, len(s)):\n                            if s[i] != s[i-d]:\n                                periodic = False\n                                break\n                        print(\"Yes\"",
      "start_char": 78547,
      "end_char": 78988,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "if periodic else \"No\")\n\n        But note: the distinct set might be computed twice: in program1.py and program2.py.\n\n        And the total length of s over test cases is 200000, so it is acceptable.",
      "start_char": 78989,
      "end_char": 79187,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "However, the problem says the provided template for program1.py and program2.py is as given.",
      "start_char": 79197,
      "end_char": 79289,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "We must fill in the TODO in the provided template. The provided template for program1.py is:\n\n            t = int(input()) while(t):\n                s = input()\n                d = len(set(s))",
      "start_char": 79299,
      "end_char": 79512,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "for i in range(d, len(s)):\n                    if(s[i] ! = s[i - d]):\n                        # TODO: Your code here\n                else:\n                    print(\"Yes\")\n                t -= 1\n\n        We cannot change the structure.",
      "start_char": 79529,
      "end_char": 79763,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "For program1.py, we must use this structure.",
      "start_char": 79773,
      "end_char": 79817,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "Similarly, program2.py has the same template.",
      "start_char": 79827,
      "end_char": 79872,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Therefore, we must solve the problem within the given structure for each program.",
      "start_char": 79882,
      "end_char": 79963,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "How can we split the condition between the two programs?\n\n        We can do:\n\n            program1.py: checks the adjacent duplicates and outputs an intermediate result.",
      "start_char": 79973,
      "end_char": 80142,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "program2.py: checks the periodicity. But the output of program1.py is the input to program2.py.",
      "start_char": 80155,
      "end_char": 80250,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Specifically, the stdout of program1.py is the stdin of program2.py.",
      "start_char": 80269,
      "end_char": 80337,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "We can have program1.py output for each test case:\n\n            If there is an adjacent duplicate, then output \"No\" for this test case.",
      "start_char": 80347,
      "end_char": 80482,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "Otherwise, output the string and also the distinct count d? But then program2.py would need to know which test case is which.",
      "start_char": 80495,
      "end_char": 80620,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Alternatively, we can do:\n\n            program1.py for each test case:\n                if there is an adjacent duplicate:",
      "start_char": 80640,
      "end_char": 80761,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "print(\"No\")\n                else:\n                    # We output the string in a transformed way? \n                    # But program2.py will then read this \"No\" as its input?",
      "start_char": 80783,
      "end_char": 80959,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "This will not work because program2.py expects t test cases, each with a string. We need a way to synchronize.",
      "start_char": 80974,
      "end_char": 81084,
      "label": "bug_fixing",
      "label_info": {
        "type": "bug_fixing"
      }
    },
    {
      "text": "Another idea: \n\n            program1.py does the adjacent duplicate check and if passed, it outputs the string.",
      "start_char": 81103,
      "end_char": 81214,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "If not passed, it outputs a special string (like \"!@#$\") that program2.py will recognize as a failure. But the string might be arbitrary.",
      "start_char": 81228,
      "end_char": 81365,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "Alternatively, we can output for each test case two lines:\n\n            line1: a flag (0 for failure due to adjacent duplicate, 1 for passed)\n            line2: the string (if passed) or a dummy string (if failed) but we can output the string always. Then program2.py reads two lines per test case. But the input to program1.py is the usual: \n            first line: t\n            then t lines of strings.",
      "start_char": 81384,
      "end_char": 81789,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "The output of program1.py should be:\n\n            t (but program2.py will read t, then 2*t lines) So:\n\n            program1.py:\n\n                t = int(input())\n                print(t)   # so that program2.py knows t\n                for i in range(t):\n                    s = input().strip()\n                    if we find an adjacent duplicate in s:\n                        print(\"0\")\n                        print(s)   # or a dummy, but we print s for consistency\n                    else:\n                        print(\"1\")\n                        print(s) program2.py:\n\n                t = int(input().strip())\n                for i in range(t):\n                    flag = input().strip()\n                    s = input().strip()\n                    if flag==\"0\":\n                        print(\"No\")\n                    else:\n                        d = len(set(s))\n                        for i in range(d, len(s)):\n                            if s[i] != s[i-d]:\n                                print(\"No\")\n                                break\n                        else:\n                            print(\"Yes\") But the template for program1.py is fixed.",
      "start_char": 81817,
      "end_char": 83003,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    },
    {
      "text": "We cannot change the output to include a flag and the string in two lines.",
      "start_char": 83013,
      "end_char": 83087,
      "label": "empty",
      "label_info": {
        "type": "empty"
      }
    },
    {
      "text": "The template for program1.py currently outputs either \"Yes\" in the else of the for loop, or in the TODO we must output something.",
      "start_char": 83097,
      "end_char": 83226,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "In the TODO, we can output \"No\" and then also output the string? But then program2.py will read that as the next test case? This is messy.",
      "start_char": 83236,
      "end_char": 83374,
      "label": "test_generation",
      "label_info": {
        "type": "test_generation"
      }
    },
    {
      "text": "Given the complexity, and since the problem says the total length of s over test cases is only 200000, we can do the entire solution in one program and pipe it to a program that does nothing? But the problem requires two programs.",
      "start_char": 83404,
      "end_char": 83634,
      "label": "high_level_plan",
      "label_info": {
        "type": "high_level_plan"
      }
    },
    {
      "text": "How about:\n\n            program1.py: \n                does the adjacent duplicate check and if passed, it outputs the string.",
      "start_char": 83654,
      "end_char": 83779,
      "label": "code_analysis",
      "label_info": {
        "type": "code_analysis"
      }
    },
    {
      "text": "if not passed, it outputs a string of one character: '0' (or something short)\n\n            program2.py: \n                reads a string for each test case. if the string is '0', then output \"No\"\n                else: \n                    d = len(set(s))\n                    ... and then the periodicity check. But then how does program2.py know how many test cases? \n\n        program",
      "start_char": 83796,
      "end_char": 84195,
      "label": "mental_execution",
      "label_info": {
        "type": "mental_execution"
      }
    }
  ],
  "metadata": {
    "answer": "```json\n{\n  \"program1\": \"        best = (i+1) + (n - j)\\n        i += 1\\n        if i < j:\\n            lsum += arr[i]\\n        j -= 1\\n        if i < j:\\n            rsum += arr[j]\",\n  \"program2\": \"    if int(c[0]) + int(c[1]) + int(c[2]) == int(c[3]) + int(c[4]) + int(c[5]):\\n        print(\\\"YES\\\")\\n    else:\\n        print(\\\"NO\\\")\"\n}\n```",
    "note": "the thinking is incomplete"
  },
  "original_reasoning": "<think>\nWe are guaranteed that the total length of all strings is <= 200,000.\n The problem: Check that for every substring t of s, and for every two characters u and v that appear in s, \n            |freq(u in t) - freq(v in t)| <= 1.\n\n However, note the note: the examples and the condition must hold for any triplet (t, u, v) where u and v are characters present in s.\n\n Important observation: \n The condition must hold for every substring t and for every pair of characters (u, v) that are in the entire string s.\n\n But note: the problem says \"for all possible triplets (t, u, v) such that t is a non-empty substring of s and u and v are characters present in s\"\n\n However, note the constraints: the total length of s over test cases is <= 200,000. But if we try to check every substring, that would be O(n^2) which is too slow.\n\n Alternate Insight:\n\n After reading the note and examples, we see that the problem is actually easier.\n\n Observation 1: The condition must hold for every contiguous substring. In particular, consider a substring of length 1: \n      For a single character c, then for any two distinct characters u and v, if u != c and v != c, then both frequencies are 0 -> okay.\n      But if one of them is c, say u = c and v is another, then |1-0| = 1 -> okay.\n      However, if we have two consecutive same characters? \n\n Example: \"aa\" -> in the substring \"aa\", if we take u='a' and v='b' (if 'b' is present in the entire string s) then |2-0| = 2 -> violates.\n\n But note: the condition says \"u and v are characters present in s\". So if the entire string s has only 'a', then we don't consider v='b' because 'b' is not present in s.\n\n Therefore, we only need to consider the characters that appear in the entire string.\n\n However, the problem becomes: for every substring t, and for every pair of distinct characters (u, v) that are in the entire string s, we require |freq(u in t) - freq(v in t)| <= 1.\n\n But note: if the entire string s has only one distinct character, then we don't have two distinct characters? Actually, the condition must hold for every pair of characters that are present. If there is only one, then there is no pair? So condition holds.\n\n However, what if the entire string has two distinct characters? Then we have to check for every substring that the counts of the two characters differ by at most 1.\n\n How about three distinct characters? Then we have to check for every substring and every pair of the three.\n\n This seems very heavy.\n\n Alternate Insight from known problems: \n There is a known problem: if a string is called balanced if for every two distinct characters the counts in any substring differ by at most 1? \n Actually, note the examples: \n   \"aba\" -> balanced, \"abc\" -> balanced, \"abb\" -> not balanced.\n\n How can we check this without iterating over all substrings?\n\n Observation 2: \n The condition is violated if there exists a substring t and two distinct characters u and v such that |freq(u in t) - freq(v in t)| >= 2.\n\n Since the condition is very strict, we can look for minimal violations.\n\n Consider: \n   The violation must occur in a relatively short substring? \n\n In fact, note that if we have two consecutive same characters, say \"aa\", then in the substring \"aa\", if there is another character (say 'b') that appears in the entire string, then |freq('a') - freq('b')| = 2 - 0 = 2 -> violation.\n\n But what if the entire string does not contain 'b'? Then we don't care about 'b'. So we only care about the characters that are in the entire string.\n\n However, note: the condition requires that for every pair of characters that are present in the entire string. So if the entire string has only 'a', then no problem. But if the entire string has at least two distinct characters, then we must check for every substring and every pair.\n\n But note: the example \"abb\": \n   Entire string has two distinct characters: 'a' and 'b'. \n   The substring \"bb\" has 0 a's and 2 b's -> |0-2| = 2 -> violation.\n\n Similarly, if we have \"aab\", then the substring \"aa\" has 2 a's and 0 b's -> |2-0|=2 -> violation.\n\n Therefore, we can deduce that if there is any substring of length 2 that has two of the same character, and if the entire string has at least two distinct characters, then that substring by itself (if it has two same characters) is a violation? \n\n However, what if the entire string has two distinct characters, but the substring of two same characters is the entire string? Then we have to check: \n   For the substring \"aa\", if the entire string has both 'a' and 'b', then we must consider the pair (a,b) and in the substring \"aa\", we have 2 a's and 0 b's -> violation.\n\n But what if the entire string does not have any other character? Then we don't have to check? \n\n Therefore, the violation can only occur if we have two consecutive same characters? \n\n However, consider a substring of three: \"aab\" -> the substring \"aa\" is of length 2 and has two a's and 0 b's -> violation.\n\n But note: the entire string \"aab\" has two distinct characters: 'a' and 'b'. So the substring \"aa\" (which is contiguous) is a violation.\n\n What about non consecutive? \n   Consider \"aba\": \n        substring \"aba\": a:2, b:1 -> |2-1|=1 -> okay.\n        substring \"ab\": a:1, b:1 -> okay.\n        substring \"ba\": same.\n\n   Consider \"abab\": \n        substring \"aba\": a:2, b:1 -> okay.\n        substring \"abab\": a:2, b:2 -> okay.\n\n   But what about \"aaba\": \n        substring \"aa\": a:2, b:0 -> violation.\n\n So the violation occurs if we have two consecutive same characters? \n\n However, what if we have three distinct characters? \n   Example: \"aabc\" -> substring \"aa\": \n        for pair (a,b): |2-0|=2 -> violation.\n        for pair (a,c): |2-0|=2 -> violation.\n\n   So again, two consecutive same characters cause a violation.\n\n But what if we have a longer gap? \n   Example: \"abac\": \n        substring \"aba\": a:2, b:1 -> okay for (a,b) and (a,c) and (b,c) in the entire string? \n        But note: the entire string has a, b, c. \n        Now consider the substring \"aba\": \n            a:2, b:1, c:0 -> \n                |a-b| = 1 -> okay\n                |a-c| = 2 -> violation.\n\n   So the substring \"aba\" has a violation for the pair (a,c). \n\n Therefore, we must also consider that if a character is missing in a substring and the entire string has that character, then the difference can be as large as the maximum frequency of a character that is present.\n\n How to avoid checking all substrings?\n\n We can try to look for minimal violations. The condition is violated if there exists a substring t and two distinct characters u and v such that |freq(u in t) - freq(v in t)| >= 2.\n\n Note that if we have a substring t that violates, then there must be two characters u and v and an integer k>=2 such that either:\n   freq(u in t) = k and freq(v in t) = k-2, or \n   freq(u in t) = k and freq(v in t) = k+2? Actually, the absolute difference is at least 2.\n\n But note: the minimal violation is when the difference is exactly 2. And we can look for the smallest substring that has a violation.\n\n Observation 3: \n   In fact, it is known from similar problems (e.g., CodeForces problems on balanced strings) that the only possible violations occur in substrings of length 2 or 3.\n\n Why?\n   Consider: \n     If we have a violation in a substring t, then there are two characters u and v such that |freq(u)-freq(v)|>=2.\n     Without loss of generality, assume freq(u) = a and freq(v)=b, and a>=b+2.\n\n     We can try to shrink the substring from the left and right until the violation still holds. \n        If we remove a character that is not u or v, then the difference remains the same (a-b) -> still violation.\n        If we remove a character that is u, then we get (a-1, b) -> difference a-1-b = (a-b)-1. Since a-b>=2, then (a-b)-1>=1 -> but we require at least 2? Then we might break the violation? \n        Similarly, if we remove a character that is v, then we get (a, b-1) -> difference a - (b-1) = a-b+1 -> which is even larger.\n\n     So we want to remove characters that are not u or v? \n\n     Alternatively, we can note that the minimal violation must occur in a substring that has at most 4 characters? \n\n   Actually, known fact: the condition is equivalent to the string being \"balanced\" in the sense that the only allowed substrings of two same characters are when the entire string has only one distinct character? \n\n   But we have a counterexample: \"aaba\" -> the violation is in \"aa\", which is of length 2.\n\n   What about a violation in a substring of length 3? \n        Example: \"aab\" -> the substring \"aa\" (length=2) is a violation? But wait, the entire string \"aab\" has two distinct characters? Then the substring \"aa\" (which is of length 2) is a violation.\n\n   How about a violation that requires 3? \n        Consider: \"aabc\" -> the substring \"aa\" (length=2) is a violation.\n\n   How about: \"abac\" -> the substring \"aba\" (length=3) is a violation? \n        In \"aba\": \n            a:2, b:1, c:0 -> so for the pair (a,c): |2-0|=2 -> violation.\n\n   So we have violations in substrings of length 2 and 3.\n\n   Therefore, we can check every substring of length 2 and 3? \n\n   But note: the total length of all strings is 200,000. The number of substrings of length 2 and 3 in one string of length n is (n-1) + (n-2) = 2n-3. \n        And the total n over test cases is 200,000 -> so total substrings to check is about 2*(200,000) = 400,000? \n\n   However, the problem says: the sum of |s| over all test cases does not exceed 200,000. So we can do:\n\n        total_n = 0\n        for each test case: \n            n = len(s)\n            total_n += n\n\n        and total_n <= 200,000.\n\n   Therefore, we can iterate over every test case and for each string, we can check every substring of length 2 and 3? \n\n   Steps for one test case:\n        Let d = distinct characters in s.\n        If d==1: then we don't have two distinct characters -> condition holds? Actually, no pair to compare -> so condition holds -> YES.\n\n        Else:\n            Check every substring of length 2: \n                if we find any substring of length 2 that has two same characters, then we have a violation? \n                    Why? because in that substring, the two same characters (say 'a') and any other distinct character (say 'b') that exists in the entire string (and note d>=2 so there is at least one other) will cause: \n                         freq(a)=2, freq(b)=0 -> |2-0|=2 -> violation.\n\n            Check every substring of length 3:\n                We need to check for every contiguous triple (i, i+1, i+2) and for every pair of distinct characters (u, v) that are in the entire string? \n                But note: we don't have to check every pair? Because the entire string might have many distinct characters, but the triple only has a few.\n\n                Actually, we can do: \n                    For a triple, we can count the frequency of each character in that triple. Then for any two distinct characters u and v that are in the entire string, we check |freq(u)-freq(v)|? \n                However, the entire string might have 26 distinct characters, but the triple only has at most 3. So we can check the distinct characters that appear in the entire string and also appear in the triple? \n\n                But note: if a character does not appear in the triple, then its frequency is 0. So we have to consider all distinct characters in the entire string? \n\n                However, the entire string might have 26 distinct characters, and we have to check 26*25 pairs for each triple? That would be 26*25*(n-2) which is about 650*(n) -> 650 * 200,000 = 130,000,000 per test case? \n                But the total n over test cases is 200,000 -> so worst-case one test case with n=200,000 -> 130e6 which is acceptable in Pyton? Maybe in C++ but in Python it might be borderline.\n\n                Alternatively, we can note: \n                    The condition in the triple is violated if there exists a character that appears at least twice and another character that does not appear at all? \n                    Why? because then the difference between the one that appears twice and the one that does not appear is 2.\n\n                Also, if a character appears three times and another appears once? Then |3-1|=2 -> violation? \n                Or if a character appears three times and another does not appear: |3-0|=3 -> violation.\n\n                Actually, the condition is violated in a triple if the maximum frequency of any character in the triple is at least 2 and the minimum frequency (among the distinct characters of the entire string) is 0? \n                But note: the entire string has multiple distinct characters. However, the triple might not contain all the distinct characters. \n\n                Specifically, for a triple t, let M = max{ f(c) for c in entire_string }? \n                But note: for a character c that is in the entire string but not in the triple, f(c)=0.\n\n                So the condition for the triple is violated if:\n                    max_freq = max( frequency in the triple of any character that is in the entire_string? ) \n                    min_freq = min( frequency in the triple of any character that is in the entire_string? ) \n                    and max_freq - min_freq >= 2.\n\n                However, note: the min_freq for a character that is in the entire string but not in the triple is 0. So if there is at least one character in the entire string that is missing in the triple, then min_freq=0. \n                Then if max_freq>=2, we have violation.\n\n                But what if the triple contains all the distinct characters? Then min_freq might be at least 1? \n                    Example: \"abc\": max_freq=1, min_freq=1 -> okay.\n                    Example: \"aba\": distinct in entire string is {'a','b'}. The triple \"aba\": \n                         a:2, b:1 -> min_freq=1, max_freq=2 -> difference=1 -> okay? \n                    But wait: the entire string might have a third character? \n                    Actually, the triple \"aba\" only has two characters. But the entire string might have a third character? Then we have to consider that third character? \n                    In the triple, the frequency of the third character is 0. So min_freq=0, max_freq=2 -> violation.\n\n                Therefore, we don't need to know which distinct characters are in the triple. We know the entire string has d distinct characters. \n                In the triple, we can only have at most 3 distinct characters. The rest (d-3) are missing (so frequency 0). \n\n                So condition for the triple: \n                    Let M = max( frequency of characters in the triple ) \n                    Then the min frequency is 0 (if d>3, then there is at least one missing character) OR if d<=3, then the min frequency is the minimum over the characters that are in the entire string? \n\n                Actually, we can compute:\n                    Let freq = [0]*26\n                    For the triple s[i:i+3], we count the frequency of each letter in the triple? \n                    Then we know that for any character c in the entire string that is not in the triple, freq(c)=0.\n\n                    Then the maximum frequency in the triple (over the 26 letters) is M, and the minimum frequency (over the entire_string's distinct set) is min( {freq(c) for c in set(s)} ) \n                    But note: for a character c in set(s) that is not in the triple, we have freq(c)=0.\n\n                    So the min_freq = min( min(freq(c) for c in set(s) that appears in the triple), 0 )? \n                    Actually, if there is at least one character in set(s) that is not in the triple, then min_freq=0.\n\n                Therefore, we can do:\n                    Let M = max(freq)   # over the 26 letters? but we only care about the ones that appear? but we can take the max over the entire 26? \n                    But note: the triple only has 3 characters, so we can compute the frequency for the entire_string? \n\n                Alternatively, we can note: \n                    The condition is violated if M>=2 and there exists at least one distinct character in the entire string that is missing in the triple? \n                    But how do we know if there is a distinct character missing? \n\n                We can precompute the distinct set for the entire string.\n\n                Then for the triple, we can check:\n                    Let present = set of characters in the triple.\n                    If the entire string has a distinct character not in present -> then min_freq=0 -> if M>=2 -> violation.\n\n                Also, what if the triple contains all distinct characters? Then we have to check the min_freq in the triple? \n                    min_freq = min( frequency of each distinct character in the triple ) \n                    Then if M - min_freq >= 2, then violation.\n\n                Example: \n                    s = \"aba\", distinct = {'a','b'}, triple=\"aba\": \n                         present = {'a','b'} -> no missing.\n                         frequencies: a:2, b:1 -> M=2, min_freq=1 -> 2-1=1 -> okay.\n\n                    s = \"aab\", distinct = {'a','b'}, triple=\"aab\": \n                         present = {'a','b'} -> no missing.\n                         frequencies: a:2, b:1 -> M=2, min_freq=1 -> 1 -> okay? \n                    But wait, the substring \"aab\" is of length 3, but we already found a violation in the substring \"aa\" (length=2). So we don't need to rely on the triple? \n\n                Actually, we already check length2: so the triple check might be redundant for the case of two same consecutive? \n\n                However, consider: \n                    s = \"abac\", distinct = {'a','b','c'}, and consider the triple \"aba\": \n                         present = {'a','b'} -> missing 'c' -> min_freq=0, M=2 -> violation.\n\n                So we need to check both.\n\n   Therefore, algorithm for one test case:\n\n        distinct = set(s)\n        d = len(distinct)\n\n        # If there is only one distinct character, then condition holds -> YES.\n        if d == 1:\n            print(\"YES\")\n            continue\n\n        n = len(s)\n        # Check all substrings of length 2\n        for i in range(n-1):\n            if s[i] == s[i+1]:\n                print(\"NO\")\n                break\n        else: \n            # Check all substrings of length 3\n            found = False\n            for i in range(n-2):\n                # Consider substring s[i:i+3]\n                triple = s[i:i+3]\n                # Count frequency in the triple for the 26 letters? We don't need 26, we can use a dict for the triple and then check the distinct set of the entire string.\n                freq = {}\n                for char in triple:\n                    freq[char] = freq.get(char,0)+1\n                M = max(freq.values())\n                # Now, if there is any character in the entire string (distinct) that is not in the triple, then min_freq=0 -> if M>=2, violation.\n                # If all distinct characters are in the triple, then min_freq = min(freq[c] for c in distinct) \n                # But note: the triple might not have all distinct? \n                missing = False\n                for c in distinct:\n                    if c not in freq:\n                        missing = True\n                        break\n\n                if missing:\n                    if M>=2:\n                        print(\"NO\")\n                        found = True\n                        break\n                else:\n                    min_freq = min(freq[c] for c in distinct)\n                    if M - min_freq >= 2:\n                        print(\"NO\")\n                        found = True\n                        break\n\n            if not found:\n                print(\"YES\")\n\n   However, note: what if the entire string has 4 distinct characters? \n        Example: \"abcd\" -> \n            Check length2: no consecutive same -> so we go to length3.\n            Check triple \"abc\": \n                distinct = {'a','b','c','d'} -> missing 'd' -> min_freq=0, M=1 -> 1<2 -> no violation.\n            Then triple \"bcd\": same -> no violation.\n            Then we say YES.\n\n        But is \"abcd\" balanced?\n            Consider the substring \"abcd\": \n                a:1, b:1, c:1, d:1 -> differences are 0 -> okay.\n            Consider any substring of length 1: okay.\n            Consider any substring of length 2: two different -> okay.\n            Consider any substring of length 3: e.g., \"abc\": \n                a:1, b:1, c:1, d:0 -> then for the pair (a,d): |1-0|=1 -> okay? \n                But wait, the condition says: for every pair of characters in the entire string. \n                So we must check (a,d): |1-0|=1 -> okay.\n                (b,d): |1-0|=1 -> okay.\n                (c,d): |1-0|=1 -> okay.\n\n            So \"abcd\" is balanced.\n\n   But what about \"aabc\" (with distinct = {'a','b','c'})? \n        We already break at the first substring of length2: \"aa\" -> we print \"NO\".\n\n   What about \"abac\" (distinct={'a','b','c'}): \n        Check length2: \n            \"ab\": a!=b -> okay\n            \"ba\": b!=a -> okay\n            \"ac\": a!=c -> okay\n        Then check length3: \n            \"aba\": \n                freq: a:2, b:1 -> distinct has 'a','b','c'. \n                missing: 'c' -> so min_freq=0, M=2 -> violation -> print \"NO\".\n\n   What about \"abcb\": \n        distinct = {'a','b','c'}\n        length2: \n            \"ab\": a!=b -> ok\n            \"bc\": b!=c -> ok\n            \"cb\": c!=b -> ok -> so no break.\n        length3:\n            \"abc\": \n                freq: a:1, b:1, c:1 -> no missing? no, distinct has a,b,c -> all present -> min_freq=1, M=1 -> no violation.\n            \"bcb\": \n                freq: b:2, c:1 -> distinct: a,b,c -> missing 'a' -> min_freq=0, M=2 -> violation -> \"NO\".\n\n   But is \"abcb\" balanced?\n        Consider the substring \"bcb\": \n            a:0, b:2, c:1 -> \n                |a-b|=2 -> violation.\n\n   So it works.\n\n   However, note: the problem says the total length of all test cases is <=200,000. \n        We are iterating for each test case: \n            For the length2: n-1 iterations per test case -> total over test cases: 200,000 (since total n<=200,000) -> that's acceptable.\n            For the length3: n-2 iterations per test case -> total over test cases: 200,000 - 2*(number of test cases) -> but the total n is 200,000, so worst-case 200,000 iterations? \n\n        But note: the total n over test cases is 200,000. So the total work for length2 and length3 is O(total_n) which is 200,000.\n\n   However, in the inner loop of the triple check, we do:\n        for each triple: \n            we build a frequency dictionary for 3 characters -> O(1)\n            we compute M = max(freq.values()) -> O(3) -> O(1)\n            we check for missing: we iterate over distinct until we find one missing? worst-case distinct size 26 -> O(26) per triple -> worst-case 26*(n-2) per test case.\n\n        But the total n over test cases is 200,000 -> worst-case 26 * 200,000 = 5,200,000 -> acceptable.\n\n   But note: the distinct set for the entire string is fixed per test case. We can precompute it. And the distinct set size is at most 26.\n\n   So we can do:\n\n        distinct = set(s)\n        d = len(distinct)\n\n        if d==1:\n            print(\"YES\")\n            continue\n\n        n = len(s)\n        # Check for consecutive same in length2\n        for i in range(n-1):\n            if s[i]==s[i+1]:\n                print(\"NO\")\n                break\n        else:\n            # Now check every triple\n            for i in range(n-2):\n                triple = s[i:i+3]\n                # Count frequency in the triple\n                freq = {}\n                for c in triple:\n                    freq[c] = freq.get(c,0)+1\n                M = max(freq.values())\n                # Check if there's any character in distinct missing in the triple?\n                # We can do: \n                #   if len(freq) < d:  # then there is at least one distinct character missing -> min_freq=0\n                if len(freq) < d:\n                    if M>=2:\n                        print(\"NO\")\n                        break\n                else:\n                    # All distinct characters are in the triple\n                    min_freq = min(freq[c] for c in distinct)   # but note: distinct is the set of the entire string, and we have all of them in the triple -> so we can compute min_freq from the freq dictionary? \n                    # However, note: the distinct set might have 26 characters? But we know the triple only has 3, so if d>3 then we wouldn't be in the else branch? \n                    # Actually, the else branch is only taken if len(freq) == d? \n                    # But wait: if the distinct set has 3, and the triple has 3 distinct, then len(freq)=3=d -> we enter else.\n                    # But if distinct set has 4, then we would have len(freq) <= 3 < 4 -> we enter the if branch (missing) -> so the else branch only runs when d<=3 and the triple has exactly d distinct characters.\n\n                    # So d is at most 3 -> so we can do min_freq = min(freq.values())? \n                    # But note: the distinct set is the entire string, and we are iterating over distinct -> but the keys in freq are exactly the distinct set? \n                    # Actually, no: the distinct set might be a subset of the keys? \n                    # We built freq only for the triple. The keys in freq are the distinct characters in the triple. \n                    # But we are in the branch where the distinct set is a subset of the keys? Actually, no: we are in the branch where the distinct set has the same size as the keys? \n                    # Actually, we are in the branch: len(freq) < d -> then we do the if. Otherwise, we do the else. \n                    # But note: it is possible that the distinct set has 3, and the triple has 3 distinct, so we do the else. \n                    # But the distinct set might be {'a','b','c'} and the triple might have {'a','b','d'}? -> but wait, the distinct set is the entire string, so the triple cannot have a character not in the distinct set? \n                    # Actually, the triple is a substring of s, so every character in the triple is in the distinct set. \n                    # Therefore, the distinct set is a superset of the keys of freq? \n                    # So in the else branch: we have that the distinct set is exactly the keys of freq? \n                    # Actually, no: the distinct set might be larger? But we are in the else branch only if the distinct set is contained in the keys? \n                    # We did: if len(freq) < d -> then there is a distinct character missing. \n                    # So the else branch: len(freq) >= d? \n                    # But note: the distinct set has d elements, and the triple has at most 3 distinct, and d can be at most 26. \n                    # Actually, the distinct set is the entire string, and the triple is a substring, so the distinct set of the triple is a subset of the distinct set of the entire string. \n                    # Therefore, the distinct set of the entire string has d elements, and the triple has len(freq) distinct. \n                    # We are in the else branch when len(freq) >= d? -> but that can only happen if len(freq)==d? \n                    # But note: the distinct set of the entire string has d elements, and the triple has at most d distinct? \n                    # Actually, the triple cannot have more distinct than the entire string. \n                    # So the condition for the else branch: we have that the distinct set of the entire string is exactly the distinct set of the triple? \n                    # That is, the triple contains all distinct characters of the entire string? \n\n                    # Therefore, we can compute min_freq = min(freq.values())   # because we are taking the min over the distinct set of the entire string, but since the triple has all distinct, then the min over the distinct set is the min of the freq values for the keys that are the distinct set -> which is the same as min(freq.values())? \n                    # But note: the distinct set is the keys of freq? \n                    # Actually, the distinct set is the set of characters that appear in the entire string, and the triple has exactly those? \n                    # Then the distinct set is the keys of freq. \n                    min_freq = min(freq.values())\n                    if M - min_freq >= 2:\n                        print(\"NO\")\n                        break\n            else:\n                print(\"YES\")\n\n   However, note: what if the entire string has 4 distinct characters? Then we never enter the else branch? \n        We only check the triple for missing: if there is a missing character (which there is, because the triple has at most 3) then we check M>=2. \n        But if the triple has M=1 (like \"abc\") then we don't break. \n        Then we move to the next triple. \n        Then if we never break, we print \"YES\".\n\n   This matches our example \"abcd\": \n        distinct = {'a','b','c','d'} -> d=4.\n        Check length2: no consecutive same -> then check triples:\n            \"abc\": len(freq)=3 < 4 -> missing -> M=1 -> no break.\n            \"bcd\": same -> no break.\n        Then print \"YES\".\n\n   But what if we have a string with 4 distinct and a triple that has two same? \n        Example: \"aabcde\" (distinct = {'a','b','c','d','e'}) -> \n            Check length2: \n                \"aa\" -> consecutive same -> break and print \"NO\".\n\n        Example: \"abacd\" (distinct = {'a','b','c','d'}) -> \n            length2: \n                \"ab\": ok\n                \"ba\": ok\n                \"ac\": ok\n                \"cd\": ok -> no break.\n            length3:\n                \"aba\": \n                    freq: a:2, b:1 -> distinct has 4 -> missing -> M=2 -> break and print \"NO\".\n\n   Therefore, the code for one test case:\n\n        s = input().strip()\n        distinct = set(s)\n        n = len(s)\n        if len(distinct) == 1:\n            print(\"YES\")\n        else:\n            found = False\n            for i in range(n-1):\n                if s[i] == s[i+1]:\n                    print(\"NO\")\n                    found = True\n                    break\n            if not found:\n                for i in range(n-2):\n                    # take substring s[i:i+3]\n                    t = s[i:i+3]\n                    freq = {}\n                    for c in t:\n                        freq[c] = freq.get(c,0)+1\n                    M = max(freq.values())\n                    if len(freq) < len(distinct):\n                        if M>=2:\n                            print(\"NO\")\n                            found = True\n                            break\n                    else:\n                        # then the triple has all distinct characters\n                        min_freq = min(freq.values())\n                        if M - min_freq >= 2:\n                            print(\"NO\")\n                            found = True\n                            break\n                if not found:\n                    print(\"YES\")\n\n   But note: the problem says the total length of s over test cases <= 200,000. \n        The inner loop for triples: worst-case we do (n-2) iterations per test case. \n        The total n over test cases is 200,000 -> so worst-case 200,000 iterations for the triples? \n        However, note: if we break early, we don't do all. \n\n   However, the problem says: the total length of all test cases is <=200,000. \n        But note: the input says \"the sum of |s| over all test cases does not exceed 200000\", so we are safe.\n\n   But note: the problem says \"the sum of n over all test cases does not exceed 200000\", meaning the total length of all strings is <=200000.\n\n   Therefore, we can do:\n\n        t = int(input().strip())\n        for _ in range(t):\n            s = input().strip()\n            distinct = set(s)\n            n = len(s)\n            if len(distinct) == 1:\n                print(\"YES\")\n            else:\n                # Check for consecutive duplicates in adjacent\n                if any(s[i] == s[i+1] for i in range(n-1)):\n                    print(\"NO\")\n                else:\n                    # Check for triples\n                    found = False\n                    for i in range(n-2):\n                        t = s[i:i+3]\n                        # We only care if the triple has at least one duplicate? \n                        # But we already know no consecutive duplicates, so the triple has no consecutive duplicates? \n                        # But we can have non consecutive duplicates: e.g., \"aba\"\n                        freq = {}\n                        for c in t:\n                            freq[c] = freq.get(c,0)+1\n                        M = max(freq.values())\n                        if len(freq) < len(distinct):\n                            if M>=2:\n                                print(\"NO\")\n                                found = True\n                                break\n                        else:\n                            min_freq = min(freq.values())\n                            if M - min_freq >= 2:\n                                print(\"NO\")\n                                found = True\n                                break\n                    if not found:\n                        print(\"YES\")\n\n   However, note: the triple might have non consecutive duplicates? But we already checked adjacent duplicates, so the triple cannot have two consecutive same. \n        But it can have the same at the ends: \"aba\" -> that's allowed? \n\n   But note: we break in the adjacent check only if we find two consecutive same. So if we get to the triple check, we know that there are no two consecutive same. \n        Therefore, the triple must be of the form: \n            abc, aba, abbc? -> but wait, we don't have consecutive same, so the triple cannot have \"aa\" in the first two or last two? \n            So the triple can be: \n                abc: all distinct -> then M=1 -> no problem.\n                aba: then the first and last are same -> then M=2 -> and we have to check.\n\n   So the triple \"aba\" is the only one that can have M=2.\n\n   Therefore, we can optimize: \n        We only need to check triples that have the form: \n            s[i] == s[i+2] and s[i]!=s[i+1] -> then we have \"aba\" pattern.\n\n        Then we can do:\n\n            for i in range(n-2):\n                if s[i] == s[i+2]:\n                    # then we have \"aba\" pattern -> then M=2 for the triple? \n                    # Now, we have to check: \n                    #   if the entire string has a distinct character that is not in the triple? \n                    #   or if the entire string has all distinct in the triple? \n                    # But note: the triple has two distinct: s[i] and s[i+1]. \n                    #   So if the entire string has a third distinct character, then we have a missing -> and M=2 -> violation.\n                    #   If the entire string has exactly these two distinct, then we have to check the min_freq: \n                    #        freq: s[i]:2, s[i+1]:1 -> min_freq=1 -> 2-1=1 -> no violation.\n\n                    # But wait: what if the entire string has more than two? \n                    #   Then we have a missing -> violation.\n\n                    if len(distinct) > 2:\n                        print(\"NO\")\n                        found = True\n                        break\n                    # else: if distinct has exactly 2, then no violation? \n            else:\n                print(\"YES\")\n\n        But note: what if the entire string has 4 distinct? Then we break at the first \"aba\" pattern? \n\n        Example: \"abac\": \n            distinct = {'a','b','c'} -> len=3>2 -> so we break at the first triple \"aba\" and print \"NO\".\n\n        Example: \"abab\": \n            distinct = {'a','b'} -> len=2 -> then we don't break? \n            Then we check the next triple: \"bab\": \n                s[1]=='b', s[3]=='b' -> \"bab\": same pattern -> distinct=2 -> no break.\n            Then we print \"YES\".\n\n        But is \"abab\" balanced?\n            The entire string: \n                distinct = {'a','b'}\n            Check every substring? \n                length1: ok.\n                length2: \"ab\": a:1,b:1 -> |1-1|=0 -> ok; \"ba\": same; \"ab\": same.\n                length3: \n                    \"aba\": a:2, b:1 -> |2-1|=1 -> ok? \n                    \"bab\": b:2, a:1 -> |2-1|=1 -> ok.\n                length4: \n                    \"abab\": a:2, b:2 -> |2-2|=0 -> ok.\n\n            So \"abab\" is balanced.\n\n        Therefore, we can do:\n\n            for i in range(n-2):\n                if s[i] == s[i+2] and s[i]!=s[i+1]:\n                    if len(distinct) > 2:\n                        print(\"NO\")\n                        found = True\n                        break\n            if not found:\n                print(\"YES\")\n\n        This is more efficient.\n\n        But note: what if the triple has three distinct? \n            Example: \"abc\" -> no \"aba\" pattern -> skip.\n            Example: \"aab\" -> but we already broke at the adjacent duplicate.\n\n        So the only triple we need to check is the \"aba\" pattern? \n\n        However, what about \"aaba\"? \n            We broke at the adjacent duplicate \"aa\", so we never get to the triple.\n\n        What about \"abca\": \n            distinct = {'a','b','c'} -> len=3>2 -> \n            Check triples:\n                \"abc\": no pattern -> skip.\n                \"bca\": no pattern -> skip.\n            Then we print \"YES\".\n\n        But is \"abca\" balanced?\n            Consider the substring \"abca\": \n                a:2, b:1, c:1 -> \n                    |a-b|=1, |a-c|=1, |b-c|=0 -> okay.\n            Consider the substring \"a\" (any single) -> okay.\n            Consider the substring \"aa\": not contiguous? \n                The substring \"aa\" is not contiguous? Actually, the substring \"aa\" would be two a's that are not consecutive? \n                But the string is \"a b c a\" -> the two a's are not consecutive. \n                How about the substring from the first a to the last a? \"abca\" -> which we already checked.\n\n            But note: the condition is for contiguous substring. \n                The contiguous substring that is \"aa\" does not exist because they are not consecutive. \n\n            However, what about the substring \"a\" (the first a) and then the last a? They are not contiguous. \n\n            So the only contiguous substrings are: \n                \"a\", \"ab\", \"abc\", \"abca\", \"b\", \"bc\", \"bca\", \"c\", \"ca\", \"a\"\n\n            Now, check the substring \"a\" (first) and the substring \"a\" (last) are both length1 -> okay.\n\n            The substring \"ca\": c:1, a:1 -> okay.\n\n            The substring \"bca\": b:1, c:1, a:1 -> okay.\n\n            So \"abca\" is balanced.\n\n        But what about \"abac\": \n            distinct = {'a','b','c'} -> \n            Check adjacent: \n                \"ab\": ok\n                \"ba\": ok\n                \"ac\": ok -> no break.\n            Check triples:\n                \"aba\": pattern -> s[0]=='a', s[2]=='a' -> and distinct has 3>2 -> break and print \"NO\".\n\n        So we have:\n\n            t = int(input().strip())\n            for _ in range(t):\n                s = input().strip()\n                distinct = set(s)\n                n = len(s)\n                if len(distinct)==1:\n                    print(\"YES\")\n                else:\n                    # Check adjacent duplicates\n                    flag = False\n                    for i in range(n-1):\n                        if s[i]==s[i+1]:\n                            print(\"NO\")\n                            flag = True\n                            break\n                    if flag:\n                        continue\n\n                    # Now check for triples of the form \"aba\"\n                    for i in range(n-2):\n                        if s[i]==s[i+2] and s[i]!=s[i+1]:\n                            if len(distinct)>2:\n                                print(\"NO\")\n                                flag = True\n                                break\n                    if not flag:\n                        print(\"YES\")\n\n   However, what if the entire string has two distinct characters and we have an \"aba\" pattern? \n        Example: \"aba\": \n            distinct = {'a','b'} -> len=2 -> we don't break in the triple check -> then print \"YES\".\n\n        But we know \"aba\" is balanced? \n            The entire string: \n                substrings: \n                    \"a\": a:1, b:0 -> |1-0|=1 -> okay? \n                    \"ab\": a:1, b:1 -> okay.\n                    \"aba\": a:2, b:1 -> |2-1|=1 -> okay.\n                    \"b\": 0,1 -> okay.\n                    \"ba\": 1,1 -> okay.\n            So it is balanced.\n\n   Therefore, the code becomes:\n\n        t = int(input().strip())\n        for _ in range(t):\n            s = input().strip()\n            distinct = set(s)\n            n = len(s)\n            if len(distinct)==1:\n                print(\"YES\")\n                continue\n\n            # Check for consecutive duplicates\n            if any(s[i]==s[i+1] for i in range(n-1)):\n                print(\"NO\")\n                continue\n\n            # Check for any triple of the form \"aba\" (with the same at the ends) and if the distinct count is more than 2\n            found = False\n            for i in range(n-2):\n                if s[i]==s[i+2] and s[i]!=s[i+1]:\n                    if len(distinct)>2:\n                        print(\"NO\")\n                        found = True\n                        break\n            if not found:\n                print(\"YES\")\n\n   But note: what if the triple is \"aaa\"? \n        But we already checked adjacent duplicates: so \"aaa\" would have been caught by the adjacent check? \n        Because the first two are 'a' and 'a' -> adjacent duplicate -> break and print \"NO\".\n\n   Therefore, we are safe.\n\n   However, what if the triple is \"abc\" and the distinct set has 3? \n        We don't break -> then we print \"YES\".\n\n   But that is correct.\n\n   Let's test with the examples from the problem:\n\n        Example 1: \"aba\" -> \n            distinct = {'a','b'} -> \n            adjacent: \n                a and b -> ok\n                b and a -> ok -> no break.\n            then check triples: \n                i=0: \"aba\": s[0]=='a', s[2]=='a' -> and distinct has 2 -> so we don't break -> then print \"YES\".\n\n        Example 2: \"abb\": \n            adjacent: \n                a and b -> ok\n                b and b -> break -> print \"NO\".\n\n        Example 3: \"abc\": \n            distinct = {'a','b','c'} -> \n            adjacent: \n                a and b -> ok\n                b and c -> ok -> no break.\n            check triples: \n                i=0: \"abc\": not of the form \"aba\" -> skip.\n            then print \"YES\".\n\n        Example 4: \"aaba\" (from above) -> \n            adjacent: \n                first two: 'a' and 'a' -> break -> \"NO\".\n\n        Example 5: \"abac\": \n            adjacent: \n                \"ab\": ok, \"ba\": ok, \"ac\": ok -> no break.\n            check triples:\n                i=0: \"aba\": form -> and distinct has 3>2 -> print \"NO\".\n\n        Example 6: \"abcb\": \n            adjacent: \n                \"ab\": ok, \"bc\": ok, \"cb\": ok -> no break.\n            check triples:\n                i=0: \"abc\": skip.\n                i=1: \"bcb\": form -> distinct has 3>2 -> print \"NO\".\n\n        Example 7: \"abab\": \n            distinct = {'a','b'} -> \n            adjacent: \n                \"ab\": ok, \"ba\": ok, \"ab\": ok -> no break.\n            check triples:\n                i=0: \"aba\": form -> but distinct has 2 -> skip.\n                i=1: \"bab\": form -> distinct has 2 -> skip.\n            then print \"YES\".\n\n   This matches.\n\n   Therefore, we can write the code accordingly.\n\n   But note: the problem says the total length of s over test cases <=200000, so we are safe.\n\n   However, the adjacent check: we do any(s[i]==s[i+1] for i in range(n-1)) -> which is O(n). \n        And the triple check: we do at most n-2 iterations -> O(n). \n        And the total n over test cases is 200000 -> so worst-case 200000*2 = 400000 iterations -> acceptable.\n\n   Code:\n\n        t = int(input().strip())\n        for _ in range(t):\n            s = input().strip()\n            distinct = set(s)\n            n = len(s)\n            if len(distinct) == 1:\n                print(\"YES\")\n                continue\n\n            # Check adjacent duplicates\n            duplicate_found = False\n            for i in range(n-1):\n                if s[i] == s[i+1]:\n                    duplicate_found = True\n                    break\n\n            if duplicate_found:\n                print(\"NO\")\n                continue\n\n            # Check for any triple (i, i+1, i+2) such that s[i] == s[i+2] and s[i] != s[i+1]\n            triple_found = False\n            for i in range(n-2):\n                if s[i] == s[i+2] and s[i] != s[i+1]:\n                    if len(distinct) > 2:\n                        triple_found = True\n                        break\n\n            print(\"NO\" if triple_found else \"YES\")\n\n   But note: the problem says the total length of s over test cases <=200000, so we are safe.\n\n   However, we can optimize the adjacent duplicate check with:\n\n        for i in range(n-1):\n            if s[i]==s[i+1]:\n                ...\n\n   This is O(n) per test case, and total n is 200000 -> acceptable.\n\n   But note: the problem says the total length of s over test cases is 200000, so worst-case one test case with n=200000 -> then the adjacent duplicate check is 200000 iterations -> acceptable.\n\n   Therefore, we output:\n\n        t = int(input().strip())\n        for _ in range(t):\n            s = input().strip()\n            distinct = set(s)\n            n = len(s)\n            if len(distinct) == 1:\n                print(\"YES\")\n                continue\n\n            dup = False\n            for i in range(n-1):\n                if s[i] == s[i+1]:\n                    dup = True\n                    break\n\n            if dup:\n                print(\"NO\")\n                continue\n\n            triple = False\n            for i in range(n-2):\n                if s[i] == s[i+2]:  # and s[i]!=s[i+1] is not needed? because if s[i]==s[i+2] and we have no adjacent duplicates, then s[i]!=s[i+1] automatically? \n                    # Because if s[i]==s[i+1] we already broke, and if s[i+1]==s[i+2] we broke? \n                    # But note: we broke at the first adjacent duplicate. \n                    # However, we are at index i and i+2: we don't know about i+1 and i+2? \n                    # But we have already checked the entire string for adjacent duplicates, so we know that s[i+1]!=s[i+2] and s[i]!=s[i+1]. \n                    # Therefore, we don't need to check s[i]!=s[i+1]? \n                    # But what if s[i]==s[i+2] and s[i]==s[i+1]? -> that would be three same -> but we already broke at the adjacent duplicate at i and i+1? \n                    # So we can skip the check for s[i]!=s[i+1]? \n                    # However, what if the adjacent duplicate was not at i and i+1 but at a later position? \n                    # But we break at the first adjacent duplicate. So if we are in the triple loop, we know there are no adjacent duplicates anywhere. \n                    # Therefore, we know s[i]!=s[i+1] and s[i+1]!=s[i+2]. \n                    # So we can just check s[i]==s[i+2]. \n                    if len(distinct) > 2:\n                        triple = True\n                        break\n\n            print(\"NO\" if triple else \"YES\")\n\n   But note: the triple condition: we break only if the distinct count is more than 2? \n\n   However, what if the distinct count is 2? Then we don't break -> which is correct.\n\n   Therefore, we can remove the s[i]!=s[i+1] condition.\n\n   Final code:\n\n        t = int(input().strip())\n        for _ in range(t):\n            s = input().strip()\n            distinct = set(s)\n            n = len(s)\n            if len(distinct) == 1:\n                print(\"YES\")\n                continue\n\n            # Check for any adjacent duplicate\n            has_dup = False\n            for i in range(n-1):\n                if s[i] == s[i+1]:\n                    has_dup = True\n                    break\n\n            if has_dup:\n                print(\"NO\")\n                continue\n\n            # Check for any triple with s[i] == s[i+2] and distinct count > 2\n            found = False\n            for i in range(n-2):\n                if s[i] == s[i+2]:\n                    if len(distinct) > 2:\n                        found = True\n                        break\n\n            print(\"NO\" if found else \"YES\")\n\n   Let's test with \"aba\": \n        distinct = {'a','b'} -> \n        no adjacent duplicate -> \n        then i=0: s[0]=='a', s[2]=='a' -> but distinct=2 -> not >2 -> so we don't break -> then print \"YES\".\n\n   With \"abc\": \n        distinct=3 -> \n        no adjacent duplicate -> \n        then check: \n            i=0: s[0]=='a', s[2]=='c' -> not equal -> skip.\n        then print \"YES\".\n\n   With \"abac\": \n        distinct=3 -> \n        i=0: s[0]=='a', s[2]=='a' -> equal -> and distinct>2 -> break -> print \"NO\".\n\n   With \"abab\": \n        distinct=2 -> \n        i=0: s[0]=='a', s[2]=='a' -> but distinct=2 -> skip.\n        i=1: s[1]=='b', s[3]=='b' -> skip.\n        then print \"YES\".\n\n   This matches.\n\n   However, note: what if the triple is \"aaa\"? \n        But we already break at the adjacent duplicate: the first two 'a's -> so we never get to the triple.\n\n   Therefore, we are done.\n\n   But note: the problem says the total length of s over test cases <=200000, so we are safe.\n\n   However, the problem says: the total length of s over test cases <=200000, so worst-case one test case with n=200000 -> then the adjacent duplicate loop is 200000 iterations and the triple loop is 200000 iterations -> 400000 iterations -> acceptable.\n\n   But note: the problem says the total length of s over test cases is 200000, meaning the sum of n for all test cases is 200000. \n        So worst-case: 200000 test cases each of length 1 -> then the adjacent duplicate loop: 0 iterations per test case -> total 0. \n        Then the triple loop: 0 iterations per test case -> total 0.\n\n        Or worst-case: one test case of length 200000 -> then adjacent duplicate: 199999 iterations, triple: 199998 iterations -> total about 400000 -> acceptable.\n\n   Therefore, we output the code accordingly.\n\n   But note: the original code template was:\n\n        t = int(input())\n        while(t):\n            s = input()\n            d = len(set(s))\n            for i in range(d, len(s)):\n                if(s[i] != s[i - d]):\n                    # TODO: Your code here\n            else:\n                print(\"Yes\")\n            t -= 1\n\n   However, our solution does not use this pattern. \n\n   We must output the missing code in the format:\n\n        {\"program1\": \"completion\", \"program2\": \"completion\"}\n\n   But note: the problem has two programs? \n\n   Actually, the problem says: \"You will be given program1.py and program2.py with missing lines or blocks\"\n\n   But we only see one program: program1.py? \n\n   And the problem says: \"Output only the missing code so that \"python3 program1.py | program2.py\" runs correctly.\"\n\n   And the example output format: \n        {\u201cprogram1\u201d: \u201ccompletion\u201d, \u201cprogram2\u201d: \u201ccompletion\u201d}\n\n   But we are only given one program? \n\n   Let me re-read: \n        \"You will be given program1.py and program2.py\"\n\n   But in the problem statement, we are only shown program1.py? \n\n   And the problem says: \"Output only the missing code\"\n\n   And the example: \n        For the first test case, ... \n\n   But the problem has two programs? \n\n   Actually, the problem says: \"python3 program1.py | program2.py\"\n\n   So program1.py and program2.py are two separate programs that are piped together.\n\n   We are only given the code for program1.py? \n\n   But the problem says: \"You will be given program1.py and program2.py with missing lines or blocks\"\n\n   And then we are shown:\n\n        # program1.py\n        ... \n\n        # program2.py\n        ... \n\n   But in the problem statement, we see:\n\n        # program1.py\n        ... \n\n        and then:\n\n        # program2.py\n        ... \n\n   But in the provided input, we only see one program? \n\n   Actually, the problem has two parts: \n\n        program1.py: \n            t = int(input())\n            while(t):\n                s = input()\n                d = len(set(s))\n                for i in range(d, len(s)):\n                    if(s[i] != s[i - d]):\n                        # TODO: Your code here\n                else:\n                    print(\"Yes\")\n                t -= 1\n\n        program2.py: \n            ... (not provided)\n\n   But the problem says: \"Output only the missing code so that \"python3 program1.py | program2.py\" runs correctly.\"\n\n   And we are to output a json with two keys: \"program1\" and \"program2\".\n\n   However, the problem only provided one program? \n\n   Let me check the problem statement again: \n\n        \"You will be given program1.py and program2.py with missing lines or blocks that you must fill in.\"\n\n   But in the description, we only see one code block for program1.py and then a separate code block for program2.py? \n\n   Actually, the problem has two separate programs. \n\n   But in the problem statement, we are only shown the code for program1.py? \n\n   And then the next part says:\n\n        # program2.py\n        ... \n\n   But the code for program2.py is not provided? \n\n   Actually, the problem says: \n\n        # program1.py\n        ... (the code above)\n\n        # program2.py\n        ... (we don't see it)\n\n   But then the problem says: \n\n        \"Complete the code in python to solve this programming problem:\"\n\n   and then the description.\n\n   And then the code for program1.py is given with a TODO.\n\n   And then the code for program2.py is given with a TODO? \n\n   But in the problem statement, we only see one TODO in program1.py? \n\n   And then the next part is:\n\n        # program2.py\n        t = int(input())\r\n        while(t):\r\n            s = input()\r\n            d = len(set(s))\r\n            for i in range(d, len(s)):\r\n                if(s[i] != s[i - d]):\r\n                    # TODO: Your code here\r\n            else:\r\n                print(\"Yes\")\r\n            t -= 1\n\n   Wait, that's the same as program1.py? \n\n   Actually, the problem has two programs? \n\n   But the problem says: \"python3 program1.py | program2.py\"\n\n   And we are to complete both.\n\n   However, the problem statement only describes one problem? \n\n   And the example input/output is for the candy problem? \n\n   But the program1.py and program2.py provided in the template are for a different problem? \n\n   The template for program1.py and program2.py is the same? \n\n   And it is about a string and set(s) and a loop from d to len(s) and checking s[i] vs s[i-d]? \n\n   This looks like a problem about string periodicity.\n\n   But the problem we solved is about balanced strings.\n\n   There is a disconnect.\n\n   Let me re-read the problem: \n\n        \"Complete the code in python to solve this programming problem:\"\n\n        Description: ... (the candy problem)\n\n   Then it shows:\n\n        # program1.py\n        ... (code for the candy problem? but the code shown does not match the candy problem)\n\n   Actually, the code shown for program1.py is:\n\n        t = int(input())\n        while(t):\n            s = input()\n            d = len(set(s))\n            for i in range(d, len(s)):\n                if(s[i] != s[i - d]):\n                    # TODO: Your code here\n            else:\n                print(\"Yes\")\n            t -= 1\n\n   This is not the candy problem.\n\n   And then it says:\n\n        # program2.py\n        ... (same as above)\n\n   But the problem says: \"You will be given program1.py and program2.py\"\n\n   And then the example: \"python3 program1.py | program2.py\"\n\n   This suggests that program1.py and program2.py are two parts of a solution.\n\n   But the candy problem is one problem.\n\n   How can we have two programs? \n\n   The problem says: \"Output only the missing code so that \"python3 program1.py | program2.py\" runs correctly.\"\n\n   And the output format is a json with two keys.\n\n   Therefore, we must complete both program1.py and program2.py.\n\n   But the problem description is for the candy problem, and the provided code for program1.py and program2.py is for a string periodicity problem.\n\n   This is confusing.\n\n   Let me read the problem again: \n\n        \"Complete the code in python to solve this programming problem:\"\n\n        Then the description of the candy problem.\n\n        Then it shows:\n\n            # program1.py\n            ... (code with TODO)\n\n        Then:\n\n            # program2.py\n            ... (code with TODO)\n\n   But the code in program1.py and program2.py is the same? \n\n   And it is not the candy problem.\n\n   There might be a mistake.\n\n   Alternatively, the problem might be: \n\n        We are given two programs that are part of a solution to the candy problem.\n\n   But the provided code in program1.py and program2.py does not resemble the candy problem we solved.\n\n   How can we output the missing code for program1.py and program2.py for the candy problem if the provided templates are for a different problem?\n\n   We must follow the provided templates.\n\n   Let me re-read the problem statement: \n\n        \"You will be given program1.py and program2.py with missing lines or blocks that you must fill in.\"\n\n   And then it shows two code blocks, one for program1.py and one for program2.py.\n\n   But in the provided message, we only see one code block for program1.py and then a separate code block for program2.py that is identical.\n\n   And the TODO is in both.\n\n   But the candy problem is not about string periodicity.\n\n   Unless... \n\n   There is a known solution for the balanced string problem that uses periodicity? \n\n   Let me think: \n\n        We deduced that the string is balanced if:\n            (1) It has no two consecutive identical characters.\n            (2) If it has more than 2 distinct characters, then it has no triple of the form \"aba\" (which is a period of 2).\n\n        But note: the triple \"aba\" has a period of 2? \n\n        The provided template in program1.py and program2.py is:\n\n            t = int(input())\n            while(t):\n                s = input()\n                d = len(set(s))\n                for i in range(d, len(s)):\n                    if(s[i] != s[i - d]):\n                        # TODO: Your code here\n                else:\n                    print(\"Yes\")\n                t -= 1\n\n        This checks for a string being periodic with period d (the number of distinct characters). \n\n        Specifically, it checks for i from d to len(s)-1: if s[i] != s[i-d] then ... \n\n        If it never breaks, it prints \"Yes\".\n\n        This is checking if the string is periodic with period d.\n\n        How is that related to the balanced string problem?\n\n        Consider: \n            If the string is periodic with period d, then what?\n\n        Example: \n            s = \"abcabc\", d = 3.\n            Then for i=3: s[3]='a', s[0]='a' -> equal.\n            i=4: s[4]='b', s[1]='b' -> equal.\n            i=5: s[5]='c', s[2]='c' -> equal.\n            Then it prints \"Yes\".\n\n        Is \"abcabc\" balanced? \n            distinct = {'a','b','c'} -> d=3.\n            Check adjacent: \n                a!=b, b!=c, c!=a, a!=b, b!=c -> no adjacent duplicate.\n            Check triples: \n                \"abc\": not \"aba\" -> skip.\n                \"bca\": not -> skip.\n                \"cab\": not -> skip.\n                \"abc\": skip.\n                \"bc\": ... \n                But also check longer substrings? \n            However, we also have to check for missing characters in short substrings? \n                Consider the substring \"abca\": \n                    a:2, b:1, c:1 -> then for the entire string distinct={'a','b','c'}, and in this substring, we have all distinct? \n                    min_freq=1, max_freq=2 -> difference=1 -> okay.\n                Consider \"abcab\": \n                    a:2, b:2, c:1 -> differences: max-min=1 -> okay.\n                Consider \"abcabc\": \n                    a:2, b:2, c:2 -> okay.\n\n            But consider the substring \"aa\": does it appear? \n                The string is \"abcabc\", there is no \"aa\". \n\n            So it is balanced.\n\n        Example: \"aba\", distinct=2, d=2.\n            i from 2 to 2: \n                i=2: s[2]='a', s[0]='a' -> equal -> then print \"Yes\".\n\n        Example: \"abac\", distinct=3, d=3.\n            i=3: s[3]='c', s[0]='a' -> not equal -> then we break out of the for loop? \n            But the template has an else for the for loop? \n                The else clause of a for loop is executed if the loop did not break.\n            So if we break, we do not execute the else.\n\n            In this case, we break at i=3, so we do not print \"Yes\". \n            But then what? The TODO is in the break branch.\n\n        The template for program1.py and program2.py is the same. \n\n        How can we use this to solve the balanced string problem?\n\n        We want to print \"Yes\" for balanced and \"No\" for not balanced.\n\n        In the template, if the for loop completes without breaking, we print \"Yes\". \n        If we break, we have the TODO.\n\n        In the break, we should print \"No\" and then break the while for this test case? \n\n        But note: the template has:\n\n            for i in range(d, len(s)):\n                if(s[i] != s[i - d]):\n                    # TODO: Your code here\n            else:\n                print(\"Yes\")\n\n        If we break in the TODO, we break the for loop and then what? The else is not executed. Then the program continues to t-=1.\n\n        But we want to print \"No\" for this test case.\n\n        So in the TODO, we should print \"No\" and then break out of the for loop? But then the while loop continues.\n\n        Actually, we can do:\n\n            if(s[i] != s[i - d]):\n                print(\"No\")\n                break\n\n        Then for the test case, if we break, we print \"No\", and then we do t-=1.\n\n        But what if we don't break? then we print \"Yes\" in the else.\n\n        Therefore, for one test case, we either print \"No\" in the for loop break, or \"Yes\" in the else.\n\n        Now, is this condition sufficient for the balanced string problem?\n\n        We need: \n            The string is balanced if and only if the for loop does not break.\n\n        What does the condition s[i] != s[i-d] mean?\n\n        We are checking for a period of d. \n\n        But we know that the balanced condition requires:\n            (1) no adjacent duplicates -> which is not checked here.\n            (2) if distinct>2, then no \"aba\" pattern.\n\n        How is the periodic condition related?\n\n        Claim: The string is balanced if and only if it is periodic with period d (distinct count) and has no adjacent duplicates.\n\n        But wait, \"aba\" has d=2 and is periodic with period 2: \n            s0 = 'a', s1='b', s2='a' -> s2 should equal s0 -> it does.\n\n        \"abc\" has d=3, and is periodic with period 3? \n            It is, because we only check i>=3, and len(s)=3, so i from 3 to 2 -> the for loop is empty -> then we print \"Yes\".\n\n        \"abac\" has d=3, and we check i=3: \n            s[3] = 'c', s[0]='a' -> not equal -> break and print \"No\".\n\n        \"abab\" has d=2, and we check:\n            i=2: s[2]='a', s[0]='a' -> equal.\n            i=3: s[3]='b', s[1]='b' -> equal.\n            then print \"Yes\".\n\n        \"abb\" (which is not balanced) has d=2, and we check:\n            i=2: s[2]='b', s[0]='a' -> not equal -> break and print \"No\".\n\n        \"aab\" (not balanced) has d=2, and we check:\n            i=2: s[2]='b', s[0]='a' -> not equal -> break and print \"No\".\n\n        \"aa\" (not balanced) has d=1, then the for loop: i from 1 to 1: \n            s[1]='a', s[0]='a' -> equal -> then print \"Yes\" -> but wait, \"aa\" is not balanced.\n\n        So we see the periodic condition alone is not sufficient: we also need to check adjacent duplicates.\n\n        How to incorporate the adjacent duplicate check?\n\n        In the template, we are not given a separate check for adjacent duplicates.\n\n        We must do it within the provided structure.\n\n        We can do:\n\n            for i in range(d, len(s)):\n                if s[i] != s[i-d] or (i>=1 and s[i]==s[i-1]): \n                    ... \n\n        But wait, the template only has one condition: s[i]!=s[i-d]. \n\n        We are not allowed to change the condition? \n\n        Or in the TODO, we can do additional checks.\n\n        In the TODO, we have:\n\n            if(s[i] != s[i - d]):\n                # TODO: Your code here\n\n        We can do:\n\n            if(s[i] != s[i - d]):\n                print(\"No\")\n                break\n\n        But this does not catch adjacent duplicates.\n\n        How about we check for adjacent duplicates in the for loop? \n\n        We can do:\n\n            for i in range(d, len(s)):\n                if s[i] == s[i-1]:   # adjacent duplicate\n                    print(\"No\")\n                    break\n                if s[i] != s[i-d]:\n                    print(\"No\")\n                    break\n            else:\n                print(\"Yes\")\n\n        But the range is from d to len(s)-1. \n            This checks adjacent duplicates only for i>=d. \n            We also need to check for adjacent duplicates in the first d characters.\n\n        So we must check the first d characters for adjacent duplicates as well.\n\n        We can do before the for loop:\n\n            # Check the first d characters for adjacent duplicates?\n            for i in range(1, d):\n                if s[i] == s[i-1]:\n                    print(\"No\")\n                    break\n            else:\n                # then do the for loop for i in range(d, len(s)) with the checks above\n                ...\n\n        But the template does not allow us to add a for loop before.\n\n        Alternatively, we can extend the for loop to start from 1? \n\n        But the template says: for i in range(d, len(s)):\n\n        We are not allowed to change the for loop range.\n\n        How about we check the adjacent duplicates in the TODO for indices < d? \n\n        We can do in the TODO:\n\n            if i < d: \n                # but i starts at d, so we never have i<d.\n\n        So we cannot.\n\n        Another idea: \n\n            We can check the entire string for adjacent duplicates in a separate loop before the provided for loop, but within the while(t) loop.\n\n        The template does not forbid adding code before the for loop.\n\n        The TODO is only in the if block.\n\n        So we can do:\n\n            t = int(input())\n            while(t):\n                s = input()\n                d = len(set(s))\n                # Check for adjacent duplicates in the entire string\n                flag = False\n                for i in range(1, len(s)):\n                    if s[i] == s[i-1]:\n                        print(\"No\")\n                        flag = True\n                        break\n                if flag:\n                    t -= 1\n                    continue\n\n                for i in range(d, len(s)):\n                    if(s[i] != s[i - d]):\n                        print(\"No\")\n                        break\n                else:\n                    print(\"Yes\")\n                t -= 1\n\n        This will work for the adjacent duplicates.\n\n        But note: the problem says the total length of s over test cases <=200000, and we are doing an extra O(n) per test case -> total O(200000) -> acceptable.\n\n        Let's test:\n\n            \"aa\": d=1.\n            Check adjacent: i=1: s[1]=='a', s[0]=='a' -> print \"No\", then continue.\n\n            \"aba\": d=2.\n                Check adjacent: \n                    i=1: 'b' vs 'a' -> not equal.\n                    i=2: 'a' vs 'b' -> not equal.\n                Then for i in range(2,3): i=2: s[2]=='a', s[0]=='a' -> equal -> then for loop finishes -> else: print \"Yes\".\n\n            \"abb\": d=2.\n                Check adjacent: \n                    i=1: 'b' vs 'a' -> not equal.\n                    i=2: 'b' vs 'b' -> equal -> print \"No\".\n\n            \"abac\": d=3.\n                Check adjacent: \n                    i=1: 'b' vs 'a' -> not.\n                    i=2: 'a' vs 'b' -> not.\n                    i=3: 'c' vs 'a' -> not.\n                Then for i in range(3,4): i=3: s[3]=='c', s[0]=='a' -> not equal -> print \"No\".\n\n            \"abc\": d=3.\n                Check adjacent: \n                    i=1: 'b' vs 'a' -> not.\n                    i=2: 'c' vs 'b' -> not.\n                Then for i in range(3,3) -> empty -> else: print \"Yes\".\n\n            \"abab\": d=2.\n                Check adjacent: \n                    i=1: 'b' vs 'a' -> not.\n                    i=2: 'a' vs 'b' -> not.\n                    i=3: 'b' vs 'a' -> not.\n                Then for i in range(2,4): \n                    i=2: s[2]=='a', s[0]=='a' -> equal.\n                    i=3: s[3]=='b', s[1]=='b' -> equal.\n                then print \"Yes\".\n\n        This matches.\n\n        But note: the condition for the triple \"aba\" in a string with distinct>2 is caught by the periodicity check? \n            In \"abac\", distinct=3, and we check s[3] (='c') against s[0] (='a') -> not equal -> break.\n\n        Why is that? \n            In a periodic string with period d, the character at position i must equal the character at position i mod d.\n            For \"abac\": \n                positions: \n                    0: 'a'\n                    1: 'b'\n                    2: 'a'\n                    3: 'c'\n                We expect: \n                    position 3 should be the same as position 3 mod 3 = 0 -> 'a', but we have 'c' -> not periodic.\n\n        In a balanced string with distinct characters d, is it necessarily periodic with period d? \n\n        Consider \"abc\": \n            periodic with period 3: \n                positions: 0:'a', 1:'b', 2:'c', 3:? (none) -> it is periodic.\n\n        Consider \"abcd\": \n            distinct=4, \n            positions: 0:'a',1:'b',2:'c',3:'d' -> periodic? \n                i=4: not present.\n                so it is periodic.\n\n        Consider \"abcabc\": \n            distinct=3, \n            periodic with period 3.\n\n        Consider \"aba\": \n            distinct=2, \n            periodic with period 2: \n                position0: 'a'\n                position1: 'b'\n                position2: 'a' -> should be the same as position0 -> 'a' -> matches.\n\n        Consider \"abac\" is not periodic with period 3.\n\n        But is every balanced string periodic with period d? \n\n        We have to be cautious.\n\n        Claim: If a string has distinct set of size d and is balanced, then it is periodic with period d.\n\n        Proof sketch: \n            By the balanced condition, we know there are no adjacent duplicates, and for any two characters the difference in any substring is at most 1. \n            In particular, consider the first d characters: they must be all distinct? \n                Because if there is a duplicate in the first d characters, then we have two of the same within a substring of length d, and then if there is a character missing in that substring (which there is, because we have d distinct and one duplicate -> then one distinct is missing in the substring) -> then the max frequency is 2 and min is 0 -> difference 2 -> violation.\n            Therefore, the first d characters are distinct.\n\n            Now, consider the next character at position d. \n                It must be the same as the first character? \n                Why? \n                Consider the substring s[0:d+1]. \n                This substring has length d+1. \n                The distinct set of the entire string is d, so there is at least one character that appears at least ceil((d+1)/d)=2 times? \n                But wait, we want to show it is periodic.\n\n            Alternatively, we can use the fact that the balanced condition forces a very regular structure.\n\n        But note: the example \"abab\" has distinct=2 and is periodic with period 2.\n\n        However, consider a string with distinct=3: \"abcabc\" -> periodic.\n\n        Consider a string with distinct=3: \"abc\" -> periodic.\n\n        Consider a string with distinct=3: \"acb\" -> not the same as the first three? \n\n        But is \"acb\" balanced? \n            Check adjacent: no duplicates.\n            Check triples: \n                \"acb\": distinct=3 -> in this substring, we have one of each -> min=1, max=1 -> okay.\n                But the entire string is \"acb\", so no longer substring.\n            So it is balanced.\n\n        Is \"acb\" periodic with period 3? \n            We only have three characters -> the for loop is empty -> so it is considered periodic.\n\n        Now consider a string with distinct=3: \"acbacb\" -> periodic.\n\n        Consider a string with distinct=3: \"acbbac\" -> \n            Check adjacent: \n                a-c, c-b, b-b -> duplicate at b-b -> not balanced.\n\n        How about \"acbca\" (distinct=3): \n            adjacent: a-c, c-b, b-c, c-a -> no adjacent duplicate.\n            Check substring \"cbc\": \n                distinct: 'c','b' -> but the entire string has 'a','b','c'. \n                In \"cbc\": a:0, b:1, c:2 -> |c-a|=2 -> violation.\n\n            So it is not balanced.\n\n        Now, is \"acbca\" periodic with period 3? \n            d=3.\n            i=3: s[3]='c', s[0]='a' -> not equal -> not periodic.\n\n        Therefore, it seems that the balanced condition is equivalent to:\n            (1) no adjacent duplicates, and\n            (2) the string is periodic with period d.\n\n        We have to check: \n            If a string has no adjacent duplicates and is periodic with period d (distinct count), is it balanced?\n\n        Consider any substring t. \n            We can write t as a contiguous substring of the periodic string.\n            The periodic string has the form: \n                s = p0, p1, p2, ..., p_{d-1}, p0, p1, ... \n                where the first d characters are distinct.\n\n            In any contiguous substring, the frequency of a character c is floor((i1-i0+1)/d) or floor((i1-i0+1)/d)+1, and it is almost uniform.\n\n            Specifically, the frequency of a character in a substring of length L is either floor(L/d) or floor(L/d)+1.\n\n            Therefore, the difference between any two characters is at most 1.\n\n            So it is balanced.\n\n        Therefore, the condition is necessary and sufficient.\n\n        So we can use:\n\n            t = int(input())\n            while(t):\n                s = input()\n                d = len(set(s))\n                # First, check for adjacent duplicates in the entire string\n                has_dup = False\n                for i in range(1, len(s)):\n                    if s[i] == s[i-1]:\n                        has_dup = True\n                        break\n                if has_dup:\n                    print(\"No\")\n                    t -= 1\n                    continue\n\n                # Then check periodicity with period d\n                periodic = True\n                for i in range(d, len(s)):\n                    if s[i] != s[i-d]:\n                        periodic = False\n                        break\n\n                print(\"Yes\" if periodic else \"No\")\n                t -= 1\n\n        But note: the template has the for loop and then an else for the for loop. \n\n        We can also do:\n\n            for i in range(d, len(s)):\n                if s[i] != s[i-d]:\n                    print(\"No\")\n                    break\n            else:\n                print(\"Yes\")\n\n        And we already did the adjacent duplicate check before.\n\n        So the code for program1.py and program2.py might be the same? \n\n        But the problem says: \"python3 program1.py | program2.py\"\n\n        This means the output of program1.py is piped to program2.py.\n\n        Therefore, program1.py and program2.py are two separate programs that communicate via pipe.\n\n        We must complete both.\n\n        How should we split the solution?\n\n        The overall solution has two parts: \n            (1) Read t test cases.\n            (2) For each test case, read s, then:\n                 a. Check adjacent duplicates.\n                 b. Check periodicity.\n\n        But if we split, then program1.py might do part of the work and program2.py the other part.\n\n        The problem does not specify how to split.\n\n        Common practice in pipe: \n            program1.py reads the input and does some processing and writes to stdout.\n            program2.py reads from stdin (which is the stdout of program1.py) and does the rest.\n\n        We have to decide what to do in program1.py and what in program2.py.\n\n        We can do:\n\n            program1.py: \n                Read t.\n                For each test case:\n                    read s.\n                    Check adjacent duplicates -> if found, output something to indicate failure for this test case.\n                    Otherwise, output the string s and its distinct count d? \n\n            program2.py:\n                Read the output of program1.py.\n                For each test case, it gets a string s and d.\n                Then it checks periodicity and outputs \"Yes\" or \"No\".\n\n        But then program1.py must output in a format that program2.py understands.\n\n        Alternatively, we can do:\n\n            program1.py: \n                t = int(input())\n                print(t)   # so that program2.py knows how many test cases\n                for each test case:\n                    s = input().strip()\n                    d = len(set(s))\n                    # Check adjacent duplicates\n                    if any(s[i]==s[i+1] for i in range(len(s)-1)):\n                        # if there is an adjacent duplicate, we output a marker and then the string? \n                        # But program2.py needs the string to compute d? \n                        # Alternatively, we can output a flag and the string.\n                        print(\"0\")  # flag for not good\n                        print(s)\n                    else:\n                        print(\"1\")  # flag for good\n                        print(s)\n                        # and also output d? \n\n            program2.py:\n                t = int(input())\n                for _ in range(t):\n                    flag = input().strip()\n                    s = input().strip()\n                    if flag==\"0\":\n                        print(\"No\")\n                    else:\n                        d = len(set(s))   # we can recompute, or we can pass it? \n                        # But program1.py did not pass d.\n                        # So we recompute.\n                        d = len(set(s))\n                        periodic = True\n                        for i in range(d, len(s)):\n                            if s[i] != s[i-d]:\n                                periodic = False\n                                break\n                        print(\"Yes\" if periodic else \"No\")\n\n        But note: the distinct set might be computed twice: in program1.py and program2.py.\n\n        And the total length of s over test cases is 200000, so it is acceptable.\n\n        However, the problem says the provided template for program1.py and program2.py is as given.\n\n        We must fill in the TODO in the provided template.\n\n        The provided template for program1.py is:\n\n            t = int(input())\n            while(t):\n                s = input()\n                d = len(set(s))\n                for i in range(d, len(s)):\n                    if(s[i] != s[i - d]):\n                        # TODO: Your code here\n                else:\n                    print(\"Yes\")\n                t -= 1\n\n        We cannot change the structure.\n\n        For program1.py, we must use this structure.\n\n        Similarly, program2.py has the same template.\n\n        Therefore, we must solve the problem within the given structure for each program.\n\n        How can we split the condition between the two programs?\n\n        We can do:\n\n            program1.py: checks the adjacent duplicates and outputs an intermediate result.\n            program2.py: checks the periodicity.\n\n        But the output of program1.py is the input to program2.py.\n\n        Specifically, the stdout of program1.py is the stdin of program2.py.\n\n        We can have program1.py output for each test case:\n\n            If there is an adjacent duplicate, then output \"No\" for this test case.\n            Otherwise, output the string and also the distinct count d? \n\n        But then program2.py would need to know which test case is which.\n\n        Alternatively, we can do:\n\n            program1.py for each test case:\n                if there is an adjacent duplicate: \n                    print(\"No\")\n                else:\n                    # We output the string in a transformed way? \n                    # But program2.py will then read this \"No\" as its input? \n\n            This will not work because program2.py expects t test cases, each with a string.\n\n        We need a way to synchronize.\n\n        Another idea: \n\n            program1.py does the adjacent duplicate check and if passed, it outputs the string. \n            If not passed, it outputs a special string (like \"!@#$\") that program2.py will recognize as a failure.\n\n        But the string might be arbitrary.\n\n        Alternatively, we can output for each test case two lines:\n\n            line1: a flag (0 for failure due to adjacent duplicate, 1 for passed)\n            line2: the string (if passed) or a dummy string (if failed) but we can output the string always.\n\n        Then program2.py reads two lines per test case.\n\n        But the input to program1.py is the usual: \n            first line: t\n            then t lines of strings.\n\n        The output of program1.py should be:\n\n            t (but program2.py will read t, then 2*t lines)\n\n        So:\n\n            program1.py:\n\n                t = int(input())\n                print(t)   # so that program2.py knows t\n                for i in range(t):\n                    s = input().strip()\n                    if we find an adjacent duplicate in s:\n                        print(\"0\")\n                        print(s)   # or a dummy, but we print s for consistency\n                    else:\n                        print(\"1\")\n                        print(s)\n\n            program2.py:\n\n                t = int(input().strip())\n                for i in range(t):\n                    flag = input().strip()\n                    s = input().strip()\n                    if flag==\"0\":\n                        print(\"No\")\n                    else:\n                        d = len(set(s))\n                        for i in range(d, len(s)):\n                            if s[i] != s[i-d]:\n                                print(\"No\")\n                                break\n                        else:\n                            print(\"Yes\")\n\n        But the template for program1.py is fixed. We cannot change the output to include a flag and the string in two lines.\n\n        The template for program1.py currently outputs either \"Yes\" in the else of the for loop, or in the TODO we must output something.\n\n        In the TODO, we can output \"No\" and then also output the string? \n\n        But then program2.py will read that as the next test case? \n\n        This is messy.\n\n        Given the complexity, and since the problem says the total length of s over test cases is only 200000, we can do the entire solution in one program and pipe it to a program that does nothing? \n\n        But the problem requires two programs.\n\n        How about:\n\n            program1.py: \n                does the adjacent duplicate check and if passed, it outputs the string.\n                if not passed, it outputs a string of one character: '0' (or something short)\n\n            program2.py: \n                reads a string for each test case.\n                if the string is '0', then output \"No\"\n                else: \n                    d = len(set(s))\n                    ... and then the periodicity check.\n\n        But then how does program2.py know how many test cases? \n\n        program"
}